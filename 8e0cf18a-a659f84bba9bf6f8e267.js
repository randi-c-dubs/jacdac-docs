(self["webpackChunkjacdac_docs"] = self["webpackChunkjacdac_docs"] || []).push([[1954],{

/***/ 93192:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var _asyncToGenerator = __webpack_require__(50358);

__webpack_require__(25438);

function e() {
  return (e = Object.assign || function (e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];

      for (var s in n) {
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
      }
    }

    return e;
  }).apply(this, arguments);
}

class t {
  constructor(e, t) {
    this.backend = e, this.dataMover = t, this.data = new WeakMap(), this.dataIdsCount = 0;
  }

  get(e) {
    return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e);
  }

  set(e, t) {
    this.dataIdsCount++, this.data.set(e, t);
  }

  has(e) {
    return this.data.has(e);
  }

  delete(e) {
    return this.dataIdsCount--, this.data.delete(e);
  }

  numDataIds() {
    return this.dataIdsCount;
  }

}

class n {
  refCount(e) {
    return s("refCount");
  }

  incRef(e) {
    return s("incRef");
  }

  timerAvailable() {
    return !0;
  }

  time(e) {
    return s("time");
  }

  read(e) {
    return s("read");
  }

  readSync(e) {
    return s("readSync");
  }

  numDataIds() {
    return s("numDataIds");
  }

  disposeData(e, t) {
    return s("disposeData");
  }

  write(e, t, n) {
    return s("write");
  }

  move(e, t, n, r, a) {
    return s("move");
  }

  memory() {
    return s("memory");
  }

  floatPrecision() {
    return s("floatPrecision");
  }

  epsilon() {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }

  dispose() {
    return s("dispose");
  }

}

function s(e) {
  throw new Error("'".concat(e, "' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen"));
}

function r(e) {
  var t = e.length,
      n = 0;

  for (; t > 0;) {
    n = Math.random() * t | 0, t--, o(e, t, n);
  }
}

function a(e, t, n) {
  return Math.max(e, Math.min(t, n));
}

function i(e) {
  return e % 2 == 0 ? e : e + 1;
}

function o(e, t, n) {
  var s = e[t];
  e[t] = e[n], e[n] = s;
}

function l(e, t) {
  if (!e) throw new Error("string" == typeof t ? t : t());
}

function u(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  l(p(e, t), () => n + " Shapes ".concat(e, " and ").concat(t, " must match"));
}

function c(e) {
  l(null != e, () => "The input to the tensor constructor must be a non-null value.");
}

function h(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  if (null == t && (t = []), Array.isArray(e) || $(e) && !n) for (var _s2 = 0; _s2 < e.length; ++_s2) {
    h(e[_s2], t, n);
  } else t.push(e);
  return t;
}

function d(e) {
  if (0 === e.length) return 1;
  var t = e[0];

  for (var _n2 = 1; _n2 < e.length; _n2++) {
    t *= e[_n2];
  }

  return t;
}

function p(e, t) {
  if (e === t) return !0;
  if (null == e || null == t) return !1;
  if (e.length !== t.length) return !1;

  for (var _n3 = 0; _n3 < e.length; _n3++) {
    if (e[_n3] !== t[_n3]) return !1;
  }

  return !0;
}

function f(e) {
  return e % 1 == 0;
}

function g(e) {
  var t = Math.ceil(Math.sqrt(e));
  return [t, Math.ceil(e / t)];
}

function m(e, t) {
  return t <= e.length ? e : e + " ".repeat(t - e.length);
}

function b(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e => 0;
  var n = arguments.length > 2 ? arguments[2] : undefined;
  return new Promise((s, r) => {
    var a = 0;

    var i = () => {
      if (e()) return void s();
      a++;
      var o = t(a);
      null != n && a >= n ? r() : setTimeout(i, o);
    };

    i();
  });
}

function x(e, t) {
  var n = 1,
      s = -1;

  for (var _t2 = 0; _t2 < e.length; ++_t2) {
    if (e[_t2] >= 0) n *= e[_t2];else if (-1 === e[_t2]) {
      if (-1 !== s) throw Error("Shapes can only have 1 implicit size. Found -1 at dim ".concat(s, " and dim ").concat(_t2));
      s = _t2;
    } else if (e[_t2] < 0) throw Error("Shapes can not be < 0. Found ".concat(e[_t2], " at dim ").concat(_t2));
  }

  if (-1 === s) {
    if (t > 0 && t !== n) throw Error("Size(".concat(t, ") must match the product of shape ").concat(e));
    return e;
  }

  if (0 === n) throw Error("Cannot infer the missing size in [".concat(e, "] when there are 0 elements"));
  if (t % n != 0) throw Error("The implicit shape can't be a fractional number. Got ".concat(t, " / ").concat(n));
  var r = e.slice();
  return r[s] = t / n, r;
}

function y(e, t) {
  var n = t.length;
  return l((e = null == e ? t.map((e, t) => t) : [].concat(e)).every(e => e >= -n && e < n), () => "All values in axis param must be in range [-".concat(n, ", ").concat(n, ") but got axis ").concat(e)), l(e.every(e => f(e)), () => "All values in axis param must be integers but got axis ".concat(e)), e.map(e => e < 0 ? n + e : e);
}

function k(e, t) {
  var n = [],
      s = [],
      r = null != t && Array.isArray(t) && 0 === t.length,
      a = null == t || r ? null : y(t, e).sort();
  var i = 0;

  for (var _t3 = 0; _t3 < e.length; ++_t3) {
    if (null != a) {
      if (a[i] === _t3 && 1 !== e[_t3]) throw new Error("Can't squeeze axis ".concat(_t3, " since its dim '").concat(e[_t3], "' is not 1"));
      (null == a[i] || a[i] > _t3) && 1 === e[_t3] && (n.push(e[_t3]), s.push(_t3)), a[i] <= _t3 && i++;
    }

    1 !== e[_t3] && (n.push(e[_t3]), s.push(_t3));
  }

  return {
    newShape: n,
    keptDims: s
  };
}

function w(e, t) {
  var n = null;
  if (null == e || "float32" === e) n = new Float32Array(t);else if ("int32" === e) n = new Int32Array(t);else {
    if ("bool" !== e) throw new Error("Unknown data type ".concat(e));
    n = new Uint8Array(t);
  }
  return n;
}

function v(e, t) {
  var n = null;
  if (null == e || "float32" === e) n = new Float32Array(t);else if ("int32" === e) n = new Int32Array(t);else if ("bool" === e) n = new Uint8Array(t);else {
    if ("string" !== e) throw new Error("Unknown data type ".concat(e));
    n = new Array(t);
  }
  return n;
}

function I(e, t) {
  return !("complex64" === t || "float32" === t && "complex64" !== e || "int32" === t && "float32" !== e && "complex64" !== e || "bool" === t && "bool" === e);
}

function $(e) {
  return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array;
}

function S(e) {
  if ("float32" === e || "int32" === e) return 4;
  if ("complex64" === e) return 8;
  if ("bool" === e) return 1;
  throw new Error("Unknown dtype ".concat(e));
}

function N(e) {
  return "string" == typeof e || e instanceof String;
}

function C(e) {
  return "number" == typeof e;
}

function T(e) {
  return Array.isArray(e) ? T(e[0]) : e instanceof Float32Array ? "float32" : e instanceof Int32Array || e instanceof Uint8Array ? "int32" : C(e) ? "float32" : N(e) ? "string" : "boolean" == typeof e ? "bool" : "float32";
}

function E(e) {
  return !!(e && e.constructor && e.call && e.apply);
}

function R(e, t) {
  for (var _n4 = t; _n4 < e; ++_n4) {
    if (e % _n4 == 0) return _n4;
  }

  return e;
}

function A(e) {
  var t = e.length;
  if (t < 2) return [];
  var n = new Array(t - 1);
  n[t - 2] = e[t - 1];

  for (var _s3 = t - 3; _s3 >= 0; --_s3) {
    n[_s3] = n[_s3 + 1] * e[_s3 + 1];
  }

  return n;
}

function F(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  var r = new Array();

  if (1 === t.length) {
    var _a2 = t[0] * (s ? 2 : 1);

    for (var _t4 = 0; _t4 < _a2; _t4++) {
      r[_t4] = n[e + _t4];
    }
  } else {
    var _a3 = t[0],
        _i2 = t.slice(1),
        _o2 = _i2.reduce((e, t) => e * t) * (s ? 2 : 1);

    for (var _t5 = 0; _t5 < _a3; _t5++) {
      r[_t5] = F(e + _t5 * _o2, _i2, n, s);
    }
  }

  return r;
}

function D(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  if (0 === e.length) return t[0];
  var s = e.reduce((e, t) => e * t) * (n ? 2 : 1);
  if (0 === s) return [];
  if (s !== t.length) throw new Error("[".concat(e, "] does not match the input size ").concat(t.length).concat(n ? " for a complex tensor" : "", "."));
  return F(0, e, t, n);
}

function _(e, t) {
  var n = O(e, t);

  for (var _e2 = 0; _e2 < n.length; _e2++) {
    n[_e2] = 1;
  }

  return n;
}

function O(e, t) {
  if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
  if ("int32" === t) return new Int32Array(e);
  if ("bool" === t) return new Uint8Array(e);
  throw new Error("Unknown data type ".concat(t));
}

function M(e, t) {
  var n = e.reduce((e, t) => e * t, 1);
  if (null == t || "float32" === t) return D(e, new Float32Array(n));
  if ("int32" === t) return D(e, new Int32Array(n));
  if ("bool" === t) return D(e, new Uint8Array(n));
  throw new Error("Unknown data type ".concat(t));
}

function L(e) {
  e.forEach(t => {
    l(Number.isInteger(t) && t >= 0, () => "Tensor must have a shape comprised of positive integers but got shape [".concat(e, "]."));
  });
}

function z(e, t, n) {
  if (0 === t) return 0;
  if (1 === t) return e[0];
  var s = e[e.length - 1];

  for (var _t6 = 0; _t6 < e.length - 1; ++_t6) {
    s += n[_t6] * e[_t6];
  }

  return s;
}

function B(e, t, n) {
  if (0 === t) return [];
  if (1 === t) return [e];
  var s = new Array(t);

  for (var _t7 = 0; _t7 < s.length - 1; ++_t7) {
    s[_t7] = Math.floor(e / n[_t7]), e -= s[_t7] * n[_t7];
  }

  return s[s.length - 1] = e, s;
}

function P(e) {
  return e && e.then && "function" == typeof e.then;
}

function W() {
  G().getBool("IS_TEST") || G().getBool("PROD") || console.warn(...arguments);
}

class U {
  constructor(e) {
    this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = V, this.populateURLFlags();
  }

  setPlatform(e, t) {
    null != this.platform && W("Platform ".concat(this.platformName, " has already been set. Overwriting the platform with ").concat(t, ".")), this.platformName = e, this.platform = t;
  }

  registerFlag(e, t, n) {
    if (this.flagRegistry[e] = {
      evaluationFn: t,
      setHook: n
    }, null != this.urlFlags[e]) {
      var _t8 = this.urlFlags[e];
      W("Setting feature override from URL ".concat(e, ": ").concat(_t8, ".")), this.set(e, _t8);
    }
  }

  getAsync(e) {
    var _this = this;

    return _asyncToGenerator(function* () {
      return e in _this.flags || (_this.flags[e] = yield _this.evaluateFlag(e)), _this.flags[e];
    })();
  }

  get(e) {
    if (e in this.flags) return this.flags[e];
    var t = this.evaluateFlag(e);
    if (P(t)) throw new Error("Flag ".concat(e, " cannot be synchronously evaluated. Please use getAsync() instead."));
    return this.flags[e] = t, this.flags[e];
  }

  getNumber(e) {
    return this.get(e);
  }

  getBool(e) {
    return this.get(e);
  }

  getFlags() {
    return this.flags;
  }

  get features() {
    return this.flags;
  }

  set(e, t) {
    if (null == this.flagRegistry[e]) throw new Error("Cannot set flag ".concat(e, " as it has not been registered."));
    this.flags[e] = t, null != this.flagRegistry[e].setHook && this.flagRegistry[e].setHook(t);
  }

  evaluateFlag(e) {
    if (null == this.flagRegistry[e]) throw new Error("Cannot evaluate flag '".concat(e, "': no evaluation function found."));
    return this.flagRegistry[e].evaluationFn();
  }

  setFlags(e) {
    this.flags = Object.assign({}, e);
  }

  reset() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }

  populateURLFlags() {
    if (void 0 === this.global || void 0 === this.global.location || void 0 === this.global.location.search) return;
    var e = this.getQueryParams(this.global.location.search);
    "tfjsflags" in e && e.tfjsflags.split(",").forEach(e => {
      var [t, n] = e.split(":");

      this.urlFlags[t] = function (e, t) {
        if ("true" === (t = t.toLowerCase()) || "false" === t) return "true" === t;
        if ("" + +t === t) return +t;
        throw new Error("Could not parse value flag value ".concat(t, " for flag ").concat(e, "."));
      }(t, n);
    });
  }

}

function V(e) {
  var t = {};
  return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (e) {
    for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      n[_key - 1] = arguments[_key];
    }

    return function (e, t, n) {
      e[decodeURIComponent(t)] = decodeURIComponent(n || "");
    }(t, n[0], n[1]), n.join("=");
  }), t;
}

function G() {
  return q;
}

var H,
    q = null;

function j() {
  if (null == H) {
    var _e3;

    if ("undefined" != typeof window) _e3 = window;else if ("undefined" != typeof __webpack_require__.g) _e3 = __webpack_require__.g;else if ("undefined" != typeof process) _e3 = process;else {
      if ("undefined" == typeof self) throw new Error("Could not find a global object");
      _e3 = self;
    }
    H = _e3;
  }

  return H;
}

function K(e, t) {
  var n = function () {
    var e = j();
    return null == e._tfGlobals && (e._tfGlobals = new Map()), e._tfGlobals;
  }();

  if (n.has(e)) return n.get(e);
  {
    var _s4 = t();

    return n.set(e, _s4), n.get(e);
  }
}

var X = K("kernelRegistry", () => new Map()),
    Y = K("gradRegistry", () => new Map());

function J(e, t) {
  var n = ne(e, t);
  return X.get(n);
}

function Z(e) {
  return Y.get(e);
}

function Q(e) {
  var t = X.entries(),
      n = [];

  for (;;) {
    var {
      done: _s5,
      value: _r2
    } = t.next();
    if (_s5) break;

    var [_a4, _i3] = _r2,
        [_o3] = _a4.split("_");

    _o3 === e && n.push(_i3);
  }

  return n;
}

function ee(e) {
  var {
    kernelName: t,
    backendName: n
  } = e,
      s = ne(t, n);
  X.has(s) && W("The kernel '".concat(t, "' for backend '").concat(n, "' is already registered")), X.set(s, e);
}

function te(e) {
  var {
    kernelName: t
  } = e;
  Y.has(t) && G().getBool("DEBUG") && W("Overriding the gradient for '".concat(t, "'")), Y.set(t, e);
}

function ne(e, t) {
  return "".concat(t, "_").concat(e);
}

var se = ae,
    re = null;

try {
  re = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch (e) {}

function ae(e, t, n) {
  this.low = 0 | e, this.high = 0 | t, this.unsigned = !!n;
}

function ie(e) {
  return !0 === (e && e.__isLong__);
}

Object.defineProperty(ae.prototype, "__isLong__", {
  value: !0
}), ae.isLong = ie;
var oe = {},
    le = {};

function ue(e, t) {
  var n, s, r;
  return t ? (r = 0 <= (e >>>= 0) && e < 256) && (s = le[e]) ? s : (n = he(e, (0 | e) < 0 ? -1 : 0, !0), r && (le[e] = n), n) : (r = -128 <= (e |= 0) && e < 128) && (s = oe[e]) ? s : (n = he(e, e < 0 ? -1 : 0, !1), r && (oe[e] = n), n);
}

function ce(e, t) {
  if (isNaN(e)) return t ? ke : ye;

  if (t) {
    if (e < 0) return ke;
    if (e >= me) return Se;
  } else {
    if (e <= -be) return Ne;
    if (e + 1 >= be) return $e;
  }

  return e < 0 ? ce(-e, t).neg() : he(e % ge | 0, e / ge | 0, t);
}

function he(e, t, n) {
  return new ae(e, t, n);
}

ae.fromInt = ue, ae.fromNumber = ce, ae.fromBits = he;
var de = Math.pow;

function pe(e, t, n) {
  if (0 === e.length) throw Error("empty string");
  if ("NaN" === e || "Infinity" === e || "+Infinity" === e || "-Infinity" === e) return ye;
  if ("number" == typeof t ? (n = t, t = !1) : t = !!t, (n = n || 10) < 2 || 36 < n) throw RangeError("radix");
  var s;
  if ((s = e.indexOf("-")) > 0) throw Error("interior hyphen");
  if (0 === s) return pe(e.substring(1), t, n).neg();

  for (var r = ce(de(n, 8)), a = ye, i = 0; i < e.length; i += 8) {
    var o = Math.min(8, e.length - i),
        l = parseInt(e.substring(i, i + o), n);

    if (o < 8) {
      var u = ce(de(n, o));
      a = a.mul(u).add(ce(l));
    } else a = (a = a.mul(r)).add(ce(l));
  }

  return a.unsigned = t, a;
}

function fe(e, t) {
  return "number" == typeof e ? ce(e, t) : "string" == typeof e ? pe(e, t) : he(e.low, e.high, "boolean" == typeof t ? t : e.unsigned);
}

ae.fromString = pe, ae.fromValue = fe;
var ge = 4294967296,
    me = ge * ge,
    be = me / 2,
    xe = ue(1 << 24),
    ye = ue(0);
ae.ZERO = ye;
var ke = ue(0, !0);
ae.UZERO = ke;
var we = ue(1);
ae.ONE = we;
var ve = ue(1, !0);
ae.UONE = ve;
var Ie = ue(-1);
ae.NEG_ONE = Ie;
var $e = he(-1, 2147483647, !1);
ae.MAX_VALUE = $e;
var Se = he(-1, -1, !0);
ae.MAX_UNSIGNED_VALUE = Se;
var Ne = he(0, -2147483648, !1);
ae.MIN_VALUE = Ne;
var Ce = ae.prototype;
Ce.toInt = function () {
  return this.unsigned ? this.low >>> 0 : this.low;
}, Ce.toNumber = function () {
  return this.unsigned ? (this.high >>> 0) * ge + (this.low >>> 0) : this.high * ge + (this.low >>> 0);
}, Ce.toString = function (e) {
  if ((e = e || 10) < 2 || 36 < e) throw RangeError("radix");
  if (this.isZero()) return "0";

  if (this.isNegative()) {
    if (this.eq(Ne)) {
      var t = ce(e),
          n = this.div(t),
          s = n.mul(t).sub(this);
      return n.toString(e) + s.toInt().toString(e);
    }

    return "-" + this.neg().toString(e);
  }

  for (var r = ce(de(e, 6), this.unsigned), a = this, i = "";;) {
    var o = a.div(r),
        l = (a.sub(o.mul(r)).toInt() >>> 0).toString(e);
    if ((a = o).isZero()) return l + i;

    for (; l.length < 6;) {
      l = "0" + l;
    }

    i = "" + l + i;
  }
}, Ce.getHighBits = function () {
  return this.high;
}, Ce.getHighBitsUnsigned = function () {
  return this.high >>> 0;
}, Ce.getLowBits = function () {
  return this.low;
}, Ce.getLowBitsUnsigned = function () {
  return this.low >>> 0;
}, Ce.getNumBitsAbs = function () {
  if (this.isNegative()) return this.eq(Ne) ? 64 : this.neg().getNumBitsAbs();

  for (var e = 0 != this.high ? this.high : this.low, t = 31; t > 0 && 0 == (e & 1 << t); t--) {
    ;
  }

  return 0 != this.high ? t + 33 : t + 1;
}, Ce.isZero = function () {
  return 0 === this.high && 0 === this.low;
}, Ce.eqz = Ce.isZero, Ce.isNegative = function () {
  return !this.unsigned && this.high < 0;
}, Ce.isPositive = function () {
  return this.unsigned || this.high >= 0;
}, Ce.isOdd = function () {
  return 1 == (1 & this.low);
}, Ce.isEven = function () {
  return 0 == (1 & this.low);
}, Ce.equals = function (e) {
  return ie(e) || (e = fe(e)), (this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) && this.high === e.high && this.low === e.low;
}, Ce.eq = Ce.equals, Ce.notEquals = function (e) {
  return !this.eq(e);
}, Ce.neq = Ce.notEquals, Ce.ne = Ce.notEquals, Ce.lessThan = function (e) {
  return this.comp(e) < 0;
}, Ce.lt = Ce.lessThan, Ce.lessThanOrEqual = function (e) {
  return this.comp(e) <= 0;
}, Ce.lte = Ce.lessThanOrEqual, Ce.le = Ce.lessThanOrEqual, Ce.greaterThan = function (e) {
  return this.comp(e) > 0;
}, Ce.gt = Ce.greaterThan, Ce.greaterThanOrEqual = function (e) {
  return this.comp(e) >= 0;
}, Ce.gte = Ce.greaterThanOrEqual, Ce.ge = Ce.greaterThanOrEqual, Ce.compare = function (e) {
  if (ie(e) || (e = fe(e)), this.eq(e)) return 0;
  var t = this.isNegative(),
      n = e.isNegative();
  return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
}, Ce.comp = Ce.compare, Ce.negate = function () {
  return !this.unsigned && this.eq(Ne) ? Ne : this.not().add(we);
}, Ce.neg = Ce.negate, Ce.add = function (e) {
  ie(e) || (e = fe(e));
  var t = 0,
      n = 0,
      s = 0,
      r = 0;
  return s += (r += (65535 & this.low) + (65535 & e.low)) >>> 16, n += (s += (this.low >>> 16) + (e.low >>> 16)) >>> 16, t += (n += (65535 & this.high) + (65535 & e.high)) >>> 16, t += (this.high >>> 16) + (e.high >>> 16), he((s &= 65535) << 16 | (r &= 65535), (t &= 65535) << 16 | (n &= 65535), this.unsigned);
}, Ce.subtract = function (e) {
  return ie(e) || (e = fe(e)), this.add(e.neg());
}, Ce.sub = Ce.subtract, Ce.multiply = function (e) {
  if (this.isZero()) return ye;
  if (ie(e) || (e = fe(e)), re) return he(re.mul(this.low, this.high, e.low, e.high), re.get_high(), this.unsigned);
  if (e.isZero()) return ye;
  if (this.eq(Ne)) return e.isOdd() ? Ne : ye;
  if (e.eq(Ne)) return this.isOdd() ? Ne : ye;
  if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative()) return this.mul(e.neg()).neg();
  if (this.lt(xe) && e.lt(xe)) return ce(this.toNumber() * e.toNumber(), this.unsigned);
  var t = 65535 & this.high,
      n = this.low >>> 16,
      s = 65535 & this.low,
      r = 65535 & e.high,
      a = e.low >>> 16,
      i = 65535 & e.low,
      o = 0,
      l = 0,
      u = 0,
      c = 0;
  return u += (c += s * i) >>> 16, l += (u += n * i) >>> 16, u &= 65535, l += (u += s * a) >>> 16, o += (l += t * i) >>> 16, l &= 65535, o += (l += n * a) >>> 16, l &= 65535, o += (l += s * r) >>> 16, o += (this.high >>> 16) * i + t * a + n * r + s * (e.high >>> 16), he((u &= 65535) << 16 | (c &= 65535), (o &= 65535) << 16 | (l &= 65535), this.unsigned);
}, Ce.mul = Ce.multiply, Ce.divide = function (e) {
  if (ie(e) || (e = fe(e)), e.isZero()) throw Error("division by zero");
  var t, n, s;
  if (re) return this.unsigned || -2147483648 !== this.high || -1 !== e.low || -1 !== e.high ? he((this.unsigned ? re.div_u : re.div_s)(this.low, this.high, e.low, e.high), re.get_high(), this.unsigned) : this;
  if (this.isZero()) return this.unsigned ? ke : ye;

  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return ke;
    if (e.gt(this.shru(1))) return ve;
    s = ke;
  } else {
    if (this.eq(Ne)) return e.eq(we) || e.eq(Ie) ? Ne : e.eq(Ne) ? we : (t = this.shr(1).div(e).shl(1)).eq(ye) ? e.isNegative() ? we : Ie : (n = this.sub(e.mul(t)), s = t.add(n.div(e)));
    if (e.eq(Ne)) return this.unsigned ? ke : ye;
    if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative()) return this.div(e.neg()).neg();
    s = ye;
  }

  for (n = this; n.gte(e);) {
    t = Math.max(1, Math.floor(n.toNumber() / e.toNumber()));

    for (var r = Math.ceil(Math.log(t) / Math.LN2), a = r <= 48 ? 1 : de(2, r - 48), i = ce(t), o = i.mul(e); o.isNegative() || o.gt(n);) {
      o = (i = ce(t -= a, this.unsigned)).mul(e);
    }

    i.isZero() && (i = we), s = s.add(i), n = n.sub(o);
  }

  return s;
}, Ce.div = Ce.divide, Ce.modulo = function (e) {
  return ie(e) || (e = fe(e)), re ? he((this.unsigned ? re.rem_u : re.rem_s)(this.low, this.high, e.low, e.high), re.get_high(), this.unsigned) : this.sub(this.div(e).mul(e));
}, Ce.mod = Ce.modulo, Ce.rem = Ce.modulo, Ce.not = function () {
  return he(~this.low, ~this.high, this.unsigned);
}, Ce.and = function (e) {
  return ie(e) || (e = fe(e)), he(this.low & e.low, this.high & e.high, this.unsigned);
}, Ce.or = function (e) {
  return ie(e) || (e = fe(e)), he(this.low | e.low, this.high | e.high, this.unsigned);
}, Ce.xor = function (e) {
  return ie(e) || (e = fe(e)), he(this.low ^ e.low, this.high ^ e.high, this.unsigned);
}, Ce.shiftLeft = function (e) {
  return ie(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? he(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : he(0, this.low << e - 32, this.unsigned);
}, Ce.shl = Ce.shiftLeft, Ce.shiftRight = function (e) {
  return ie(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? he(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : he(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
}, Ce.shr = Ce.shiftRight, Ce.shiftRightUnsigned = function (e) {
  if (ie(e) && (e = e.toInt()), 0 == (e &= 63)) return this;
  var t = this.high;
  return e < 32 ? he(this.low >>> e | t << 32 - e, t >>> e, this.unsigned) : he(32 === e ? t : t >>> e - 32, 0, this.unsigned);
}, Ce.shru = Ce.shiftRightUnsigned, Ce.shr_u = Ce.shiftRightUnsigned, Ce.toSigned = function () {
  return this.unsigned ? he(this.low, this.high, !1) : this;
}, Ce.toUnsigned = function () {
  return this.unsigned ? this : he(this.low, this.high, !0);
}, Ce.toBytes = function (e) {
  return e ? this.toBytesLE() : this.toBytesBE();
}, Ce.toBytesLE = function () {
  var e = this.high,
      t = this.low;
  return [255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, 255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
}, Ce.toBytesBE = function () {
  var e = this.high,
      t = this.low;
  return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, 255 & t];
}, ae.fromBytes = function (e, t, n) {
  return n ? ae.fromBytesLE(e, t) : ae.fromBytesBE(e, t);
}, ae.fromBytesLE = function (e, t) {
  return new ae(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
}, ae.fromBytesBE = function (e, t) {
  return new ae(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
};
var Te = se;
var Ee = Te || Object.assign(Object.create(null), se, {
  default: Te
});

function Re(e) {
  return Ee.fromString(e, !0, 16);
}

var Ae = Re("c3a5c85c97cb3127"),
    Fe = Re("b492b66fbe98f273"),
    De = Re("9ae16a3b2f90404f");

function _e(e) {
  return e.xor(e.shru(47));
}

function Oe(e, t, n) {
  var s = e.slice(t, t + n);
  return Ee.fromBytes(Array.from(s), !0, !0);
}

function Me(e, t) {
  return Oe(e, t, 8);
}

function Le(e, t) {
  return Oe(e, t, 4);
}

function ze(e, t) {
  return 0 === t ? e : e.shru(t).or(e.shl(64 - t));
}

function Be(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Re("9ddfea08eb382d69");
  var s = e.xor(t).mul(n);
  s = s.xor(s.shru(47));
  var r = t.xor(s).mul(n);
  return r = r.xor(r.shru(47)), r = r.mul(n), r;
}

function Pe(e, t, n, s) {
  return function (e, t, n, s, r, a) {
    r = r.add(e), a = ze(a.add(r).add(s), 21);
    var i = r;
    return r = (r = r.add(t)).add(n), a = a.add(ze(r, 44)), [r.add(s), a.add(i)];
  }(Me(e, t), Me(e, t + 8), Me(e, t + 16), Me(e, t + 24), n, s);
}

function We(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;
  var n = Ee.fromNumber(81, !0);
  if (t <= 32) return t <= 16 ? function (e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;

    if (t >= 8) {
      var _n5 = De.add(2 * t),
          _s6 = Me(e, 0).add(De),
          _r3 = Me(e, t - 8);

      return Be(ze(_r3, 37).mul(_n5).add(_s6), ze(_s6, 25).add(_r3).mul(_n5), _n5);
    }

    if (t >= 4) {
      var _n6 = De.add(2 * t);

      return Be(Le(e, 0).shl(3).add(t), Le(e, t - 4), _n6);
    }

    if (t > 0) {
      var _n7 = t + (e[t - 1] << 2);

      return _e(De.mul(e[0] + (e[t >> 1] << 8)).xor(Ae.mul(_n7))).mul(De);
    }

    return De;
  }(e, t) : function (e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;
    var n = De.add(2 * t),
        s = Me(e, 0).mul(Fe),
        r = Me(e, 8),
        a = Me(e, t - 8).mul(n),
        i = Me(e, t - 16).mul(De);
    return Be(ze(s.add(r), 43).add(ze(a, 30)).add(i), s.add(ze(r.add(De), 18)).add(a), n);
  }(e, t);
  if (t <= 64) return function (e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;
    var n = De.add(2 * t),
        s = Me(e, 0).mul(De),
        r = Me(e, 8),
        a = Me(e, t - 8).mul(n),
        i = Me(e, t - 16).mul(De),
        o = ze(s.add(r), 43).add(ze(a, 30)).add(i),
        l = Be(o, s.add(ze(r.add(De), 18)).add(a), n),
        u = Me(e, 16).mul(n),
        c = Me(e, 24),
        h = o.add(Me(e, t - 32)).mul(n),
        d = l.add(Me(e, t - 24)).mul(n);
    return Be(ze(u.add(c), 43).add(ze(h, 30)).add(d), u.add(ze(c.add(s), 18)).add(h), n);
  }(e, t);

  var s = n,
      r = n.mul(Fe).add(113),
      a = _e(r.mul(De).add(113)).mul(De),
      i = [Ee.UZERO, Ee.UZERO],
      o = [Ee.UZERO, Ee.UZERO];

  s = s.mul(De).add(Me(e, 0));
  var l = 0;
  var u = 64 * (t - 1 >> 6),
      c = u + (t - 1 & 63) - 63;

  do {
    s = ze(s.add(r).add(i[0]).add(Me(e, l + 8)), 37).mul(Fe), r = ze(r.add(i[1]).add(Me(e, l + 48)), 42).mul(Fe), s = s.xor(o[1]), r = r.add(i[0]).add(Me(e, l + 40)), a = ze(a.add(o[0]), 33).mul(Fe), i = Pe(e, l, i[1].mul(Fe), s.add(o[0])), o = Pe(e, l + 32, a.add(o[1]), r.add(Me(e, l + 16))), [a, s] = [s, a], l += 64;
  } while (l !== u);

  var h = Fe.add(a.and(255).shl(1));
  return l = c, o[0] = o[0].add(t - 1 & 63), i[0] = i[0].add(o[0]), o[0] = o[0].add(i[0]), s = ze(s.add(r).add(i[0]).add(Me(e, l + 8)), 37).mul(h), r = ze(r.add(i[1]).add(Me(e, l + 48)), 42).mul(h), s = s.xor(o[1].mul(9)), r = r.add(i[0].mul(9).add(Me(e, l + 40))), a = ze(a.add(o[0]), 33).mul(h), i = Pe(e, l, i[1].mul(h), s.add(o[0])), o = Pe(e, l + 32, a.add(o[1]), r.add(Me(e, l + 16))), [a, s] = [s, a], Be(Be(i[0], o[0], h).add(_e(r).mul(Ae)).add(a), Be(i[1], o[1], h).add(s), h);
}

function Ue(e, t) {
  return "string" === t ? He(e) : Ve([e], t);
}

function Ve(e, t) {
  if ("string" === t) throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(e) && (e = h(e)), G().getBool("DEBUG") && function (e, t) {
    for (var _n8 = 0; _n8 < e.length; _n8++) {
      var _s7 = e[_n8];
      if (isNaN(_s7) || !isFinite(_s7)) throw Error("A tensor of type ".concat(t, " being uploaded contains ").concat(_s7, "."));
    }
  }(e, t), function (e, t) {
    return e instanceof Float32Array && "float32" === t || e instanceof Int32Array && "int32" === t || e instanceof Uint8Array && "bool" === t;
  }(e, t)) return e;
  if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
  if ("int32" === t) return new Int32Array(e);

  if ("bool" === t) {
    var _t9 = new Uint8Array(e.length);

    for (var _n9 = 0; _n9 < _t9.length; ++_n9) {
      0 !== Math.round(e[_n9]) && (_t9[_n9] = 1);
    }

    return _t9;
  }

  throw new Error("Unknown data type ".concat(t));
}

function Ge() {
  return G().platform.now();
}

function He(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf-8";
  return t = t || "utf-8", G().platform.encode(e, t);
}

function qe(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf-8";
  return t = t || "utf-8", G().platform.decode(e, t);
}

class je {
  constructor(e, t) {
    this.backendTimer = e, this.logger = t, null == t && (this.logger = new Xe());
  }

  profileKernel(e, t, n) {
    var s;

    var r = () => {
      s = n();
    };

    var a;
    var i = Ge();
    if (this.backendTimer.timerAvailable()) a = this.backendTimer.time(r);else {
      r();

      for (var _e4 of s) {
        _e4.dataSync();
      }

      a = Promise.resolve({
        kernelMs: Ge() - i
      });
    }

    if (G().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
      var _loop = function _loop(_t10) {
        var n = s[_t10];
        n.data().then(t => {
          Ke(t, n.dtype, e);
        });
      };

      for (var _t10 = 0; _t10 < s.length; _t10++) {
        _loop(_t10);
      }
    }

    return {
      kernelName: e,
      outputs: s,
      inputs: t,
      timeMs: a.then(e => e.kernelMs),
      extraInfo: a.then(e => null != e.getExtraProfileInfo ? e.getExtraProfileInfo() : "")
    };
  }

  logKernelProfile(e) {
    var {
      kernelName: t,
      outputs: n,
      timeMs: s,
      inputs: r,
      extraInfo: a
    } = e;
    n.forEach(e => {
      Promise.all([e.data(), s, a]).then(n => {
        this.logger.logKernelProfile(t, e, n[0], n[1], r, n[2]);
      });
    });
  }

}

function Ke(e, t, n) {
  if ("float32" !== t) return !1;

  for (var _t11 = 0; _t11 < e.length; _t11++) {
    var _s8 = e[_t11];
    if (isNaN(_s8) || !isFinite(_s8)) return console.warn("Found ".concat(_s8, " in the result of '").concat(n, "'")), !0;
  }

  return !1;
}

class Xe {
  logKernelProfile(e, t, n, s, r, a) {
    var i = "number" == typeof s ? m("".concat(s, "ms"), 9) : s.error,
        o = m(e, 25),
        l = t.rank,
        u = t.size,
        c = m(t.shape.toString(), 14);
    var h = "";

    for (var _e5 in r) {
      var _n10 = r[_e5];

      if (null != _n10) {
        var _s9 = _n10.shape || t.shape,
            _r4 = _s9.length;

        h += "".concat(_e5, ": ").concat(_r4, "D ").concat(_r4 > 0 ? _s9 : "", " ");
      }
    }

    console.log("%c".concat(o, "\t%c").concat(i, "\t%c").concat(l, "D ").concat(c, "\t%c").concat(u, "\t%c").concat(h, "\t%c").concat(a), "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }

}

function Ye(e, t, n, s) {
  var r = A(t),
      a = function (e, t, n, s) {
    var r = d(t),
        a = s[s.length - 1],
        i = new Array(a).fill(0),
        o = t.length,
        l = "complex64" === n ? et(e) : e;
    if (o > 1) for (var _e6 = 0; _e6 < r / a; _e6++) {
      var _t12 = _e6 * a;

      for (var _e7 = 0; _e7 < a; _e7++) {
        i[_e7] = Math.max(i[_e7], Je(l[_t12 + _e7], 0, n).length);
      }
    }
    return i;
  }(e, t, n, r),
      i = t.length,
      o = Qe(e, t, n, r, a),
      l = ["Tensor"];

  return s && (l.push("  dtype: ".concat(n)), l.push("  rank: ".concat(i)), l.push("  shape: [".concat(t, "]")), l.push("  values:")), l.push(o.map(e => "    " + e).join("\n")), l.join("\n");
}

function Je(e, t, n) {
  var s;
  return s = Array.isArray(e) ? "".concat(parseFloat(e[0].toFixed(7)), " + ").concat(parseFloat(e[1].toFixed(7)), "j") : N(e) ? "'".concat(e, "'") : "bool" === n ? Ze(e) : parseFloat(e.toFixed(7)).toString(), m(s, t);
}

function Ze(e) {
  return 0 === e ? "false" : "true";
}

function Qe(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !0;
  var i = "complex64" === n ? 2 : 1,
      o = t[0],
      l = t.length;
  if (0 === l) return "complex64" === n ? [Je(et(e)[0], 0, n)] : "bool" === n ? [Ze(e[0])] : [e[0].toString()];

  if (1 === l) {
    if (o > 20) {
      var _t13 = Array.from(e.slice(0, 3 * i)),
          _s10 = Array.from(e.slice((o - 3) * i, o * i));

      return "complex64" === n && (_t13 = et(_t13), _s10 = et(_s10)), ["[" + _t13.map((e, t) => Je(e, r[t], n)).join(", ") + ", ..., " + _s10.map((e, t) => Je(e, r[o - 3 + t], n)).join(", ") + "]"];
    }

    return ["[" + ("complex64" === n ? et(e) : Array.from(e)).map((e, t) => Je(e, r[t], n)).join(", ") + "]"];
  }

  var u = t.slice(1),
      c = s.slice(1),
      h = s[0] * i,
      d = [];

  if (o > 20) {
    for (var _t14 = 0; _t14 < 3; _t14++) {
      var _s11 = _t14 * h;

      d.push(...Qe(e.slice(_s11, _s11 + h), u, n, c, r, !1));
    }

    d.push("...");

    for (var _t15 = o - 3; _t15 < o; _t15++) {
      var _s12 = _t15 * h;

      d.push(...Qe(e.slice(_s12, _s12 + h), u, n, c, r, _t15 === o - 1));
    }
  } else for (var _t16 = 0; _t16 < o; _t16++) {
    var _s13 = _t16 * h;

    d.push(...Qe(e.slice(_s13, _s13 + h), u, n, c, r, _t16 === o - 1));
  }

  var p = 2 === l ? "," : "";
  d[0] = "[" + d[0] + p;

  for (var _e8 = 1; _e8 < d.length - 1; _e8++) {
    d[_e8] = " " + d[_e8] + p;
  }

  var f = ",\n";

  for (var _e9 = 2; _e9 < l; _e9++) {
    f += "\n";
  }

  return d[d.length - 1] = " " + d[d.length - 1] + "]" + (a ? "" : f), d;
}

function et(e) {
  var t = [];

  for (var _n11 = 0; _n11 < e.length; _n11 += 2) {
    t.push([e[_n11], e[_n11 + 1]]);
  }

  return t;
}

class tt {
  constructor(e, t, n) {
    if (this.dtype = t, this.shape = e.slice(), this.size = d(e), null != n) {
      var _e10 = n.length;
      l(_e10 === this.size, () => "Length of values '".concat(_e10, "' does not match the size inferred by the shape '").concat(this.size, "'."));
    }

    if ("complex64" === t) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = n || v(t, this.size), this.strides = A(e);
  }

  set(e) {
    for (var _len2 = arguments.length, t = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      t[_key2 - 1] = arguments[_key2];
    }

    0 === t.length && (t = [0]), l(t.length === this.rank, () => "The number of provided coordinates (".concat(t.length, ") must match the rank (").concat(this.rank, ")"));
    var n = this.locToIndex(t);
    this.values[n] = e;
  }

  get() {
    for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      e[_key3] = arguments[_key3];
    }

    0 === e.length && (e = [0]);
    var t = 0;

    for (var _n12 of e) {
      if (_n12 < 0 || _n12 >= this.shape[t]) throw new Error("Requested out of range element at ".concat(e, ".   Buffer shape=").concat(this.shape));
      t++;
    }

    var n = e[e.length - 1];

    for (var _t17 = 0; _t17 < e.length - 1; ++_t17) {
      n += this.strides[_t17] * e[_t17];
    }

    return this.values[n];
  }

  locToIndex(e) {
    if (0 === this.rank) return 0;
    if (1 === this.rank) return e[0];
    var t = e[e.length - 1];

    for (var _n13 = 0; _n13 < e.length - 1; ++_n13) {
      t += this.strides[_n13] * e[_n13];
    }

    return t;
  }

  indexToLoc(e) {
    if (0 === this.rank) return [];
    if (1 === this.rank) return [e];
    var t = new Array(this.shape.length);

    for (var _n14 = 0; _n14 < t.length - 1; ++_n14) {
      t[_n14] = Math.floor(e / this.strides[_n14]), e -= t[_n14] * this.strides[_n14];
    }

    return t[t.length - 1] = e, t;
  }

  get rank() {
    return this.shape.length;
  }

  toTensor() {
    return nt().makeTensor(this.values, this.shape, this.dtype);
  }

}

var nt = null,
    st = null;

class rt {
  constructor(e, t, n, s) {
    this.kept = !1, this.isDisposedInternal = !1, this.shape = e.slice(), this.dtype = t || "float32", this.size = d(e), this.strides = A(e), this.dataId = n, this.id = s, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }

  get rank() {
    return this.shape.length;
  }

  buffer() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      var e = yield _this2.data();
      return st.buffer(_this2.shape, _this2.dtype, e);
    })();
  }

  bufferSync() {
    return st.buffer(this.shape, this.dtype, this.dataSync());
  }

  array() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      var e = yield _this3.data();
      return D(_this3.shape, e, "complex64" === _this3.dtype);
    })();
  }

  arraySync() {
    return D(this.shape, this.dataSync(), "complex64" === this.dtype);
  }

  data() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      _this4.throwIfDisposed();

      var e = nt().read(_this4.dataId);

      if ("string" === _this4.dtype) {
        var _t18 = yield e;

        try {
          return _t18.map(e => qe(e));
        } catch (e) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }

      return e;
    })();
  }

  dataSync() {
    this.throwIfDisposed();
    var e = nt().readSync(this.dataId);
    if ("string" === this.dtype) try {
      return e.map(e => qe(e));
    } catch (e) {
      throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
    }
    return e;
  }

  bytes() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      _this5.throwIfDisposed();

      var e = yield nt().read(_this5.dataId);
      return "string" === _this5.dtype ? e : new Uint8Array(e.buffer);
    })();
  }

  dispose() {
    this.isDisposed || (nt().disposeTensor(this), this.isDisposedInternal = !0);
  }

  get isDisposed() {
    return this.isDisposedInternal;
  }

  throwIfDisposed() {
    if (this.isDisposed) throw new Error("Tensor is disposed.");
  }

  print() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    return st.print(this, e);
  }

  clone() {
    return this.throwIfDisposed(), st.clone(this);
  }

  toString() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    return Ye(this.dataSync(), this.shape, this.dtype, e);
  }

  cast(e) {
    return this.throwIfDisposed(), st.cast(this, e);
  }

  variable() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    var t = arguments.length > 1 ? arguments[1] : undefined;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    return this.throwIfDisposed(), nt().makeVariable(this, e, t, n);
  }

}

function at() {
  return K("Tensor", () => rt);
}

Object.defineProperty(rt, Symbol.hasInstance, {
  value: e => !!e && null != e.data && null != e.dataSync && null != e.throwIfDisposed
}), at();

class it extends rt {
  constructor(e, t, n, s) {
    super(e.shape, e.dtype, e.dataId, s), this.trainable = t, this.name = n;
  }

  assign(e) {
    if (e.dtype !== this.dtype) throw new Error("dtype of the new value (".concat(e.dtype, ") and previous value (").concat(this.dtype, ") must match"));
    if (!p(e.shape, this.shape)) throw new Error("shape of the new value (".concat(e.shape, ") and previous value (").concat(this.shape, ") must match"));
    nt().disposeTensor(this), this.dataId = e.dataId, nt().incRef(this, null);
  }

  dispose() {
    nt().disposeVariable(this), this.isDisposedInternal = !0;
  }

}

var ot, lt, ut, ct, ht;
Object.defineProperty(it, Symbol.hasInstance, {
  value: e => e instanceof rt && null != e.assign && e.assign instanceof Function
}), function (e) {
  e.R0 = "R0", e.R1 = "R1", e.R2 = "R2", e.R3 = "R3", e.R4 = "R4", e.R5 = "R5", e.R6 = "R6";
}(ot || (ot = {})), function (e) {
  e.float32 = "float32", e.int32 = "int32", e.bool = "int32", e.complex64 = "complex64";
}(lt || (lt = {})), function (e) {
  e.float32 = "float32", e.int32 = "int32", e.bool = "bool", e.complex64 = "complex64";
}(ut || (ut = {})), function (e) {
  e.float32 = "float32", e.int32 = "float32", e.bool = "float32", e.complex64 = "complex64";
}(ct || (ct = {})), function (e) {
  e.float32 = "complex64", e.int32 = "complex64", e.bool = "complex64", e.complex64 = "complex64";
}(ht || (ht = {}));
var dt = {
  float32: ct,
  int32: lt,
  bool: ut,
  complex64: ht
};

function pt(e, t) {
  if ("string" === e || "string" === t) {
    if ("string" === e && "string" === t) return "string";
    throw new Error("Can not upcast ".concat(e, " with ").concat(t));
  }

  return dt[e][t];
}

function ft(e) {
  return pt(e, "int32");
}

function gt(e, t) {
  if (e.dtype === t.dtype) return [e, t];
  var n = pt(e.dtype, t.dtype);
  return [e.cast(n), t.cast(n)];
}

function mt(e) {
  var t = [];
  return bt(e, t, new Set()), t;
}

function bt(e, t, n) {
  if (null == e) return;
  if (e instanceof rt) return void t.push(e);
  if (s = e, !Array.isArray(s) && "object" != typeof s) return;
  var s;
  var r = e;

  for (var _e11 in r) {
    var _s14 = r[_e11];
    n.has(_s14) || (n.add(_s14), bt(_s14, t, n));
  }
}

function xt(e) {
  return null != e.kernelName;
}

class yt {
  constructor() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap(), this.profiling = !1, this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null,

      get kernelNames() {
        return Array.from(new Set(this.kernels.map(e => e.name)));
      }

    };
  }

  dispose() {
    for (var _e12 in this.registeredVariables) {
      this.registeredVariables[_e12].dispose();
    }
  }

}

class kt {
  constructor(e) {
    this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new yt();
  }

  ready() {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      if (null != _this6.pendingBackendInit) return _this6.pendingBackendInit.then(() => {});
      if (null != _this6.backendInstance) return;

      var e = _this6.getSortedBackends();

      for (var _t19 = 0; _t19 < e.length; _t19++) {
        var _n15 = e[_t19];
        if (yield _this6.initializeBackend(_n15).success) return void (yield _this6.setBackend(_n15));
      }

      throw new Error("Could not initialize any backends, all backend initializations failed.");
    })();
  }

  get backend() {
    if (null != this.pendingBackendInit) throw new Error("Backend '".concat(this.backendName, "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"));

    if (null == this.backendInstance) {
      var {
        name: _e13,
        asyncInit: _t20
      } = this.initializeBackendsAndReturnBest();
      if (_t20) throw new Error("The highest priority backend '".concat(_e13, "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"));
      this.setBackend(_e13);
    }

    return this.backendInstance;
  }

  backendNames() {
    return Object.keys(this.registryFactory);
  }

  findBackend(e) {
    if (!(e in this.registry)) {
      if (!(e in this.registryFactory)) return null;
      {
        var {
          asyncInit: _t21
        } = this.initializeBackend(e);
        if (_t21) return null;
      }
    }

    return this.registry[e];
  }

  findBackendFactory(e) {
    return e in this.registryFactory ? this.registryFactory[e].factory : null;
  }

  registerBackend(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return e in this.registryFactory ? (W("".concat(e, " backend was already registered. Reusing existing backend factory.")), !1) : (this.registryFactory[e] = {
      factory: t,
      priority: n
    }, !0);
  }

  setBackend(e) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      if (null == _this7.registryFactory[e]) throw new Error("Backend name '".concat(e, "' not found in registry"));

      if (_this7.backendName = e, null == _this7.registry[e]) {
        _this7.backendInstance = null;

        var {
          success: _t22,
          asyncInit: _n16
        } = _this7.initializeBackend(e);

        if (!(_n16 ? yield _t22 : _t22)) return !1;
      }

      return _this7.backendInstance = _this7.registry[e], _this7.setupRegisteredKernels(), _this7.profiler = new je(_this7.backendInstance), !0;
    })();
  }

  setupRegisteredKernels() {
    Q(this.backendName).forEach(e => {
      null != e.setupFunc && e.setupFunc(this.backendInstance);
    });
  }

  disposeRegisteredKernels(e) {
    Q(e).forEach(t => {
      null != t.disposeFunc && t.disposeFunc(this.registry[e]);
    });
  }

  initializeBackend(e) {
    var t = this.registryFactory[e];
    if (null == t) throw new Error("Cannot initialize backend ".concat(e, ", no registration found."));

    try {
      var _s15 = t.factory();

      if (!_s15 || _s15 instanceof n || "function" != typeof _s15.then) return this.registry[e] = _s15, {
        success: !0,
        asyncInit: !1
      };
      {
        var _t23 = ++this.pendingBackendInitId,
            _n17 = _s15.then(n => !(_t23 < this.pendingBackendInitId || (this.registry[e] = n, this.pendingBackendInit = null, 0))).catch(n => (_t23 < this.pendingBackendInitId || (this.pendingBackendInit = null, W("Initialization of backend ".concat(e, " failed")), W(n.stack || n.message)), !1));

        return this.pendingBackendInit = _n17, {
          success: _n17,
          asyncInit: !0
        };
      }
    } catch (t) {
      return W("Initialization of backend ".concat(e, " failed")), W(t.stack || t.message), {
        success: !1,
        asyncInit: !1
      };
    }
  }

  removeBackend(e) {
    if (!(e in this.registryFactory)) throw new Error("".concat(e, " backend not found in registry"));
    this.backendName === e && null != this.pendingBackendInit && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }

  getSortedBackends() {
    if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort((e, t) => this.registryFactory[t].priority - this.registryFactory[e].priority);
  }

  initializeBackendsAndReturnBest() {
    var e = this.getSortedBackends();

    for (var _t24 = 0; _t24 < e.length; _t24++) {
      var _n18 = e[_t24],
          {
        success: _s16,
        asyncInit: _r5
      } = this.initializeBackend(_n18);
      if (_r5 || _s16) return {
        name: _n18,
        asyncInit: _r5
      };
    }

    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }

  moveData(e, t) {
    var n = this.state.tensorInfo.get(t),
        s = n.backend,
        r = this.readSync(t),
        a = s.refCount(t);
    s.disposeData(t, !0), n.backend = e, e.move(t, r, n.shape, n.dtype, a), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }

  tidy(e, t) {
    var n,
        s = null;

    if (null == t) {
      if ("function" != typeof e) throw new Error("Please provide a function to tidy()");
      t = e;
    } else {
      if ("string" != typeof e && !(e instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if ("function" != typeof t) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      s = e;
    }

    return this.scopedRun(() => this.startScope(s), () => this.endScope(n), () => (n = t(), n instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n));
  }

  scopedRun(e, t, n) {
    e();

    try {
      var _e14 = n();

      return t(), _e14;
    } catch (e) {
      throw t(), e;
    }
  }

  nextTensorId() {
    return kt.nextTensorId++;
  }

  nextVariableId() {
    return kt.nextVariableId++;
  }

  clone(e) {
    var t = vt.runKernel("Identity", {
      x: e
    });
    return this.addTapeNode(this.state.activeScope.name, {
      x: e
    }, [t], e => ({
      x: () => vt.runKernel("Cast", {
        x: e
      }, {
        dtype: "float32"
      })
    }), [], {}), t;
  }

  runKernel(e, t, n) {
    if (null == J(e, this.backendName)) throw new Error("Kernel '".concat(e, "' not registered for backend '").concat(this.backendName, "'"));
    return this.runKernelFunc({
      kernelName: e,
      inputs: t,
      attrs: n
    });
  }

  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }

  checkKernelForMemLeak(e, t, n) {
    var s = this.backend.numDataIds();
    var r = 0;
    n.forEach(e => {
      r += "complex64" === e.dtype ? 3 : 1;
    });
    var a = s - t - r - this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
    if (a > 0) throw new Error("Backend '".concat(this.backendName, "' has an internal memory leak (").concat(a, " data ids) after running '").concat(e, "'"));
  }

  runKernelFunc(e) {
    var t,
        n = [];
    var s = this.isTapeOn(),
        r = this.state.numBytes,
        a = this.state.numTensors;
    var i, o;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    var u = xt(e) ? e.kernelName : null != this.state.activeScope ? this.state.activeScope.name : "";

    if (xt(e)) {
      var {
        kernelName: _t25,
        inputs: _r6,
        attrs: _a5
      } = e,
          _u2 = J(_t25, this.backendName);

      l(null != _u2, () => "Cannot find registered kernel '".concat(_t25, "' for backend '").concat(this.backendName, "'")), i = () => {
        var e = this.backend.numDataIds();
        o = _u2.kernelFunc({
          inputs: _r6,
          attrs: _a5,
          backend: this.backend
        });
        var i = Array.isArray(o) ? o : [o];
        this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(_t25, e, i);
        var l = i.map(e => {
          if (null != e.rank) return e;
          var {
            dataId: t,
            shape: n,
            dtype: s
          } = e;
          return this.makeTensorFromDataId(t, n, s);
        });

        if (s) {
          var _e15 = this.getTensorsForGradient(_t25, _r6, l);

          n = this.saveTensorsForBackwardMode(_e15);
        }

        return l;
      };
    } else {
      var {
        forwardFunc: _t26
      } = e,
          _r7 = e => {
        s && (n = e.map(e => this.keep(this.clone(e))));
      };

      i = () => {
        var e = this.backend.numDataIds();
        o = this.tidy(() => _t26(this.backend, _r7));
        var n = Array.isArray(o) ? o : [o];
        return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(u, e, n), n;
      };
    }

    var {
      inputs: c,
      attrs: h
    } = e,
        d = xt(e) ? null : e.backwardsFunc;
    var p;
    return this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
      this.ENV.getBool("DEBUG") || this.state.profiling ? (p = this.profiler.profileKernel(u, c, () => i()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(p), t = p.outputs) : t = i();
    }), s && this.addTapeNode(u, c, t, d, n, h), this.state.profiling && this.state.activeProfile.kernels.push({
      name: u,
      bytesAdded: this.state.numBytes - r,
      totalBytesSnapshot: this.state.numBytes,
      tensorsAdded: this.state.numTensors - a,
      totalTensorsSnapshot: this.state.numTensors,
      inputShapes: Object.keys(c).map(e => null != c[e] ? c[e].shape : null),
      outputShapes: t.map(e => e.shape),
      kernelTimeMs: p.timeMs,
      extraInfo: p.extraInfo
    }), Array.isArray(o) ? t : t[0];
  }

  saveTensorsForBackwardMode(e) {
    return e.map(e => this.keep(this.clone(e)));
  }

  getTensorsForGradient(e, t, n) {
    var s = Z(e);

    if (null != s) {
      var _e16 = s.inputsToSave || [],
          _r8 = s.outputsToSave || [];

      var _a6;

      s.saveAllInputs ? (l(Array.isArray(t), () => "saveAllInputs is true, expected inputs to be an array."), _a6 = Object.keys(t).map(e => t[e])) : _a6 = _e16.map(e => t[e]);

      var _i4 = n.filter((e, t) => _r8[t]);

      return _a6.concat(_i4);
    }

    return [];
  }

  makeTensor(e, t, n, s) {
    if (null == e) throw new Error("Values passed to engine.makeTensor() are null");
    s = s || this.backend;
    var r = e;
    "string" === (n = n || "float32") && N(e[0]) && (r = e.map(e => He(e)));
    var a = s.write(r, t, n),
        i = new rt(t, n, a, this.nextTensorId());

    if (this.trackTensor(i, s), "string" === n) {
      var _e17 = this.state.tensorInfo.get(a),
          _t27 = function (e) {
        if (null == e) return 0;
        var t = 0;
        return e.forEach(e => t += e.length), t;
      }(r);

      this.state.numBytes += _t27 - _e17.bytes, _e17.bytes = _t27;
    }

    return i;
  }

  makeTensorFromDataId(e, t, n, s) {
    var r = new rt(t, n = n || "float32", e, this.nextTensorId());
    return this.trackTensor(r, s), r;
  }

  makeVariable(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    n = n || this.nextVariableId().toString(), null != s && s !== e.dtype && (e = e.cast(s));
    var r = new it(e, t, n, this.nextTensorId());
    if (null != this.state.registeredVariables[r.name]) throw new Error("Variable with name ".concat(r.name, " was already registered"));
    return this.state.registeredVariables[r.name] = r, this.incRef(r, this.backend), r;
  }

  trackTensor(e, t) {
    this.state.numTensors++, "string" === e.dtype && this.state.numStringTensors++;
    var n = 0;
    "complex64" !== e.dtype && "string" !== e.dtype && (n = e.size * S(e.dtype)), this.state.numBytes += n, this.state.tensorInfo.has(e.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e.dataId, {
      backend: t || this.backend,
      dtype: e.dtype,
      shape: e.shape,
      bytes: n
    })), e instanceof it || this.track(e);
  }

  incRef(e, t) {
    this.trackTensor(e, t), this.backend.incRef(e.dataId);
  }

  removeDataId(e, t) {
    this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === t && (this.state.tensorInfo.delete(e), this.state.numDataBuffers--);
  }

  disposeTensor(e) {
    if (!this.state.tensorInfo.has(e.dataId)) return;
    var t = this.state.tensorInfo.get(e.dataId);

    if (this.state.numTensors--, "string" === e.dtype && (this.state.numStringTensors--, this.state.numBytes -= t.bytes), "complex64" !== e.dtype && "string" !== e.dtype) {
      var _t28 = e.size * S(e.dtype);

      this.state.numBytes -= _t28;
    }

    t.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, t.backend);
  }

  disposeVariables() {
    for (var _e18 in this.state.registeredVariables) {
      this.disposeVariable(this.state.registeredVariables[_e18]);
    }
  }

  disposeVariable(e) {
    this.disposeTensor(e), null != this.state.registeredVariables[e.name] && delete this.state.registeredVariables[e.name];
  }

  memory() {
    var e = this.backend.memory();
    return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = !0, null == e.reasons && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e;
  }

  profile(e) {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      _this8.state.profiling = !0;
      var t = _this8.state.numBytes,
          n = _this8.state.numTensors;
      _this8.state.activeProfile.kernels = [], _this8.state.activeProfile.result = yield e(), _this8.state.profiling = !1, _this8.state.activeProfile.peakBytes = Math.max(..._this8.state.activeProfile.kernels.map(e => e.totalBytesSnapshot)), _this8.state.activeProfile.newBytes = _this8.state.numBytes - t, _this8.state.activeProfile.newTensors = _this8.state.numTensors - n;

      for (var _e19 of _this8.state.activeProfile.kernels) {
        _e19.kernelTimeMs = yield _e19.kernelTimeMs, _e19.extraInfo = yield _e19.extraInfo;
      }

      return _this8.state.activeProfile;
    })();
  }

  isTapeOn() {
    return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
  }

  addTapeNode(e, t, n, s, r, a) {
    var i = {
      id: this.state.nextTapeNodeId++,
      kernelName: e,
      inputs: t,
      outputs: n,
      saved: r
    },
        o = Z(e);
    null != o && (s = o.gradFunc), null != s && (i.gradient = e => (e = e.map((e, t) => {
      if (null == e) {
        var _e20 = n[t],
            _s17 = O(_e20.size, _e20.dtype);

        return this.makeTensor(_s17, _e20.shape, _e20.dtype);
      }

      return e;
    }), s(e.length > 1 ? e : e[0], r, a))), this.state.activeTape.push(i);
  }

  keep(e) {
    return e.kept = !0, e;
  }

  startTape() {
    0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
  }

  endTape() {
    this.state.gradientDepth--;
  }

  startScope(e) {
    var t = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    e && (t.name = e), this.state.scopeStack.push(t), this.state.activeScope = t;
  }

  endScope(e) {
    var t = mt(e),
        n = new Set(t.map(e => e.id));

    for (var _e21 = 0; _e21 < this.state.activeScope.track.length; _e21++) {
      var _t29 = this.state.activeScope.track[_e21];
      _t29.kept || n.has(_t29.id) || _t29.dispose();
    }

    var s = this.state.scopeStack.pop();
    this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], t.forEach(e => {
      e.kept || e.scopeId !== s.id || this.track(e);
    });
  }

  gradients(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    if (l(t.length > 0, () => "gradients() received an empty list of xs."), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype, "'"));
    var r = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", e));
    l(r instanceof rt, () => "The result y returned by f() must be a tensor.");

    var a = function (e, t, n) {
      var s = {},
          r = {};

      for (var _e22 = 0; _e22 < t.length; _e22++) {
        s[t[_e22].id] = !0;
      }

      for (var _n19 = 0; _n19 < e.length; _n19++) {
        var _a7 = e[_n19],
            _i5 = _a7.inputs;

        for (var _e23 in _i5) {
          var _n20 = _i5[_e23];

          var _o4 = !1;

          for (var _e24 = 0; _e24 < t.length; _e24++) {
            if (s[_n20.id]) {
              _a7.outputs.forEach(e => s[e.id] = !0), _o4 = !0, r[_a7.id] = !0;
              break;
            }
          }

          if (_o4) break;
        }
      }

      var a = {};
      a[n.id] = !0;
      var i = {};

      for (var _t30 = e.length - 1; _t30 >= 0; _t30--) {
        var _n21 = e[_t30],
            _s18 = _n21.inputs;

        for (var _e25 = 0; _e25 < _n21.outputs.length; _e25++) {
          if (a[_n21.outputs[_e25].id]) {
            for (var _e26 in _s18) {
              a[_s18[_e26].id] = !0, i[_n21.id] = !0;
            }

            break;
          }
        }
      }

      var o = [];

      for (var _t31 = 0; _t31 < e.length; _t31++) {
        var _n22 = e[_t31];

        if (r[_n22.id] && i[_n22.id]) {
          var _e27 = {};

          for (var _t33 in _n22.inputs) {
            var _r9 = _n22.inputs[_t33];
            s[_r9.id] && (_e27[_t33] = _r9);
          }

          var _t32 = Object.assign({}, _n22);

          _t32.inputs = _e27, _t32.outputs = _n22.outputs, o.push(_t32);
        }
      }

      return o;
    }(this.state.activeTape, t, r);

    if (!s && 0 === a.length && t.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", () => {
      var e = {};
      e[r.id] = null == n ? function (e) {
        var t = _(d(e), "float32");

        return vt.makeTensor(t, e, "float32");
      }(r.shape) : n, function (e, t, n, s) {
        var _loop2 = function _loop2(_r10) {
          var a = t[_r10],
              i = [];
          if (a.outputs.forEach(t => {
            var n = e[t.id];
            i.push(null != n ? n : null);
          }), null == a.gradient) throw new Error("Cannot compute gradient: gradient function not found for ".concat(a.kernelName, "."));
          var o = a.gradient(i);

          var _loop3 = function _loop3(_t34) {
            if (!(_t34 in o)) throw new Error("Cannot backprop through input ".concat(_t34, ". Available gradients found: ").concat(Object.keys(o), "."));
            var r = n(() => o[_t34]());
            if ("float32" !== r.dtype) throw new Error("Error in gradient for op ".concat(a.kernelName, ". The gradient of input ").concat(_t34, " must have 'float32' dtype, but has '").concat(r.dtype, "'"));
            var i = a.inputs[_t34];
            if (!p(r.shape, i.shape)) throw new Error("Error in gradient for op ".concat(a.kernelName, ". The gradient of input '").concat(_t34, "' has shape '").concat(r.shape, "', which does not match the shape of the input '").concat(i.shape, "'"));
            if (null == e[i.id]) e[i.id] = r;else {
              var _t35 = e[i.id];
              e[i.id] = s(_t35, r), _t35.dispose();
            }
          };

          for (var _t34 in a.inputs) {
            _loop3(_t34);
          }
        };

        for (var _r10 = t.length - 1; _r10 >= 0; _r10--) {
          _loop2(_r10);
        }
      }(e, a, e => this.tidy(e), It);
      var s = t.map(t => e[t.id]);
      return 0 === this.state.gradientDepth && (this.state.activeTape.forEach(e => {
        for (var _t36 of e.saved) {
          _t36.dispose();
        }
      }), this.state.activeTape = null), {
        value: r,
        grads: s
      };
    });
  }

  customGrad(e) {
    var _this9 = this;

    return l(E(e), () => "The f passed in customGrad(f) must be a function."), function () {
      for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        t[_key4] = arguments[_key4];
      }

      var n;
      l(t.every(e => e instanceof rt), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      var s = {};
      return t.forEach((e, t) => {
        s[t] = e;
      }), _this9.runKernelFunc({
        forwardFunc: (s, r) => (n = e(...t, r), l(n.value instanceof rt, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), l(E(n.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), n.value),
        backwardsFunc: (e, s) => {
          var r = n.gradFunc(e, s),
              a = Array.isArray(r) ? r : [r];
          l(a.length === t.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), l(a.every(e => e instanceof rt), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
          var i = {};
          return a.forEach((e, t) => {
            i[t] = () => e;
          }), i;
        },
        inputs: s
      });
    };
  }

  readSync(e) {
    return this.state.tensorInfo.get(e).backend.readSync(e);
  }

  read(e) {
    return this.state.tensorInfo.get(e).backend.read(e);
  }

  time(e) {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      var t = Ge(),
          n = yield _this10.backend.time(e);
      return n.wallMs = Ge() - t, n;
    })();
  }

  track(e) {
    return null != this.state.activeScope && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e;
  }

  get registeredVariables() {
    return this.state.registeredVariables;
  }

  reset() {
    this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new yt();

    for (var _e28 in this.registry) {
      this.disposeRegisteredKernels(_e28), this.registry[_e28].dispose(), delete this.registry[_e28];
    }

    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }

}

function wt() {
  var e = j();

  if (null == e._tfengine) {
    var _t37 = new U(e);

    e._tfengine = new kt(_t37);
  }

  return q = e._tfengine.ENV, nt = () => e._tfengine, e._tfengine;
}

kt.nextTensorId = 0, kt.nextVariableId = 0;
var vt = wt();

function It(e, t) {
  return vt.runKernel("Add", {
    a: e,
    b: t
  });
}

function $t(e) {
  if (e || "undefined" != typeof navigator && null != navigator) {
    if (e || (e = navigator), "ReactNative" === e.product) return !0;

    var _t38 = e.userAgent || e.vendor || ("undefined" != typeof window ? window.opera : "");

    if (!_t38) {
      var _t39 = e;
      return _t39.userAgentData && _t39.userAgentData.mobile;
    }

    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(_t38) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(_t38.substr(0, 4));
  }

  return !1;
}

function St() {
  return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}

var Nt = G();

function Ct(e, t) {
  var n = e;
  if ($(e)) return "string" === t ? [] : [e.length];
  if (!Array.isArray(e)) return [];
  var s = [];

  for (; Array.isArray(n) || $(n) && "string" !== t;) {
    s.push(n.length), n = n[0];
  }

  return Array.isArray(e) && G().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && Tt(e, s, []), s;
}

function Tt(e, t, n) {
  if (n = n || [], !Array.isArray(e) && !$(e)) return void l(0 === t.length, () => "Element arr[".concat(n.join("]["), "] is a primitive, but should be an array/TypedArray of ").concat(t[0], " elements"));
  l(t.length > 0, () => "Element arr[".concat(n.join("]["), "] should be a primitive, but is an array of ").concat(e.length, " elements")), l(e.length === t[0], () => "Element arr[".concat(n.join("]["), "] should have ").concat(t[0], " elements, but has ").concat(e.length, " elements"));
  var s = t.slice(1);

  for (var _t40 = 0; _t40 < e.length; ++_t40) {
    Tt(e[_t40], s, n.concat(_t40));
  }
}

function Et(e, t, n, s) {
  if ("string_or_numeric" !== e) {
    if (null == e) throw new Error("Expected dtype cannot be null.");
    if ("numeric" !== e && e !== t || "numeric" === e && "string" === t) throw new Error("Argument '".concat(n, "' passed to '").concat(s, "' must be ").concat(e, " tensor, but got ").concat(t, " tensor"));
  }
}

function Rt(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "numeric";
  if (e instanceof rt) return Et(s, e.dtype, t, n), e;
  var r = T(e);
  if ("string" !== r && ["bool", "int32", "float32"].indexOf(s) >= 0 && (r = s), Et(s, r, t, n), null == e || !$(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) throw new Error("Argument '".concat(t, "' passed to '").concat(n, "' must be a Tensor or TensorLike, but got '").concat(null == e ? "null" : e.constructor.name, "'"));
  var a = Ct(e, r);
  $(e) || Array.isArray(e) || (e = [e]);
  var i = "string" !== r ? Ve(e, r) : h(e, [], !0);
  return vt.makeTensor(i, a, r);
}

function At(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "numeric";
  if (!Array.isArray(e)) throw new Error("Argument ".concat(t, " passed to ").concat(n, " must be a `Tensor[]` or `TensorLike[]`"));
  return e.map((e, r) => Rt(e, "".concat(t, "[").concat(r, "]"), n, s));
}

function Ft(e) {
  var t = Object.keys(e);
  if (1 !== t.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with ".concat(t.length, " keys."));
  var n = t[0];
  var s = e[n];
  n.endsWith("_") && (n = n.substring(0, n.length - 1)), n += "__op";

  var r = function r() {
    vt.startScope(n);

    try {
      var _t41 = s(...arguments);

      return P(_t41) && console.error("Cannot return a Promise inside of tidy."), vt.endScope(_t41), _t41;
    } catch (e) {
      throw vt.endScope(null), e;
    }
  };

  return Object.defineProperty(r, "name", {
    value: n,
    configurable: !0
  }), r;
}

Nt.registerFlag("DEBUG", () => !1, e => {
  e && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Nt.registerFlag("IS_BROWSER", () => St()), Nt.registerFlag("IS_NODE", () => "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node), Nt.registerFlag("IS_CHROME", () => "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)), Nt.registerFlag("PROD", () => !1), Nt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => Nt.getBool("DEBUG")), Nt.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => !0), Nt.registerFlag("IS_TEST", () => !1), Nt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => !0), Nt.registerFlag("WRAP_TO_IMAGEBITMAP", () => !1);
var Dt = Ft({
  complex_: function complex_(e, t) {
    var n = Rt(e, "real", "complex"),
        s = Rt(t, "imag", "complex");
    return u(n.shape, s.shape, "real and imag shapes, ".concat(n.shape, " and ").concat(s.shape, ", must match in call to tf.complex().")), vt.runKernel("Complex", {
      real: n,
      imag: s
    });
  }
});

function _t(e, t, n, s) {
  if (null == s && (s = T(e)), "complex64" === s) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!$(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");

  if (null != t) {
    L(t);

    var _e29 = d(t),
        _s19 = d(n);

    l(_e29 === _s19, () => "Based on the provided shape, [".concat(t, "], the tensor should have ").concat(_e29, " values but has ").concat(_s19));

    for (var _e30 = 0; _e30 < n.length; ++_e30) {
      var _s20 = n[_e30],
          _r11 = _e30 !== n.length - 1 || _s20 !== d(t.slice(_e30));

      l(n[_e30] === t[_e30] || !_r11, () => "Error creating a new Tensor. Inferred shape (".concat(n, ") does not match the provided shape (").concat(t, "). "));
    }
  }

  return $(e) || Array.isArray(e) || (e = [e]), t = t || n, e = "string" !== s ? Ve(e, s) : h(e, [], !0), vt.makeTensor(e, t, s);
}

function Ot(e, t, n) {
  return _t(e, t, Ct(e, n), n);
}

var Mt = {
  float32: 4,
  float16: 2,
  int32: 4,
  uint16: 2,
  uint8: 1,
  bool: 1,
  complex64: 8
};

function Lt(_x2, _x3) {
  return _Lt.apply(this, arguments);
}

function _Lt() {
  _Lt = _asyncToGenerator(function* (e, t) {
    var n = [],
        s = [],
        r = Array.isArray(e) ? e.map(e => e.name) : Object.keys(e);

    var _loop32 = function _loop32(_a146) {
      var i = r[_a146],
          o = Array.isArray(e) ? e[_a146].tensor : e[i];
      if ("float32" !== o.dtype && "int32" !== o.dtype && "bool" !== o.dtype && "string" !== o.dtype && "complex64" !== o.dtype) throw new Error("Unsupported dtype in weight '".concat(i, "': ").concat(o.dtype));
      var l = {
        name: i,
        shape: o.shape,
        dtype: o.dtype
      };

      if ("string" === o.dtype) {
        var _e527 = new Promise( /*#__PURE__*/function () {
          var _ref38 = _asyncToGenerator(function* (e) {
            var t = yield o.bytes(),
                n = t.reduce((e, t) => e + t.length, 0) + 4 * t.length,
                s = new Uint8Array(n);
            var r = 0;

            for (var _e528 = 0; _e528 < t.length; _e528++) {
              var _n296 = t[_e528],
                  _a147 = new Uint8Array(new Uint32Array([_n296.length]).buffer);

              s.set(_a147, r), r += 4, s.set(_n296, r), r += _n296.length;
            }

            e(s);
          });

          return function (_x65) {
            return _ref38.apply(this, arguments);
          };
        }());

        s.push(_e527);
      } else s.push(o.data());

      null != t && (l.group = t), n.push(l);
    };

    for (var _a146 = 0; _a146 < r.length; ++_a146) {
      _loop32(_a146);
    }

    return {
      data: zt(yield Promise.all(s)),
      specs: n
    };
  });
  return _Lt.apply(this, arguments);
}

function zt(e) {
  if (null === e) throw new Error("Invalid input value: ".concat(JSON.stringify(e)));
  var t = 0;
  var n = [];
  e.forEach(e => {
    if (t += e.byteLength, n.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e)), !(e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name));
  });
  var s = new Uint8Array(t);
  var r = 0;
  return n.forEach(e => {
    s.set(new Uint8Array(e.buffer), r), r += e.byteLength;
  }), s.buffer;
}

var Bt = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

function Pt(e) {
  return Bt ? Buffer.byteLength(e) : new Blob([e]).size;
}

function Wt(e) {
  if (1 === e.length) return e[0];
  var t = 0;
  e.forEach(e => {
    t += e.byteLength;
  });
  var n = new Uint8Array(t);
  var s = 0;
  return e.forEach(e => {
    n.set(new Uint8Array(e), s), s += e.byteLength;
  }), n.buffer;
}

function Ut(e, t) {
  var n = {
    modelTopology: e.modelTopology,
    format: e.format,
    generatedBy: e.generatedBy,
    convertedBy: e.convertedBy,
    weightsManifest: t
  };
  return null != e.signature && (n.signature = e.signature), null != e.userDefinedMetadata && (n.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (n.modelInitializer = e.modelInitializer), null != e.trainingConfig && (n.trainingConfig = e.trainingConfig), n;
}

function Vt(e) {
  if (e.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {
    dateSaved: new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: null == e.modelTopology ? 0 : Pt(JSON.stringify(e.modelTopology)),
    weightSpecsBytes: null == e.weightSpecs ? 0 : Pt(JSON.stringify(e.weightSpecs)),
    weightDataBytes: null == e.weightData ? 0 : e.weightData.byteLength
  };
}

function Gt() {
  var e = function () {
    var e = e => {
      var t = e << 13,
          n = 0;

      for (; 0 == (8388608 & t);) {
        n -= 8388608, t <<= 1;
      }

      return t &= -8388609, n += 947912704, t | n;
    },
        t = new Uint32Array(2048);

    t[0] = 0;

    for (var _n23 = 1; _n23 < 1024; _n23++) {
      t[_n23] = e(_n23);
    }

    for (var _e31 = 1024; _e31 < 2048; _e31++) {
      t[_e31] = 939524096 + (_e31 - 1024 << 13);
    }

    return t;
  }(),
      t = function () {
    var e = new Uint32Array(64);
    e[0] = 0, e[31] = 1199570944, e[32] = 2147483648, e[63] = 3347054592;

    for (var _t42 = 1; _t42 < 31; _t42++) {
      e[_t42] = _t42 << 23;
    }

    for (var _t43 = 33; _t43 < 63; _t43++) {
      e[_t43] = 2147483648 + (_t43 - 32 << 23);
    }

    return e;
  }(),
      n = function () {
    var e = new Uint32Array(64);

    for (var _t44 = 0; _t44 < 64; _t44++) {
      e[_t44] = 1024;
    }

    return e[0] = e[32] = 0, e;
  }();

  return s => {
    var r = new ArrayBuffer(4 * s.length),
        a = new Uint32Array(r);

    for (var _r12 = 0; _r12 < s.length; _r12++) {
      var _i6 = s[_r12];
      a[_r12] = e[n[_i6 >> 10] + (1023 & _i6)] + t[_i6 >> 10];
    }

    return new Float32Array(r);
  };
}

class Ht {
  constructor() {
    this.saveRouters = [], this.loadRouters = [];
  }

  static getInstance() {
    return null == Ht.instance && (Ht.instance = new Ht()), Ht.instance;
  }

  static registerSaveRouter(e) {
    Ht.getInstance().saveRouters.push(e);
  }

  static registerLoadRouter(e) {
    Ht.getInstance().loadRouters.push(e);
  }

  static getSaveHandlers(e) {
    return Ht.getHandlers(e, "save");
  }

  static getLoadHandlers(e, t) {
    return Ht.getHandlers(e, "load", t);
  }

  static getHandlers(e, t, n) {
    var s = [];
    return ("load" === t ? Ht.getInstance().loadRouters : Ht.getInstance().saveRouters).forEach(t => {
      var r = t(e, n);
      null !== r && s.push(r);
    }), s;
  }

}

function qt() {
  if (!G().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var e = "undefined" == typeof window ? self : window,
      t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
  if (null == t) throw new Error("The current browser does not appear to support IndexedDB.");
  return t;
}

function jt(e) {
  var t = e.result;
  t.createObjectStore("models_store", {
    keyPath: "modelPath"
  }), t.createObjectStore("model_info_store", {
    keyPath: "modelPath"
  });
}

class Kt {
  constructor(e) {
    if (this.indexedDB = qt(), null == e || !e) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = e;
  }

  save(e) {
    var _this11 = this;

    return _asyncToGenerator(function* () {
      if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      return _this11.databaseAction(_this11.modelPath, e);
    })();
  }

  load() {
    var _this12 = this;

    return _asyncToGenerator(function* () {
      return _this12.databaseAction(_this12.modelPath);
    })();
  }

  databaseAction(e, t) {
    return new Promise((e, n) => {
      var s = this.indexedDB.open("tensorflowjs", 1);
      s.onupgradeneeded = () => jt(s), s.onsuccess = () => {
        var r = s.result;

        if (null == t) {
          var _t45 = r.transaction("models_store", "readonly"),
              _s21 = _t45.objectStore("models_store").get(this.modelPath);

          _s21.onsuccess = () => {
            if (null == _s21.result) return r.close(), n(new Error("Cannot find model with path '".concat(this.modelPath, "' in IndexedDB.")));
            e(_s21.result.modelArtifacts);
          }, _s21.onerror = e => (r.close(), n(_s21.error)), _t45.oncomplete = () => r.close();
        } else {
          var _s22 = Vt(t),
              _a8 = r.transaction("model_info_store", "readwrite");

          var _i7 = _a8.objectStore("model_info_store");

          var _o5 = _i7.put({
            modelPath: this.modelPath,
            modelArtifactsInfo: _s22
          });

          var _l2;

          _o5.onsuccess = () => {
            _l2 = r.transaction("models_store", "readwrite");

            var o = _l2.objectStore("models_store").put({
              modelPath: this.modelPath,
              modelArtifacts: t,
              modelArtifactsInfo: _s22
            });

            o.onsuccess = () => e({
              modelArtifactsInfo: _s22
            }), o.onerror = e => {
              _i7 = _a8.objectStore("model_info_store");

              var t = _i7.delete(this.modelPath);

              t.onsuccess = () => (r.close(), n(o.error)), t.onerror = e => (r.close(), n(o.error));
            };
          }, _o5.onerror = e => (r.close(), n(_o5.error)), _a8.oncomplete = () => {
            null == _l2 ? r.close() : _l2.oncomplete = () => r.close();
          };
        }
      }, s.onerror = e => n(s.error);
    });
  }

}

Kt.URL_SCHEME = "indexeddb://";

var Xt = e => {
  return G().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(Kt.URL_SCHEME) ? (t = e.slice(Kt.URL_SCHEME.length), new Kt(t)) : null;
  var t;
};

Ht.registerSaveRouter(Xt), Ht.registerLoadRouter(Xt);

class Yt {
  constructor() {
    this.indexedDB = qt();
  }

  listModels() {
    var _this13 = this;

    return _asyncToGenerator(function* () {
      return new Promise((e, t) => {
        var n = _this13.indexedDB.open("tensorflowjs", 1);

        n.onupgradeneeded = () => jt(n), n.onsuccess = () => {
          var s = n.result,
              r = s.transaction("model_info_store", "readonly"),
              a = r.objectStore("model_info_store").getAll();
          a.onsuccess = () => {
            var t = {};

            for (var _e32 of a.result) {
              t[_e32.modelPath] = _e32.modelArtifactsInfo;
            }

            e(t);
          }, a.onerror = e => (s.close(), t(a.error)), r.oncomplete = () => s.close();
        }, n.onerror = e => t(n.error);
      });
    })();
  }

  removeModel(e) {
    var _this14 = this;

    return _asyncToGenerator(function* () {
      var t;
      return e = (t = e).startsWith(Kt.URL_SCHEME) ? t.slice(Kt.URL_SCHEME.length) : t, new Promise((t, n) => {
        var s = _this14.indexedDB.open("tensorflowjs", 1);

        s.onupgradeneeded = () => jt(s), s.onsuccess = () => {
          var r = s.result,
              a = r.transaction("model_info_store", "readwrite"),
              i = a.objectStore("model_info_store"),
              o = i.get(e);
          var l;
          o.onsuccess = () => {
            if (null == o.result) return r.close(), n(new Error("Cannot find model with path '".concat(e, "' in IndexedDB.")));
            {
              var _s23 = i.delete(e),
                  _a9 = () => {
                l = r.transaction("models_store", "readwrite");
                var s = l.objectStore("models_store").delete(e);
                s.onsuccess = () => t(o.result.modelArtifactsInfo), s.onerror = e => n(o.error);
              };

              _s23.onsuccess = _a9, _s23.onerror = e => (_a9(), r.close(), n(o.error));
            }
          }, o.onerror = e => (r.close(), n(o.error)), a.oncomplete = () => {
            null == l ? r.close() : l.oncomplete = () => r.close();
          };
        }, s.onerror = e => n(s.error);
      });
    })();
  }

}

var Jt = "tensorflowjs_models",
    Zt = "info",
    Qt = "model_topology",
    en = "weight_specs",
    tn = "weight_data",
    nn = "model_metadata";

function sn(e) {
  return {
    info: [Jt, e, Zt].join("/"),
    topology: [Jt, e, Qt].join("/"),
    weightSpecs: [Jt, e, en].join("/"),
    weightData: [Jt, e, tn].join("/"),
    modelMetadata: [Jt, e, nn].join("/")
  };
}

function rn(e) {
  for (var _t46 of Object.values(e)) {
    window.localStorage.removeItem(_t46);
  }
}

function an(e) {
  var t = e.split("/");
  if (t.length < 3) throw new Error("Invalid key format: ".concat(e));
  return t.slice(1, t.length - 1).join("/");
}

class on {
  constructor(e) {
    if (!G().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, null == e || !e) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = e, this.keys = sn(this.modelPath);
  }

  save(e) {
    var _this15 = this;

    return _asyncToGenerator(function* () {
      if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      {
        var _t47 = JSON.stringify(e.modelTopology),
            _n24 = JSON.stringify(e.weightSpecs),
            _s24 = Vt(e);

        try {
          return _this15.LS.setItem(_this15.keys.info, JSON.stringify(_s24)), _this15.LS.setItem(_this15.keys.topology, _t47), _this15.LS.setItem(_this15.keys.weightSpecs, _n24), _this15.LS.setItem(_this15.keys.weightData, function (e) {
            if (Bt) return Buffer.from(e).toString("base64");
            var t = new Uint8Array(e);
            var n = "";

            for (var _e33 = 0, _s25 = t.length; _e33 < _s25; _e33++) {
              n += String.fromCharCode(t[_e33]);
            }

            return btoa(n);
          }(e.weightData)), _this15.LS.setItem(_this15.keys.modelMetadata, JSON.stringify({
            format: e.format,
            generatedBy: e.generatedBy,
            convertedBy: e.convertedBy,
            signature: null != e.signature ? e.signature : void 0,
            userDefinedMetadata: null != e.userDefinedMetadata ? e.userDefinedMetadata : void 0,
            modelInitializer: null != e.modelInitializer ? e.modelInitializer : void 0,
            trainingConfig: null != e.trainingConfig ? e.trainingConfig : void 0
          })), {
            modelArtifactsInfo: _s24
          };
        } catch (e) {
          throw rn(_this15.keys), new Error("Failed to save model '".concat(_this15.modelPath, "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=").concat(_s24.modelTopologyBytes, ", weightSpecsBytes=").concat(_s24.weightSpecsBytes, ", weightDataBytes=").concat(_s24.weightDataBytes, "."));
        }
      }
    })();
  }

  load() {
    var _this16 = this;

    return _asyncToGenerator(function* () {
      var e = JSON.parse(_this16.LS.getItem(_this16.keys.info));
      if (null == e) throw new Error("In local storage, there is no model with name '".concat(_this16.modelPath, "'"));
      if ("JSON" !== e.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
      var t = {},
          n = JSON.parse(_this16.LS.getItem(_this16.keys.topology));
      if (null == n) throw new Error("In local storage, the topology of model '".concat(_this16.modelPath, "' is missing."));
      t.modelTopology = n;
      var s = JSON.parse(_this16.LS.getItem(_this16.keys.weightSpecs));
      if (null == s) throw new Error("In local storage, the weight specs of model '".concat(_this16.modelPath, "' are missing."));
      t.weightSpecs = s;

      var r = _this16.LS.getItem(_this16.keys.modelMetadata);

      if (null != r) {
        var _e34 = JSON.parse(r);

        t.format = _e34.format, t.generatedBy = _e34.generatedBy, t.convertedBy = _e34.convertedBy, null != _e34.signature && (t.signature = _e34.signature), null != _e34.userDefinedMetadata && (t.userDefinedMetadata = _e34.userDefinedMetadata), null != _e34.modelInitializer && (t.modelInitializer = _e34.modelInitializer), null != _e34.trainingConfig && (t.trainingConfig = _e34.trainingConfig);
      }

      var a = _this16.LS.getItem(_this16.keys.weightData);

      if (null == a) throw new Error("In local storage, the binary weight values of model '".concat(_this16.modelPath, "' are missing."));
      return t.weightData = function (e) {
        if (Bt) {
          var _t48 = Buffer.from(e, "base64");

          return _t48.buffer.slice(_t48.byteOffset, _t48.byteOffset + _t48.byteLength);
        }

        var t = atob(e),
            n = new Uint8Array(t.length);

        for (var _e35 = 0; _e35 < t.length; ++_e35) {
          n.set([t.charCodeAt(_e35)], _e35);
        }

        return n.buffer;
      }(a), t;
    })();
  }

}

on.URL_SCHEME = "localstorage://";

var ln = e => {
  return G().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(on.URL_SCHEME) ? (t = e.slice(on.URL_SCHEME.length), new on(t)) : null;
  var t;
};

Ht.registerSaveRouter(ln), Ht.registerLoadRouter(ln);

class un {
  constructor() {
    l(G().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), l("undefined" == typeof window || void 0 !== window.localStorage, () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
  }

  listModels() {
    var _this17 = this;

    return _asyncToGenerator(function* () {
      var e = {},
          t = Jt + "/",
          n = "/" + Zt;

      for (var _s26 = 0; _s26 < _this17.LS.length; ++_s26) {
        var _r13 = _this17.LS.key(_s26);

        _r13.startsWith(t) && _r13.endsWith(n) && (e[an(_r13)] = JSON.parse(_this17.LS.getItem(_r13)));
      }

      return e;
    })();
  }

  removeModel(e) {
    var _this18 = this;

    return _asyncToGenerator(function* () {
      var t;
      var n = sn(e = (t = e).startsWith(on.URL_SCHEME) ? t.slice(on.URL_SCHEME.length) : t);
      if (null == _this18.LS.getItem(n.info)) throw new Error("Cannot find model at path '".concat(e, "'"));
      var s = JSON.parse(_this18.LS.getItem(n.info));
      return rn(n), s;
    })();
  }

}

class cn {
  constructor() {
    this.managers = {};
  }

  static getInstance() {
    return null == cn.instance && (cn.instance = new cn()), cn.instance;
  }

  static registerManager(e, t) {
    l(null != e, () => "scheme must not be undefined or null."), e.endsWith("://") && (e = e.slice(0, e.indexOf("://"))), l(e.length > 0, () => "scheme must not be an empty string.");
    var n = cn.getInstance();
    l(null == n.managers[e], () => "A model store manager is already registered for scheme '".concat(e, "'.")), n.managers[e] = t;
  }

  static getManager(e) {
    var t = this.getInstance().managers[e];
    if (null == t) throw new Error("Cannot find model manager for scheme '".concat(e, "'"));
    return t;
  }

  static getSchemes() {
    return Object.keys(this.getInstance().managers);
  }

}

class hn {
  fetch(e, t) {
    return fetch(e, t);
  }

  now() {
    return performance.now();
  }

  encode(e, t) {
    if ("utf-8" !== t && "utf8" !== t) throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));
    return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e);
  }

  decode(e, t) {
    return new TextDecoder(t).decode(e);
  }

}

if (G().get("IS_BROWSER")) {
  G().setPlatform("browser", new hn());

  try {
    cn.registerManager(on.URL_SCHEME, new un());
  } catch (e) {}

  try {
    cn.registerManager(Kt.URL_SCHEME, new Yt());
  } catch (e) {}
}

var dn;

function pn(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";
  var n = arguments.length > 2 ? arguments[2] : undefined;
  return t = t || "float32", L(e), new tt(e, t, n);
}

G().get("IS_NODE") && G().setPlatform("node", new class {
  constructor() {
    this.util = __webpack_require__(15895), this.textEncoder = new this.util.TextEncoder();
  }

  fetch(e, t) {
    return null != G().global.fetch ? G().global.fetch(e, t) : (null == dn && (dn = __webpack_require__(76474)), dn(e, t));
  }

  now() {
    var e = process.hrtime();
    return 1e3 * e[0] + e[1] / 1e6;
  }

  encode(e, t) {
    if ("utf-8" !== t && "utf8" !== t) throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));
    return this.textEncoder.encode(e);
  }

  decode(e, t) {
    return 0 === e.length ? "" : new this.util.TextDecoder(t).decode(e);
  }

}());
var fn = Ft({
  cast_: function cast_(e, t) {
    var n = Rt(e, "x", "cast");
    if (!function (e) {
      return "bool" === e || "complex64" === e || "float32" === e || "int32" === e || "string" === e;
    }(t)) throw new Error("Failed to cast to unknown dtype ".concat(t));
    if ("string" === t && "string" !== n.dtype || "string" !== t && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
    return vt.runKernel("Cast", {
      x: n
    }, {
      dtype: t
    });
  }
}),
    gn = Ft({
  clone_: function clone_(e) {
    var t = Rt(e, "x", "clone", "string_or_numeric");
    return vt.runKernel("Identity", {
      x: t
    });
  }
});

function mn(e) {
  return new Promise(e => setTimeout(e)).then(e);
}

wt(), st = {
  buffer: pn,
  cast: fn,
  clone: gn,
  print: function print(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    console.log(e.toString(t));
  }
};

class bn {
  constructor(e) {
    if (!G().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(bn.URL_SCHEME) && (e = e.slice(bn.URL_SCHEME.length)), null != e && 0 !== e.length || (e = "model"), this.modelJsonFileName = e + ".json", this.weightDataFileName = e + ".weights.bin";
  }

  save(e) {
    var _this19 = this;

    return _asyncToGenerator(function* () {
      if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
      var t = window.URL.createObjectURL(new Blob([e.weightData], {
        type: "application/octet-stream"
      }));
      if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
      {
        var _n25 = Ut(e, [{
          paths: ["./" + _this19.weightDataFileName],
          weights: e.weightSpecs
        }]),
            _s27 = window.URL.createObjectURL(new Blob([JSON.stringify(_n25)], {
          type: "application/json"
        })),
            _r14 = null == _this19.modelJsonAnchor ? document.createElement("a") : _this19.modelJsonAnchor;

        if (_r14.download = _this19.modelJsonFileName, _r14.href = _s27, yield mn(() => _r14.dispatchEvent(new MouseEvent("click"))), null != e.weightData) {
          var _e36 = null == _this19.weightDataAnchor ? document.createElement("a") : _this19.weightDataAnchor;

          _e36.download = _this19.weightDataFileName, _e36.href = t, yield mn(() => _e36.dispatchEvent(new MouseEvent("click")));
        }

        return {
          modelArtifactsInfo: Vt(e)
        };
      }
    })();
  }

}

function xn(e, t, n, s) {
  !function (e) {
    l(null != e && Array.isArray(e) && e.length > 0, () => "promises must be a none empty array");
  }(e), function (e, t) {
    l(e >= 0 && e <= 1, () => "Progress fraction must be in range [0, 1], but got startFraction ".concat(e)), l(t >= 0 && t <= 1, () => "Progress fraction must be in range [0, 1], but got endFraction ".concat(t)), l(t >= e, () => "startFraction must be no more than endFraction, but got startFraction ".concat(e, " and endFraction ").concat(t));
  }(n = null == n ? 0 : n, s = null == s ? 1 : s);
  var r = 0;
  return Promise.all(e.map(a => (a.then(a => {
    var i = n + ++r / e.length * (s - n);
    return t(i), a;
  }), a)));
}

bn.URL_SCHEME = "downloads://", Ht.registerSaveRouter(e => G().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(bn.URL_SCHEME) ? function () {
  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "model";
  return new bn(e);
}(e.slice(bn.URL_SCHEME.length)) : null);

class yn {
  constructor(e, t) {
    if (this.DEFAULT_METHOD = "POST", null == t && (t = {}), this.weightPathPrefix = t.weightPathPrefix, this.onProgress = t.onProgress, this.weightUrlConverter = t.weightUrlConverter, null != t.fetchFunc ? (l("function" == typeof t.fetchFunc, () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this.fetch = t.fetchFunc) : this.fetch = G().platform.fetch, l(null != e && e.length > 0, () => "URL path for http must not be null, undefined or empty."), Array.isArray(e) && l(2 === e.length, () => "URL paths for http must have a length of 2, (actual length is ".concat(e.length, ").")), this.path = e, null != t.requestInit && null != t.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = t.requestInit || {};
  }

  save(e) {
    var _this20 = this;

    return _asyncToGenerator(function* () {
      if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
      var t = Object.assign({
        method: _this20.DEFAULT_METHOD
      }, _this20.requestInit);
      t.body = new FormData();
      var n = Ut(e, [{
        paths: ["./model.weights.bin"],
        weights: e.weightSpecs
      }]);
      t.body.append("model.json", new Blob([JSON.stringify(n)], {
        type: "application/json"
      }), "model.json"), null != e.weightData && t.body.append("model.weights.bin", new Blob([e.weightData], {
        type: "application/octet-stream"
      }), "model.weights.bin");
      var s = yield _this20.fetch(_this20.path, t);
      if (s.ok) return {
        modelArtifactsInfo: Vt(e),
        responses: [s]
      };
      throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status ".concat(s.status, "."));
    })();
  }

  load() {
    var _this21 = this;

    return _asyncToGenerator(function* () {
      var e = yield _this21.fetch(_this21.path, _this21.requestInit);
      if (!e.ok) throw new Error("Request to ".concat(_this21.path, " failed with status code ").concat(e.status, ". Please verify this URL points to the model JSON of the model to load."));
      var t;

      try {
        t = yield e.json();
      } catch (e) {
        var _t49 = "Failed to parse model JSON of response from ".concat(_this21.path, ".");

        throw _this21.path.endsWith(".pb") ? _t49 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : _t49 += " Please make sure the server is serving valid JSON for this request.", new Error(_t49);
      }

      if (null == t.modelTopology && null == t.weightsManifest) throw new Error("The JSON from HTTP path ".concat(_this21.path, " contains neither model topology or manifest for weights."));
      return function () {
        var _ref = _asyncToGenerator(function* (e, t) {
          var n = {
            modelTopology: e.modelTopology,
            format: e.format,
            generatedBy: e.generatedBy,
            convertedBy: e.convertedBy
          };

          if (null != e.trainingConfig && (n.trainingConfig = e.trainingConfig), null != e.weightsManifest) {
            var [_s28, _r15] = yield t(e.weightsManifest);
            n.weightSpecs = _s28, n.weightData = _r15;
          }

          return null != e.signature && (n.signature = e.signature), null != e.userDefinedMetadata && (n.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (n.modelInitializer = e.modelInitializer), n;
        });

        return function (_x4, _x5) {
          return _ref.apply(this, arguments);
        };
      }()(t, e => _this21.loadWeights(e));
    })();
  }

  loadWeights(e) {
    var _this22 = this;

    return _asyncToGenerator(function* () {
      var t = Array.isArray(_this22.path) ? _this22.path[1] : _this22.path,
          [n, s] = function (e) {
        var t = e.lastIndexOf("/"),
            n = e.lastIndexOf("?");
        return [e.substring(0, t) + "/", n > t ? e.substring(n) : ""];
      }(t),
          r = _this22.weightPathPrefix || n,
          a = [];

      for (var _t50 of e) {
        a.push(..._t50.weights);
      }

      var i = [],
          o = [];

      for (var _t51 of e) {
        for (var _e37 of _t51.paths) {
          null != _this22.weightUrlConverter ? o.push(_this22.weightUrlConverter(_e37)) : i.push(r + _e37 + s);
        }
      }

      return _this22.weightUrlConverter && i.push(...(yield Promise.all(o))), [a, Wt(yield function () {
        var _ref2 = _asyncToGenerator(function* (e, t) {
          null == t && (t = {});
          var n = null == t.fetchFunc ? G().platform.fetch : t.fetchFunc,
              s = e.map(e => n(e, t.requestInit, {
            isBinary: !0
          })),
              r = (null == t.onProgress ? yield Promise.all(s) : yield xn(s, t.onProgress, 0, .5)).map(e => e.arrayBuffer());
          return null == t.onProgress ? yield Promise.all(r) : yield xn(r, t.onProgress, .5, 1);
        });

        return function (_x6, _x7) {
          return _ref2.apply(this, arguments);
        };
      }()(i, {
        requestInit: _this22.requestInit,
        fetchFunc: _this22.fetch,
        onProgress: _this22.onProgress
      }))];
    })();
  }

}

function kn(e) {
  return null != e.match(yn.URL_SCHEME_REGEX);
}

yn.URL_SCHEME_REGEX = /^https?:\/\//;

var wn = (e, t) => {
  if ("undefined" == typeof fetch && (null == t || null == t.fetchFunc)) return null;
  {
    var _n26 = !0;

    if (_n26 = Array.isArray(e) ? e.every(e => kn(e)) : kn(e), _n26) return vn(e, t);
  }
  return null;
};

function vn(e, t) {
  return new yn(e, t);
}

Ht.registerSaveRouter(wn), Ht.registerLoadRouter(wn);
var In = Ft({
  matMul_: function matMul_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Rt(e, "a", "matMul"),
        a = Rt(t, "b", "matMul");
    return [r, a] = gt(r, a), vt.runKernel("BatchMatMul", {
      a: r,
      b: a
    }, {
      transposeA: n,
      transposeB: s
    });
  }
}),
    $n = Ft({
  oneHot_: function oneHot_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    if (t < 2) throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));
    var r = Rt(e, "indices", "oneHot", "int32");
    return vt.runKernel("OneHot", {
      indices: r
    }, {
      depth: t,
      onValue: n,
      offValue: s
    });
  }
}),
    Sn = Ft({
  transpose_: function transpose_(e, t) {
    var n = Rt(e, "x", "transpose");
    return null == t && (t = n.shape.map((e, t) => t).reverse()), l(n.rank === t.length, () => "Error in transpose: rank of input ".concat(n.rank, " must match length of perm ").concat(t, ".")), t.forEach(e => {
      l(e >= 0 && e < n.rank, () => "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got ".concat(t));
    }), n.rank <= 1 ? n.clone() : vt.runKernel("Transpose", {
      x: n
    }, {
      perm: t
    });
  }
});

function Nn(e, t) {
  var n = e.shape.length,
      s = t.shape.length;
  if (n < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was ".concat(n, "."));
  if (s < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ".concat(s, "."));
  if ("int32" !== t.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was ".concat(t.dtype, "."));
  if (t.shape[s - 1] > n) throw new Error("index innermost dimension length must be <= tensor rank; saw: ".concat(t.shape[s - 1], " vs. ").concat(n));
  if (0 === d(e.shape)) throw new Error("Requested more than 0 entries, but input is empty. Input shape: ".concat(e.shape, "."));
  var r = t.shape,
      a = r[r.length - 1];
  var i = 1;

  for (var _e38 = 0; _e38 < r.length - 1; ++_e38) {
    i *= r[_e38];
  }

  var o = e.shape,
      l = r.slice();
  l.pop();
  var u = 1;

  for (var _e39 = a; _e39 < n; ++_e39) {
    u *= o[_e39], l.push(o[_e39]);
  }

  var c = [...A(e.shape).map(e => e / u), 1].slice(0, a);
  return [l, i, u, c];
}

function Cn(e, t, n) {
  var s = t.rank > 1 ? t.shape[t.rank - 1] : 1,
      r = t.rank > 1 ? t.rank - 1 : 1,
      a = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ".concat(n.shape, ", indices.shape: ").concat(t.shape, ", shape: ").concat(e, ", sliceDim: ").concat(s, ", and batchDim: ").concat(r, ".");
  if (n.rank < r) throw new Error(a + " update.rank < ".concat(r, ". "));
  if (e.length < s + (n.rank - r)) throw new Error(a + " Output shape length < ".concat(s + (n.rank - r)));
  if (n.rank !== r + e.length - s) throw new Error(a + " update.rank != " + (r + e.length - s));

  for (var _e40 = 0; _e40 < r; ++_e40) {
    if (n.shape[_e40] !== t.shape[_e40]) throw new Error(a + " updates.shape[".concat(_e40, "] (").concat(n.shape[_e40], ") != indices.shape[").concat(_e40, "] (").concat(t.shape[_e40], ")."));
  }

  for (var _t52 = 0; _t52 < n.rank - r; ++_t52) {
    if (n.shape[_t52 + r] !== e[_t52 + s]) throw new Error(a + " updates.shape[".concat(_t52 + r, "] (").concat(n.shape[_t52 + r], ") != shape[").concat(_t52 + r, "] (").concat(e[_t52 + r], ")"));
  }
}

function Tn(e, t, n) {
  var s = t.shape.length,
      r = s > 1 ? t.shape[s - 1] : 1,
      a = n.length;
  var i = 1;

  for (var _e41 = r; _e41 < a; ++_e41) {
    i *= n[_e41];
  }

  var o = r < 1 ? 1 : r;
  return {
    sliceRank: r,
    numUpdates: d(t.shape) / o,
    sliceSize: i,
    strides: [...A(n.slice(0, r)), 1],
    outputSize: d(n)
  };
}

function En(e, t, n) {
  var s = e.shape.length;
  l(s === t.length, () => "Error in slice".concat(s, "D: Length of begin ").concat(t, " must match the rank of the array (").concat(s, ").")), l(s === n.length, () => "Error in slice".concat(s, "D: Length of size ").concat(n, " must match the rank of the array (").concat(s, ")."));

  var _loop4 = function _loop4(_r16) {
    l(t[_r16] + n[_r16] <= e.shape[_r16], () => "Error in slice".concat(s, "D: begin[").concat(_r16, "] + size[").concat(_r16, "] (").concat(t[_r16] + n[_r16], ") would overflow input.shape[").concat(_r16, "] (").concat(e.shape[_r16], ")"));
  };

  for (var _r16 = 0; _r16 < s; ++_r16) {
    _loop4(_r16);
  }
}

function Rn(e) {
  var t = [];
  var n = 0;

  for (; e > 0;) {
    1 & e && t.push(n), e /= 2, n++;
  }

  return t;
}

function An(e, t, n) {
  var s = [];

  for (var _r17 = 0; _r17 < e.length; _r17++) {
    s[_r17] = Math.ceil((t[_r17] - e[_r17]) / n[_r17]);
  }

  return s;
}

function Fn(e, t, n, s) {
  var r = [...e];

  for (var _e42 = r.length; _e42 < s.length; _e42++) {
    r.push(1);
  }

  for (var _e43 = 0; _e43 < n; _e43++) {
    0 === _e43 ? r[t] = 1 : (r.splice(t, 0, 1), r.pop());
  }

  return r;
}

function Dn(e, t, n) {
  return n <= e ? n : n - (t - 1);
}

function _n(e, t) {
  var n = [];

  for (var _s29 = 0; _s29 < e; _s29++) {
    n.push(t + _s29);
  }

  return n;
}

function On(e, t, n, s, r, a, i, o, l) {
  var u = e.length;
  var c = new Array(u),
      h = new Array(u),
      d = new Array(u);

  if (t.length && n > 0) {
    var _l3 = t[0],
        _u3 = n + 1;

    c = Mn(i, _l3, _u3, s, e), h = Ln(o, _l3, _u3, r, e), d = Fn(a, _l3, _u3, e);
  } else for (var _t53 = 0; _t53 < u; _t53++) {
    c[_t53] = Bn(i, s, a, e, _t53, l), h[_t53] = Pn(o, r, a, e, _t53, l), d[_t53] = zn(a, _t53, l);
  }

  return {
    begin: c,
    end: h,
    strides: d
  };
}

function Mn(e, t, n, s, r) {
  var a = [...r],
      i = _n(n, t);

  for (var _r18 = 0; _r18 < a.length; _r18++) {
    if (i.indexOf(_r18) > -1) a[_r18] = 0;else {
      var _i8 = Dn(t, n, _r18);

      var _o6 = s[_i8];
      e & 1 << _i8 && (_o6 = 0), a[_r18] = _o6;
    }
  }

  return a;
}

function Ln(e, t, n, s, r) {
  var i = [...r],
      o = _n(n, t);

  for (var _r19 = 0; _r19 < i.length; _r19++) {
    if (o.indexOf(_r19) > -1) i[_r19] = Number.MAX_SAFE_INTEGER;else {
      var _a10 = Dn(t, n, _r19);

      var _o7 = s[_a10];
      e & 1 << _a10 && (_o7 = Number.MAX_SAFE_INTEGER), i[_r19] = _o7;
    }
  }

  for (var _e44 = 0; _e44 < i.length; _e44++) {
    var _t54 = r[_e44];
    i[_e44] < 0 && (i[_e44] += _t54), i[_e44] = a(0, i[_e44], r[_e44]);
  }

  return i;
}

function zn(e, t, n) {
  var s = e[t];
  return (n & 1 << t || null == s) && (s = 1), s;
}

function Bn(e, t, n, s, r, i) {
  var o = t[r];
  (e & 1 << r || i & 1 << r || null == o) && (o = (n[r] || 1) > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var l = s[r];
  return o < 0 && (o += l), o = a(0, o, l - 1), o;
}

function Pn(e, t, n, s, r, i) {
  var o = t[r];
  var l = n[r] || 1;
  (e & 1 << r || i & 1 << r || null == o) && (o = l > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var u = s[r];
  return o < 0 && (o += u), o = l > 0 ? a(0, o, u) : a(-1, o, u - 1), o;
}

function Wn(e, t, n) {
  var s = n.length;

  for (var _e45 = 0; _e45 < n.length; _e45++) {
    if (n[_e45] > 1) {
      s = _e45;
      break;
    }
  }

  for (var _r20 = s + 1; _r20 < n.length; _r20++) {
    if (t[_r20] > 0 || n[_r20] !== e[_r20]) return !1;
  }

  return !0;
}

function Un(e, t) {
  var n = e.length > 0 ? e[e.length - 1] : 1;

  for (var _s30 = 0; _s30 < e.length - 1; _s30++) {
    n += e[_s30] * t[_s30];
  }

  return n;
}

function Vn(e, t, n) {
  var s;
  var r = e.shape.length;
  var a;
  return s = "number" == typeof t ? [t, ...new Array(r - 1).fill(0)] : t.length < r ? t.concat(new Array(r - t.length).fill(0)) : t.slice(), s.forEach(e => {
    l(-1 !== e, () => "slice() does not support negative begin indexing.");
  }), a = null == n ? new Array(r).fill(-1) : "number" == typeof n ? [n, ...new Array(r - 1).fill(-1)] : n.length < r ? n.concat(new Array(r - n.length).fill(-1)) : n, a = a.map((t, n) => t >= 0 ? t : (l(-1 === t, () => "Negative size values should be exactly -1 but got ".concat(t, " for the slice() size at index ").concat(n, ".")), e.shape[n] - s[n])), [s, a];
}

function Gn(e, t, n, s, r, a, i, o, l) {
  var u = t.slice(),
      c = n.slice(),
      h = s;
  null == s && (h = new Array(u.length));
  var d = Rn(i);
  if (d.length > 1) throw new Error("Multiple ellipses in slice is not allowed.");
  if (0 !== i && 0 !== o) throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
  if (0 !== i && 0 !== l) throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
  var p = e.length - u.length,
      f = Rn(o),
      g = e.slice();
  f.forEach(e => {
    u[e] = 0, c[e] = 1, g.splice(e, 0, 1);
  });
  var {
    begin: m,
    end: b,
    strides: x
  } = On(g, d, p, u, c, h, r, a, i);
  u = m, c = b, h = x;
  var y = Rn(l);
  y.forEach(e => {
    c[e] = u[e] + 1, h[e] = 1;
  });
  var k = An(u, c, h),
      w = k.filter((e, t) => -1 === y.indexOf(t));
  return {
    nonStrided: h.every(e => 1 === e),
    $begin: u,
    $end: c,
    $strides: h,
    size: k,
    newShape: g,
    outShape: w
  };
}

var Hn = {
  __proto__: null,
  assertParamsValid: En,
  maskToAxes: Rn,
  computeOutShape: An,
  stridesWithElidedDims: Fn,
  getNormalizedAxes: On,
  startIndicesWithElidedDims: Mn,
  stopIndicesWithElidedDims: Ln,
  stridesForAxis: zn,
  startForAxis: Bn,
  stopForAxis: Pn,
  isSliceContinous: Wn,
  computeFlatOffset: Un,
  parseSliceParams: Vn,
  sliceInfo: Gn
};

class qn {
  getClassName() {
    return this.constructor.className;
  }

  static fromConfig(e, t) {
    return new e(t);
  }

}

class jn {
  constructor() {
    this.classNameMap = {};
  }

  static getMap() {
    return null == jn.instance && (jn.instance = new jn()), jn.instance;
  }

  static register(e) {
    jn.getMap().classNameMap[e.className] = [e, e.fromConfig];
  }

}

function Kn(e) {
  l(null != e.className, () => "Class being registered does not have the static className property defined."), l("string" == typeof e.className, () => "className is required to be a string, but got type " + typeof e.className), l(e.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), jn.register(e);
}

function Xn() {
  return vt;
}

function Yn() {
  return vt.memory();
}

function Jn(e, t) {
  return vt.tidy(e, t);
}

function Zn(e) {
  mt(e).forEach(e => e.dispose());
}

function Qn(e) {
  return vt.keep(e);
}

function es(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return vt.registerBackend(e, t, n);
}

var ts = Ft({
  add_: function add_(e, t) {
    var n = Rt(e, "a", "add"),
        s = Rt(t, "b", "add");
    return [n, s] = gt(n, s), vt.runKernel("Add", {
      a: n,
      b: s
    });
  }
}),
    ns = Ft({
  floorDiv_: function floorDiv_(e, t) {
    var n = Rt(e, "a", "floorDiv"),
        s = Rt(t, "b", "floorDiv");
    return [n, s] = gt(n, s), vt.runKernel("FloorDiv", {
      a: n,
      b: s
    });
  }
}),
    ss = Ft({
  div_: function div_(e, t) {
    var n = Rt(e, "a", "div"),
        s = Rt(t, "b", "div");
    return [n, s] = gt(n, s), "int32" === n.dtype && "int32" === s.dtype ? ns(n, s) : vt.runKernel("RealDiv", {
      a: n,
      b: s
    }, {});
  }
}),
    rs = Ft({
  mul_: function mul_(e, t) {
    var n = Rt(e, "a", "mul"),
        s = Rt(t, "b", "mul");
    return [n, s] = gt(n, s), vt.runKernel("Multiply", {
      a: n,
      b: s
    });
  }
}),
    as = Ft({
  abs_: function abs_(e) {
    var t = Rt(e, "x", "abs");
    return vt.runKernel("complex64" === t.dtype ? "ComplexAbs" : "Abs", {
      x: t
    });
  }
}),
    is = Ft({
  acos_: function acos_(e) {
    var t = Rt(e, "x", "acos");
    return vt.runKernel("Acos", {
      x: t
    });
  }
}),
    os = Ft({
  acosh_: function acosh_(e) {
    var t = Rt(e, "x", "acosh");
    return vt.runKernel("Acosh", {
      x: t
    });
  }
}),
    ls = Ft({
  all_: function all_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Rt(e, "x", "all", "bool");
    return vt.runKernel("All", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    us = Ft({
  any_: function any_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Rt(e, "x", "any", "bool");
    return vt.runKernel("Any", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    cs = Ft({
  argMax_: function argMax_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Rt(e, "x", "argMax");
    return vt.runKernel("ArgMax", {
      x: n
    }, {
      axis: t
    });
  }
}),
    hs = Ft({
  argMin_: function argMin_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Rt(e, "x", "argMin");
    return vt.runKernel("ArgMin", {
      x: n
    }, {
      axis: t
    });
  }
}),
    ds = Ft({
  asin_: function asin_(e) {
    var t = Rt(e, "x", "asin");
    return vt.runKernel("Asin", {
      x: t
    });
  }
}),
    ps = Ft({
  asinh_: function asinh_(e) {
    var t = Rt(e, "x", "asinh");
    return vt.runKernel("Asinh", {
      x: t
    });
  }
}),
    fs = Ft({
  atan_: function atan_(e) {
    var t = Rt(e, "x", "atan");
    return vt.runKernel("Atan", {
      x: t
    });
  }
}),
    gs = Ft({
  atan2_: function atan2_(e, t) {
    var n = Rt(e, "a", "atan2"),
        s = Rt(t, "b", "atan2");
    return [n, s] = gt(n, s), vt.runKernel("Atan2", {
      a: n,
      b: s
    });
  }
}),
    ms = Ft({
  atanh_: function atanh_(e) {
    var t = Rt(e, "x", "atanh");
    return vt.runKernel("Atanh", {
      x: t
    });
  }
});

function bs(e, t, n, s) {
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NHWC";
  var a = arguments.length > 5 ? arguments[5] : undefined;
  return ks(e, [...t, e[3]], n, a, s, null, null, Es(r));
}

function xs(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "channelsLast";
  var [o, l] = Is(t);
  var u;
  if ("channelsLast" === i) u = [o, l, e[3], e[3]];else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat ".concat(i));
    u = [o, l, e[1], e[1]];
  }
  return ks(e, u, n, s, r, a, !1, i);
}

function ys(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "NDHWC";
  var [o, l, u] = $s(t);
  var c, h;
  if ("NDHWC" === i) h = "channelsLast", c = [o, l, u, e[4], e[4]];else {
    if ("NCDHW" !== i) throw new Error("Unknown dataFormat ".concat(i));
    h = "channelsFirst", c = [o, l, u, e[1], e[1]];
  }
  return ws(e, c, n, s, r, !1, h, a);
}

function ks(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : "channelsLast";
  var [l, u, c, h] = [-1, -1, -1, -1];
  if ("channelsLast" === o) [l, u, c, h] = e;else {
    if ("channelsFirst" !== o) throw new Error("Unknown dataFormat ".concat(o));
    [l, h, u, c] = e;
  }

  var [d, p,, f] = t,
      [g, m] = Is(n),
      [b, x] = Is(s),
      y = Ss(d, b),
      k = Ss(p, x),
      {
    padInfo: w,
    outHeight: v,
    outWidth: I
  } = function (e, t, n, s, r, a, i, o, l) {
    var u, c, h;

    if ("number" == typeof e) {
      u = {
        top: e,
        bottom: e,
        left: e,
        right: e,
        type: 0 === e ? "VALID" : "NUMBER"
      };

      var _r21 = function (e, t, n, s, r) {
        null == s && (s = vs(e, t, n));
        var a = e[1];
        return [Ns((e[0] - t + 2 * s) / n + 1, r), Ns((a - t + 2 * s) / n + 1, r)];
      }([t, n], a, s, e, o);

      c = _r21[0], h = _r21[1];
    } else if ("same" === e) {
      c = Math.ceil(t / s), h = Math.ceil(n / r);

      var _e46 = Math.max(0, (c - 1) * s + a - t),
          _o8 = Math.max(0, (h - 1) * r + i - n),
          _l4 = Math.floor(_e46 / 2),
          _d2 = _e46 - _l4,
          _p2 = Math.floor(_o8 / 2);

      u = {
        top: _l4,
        bottom: _d2,
        left: _p2,
        right: _o8 - _p2,
        type: "SAME"
      };
    } else if ("valid" === e) u = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      type: "VALID"
    }, c = Math.ceil((t - a + 1) / s), h = Math.ceil((n - i + 1) / r);else {
      if ("object" != typeof e) throw Error("Unknown padding parameter: ".concat(e));
      {
        var _d3 = "channelsLast" === l ? e[1][0] : e[2][0],
            _p3 = "channelsLast" === l ? e[1][1] : e[2][1],
            _f2 = "channelsLast" === l ? e[2][0] : e[3][0],
            _g2 = "channelsLast" === l ? e[2][1] : e[3][1];

        u = {
          top: _d3,
          bottom: _p3,
          left: _f2,
          right: _g2,
          type: 0 === _d3 && 0 === _p3 && 0 === _f2 && 0 === _g2 ? "VALID" : "EXPLICIT"
        }, c = Ns((t - a + _d3 + _p3) / s + 1, o), h = Ns((n - i + _f2 + _g2) / r + 1, o);
      }
    }

    return {
      padInfo: u,
      outHeight: c,
      outWidth: h
    };
  }(r, u, c, g, m, y, k, a, o),
      $ = i ? f * h : f;

  var S;
  return "channelsFirst" === o ? S = [l, $, v, I] : "channelsLast" === o && (S = [l, v, I, $]), {
    batchSize: l,
    dataFormat: o,
    inHeight: u,
    inWidth: c,
    inChannels: h,
    outHeight: v,
    outWidth: I,
    outChannels: $,
    padInfo: w,
    strideHeight: g,
    strideWidth: m,
    filterHeight: d,
    filterWidth: p,
    effectiveFilterHeight: y,
    effectiveFilterWidth: k,
    dilationHeight: b,
    dilationWidth: x,
    inShape: e,
    outShape: S,
    filterShape: t
  };
}

function ws(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "channelsLast";
  var o = arguments.length > 7 ? arguments[7] : undefined;
  var [l, u, c, h, d] = [-1, -1, -1, -1, -1];
  if ("channelsLast" === i) [l, u, c, h, d] = e;else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat ".concat(i));
    [l, d, u, c, h] = e;
  }

  var [p, f, g,, m] = t,
      [b, x, y] = $s(n),
      [k, w, v] = $s(s),
      I = Ss(p, k),
      $ = Ss(f, w),
      S = Ss(g, v),
      {
    padInfo: N,
    outDepth: C,
    outHeight: T,
    outWidth: E
  } = function (e, t, n, s, r, a, i, o, l, u, c) {
    var h, d, p, f;

    if ("number" == typeof e) {
      h = {
        top: e,
        bottom: e,
        left: e,
        right: e,
        front: e,
        back: e,
        type: 0 === e ? "VALID" : "NUMBER"
      };

      var _a11 = function (e, t, n, s, r, a) {
        null == r && (r = vs(e, t, s));
        var i = e[1],
            o = e[2];
        return [Ns((e[0] - t + 2 * r) / s + 1, a), Ns((i - t + 2 * r) / s + 1, a), Ns((o - t + 2 * r) / s + 1, a), 1];
      }([t, n, s, 1], o, 0, r, e, c);

      d = _a11[0], p = _a11[1], f = _a11[2];
    } else if ("same" === e) {
      d = Math.ceil(t / r), p = Math.ceil(n / a), f = Math.ceil(s / i);

      var _e47 = (d - 1) * r + o - t,
          _c2 = (p - 1) * a + l - n,
          _g3 = (f - 1) * i + u - s,
          _m2 = Math.floor(_e47 / 2),
          _b2 = _e47 - _m2,
          _x8 = Math.floor(_c2 / 2),
          _y2 = _c2 - _x8,
          _k2 = Math.floor(_g3 / 2);

      h = {
        top: _x8,
        bottom: _y2,
        left: _k2,
        right: _g3 - _k2,
        front: _m2,
        back: _b2,
        type: "SAME"
      };
    } else {
      if ("valid" !== e) throw Error("Unknown padding parameter: ".concat(e));
      h = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        front: 0,
        back: 0,
        type: "VALID"
      }, d = Math.ceil((t - o + 1) / r), p = Math.ceil((n - l + 1) / a), f = Math.ceil((s - u + 1) / i);
    }

    return {
      padInfo: h,
      outDepth: d,
      outHeight: p,
      outWidth: f
    };
  }(r, u, c, h, b, x, y, I, $, S, o),
      R = a ? m * d : m;

  var A;
  return "channelsFirst" === i ? A = [l, R, C, T, E] : "channelsLast" === i && (A = [l, C, T, E, R]), {
    batchSize: l,
    dataFormat: i,
    inDepth: u,
    inHeight: c,
    inWidth: h,
    inChannels: d,
    outDepth: C,
    outHeight: T,
    outWidth: E,
    outChannels: R,
    padInfo: N,
    strideDepth: b,
    strideHeight: x,
    strideWidth: y,
    filterDepth: p,
    filterHeight: f,
    filterWidth: g,
    effectiveFilterDepth: I,
    effectiveFilterHeight: $,
    effectiveFilterWidth: S,
    dilationDepth: k,
    dilationHeight: w,
    dilationWidth: v,
    inShape: e,
    outShape: A,
    filterShape: t
  };
}

function vs(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var r = Ss(t, s);
  return Math.floor((e[0] * (n - 1) - n + r) / 2);
}

function Is(e) {
  return "number" == typeof e ? [e, e, e] : 2 === e.length ? [e[0], e[1], 1] : e;
}

function $s(e) {
  return "number" == typeof e ? [e, e, e] : e;
}

function Ss(e, t) {
  return t <= 1 ? e : e + (e - 1) * (t - 1);
}

function Ns(e, t) {
  if (!t) return Math.trunc(e);

  switch (t) {
    case "round":
      return Math.round(e);

    case "ceil":
      return Math.ceil(e);

    case "floor":
      return Math.floor(e);

    default:
      throw new Error("Unknown roundingMode ".concat(t));
  }
}

function Cs(e) {
  var [t, n, s] = Is(e);
  return 1 === t && 1 === n && 1 === s;
}

function Ts(e, t) {
  return Cs(e) || Cs(t);
}

function Es(e) {
  if ("NHWC" === e) return "channelsLast";
  if ("NCHW" === e) return "channelsFirst";
  throw new Error("Unknown dataFormat ".concat(e));
}

var Rs = Ft({
  reshape_: function reshape_(e, t) {
    var n = Rt(e, "x", "reshape", "string_or_numeric");
    return vt.runKernel("Reshape", {
      x: n
    }, {
      shape: t
    });
  }
}),
    As = Ft({
  avgPool_: function avgPool_(e, t, n, s, r) {
    var a = Rt(e, "x", "avgPool", "float32");
    l(Ts(n, 1), () => "Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '1'"));
    var i = a,
        o = !1;
    3 === a.rank && (o = !0, i = Rs(a, [1, a.shape[0], a.shape[1], a.shape[2]])), l(4 === i.rank, () => "Error in avgPool: x must be rank 4 but got rank ".concat(i.rank, ".")), null != r && l(f(s), () => "Error in avgPool: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, "."));
    var u = vt.runKernel("AvgPool", {
      x: i
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r
    });
    return u = fn(u, a.dtype), o ? Rs(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    Fs = Ft({
  avgPool3d_: function avgPool3d_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NDHWC";
    var i = Rt(e, "x", "avgPool3d", "float32");
    var o = i,
        u = !1;
    4 === i.rank && (u = !0, o = Rs(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), l(5 === o.rank, () => "Error in avgPool3d: x must be rank 5 but got rank ".concat(o.rank, ".")), l("NDHWC" === a, () => "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ".concat(a)), null != r && l(f(s), () => "Error in avgPool3d: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, "."));
    var c = vt.runKernel("AvgPool3D", {
      x: o
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r,
      dataFormat: a
    });
    return c = fn(c, o.dtype), u ? Rs(c, [c.shape[1], c.shape[2], c.shape[3], c.shape[4]]) : c;
  }
}),
    Ds = Ft({
  concat_: function concat_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    l(e.length >= 1, () => "Pass at least one tensor to concat");
    var n = At(e, "tensors", "concat", "string_or_numeric");
    return "complex64" === n[0].dtype && n.forEach(e => {
      if ("complex64" !== e.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype, ". "));
    }), 1 === n.length ? gn(n[0]) : vt.runKernel("Concat", n, {
      axis: t
    });
  }
}),
    _s = Ft({
  sigmoid_: function sigmoid_(e) {
    var t = Rt(e, "x", "sigmoid");
    return vt.runKernel("Sigmoid", {
      x: t
    });
  }
}),
    Os = Ft({
  slice_: function slice_(e, t, n) {
    var s = Rt(e, "x", "slice", "string_or_numeric");
    if (0 === s.rank) throw new Error("Slicing scalar is not possible");
    return vt.runKernel("Slice", {
      x: s
    }, {
      begin: t,
      size: n
    });
  }
}),
    Ms = Ft({
  tanh_: function tanh_(e) {
    var t = Rt(e, "x", "tanh");
    return vt.runKernel("Tanh", {
      x: t
    });
  }
}),
    Ls = Ft({
  batchToSpaceND_: function batchToSpaceND_(e, t, n) {
    var s = Rt(e, "x", "batchToSpaceND"),
        r = t.reduce((e, t) => e * t);
    return l(s.rank >= 1 + t.length, () => "input rank is ".concat(s.rank, " but should be > than blockShape.length ").concat(t.length)), l(n.length === t.length, () => "crops.length is ".concat(n.length, " but should be equal to blockShape.length  ").concat(t.length)), l(s.shape[0] % r == 0, () => "input tensor batch is ".concat(s.shape[0], " but is not divisible by the product of the elements of blockShape ").concat(t.join(" * "), " === ").concat(r)), vt.runKernel("BatchToSpaceND", {
      x: s
    }, {
      blockShape: t,
      crops: n
    });
  }
}),
    zs = Ft({
  batchNorm_: function batchNorm_(e, t, n, s, r, a) {
    null == a && (a = .001);
    var i = Rt(e, "x", "batchNorm"),
        o = Rt(t, "mean", "batchNorm"),
        u = Rt(n, "variance", "batchNorm");
    var c, h;
    null != r && (c = Rt(r, "scale", "batchNorm")), null != s && (h = Rt(s, "offset", "batchNorm")), l(o.rank === u.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), l(null == h || o.rank === h.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), l(null == c || o.rank === c.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");

    var d = function (e) {
      var t;
      return t = 0 === e.rank || 1 === e.rank ? Rs(e, [1, 1, 1, e.size]) : 2 === e.rank ? Rs(e, [1, 1, e.shape[0], e.shape[1]]) : 3 === e.rank ? Rs(e, [1, e.shape[0], e.shape[1], e.shape[2]]) : e, t;
    }(i),
        p = vt.runKernel("FusedBatchNorm", {
      x: d,
      scale: c,
      offset: h,
      mean: o,
      variance: u
    }, {
      varianceEpsilon: a
    });

    return Rs(p, i.shape);
  }
}),
    Bs = Ft({
  batchNorm2d_: function batchNorm2d_(e, t, n, s, r, a) {
    var i = Rt(e, "x", "batchNorm"),
        o = Rt(t, "mean", "batchNorm"),
        u = Rt(n, "variance", "batchNorm");
    var c, h;
    return null != r && (c = Rt(r, "scale", "batchNorm")), null != s && (h = Rt(s, "offset", "batchNorm")), l(2 === i.rank, () => "Error in batchNorm2D: x must be rank 2 but got rank ".concat(i.rank, ".")), l(2 === o.rank || 1 === o.rank, () => "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ".concat(o.rank, ".")), l(2 === u.rank || 1 === u.rank, () => "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ".concat(u.rank, ".")), null != c && l(2 === c.rank || 1 === c.rank, () => "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ".concat(c.rank, ".")), null != h && l(2 === h.rank || 1 === h.rank, () => "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ".concat(h.rank, ".")), zs(i, o, u, h, c, a);
  }
}),
    Ps = Ft({
  batchNorm3d_: function batchNorm3d_(e, t, n, s, r, a) {
    var i = Rt(e, "x", "batchNorm"),
        o = Rt(t, "mean", "batchNorm"),
        u = Rt(n, "variance", "batchNorm");
    var c, h;
    return null != r && (c = Rt(r, "scale", "batchNorm")), null != s && (h = Rt(s, "offset", "batchNorm")), l(3 === i.rank, () => "Error in batchNorm3D: x must be rank 3 but got rank ".concat(i.rank, ".")), l(3 === o.rank || 1 === o.rank, () => "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ".concat(o.rank, ".")), l(3 === u.rank || 1 === u.rank, () => "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ".concat(u.rank, ".")), null != c && l(3 === c.rank || 1 === c.rank, () => "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ".concat(c.rank, ".")), null != h && l(3 === h.rank || 1 === h.rank, () => "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ".concat(h.rank, ".")), zs(i, o, u, h, c, a);
  }
}),
    Ws = Ft({
  batchNorm4d_: function batchNorm4d_(e, t, n, s, r, a) {
    var i = Rt(e, "x", "batchNorm"),
        o = Rt(t, "mean", "batchNorm"),
        u = Rt(n, "variance", "batchNorm");
    var c, h;
    return null != r && (c = Rt(r, "scale", "batchNorm")), null != s && (h = Rt(s, "offset", "batchNorm")), l(4 === i.rank, () => "Error in batchNorm4D: x must be rank 4 but got rank ".concat(i.rank, ".")), l(4 === o.rank || 1 === o.rank, () => "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ".concat(o.rank, ".")), l(4 === u.rank || 1 === u.rank, () => "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ".concat(u.rank, ".")), null != c && l(4 === c.rank || 1 === c.rank, () => "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ".concat(c.rank, ".")), null != h && l(4 === h.rank || 1 === h.rank, () => "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ".concat(h.rank, ".")), zs(i, o, u, h, c, a);
  }
}),
    Us = Ft({
  bincount_: function bincount_(e, t, n) {
    var s = Rt(e, "x", "bincount"),
        r = Rt(t, "weights", "bincount");
    return l("int32" === s.dtype, () => "Error in bincount: input dtype must be int32, but got ".concat(s.dtype)), l(n >= 0, () => "size must be non-negative, but got ".concat(n, ".")), l(r.size === s.size || 0 === r.size, () => "Error in bincount: weights must have the same size as input or0-length, but got input shape: ".concat(s.shape, ", weights shape: ").concat(r.shape, ".")), vt.runKernel("Bincount", {
      x: s,
      weights: r
    }, {
      size: n
    });
  }
}),
    Vs = Ft({
  broadcastTo_: function broadcastTo_(e, t) {
    var n = Rt(e, "broadcastTo", "x");
    var s = n.shape;
    if (t.some(e => !(e > 0) || e % 1 != 0)) throw new Error("broadcastTo(): Invalid broadcast shape [".concat(t, "]."));
    if (t.length < n.rank) throw new Error("broadcastTo(): shape.length=".concat(t.length, " < input.rank=").concat(n.rank, "."));

    if (t.length > n.rank) {
      var _e48 = n.shape.slice();

      for (; _e48.length < t.length;) {
        _e48.unshift(1);
      }

      n = Rs(n, _e48);
    }

    var r = n.shape,
        a = Array.from(t);

    for (var _e49 = t.length - 1; _e49 >= 0; _e49--) {
      if (r[_e49] === t[_e49]) a[_e49] = 1;else if (1 !== n.shape[_e49]) throw new Error("broadcastTo(): [".concat(s, "] cannot be broadcast to [").concat(t, "]."));
    }

    return 0 === a.map((e, t) => e > 1 ? t : -1).filter(e => e >= 0).length ? gn(n) : vt.runKernel("Tile", {
      x: n
    }, {
      reps: a
    });
  }
}),
    Gs = Ft({
  ceil_: function ceil_(e) {
    var t = Rt(e, "x", "ceil");
    return vt.runKernel("Ceil", {
      x: t
    });
  }
}),
    Hs = Ft({
  clipByValue_: function clipByValue_(e, t, n) {
    var s = Rt(e, "x", "clipByValue");
    return l(t <= n, () => "Error in clip: min (".concat(t, ") must be less than or equal to max (").concat(n, ").")), vt.runKernel("ClipByValue", {
      x: s
    }, {
      clipValueMin: t,
      clipValueMax: n
    });
  }
}),
    qs = Ft({
  concat1d_: function concat1d_(e) {
    return Ds(e, 0);
  }
}),
    js = Ft({
  concat2d_: function concat2d_(e, t) {
    return Ds(e, t);
  }
}),
    Ks = Ft({
  concat3d_: function concat3d_(e, t) {
    return Ds(e, t);
  }
}),
    Xs = Ft({
  concat4d_: function concat4d_(e, t) {
    return Ds(e, t);
  }
}),
    Ys = Ft({
  conv2d_: function conv2d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NHWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = Rt(e, "x", "conv2d"),
        u = Rt(t, "filter", "conv2d");
    var c = o,
        h = !1;
    3 === o.rank && (h = !0, c = Rs(o, [1, o.shape[0], o.shape[1], o.shape[2]])), l(4 === c.rank, () => "Error in conv2d: input must be rank 4, but got rank ".concat(c.rank, ".")), l(4 === u.rank, () => "Error in conv2d: filter must be rank 4, but got rank ".concat(u.rank, ".")), null != i && l(f(s), () => "Error in conv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, "."));
    var d = "NHWC" === r ? c.shape[3] : c.shape[1];
    l(d === u.shape[2], () => "Error in conv2d: depth of input (".concat(d, ") must match input depth for filter ").concat(u.shape[2], ".")), l(Ts(n, a), () => "Error in conv2D: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '").concat(a, "'"));
    var p = vt.runKernel("Conv2D", {
      x: c,
      filter: u
    }, {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a,
      dimRoundingMode: i
    });
    return h ? Rs(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
  }
}),
    Js = Ft({
  conv1d_: function conv1d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = Rt(e, "x", "conv1d"),
        u = Rt(t, "filter", "conv1d");
    var c = o,
        h = !1;
    2 === o.rank && (h = !0, c = Rs(o, [1, o.shape[0], o.shape[1]])), l(3 === c.rank, () => "Error in conv1d: input must be rank 3, but got rank ".concat(c.rank, ".")), l(3 === u.rank, () => "Error in conv1d: filter must be rank 3, but got rank ".concat(u.rank, ".")), null != i && l(f(s), () => "Error in conv1d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, ".")), l(c.shape[2] === u.shape[1], () => "Error in conv1d: depth of input (".concat(c.shape[2], ") must match input depth for filter ").concat(u.shape[1], ".")), l(Ts(n, a), () => "Error in conv1D: Either stride or dilation must be 1. Got stride ".concat(n, " and dilation '").concat(a, "'")), l("NWC" === r, () => "Error in conv1d: got dataFormat of ".concat(r, " but only NWC is currently supported."));
    var d = Rs(u, [1, u.shape[0], u.shape[1], u.shape[2]]),
        p = Rs(c, [c.shape[0], 1, c.shape[1], c.shape[2]]),
        g = Ys(p, d, [1, n], s, "NHWC", [1, a], i);
    return Rs(g, h ? [g.shape[2], g.shape[3]] : [g.shape[0], g.shape[2], g.shape[3]]);
  }
}),
    Zs = Ft({
  conv2DBackpropInput_: function conv2DBackpropInput_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NHWC";
    var i = arguments.length > 6 ? arguments[6] : undefined;
    l(e.length === t.rank, () => "Length of inShape (".concat(e.length, ") and rank of dy (").concat(t.rank, ") must match"));
    var o = e,
        u = t,
        c = !1;
    3 === t.rank && (c = !0, u = Rs(t, [1, t.shape[0], t.shape[1], t.shape[2]]), o = [1, e[0], e[1], e[2]]), l(4 === o.length, () => "Error in conv2dDerInput: inShape must be length 4, but got length ".concat(o.length, ".")), l(4 === u.rank, () => "Error in conv2dDerInput: dy must be rank 4, but got rank ".concat(u.rank)), l(4 === n.rank, () => "Error in conv2dDerInput: filter must be rank 4, but got rank ".concat(n.rank));
    var h = "NHWC" === a ? o[3] : o[1],
        d = "NHWC" === a ? u.shape[3] : u.shape[1];
    l(h === n.shape[2], () => "Error in conv2dDerInput: depth of input (".concat(h, ") must match input depth for filter ").concat(n.shape[2], ".")), l(d === n.shape[3], () => "Error in conv2dDerInput: depth of output (".concat(d, ") must match output depth for filter ").concat(n.shape[3], ".")), null != i && l(f(r), () => "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(r, "."));
    var p = vt.runKernel("Conv2DBackpropInput", {
      dy: u,
      filter: n
    }, {
      strides: s,
      pad: r,
      dataFormat: a,
      dimRoundingMode: i,
      inputShape: o
    });
    return c ? Rs(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
  }
}),
    Qs = Ft({
  conv2dTranspose_: function conv2dTranspose_(e, t, n, s, r, a) {
    var i = Rt(e, "x", "conv2dTranspose"),
        o = Rt(t, "filter", "conv2dTranspose");
    return Zs(n, i, o, s, r, "NHWC", a);
  }
}),
    er = Ft({
  conv3d_: function conv3d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NDHWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1, 1];
    var i = Rt(e, "x", "conv3d"),
        o = Rt(t, "filter", "conv3d");
    var u = i,
        c = !1;
    4 === i.rank && (c = !0, u = Rs(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), l(5 === u.rank, () => "Error in conv3d: input must be rank 5, but got rank ".concat(u.rank, ".")), l(5 === o.rank, () => "Error in conv3d: filter must be rank 5, but got rank ".concat(o.rank, ".")), l(u.shape[4] === o.shape[3], () => "Error in conv3d: depth of input (".concat(u.shape[4], ") must match input depth for filter ").concat(o.shape[3], ".")), l(Ts(n, a), () => "Error in conv3D: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '").concat(a, "'")), l("NDHWC" === r, () => "Error in conv3d: got dataFormat of ".concat(r, " but only NDHWC is currently supported."));
    var h = vt.runKernel("Conv3D", {
      x: u,
      filter: o
    }, {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a
    });
    return c ? Rs(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h;
  }
}),
    tr = Ft({
  conv3DBackpropInput_: function conv3DBackpropInput_(e, t, n, s, r) {
    l(e.length === t.rank, () => "Length of inShape (".concat(e.length, ") and rank of dy (").concat(t.rank, ") must match"));
    var a = e,
        i = t,
        o = !1;
    4 === t.rank && (o = !0, i = Rs(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]), a = [1, e[0], e[1], e[2], e[3]]);
    var u = a[4],
        c = i.shape[4];
    l(5 === a.length, () => "Error in conv3dDerInput: inShape must be length 5, but got length ".concat(a.length, ".")), l(5 === i.rank, () => "Error in conv3dDerInput: dy must be rank 5, but got rank ".concat(i.rank)), l(5 === n.rank, () => "Error in conv3dDerInput: filter must be rank 5, but got rank ".concat(n.rank)), l(u === n.shape[3], () => "Error in conv3dDerInput: depth of input (".concat(u, ") must match input depth for filter ").concat(n.shape[3], ".")), l(c === n.shape[4], () => "Error in conv3dDerInput: depth of output (".concat(c, ") must match output depth for filter ").concat(n.shape[4], "."));
    var h = vt.runKernel("Conv3DBackpropInputV2", {
      dy: i,
      filter: n
    }, {
      pad: r,
      strides: s,
      inputShape: a
    });
    return o ? Rs(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h;
  }
}),
    nr = Ft({
  conv3dTranspose_: function conv3dTranspose_(e, t, n, s, r) {
    var a = Rt(e, "x", "conv3dTranspose"),
        i = Rt(t, "filter", "conv3dTranspose");
    return tr(n, a, i, s, r);
  }
}),
    sr = Ft({
  cos_: function cos_(e) {
    var t = Rt(e, "x", "cos");
    return vt.runKernel("Cos", {
      x: t
    });
  }
}),
    rr = Ft({
  cosh_: function cosh_(e) {
    var t = Rt(e, "x", "cosh");
    return vt.runKernel("Cosh", {
      x: t
    });
  }
}),
    ar = Ft({
  cumsum_: function cumsum_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Rt(e, "x", "cumsum");
    return vt.runKernel("Cumsum", {
      x: r
    }, {
      axis: t,
      exclusive: n,
      reverse: s
    });
  }
}),
    ir = Ft({
  depthToSpace_: function depthToSpace_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "NHWC";
    var s = Rt(e, "x", "depthToSpace"),
        r = "NHWC" === n ? s.shape[1] : s.shape[2],
        a = "NHWC" === n ? s.shape[2] : s.shape[3],
        i = "NHWC" === n ? s.shape[3] : s.shape[1];
    return l(r * t >= 0, () => "Negative dimension size caused by overflow when multiplying\n    ".concat(r, " and ").concat(t, "  for depthToSpace with input shape\n    ").concat(s.shape)), l(a * t >= 0, () => "Negative dimension size caused by overflow when multiplying\n    ".concat(a, " and ").concat(t, " for depthToSpace with input shape\n        ").concat(s.shape)), l(i % (t * t) == 0, () => "Dimension size must be evenly divisible by ".concat(t * t, " but is ").concat(i, " for depthToSpace with input shape ").concat(s.shape)), vt.runKernel("DepthToSpace", {
      x: s
    }, {
      blockSize: t,
      dataFormat: n
    });
  }
}),
    or = Ft({
  depthwiseConv2d_: function depthwiseConv2d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NHWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = Rt(e, "x", "depthwiseConv2d"),
        u = Rt(t, "filter", "depthwiseConv2d");
    var c = o,
        h = !1;
    3 === o.rank && (h = !0, c = Rs(o, [1, o.shape[0], o.shape[1], o.shape[2]])), l(4 === c.rank, () => "Error in depthwiseConv2d: input must be rank 4, but got rank ".concat(c.rank, ".")), l(4 === u.rank, () => "Error in depthwiseConv2d: filter must be rank 4, but got rank ".concat(u.rank, ".")), l(c.shape[3] === u.shape[2], () => "Error in depthwiseConv2d: number of input channels (".concat(c.shape[3], ") must match the inChannels dimension in filter ").concat(u.shape[2], ".")), null != i && l(f(s), () => "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, "."));
    var d = vt.runKernel("DepthwiseConv2dNative", {
      x: c,
      filter: u
    }, {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a,
      dimRoundingMode: i
    });
    return h ? Rs(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
  }
}),
    lr = Ft({
  dilation2d_: function dilation2d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [1, 1];
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NHWC";
    var i = Rt(e, "x", "dilation2d"),
        o = Rt(t, "filter", "dilation2d");
    l(3 === i.rank || 4 === i.rank, () => "Error in dilation2d: input must be rank 3 or 4, but got rank ".concat(i.rank, ".")), l(3 === o.rank, () => "Error in dilation2d: filter must be rank 3, but got rank ".concat(o.rank, ".")), l("NHWC" === a, () => "Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ".concat(a));
    var u = i,
        c = !1;
    3 === i.rank && (u = Rs(i, [1, i.shape[0], i.shape[1], i.shape[2]]), c = !0);
    var h = vt.runKernel("Dilation2D", {
      x: u,
      filter: o
    }, {
      strides: n,
      pad: s,
      dilations: r
    });
    return c ? Rs(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
  }
});

function ur(e, t) {
  var n = e.length,
      s = [];

  for (var _r22 = 0; _r22 < n; _r22++) {
    var _a12 = n - 1 - _r22,
        _i9 = e[_a12] || 1;

    (t[t.length - 1 - _r22] || 1) > 1 && 1 === _i9 && s.unshift(_a12);
  }

  return s;
}

function cr(e, t) {
  var n = [];

  for (var _s31 = 0; _s31 < t.length; _s31++) {
    var _r23 = e[e.length - _s31 - 1],
        _a13 = t.length - _s31 - 1,
        _i10 = t[_a13];

    (null == _r23 || 1 === _r23 && _i10 > 1) && n.unshift(_a13);
  }

  return n;
}

function hr(e, t) {
  var n = [],
      s = Math.max(e.length, t.length);

  for (var _r24 = 0; _r24 < s; _r24++) {
    var _s32 = e[e.length - _r24 - 1];
    null == _s32 && (_s32 = 1);
    var _a14 = t[t.length - _r24 - 1];
    if (null == _a14 && (_a14 = 1), 1 === _s32) n.unshift(_a14);else if (1 === _a14) n.unshift(_s32);else {
      if (_s32 !== _a14) throw Error("Operands could not be broadcast together with shapes ".concat(e, " and ").concat(t, "."));
      n.unshift(_s32);
    }
  }

  return n;
}

var dr = Ft({
  equal_: function equal_(e, t) {
    var n = Rt(e, "a", "equal", "string_or_numeric"),
        s = Rt(t, "b", "equal", "string_or_numeric");
    return [n, s] = gt(n, s), hr(n.shape, s.shape), vt.runKernel("Equal", {
      a: n,
      b: s
    });
  }
}),
    pr = Ft({
  where_: function where_(e, t, n) {
    var s = Rt(t, "a", "where"),
        r = Rt(n, "b", "where"),
        a = Rt(e, "condition", "where", "bool"),
        i = hr(hr(a.shape, s.shape), r.shape),
        o = Vs(a, i),
        l = Vs(s, i),
        u = Vs(r, i);
    return vt.runKernel("Select", {
      condition: o,
      t: l,
      e: u
    });
  }
}),
    fr = Ft({
  zerosLike_: function zerosLike_(e) {
    var t = Rt(e, "x", "zerosLike");
    return vt.runKernel("ZerosLike", {
      x: t
    });
  }
}),
    gr = Ft({
  divNoNan_: function divNoNan_(e, t) {
    var n = Rt(e, "a", "div"),
        s = Rt(t, "b", "div");
    [n, s] = gt(n, s);
    var r = ss(n, s),
        a = fr(r),
        i = dr(s, a);
    return pr(i, a, r);
  }
}),
    mr = Ft({
  dot_: function dot_(e, t) {
    var n = Rt(e, "t1", "dot"),
        s = Rt(t, "t2", "dot");
    l(!(1 !== n.rank && 2 !== n.rank || 1 !== s.rank && 2 !== s.rank), () => "Error in dot: inputs must all be rank 1 or 2, but got ranks ".concat(n.rank, " and ").concat(s.rank, "."));
    var r = 1 === n.rank ? n.size : n.shape[1],
        a = 1 === s.rank ? s.size : s.shape[0];

    if (l(r === a, () => "Error in dot: inner dimensions of inputs must match, but got ".concat(r, " and ").concat(a, ".")), 1 === n.rank && 1 === s.rank) {
      var _e50 = Rs(n, [1, -1]),
          _t55 = Rs(s, [-1, 1]),
          _r25 = In(_e50, _t55);

      return Rs(_r25, []);
    }

    if (1 === n.rank && 2 === s.rank) {
      var _e51 = Rs(n, [1, -1]),
          _t56 = Rs(s, [s.shape[0], s.shape[1]]),
          _r26 = In(_e51, _t56);

      return Rs(_r26, [_r26.size]);
    }

    if (2 === n.rank && 1 === s.rank) {
      var _e52 = Rs(s, [-1, 1]),
          _t57 = In(n, _e52);

      return Rs(_t57, [_t57.size]);
    }

    {
      var _e53 = Rs(s, [s.shape[0], s.shape[1]]);

      return In(n, _e53);
    }
  }
}),
    br = Ft({
  elu_: function elu_(e) {
    var t = Rt(e, "x", "elu");
    return vt.runKernel("Elu", {
      x: t
    });
  }
}),
    xr = Ft({
  erf_: function erf_(e) {
    var t = Rt(e, "x", "erf");
    return l("int32" === t.dtype || "float32" === t.dtype, () => "Input dtype must be `int32` or `float32`."), "int32" === t.dtype && (t = fn(t, "float32")), vt.runKernel("Erf", {
      x: t
    });
  }
}),
    yr = Ft({
  exp_: function exp_(e) {
    var t = Rt(e, "x", "exp");
    return vt.runKernel("Exp", {
      x: t
    });
  }
}),
    kr = Ft({
  expandDims_: function expandDims_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Rt(e, "x", "expandDims", "string_or_numeric");
    return l(t <= n.rank, () => "Axis must be <= rank of the tensor"), vt.runKernel("ExpandDims", {
      input: n
    }, {
      dim: t
    });
  }
}),
    wr = Ft({
  expm1_: function expm1_(e) {
    var t = Rt(e, "x", "expm1");
    return vt.runKernel("Expm1", {
      x: t
    });
  }
}),
    vr = Ft({
  tile_: function tile_(e, t) {
    var n = Rt(e, "x", "tile", "string_or_numeric");
    return l(n.rank === t.length, () => "Error in transpose: rank of input ".concat(n.rank, " must match length of reps ").concat(t, ".")), vt.runKernel("Tile", {
      x: n
    }, {
      reps: t
    });
  }
}),
    Ir = Ft({
  eye_: function eye_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "float32";
    null == t && (t = e);
    var r = pn([e, t], s),
        a = e <= t ? e : t;

    for (var _e54 = 0; _e54 < a; ++_e54) {
      r.set(1, _e54, _e54);
    }

    var i = Rs(r.toTensor(), [e, t]);
    if (null == n) return i;
    if (1 === n.length) return vr(kr(i, 0), [n[0], 1, 1]);
    if (2 === n.length) return vr(kr(kr(i, 0), 0), [n[0], n[1], 1, 1]);
    if (3 === n.length) return vr(kr(kr(kr(i, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
    throw new Error("eye() currently supports only 1D and 2D batchShapes, but received ".concat(n.length, "D."));
  }
});

function $r(e, t, n) {
  return vt.runKernel("Fill", {}, {
    shape: e,
    value: t,
    dtype: n
  });
}

var Sr = Ft({
  floor_: function floor_(e) {
    var t = Rt(e, "x", "floor");
    return vt.runKernel("Floor", {
      x: t
    });
  }
}),
    Nr = Ft({
  gather_: function gather_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = Rt(e, "x", "gather"),
        a = Rt(t, "indices", "gather", "int32");
    return vt.runKernel("GatherV2", {
      x: r,
      indices: a
    }, {
      axis: n,
      batchDims: s
    });
  }
}),
    Cr = Ft({
  greater_: function greater_(e, t) {
    var n = Rt(e, "a", "greater", "string_or_numeric"),
        s = Rt(t, "b", "greater", "string_or_numeric");
    return [n, s] = gt(n, s), hr(n.shape, s.shape), vt.runKernel("Greater", {
      a: n,
      b: s
    });
  }
}),
    Tr = Ft({
  greaterEqual_: function greaterEqual_(e, t) {
    var n = Rt(e, "a", "greaterEqual", "string_or_numeric"),
        s = Rt(t, "b", "greaterEqual", "string_or_numeric");
    return [n, s] = gt(n, s), hr(n.shape, s.shape), vt.runKernel("GreaterEqual", {
      a: n,
      b: s
    });
  }
}),
    Er = Ft({
  imag_: function imag_(e) {
    var t = Rt(e, "input", "imag");
    return vt.runKernel("Imag", {
      input: t
    });
  }
}),
    Rr = Ft({
  isFinite_: function isFinite_(e) {
    var t = Rt(e, "x", "isFinite");
    return vt.runKernel("IsFinite", {
      x: t
    });
  }
}),
    Ar = Ft({
  isInf_: function isInf_(e) {
    var t = Rt(e, "x", "isInf");
    return vt.runKernel("IsInf", {
      x: t
    });
  }
}),
    Fr = Ft({
  isNaN_: function isNaN_(e) {
    var t = Rt(e, "x", "isNaN");
    return vt.runKernel("IsNan", {
      x: t
    });
  }
}),
    Dr = Ft({
  leakyRelu_: function leakyRelu_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .2;
    var n = Rt(e, "x", "leakyRelu");
    return vt.runKernel("LeakyRelu", {
      x: n
    }, {
      alpha: t
    });
  }
}),
    _r = Ft({
  less_: function less_(e, t) {
    var n = Rt(e, "a", "less", "string_or_numeric"),
        s = Rt(t, "b", "less", "string_or_numeric");
    return [n, s] = gt(n, s), hr(n.shape, s.shape), vt.runKernel("Less", {
      a: n,
      b: s
    });
  }
}),
    Or = Ft({
  lessEqual_: function lessEqual_(e, t) {
    var n = Rt(e, "a", "lessEqual", "string_or_numeric"),
        s = Rt(t, "b", "lessEqual", "string_or_numeric");
    return [n, s] = gt(n, s), hr(n.shape, s.shape), vt.runKernel("LessEqual", {
      a: n,
      b: s
    });
  }
}),
    Mr = Ft({
  localResponseNormalization_: function localResponseNormalization_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .5;
    var a = Rt(e, "x", "localResponseNormalization");
    l(4 === a.rank || 3 === a.rank, () => "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(a.rank, ".")), l(f(t), () => "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ".concat(t, "."));
    var i = a,
        o = !1;
    3 === a.rank && (o = !0, i = Rs(a, [1, a.shape[0], a.shape[1], a.shape[2]]));
    var u = vt.runKernel("LRN", {
      x: i
    }, {
      depthRadius: t,
      bias: n,
      alpha: s,
      beta: r
    });
    return o ? Rs(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    Lr = Ft({
  log_: function log_(e) {
    var t = Rt(e, "x", "log");
    return vt.runKernel("Log", {
      x: t
    });
  }
}),
    zr = Ft({
  log1p_: function log1p_(e) {
    var t = Rt(e, "x", "log1p");
    return vt.runKernel("Log1p", {
      x: t
    });
  }
});

function Br(e) {
  return vt.customGrad(e);
}

var Pr = Ft({
  neg_: function neg_(e) {
    var t = Rt(e, "x", "neg");
    return vt.runKernel("Neg", {
      x: t
    });
  }
}),
    Wr = Ft({
  softplus_: function softplus_(e) {
    var t = Rt(e, "x", "softplus");
    return vt.runKernel("Softplus", {
      x: t
    });
  }
}),
    Ur = Ft({
  logSigmoid_: function logSigmoid_(e) {
    var t = Rt(e, "x", "logSigmoid");
    return Br(e => ({
      value: Pr(Wr(Pr(e))),
      gradFunc: t => rs(t, _s(Pr(e)))
    }))(t);
  }
}),
    Vr = Ft({
  max_: function max_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Rt(e, "x", "max");
    return vt.runKernel("Max", {
      x: s
    }, {
      reductionIndices: t,
      keepDims: n
    });
  }
}),
    Gr = Ft({
  sub_: function sub_(e, t) {
    var n = Rt(e, "a", "sub"),
        s = Rt(t, "b", "sub");
    return [n, s] = gt(n, s), vt.runKernel("Sub", {
      a: n,
      b: s
    });
  }
}),
    Hr = Ft({
  sum_: function sum_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Rt(e, "x", "sum");
    return "bool" === s.dtype && (s = fn(s, "int32")), vt.runKernel("Sum", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    qr = Ft({
  logSoftmax_: function logSoftmax_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var n = Rt(e, "logits", "logSoftmax");
    if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(n.rank, " and axis was ").concat(t));
    return Br((e, n) => {
      var s = Vr(e, t, !0),
          r = Gr(e, s),
          a = Gr(fn(r, "float32"), Lr(Hr(yr(r), t, !0)));
      return n([a]), {
        value: a,
        gradFunc: (e, n) => {
          var [s] = n,
              r = yr(s);
          return Gr(e, rs(Hr(e, t, !0), r));
        }
      };
    })(n);
  }
});

function jr(e, t) {
  for (var _n27 = 0; _n27 < e.length; ++_n27) {
    if (e[e.length - _n27 - 1] !== t - 1 - _n27) return !1;
  }

  return !0;
}

function Kr(e, t, n) {
  var s = e.length + t.length,
      r = [];
  var a = 0,
      i = 0;

  for (var _o9 = 0; _o9 < s; _o9++) {
    -1 === n.indexOf(_o9) ? r.push(e[a++]) : r.push(t[i++]);
  }

  return r;
}

function Xr(e, t) {
  var n = [],
      s = e.length;

  for (var _r27 = 0; _r27 < s; _r27++) {
    -1 === t.indexOf(_r27) && n.push(e[_r27]);
  }

  return [n, t.map(t => e[t])];
}

function Yr(e, t) {
  return Kr(e, t.map(e => 1), t);
}

function Jr(e, t, n) {
  l(jr(t, n), () => "".concat(e, " supports only inner-most axes for now. Got axes ").concat(t, " and rank-").concat(n, " input."));
}

function Zr(e, t) {
  if (jr(e, t)) return null;
  var n = [];

  for (var _s33 = 0; _s33 < t; ++_s33) {
    -1 === e.indexOf(_s33) && n.push(_s33);
  }

  return e.forEach(e => n.push(e)), n;
}

function Qr(e) {
  return e.map((e, t) => [t, e]).sort((e, t) => e[1] - t[1]).map(e => e[0]);
}

function ea(e, t) {
  var n = [];

  for (var _s34 = t - e; _s34 < t; ++_s34) {
    n.push(_s34);
  }

  return n;
}

var ta = Ft({
  logSumExp_: function logSumExp_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Rt(e, "x", "logSumExp"),
        r = y(t, s.shape),
        a = Vr(s, r, !0),
        i = Gr(s, a),
        o = yr(i),
        l = Hr(o, r),
        u = Lr(l),
        c = ts(Rs(a, u.shape), u);

    if (n) {
      var _e55 = Yr(c.shape, r);

      return Rs(c, _e55);
    }

    return c;
  }
}),
    na = Ft({
  logicalAnd_: function logicalAnd_(e, t) {
    var n = Rt(e, "a", "logicalAnd", "bool"),
        s = Rt(t, "b", "logicalAnd", "bool");
    return hr(n.shape, s.shape), vt.runKernel("LogicalAnd", {
      a: n,
      b: s
    });
  }
}),
    sa = Ft({
  logicalNot_: function logicalNot_(e) {
    var t = Rt(e, "x", "logicalNot", "bool");
    return vt.runKernel("LogicalNot", {
      x: t
    });
  }
}),
    ra = Ft({
  logicalOr_: function logicalOr_(e, t) {
    var n = Rt(e, "a", "logicalOr", "bool"),
        s = Rt(t, "b", "logicalOr", "bool");
    return hr(n.shape, s.shape), vt.runKernel("LogicalOr", {
      a: n,
      b: s
    });
  }
}),
    aa = Ft({
  logicalXor_: function logicalXor_(e, t) {
    var n = Rt(e, "a", "logicalXor", "bool"),
        s = Rt(t, "b", "logicalXor", "bool");
    return hr(n.shape, s.shape), na(ra(e, t), sa(na(e, t)));
  }
}),
    ia = Ft({
  maxPool_: function maxPool_(e, t, n, s, r) {
    var a = Rt(e, "x", "maxPool");
    var i = a,
        o = !1;
    3 === a.rank && (o = !0, i = Rs(a, [1, a.shape[0], a.shape[1], a.shape[2]])), l(4 === i.rank, () => "Error in maxPool: input must be rank 4 but got rank ".concat(i.rank, ".")), l(Ts(n, 1), () => "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '1'")), null != r && l(f(s), () => "Error in maxPool: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, "."));
    var u = vt.runKernel("MaxPool", {
      x: i
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r
    });
    return o ? Rs(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    oa = Ft({
  maxPool3d_: function maxPool3d_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1];
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NDHWC";
    var i = Rt(e, "x", "maxPool3d");
    var o = i,
        u = !1;
    4 === i.rank && (u = !0, o = Rs(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), l(5 === o.rank, () => "Error in maxPool3d: x must be rank 5 but got rank ".concat(o.rank, ".")), l("NDHWC" === a, () => "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ".concat(a)), null != r && l(f(s), () => "Error in maxPool3d: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, "."));
    var c = vt.runKernel("MaxPool3D", {
      x: o
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r,
      dataFormat: a
    });
    return u ? Rs(c, [c.shape[1], c.shape[2], c.shape[3], c.shape[4]]) : c;
  }
}),
    la = Ft({
  maximum_: function maximum_(e, t) {
    var n = Rt(e, "a", "maximum"),
        s = Rt(t, "b", "maximum");
    return [n, s] = gt(n, s), "bool" === n.dtype && (n = fn(n, "int32"), s = fn(s, "int32")), hr(n.shape, s.shape), vt.runKernel("Maximum", {
      a: n,
      b: s
    });
  }
}),
    ua = Ft({
  mean_: function mean_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Rt(e, "x", "mean");
    return vt.runKernel("Mean", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
});

function ca(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";

  if ("complex64" === t) {
    var _t58 = ca(e, "float32"),
        _n28 = ca(e, "float32");

    return Dt(_t58, _n28);
  }

  var n = O(d(e), t);
  return vt.makeTensor(n, e, t);
}

function ha(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";

  if ("complex64" === t) {
    var _t59 = ha(e, "float32"),
        _n29 = ca(e, "float32");

    return Dt(_t59, _n29);
  }

  var n = _(d(e), t);

  return vt.makeTensor(n, e, t);
}

var da = Ft({
  min_: function min_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Rt(e, "x", "min");
    return vt.runKernel("Min", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    pa = Ft({
  minimum_: function minimum_(e, t) {
    var n = Rt(e, "a", "minimum"),
        s = Rt(t, "b", "minimum");
    return [n, s] = gt(n, s), "bool" === n.dtype && (n = fn(n, "int32"), s = fn(s, "int32")), hr(n.shape, s.shape), vt.runKernel("Minimum", {
      a: n,
      b: s
    });
  }
}),
    fa = Ft({
  mirrorPad_: function mirrorPad_(e, t, n) {
    l("reflect" === n || "symmetric" === n, () => "Invalid mode. Mode must be either reflect or symmetric. Got ".concat(n, "."));
    var s = Rt(e, "x", "mirrorPad");
    if (0 === s.rank) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
    l(t.length === s.rank, () => "Padding doesn't match input. Must be ".concat(s.rank, ". Got ").concat(t.length, "."));
    var r = "reflect" === n ? 1 : 0;

    var _loop5 = function _loop5(_e56) {
      l(2 === t[_e56].length, () => "Invalid number of paddings. Must be length of 2 each."), l(t[_e56][0] >= 0 && t[_e56][0] <= s.shape[_e56] - r && t[_e56][1] >= 0 && t[_e56][1] <= s.shape[_e56] - r, () => "Padding in dimension ".concat(_e56, " cannot be greater than or equal to ").concat(s.shape[_e56] - r, " or less than 0 for input of shape ").concat(s.shape));
    };

    for (var _e56 = 0; _e56 < s.rank; _e56++) {
      _loop5(_e56);
    }

    return vt.runKernel("MirrorPad", {
      x: s
    }, {
      paddings: t,
      mode: n
    });
  }
}),
    ga = Ft({
  mod_: function mod_(e, t) {
    var n = Rt(e, "a", "mod"),
        s = Rt(t, "b", "mod");
    return [n, s] = gt(n, s), vt.runKernel("Mod", {
      a: n,
      b: s
    });
  }
}),
    ma = Ft({
  square_: function square_(e) {
    var t = Rt(e, "x", "square");
    return vt.runKernel("Square", {
      x: t
    }, {});
  }
}),
    ba = Ft({
  moments_: function moments_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = y(t, (e = Rt(e, "x", "moments")).shape),
        r = ua(e, s, n);
    var a = r.shape;
    n || (a = Yr(r.shape, s));
    var i = ma(Gr(fn(e, "float32"), Rs(r, a)));
    return {
      mean: r,
      variance: ua(i, s, n)
    };
  }
}),
    xa = Ft({
  notEqual_: function notEqual_(e, t) {
    var n = Rt(e, "a", "notEqual", "string_or_numeric"),
        s = Rt(t, "b", "notEqual", "string_or_numeric");
    return [n, s] = gt(n, s), hr(n.shape, s.shape), vt.runKernel("NotEqual", {
      a: n,
      b: s
    });
  }
}),
    ya = Ft({
  onesLike_: function onesLike_(e) {
    var t = Rt(e, "x", "onesLike");
    return vt.runKernel("OnesLike", {
      x: t
    });
  }
}),
    ka = Ft({
  pad_: function pad_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = Rt(e, "x", "pad");
    if (0 === s.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    return vt.runKernel("PadV2", {
      x: s
    }, {
      paddings: t,
      constantValue: n
    });
  }
}),
    wa = Ft({
  spaceToBatchND_: function spaceToBatchND_(e, t, n) {
    var s = Rt(e, "x", "spaceToBatchND");
    return l(s.rank >= 1 + t.length, () => "input rank ".concat(s.rank, " should be > than [blockShape] ").concat(t.length)), l(n.length === t.length, () => "paddings.shape[0] ".concat(n.length, " must be equal to [blockShape] ").concat(t.length)), l(s.shape.reduce((e, s, r) => r > 0 && r <= t.length ? e && (s + n[r - 1][0] + n[r - 1][1]) % t[r - 1] == 0 : e, !0), () => "input spatial dimensions ".concat(s.shape.slice(1), " with paddings ").concat(n.toString(), " must be divisible by blockShapes ").concat(t.toString())), vt.runKernel("SpaceToBatchND", {
      x: s
    }, {
      blockShape: t,
      paddings: n
    });
  }
}),
    va = Ft({
  pool_: function pool_(e, t, n, s, r, a) {
    null == r && (r = [1, 1]), null == a && (a = 1), 0 === s && (s = "valid");
    var i = Rt(e, "x", "maxPool");
    var o = i,
        u = !1;
    3 === i.rank && (u = !0, o = Rs(i, [1, i.shape[0], i.shape[1], i.shape[2]])), l(Ts(a, r), () => "Error in pool: Either strides or dilations must be 1. Got strides ".concat(a, " and dilations '").concat(r, "'"));
    var c = xs(o.shape, t, a, r, s),
        h = [c.dilationHeight, c.dilationWidth];
    var d;
    d = "same" === s ? function (e, t) {
      var n = e.map((e, n) => e + (e - 1) * (t[n] - 1)).map(e => e - 1),
          s = n.map(e => Math.floor(e / 2)),
          r = n.map((e, t) => e - s[t]);
      return n.map((e, t) => [s[t], r[t]]);
    }([c.filterHeight, c.filterWidth], h) : [[0, 0], [0, 0]];

    var p = 1 === h[0] && 1 === h[1],
        [f, g] = function (e, t, n) {
      var s = n.map(e => e[0]),
          r = n.map(e => e[1]),
          a = e.concat(s, r),
          i = t.map((e, t) => (e - a[t] % e) % e),
          o = r.map((e, t) => e + i[t]);
      return [t.map((e, t) => [s[t], o[t]]), t.map((e, t) => [0, i[t]])];
    }([c.inHeight, c.inWidth], h, d),
        m = p ? s : "valid",
        b = p ? o : wa(o, h, f),
        x = ("avg" === n ? () => As(b, t, a, m) : () => ia(b, t, a, m))(),
        y = p ? x : Ls(x, h, g);

    return u ? Rs(y, [y.shape[1], y.shape[2], y.shape[3]]) : y;
  }
}),
    Ia = Ft({
  pow_: function pow_(e, t) {
    var n = Rt(e, "base", "pow"),
        s = Rt(t, "exp", "pow");
    return [n, s] = gt(n, s), vt.runKernel("Pow", {
      a: n,
      b: s
    });
  }
}),
    $a = Ft({
  prelu_: function prelu_(e, t) {
    var n = Rt(e, "x", "prelu"),
        s = Rt(t, "alpha", "prelu");
    return vt.runKernel("Prelu", {
      x: n,
      alpha: s
    });
  }
}),
    Sa = Ft({
  prod_: function prod_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Rt(e, "x", "prod");
    return "bool" === s.dtype && (s = fn(s, "int32")), vt.runKernel("Prod", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
});

function Na(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports), t.exports;
}

"undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self && self;

var Ca = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t,
          n = this,
          s = (t = 4022871197, function (e) {
        e = e.toString();

        for (var n = 0; n < e.length; n++) {
          var s = .02519603282416938 * (t += e.charCodeAt(n));
          s -= t = s >>> 0, t = (s *= t) >>> 0, t += 4294967296 * (s -= t);
        }

        return 2.3283064365386963e-10 * (t >>> 0);
      });
      n.next = function () {
        var e = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
        return n.s0 = n.s1, n.s1 = n.s2, n.s2 = e - (n.c = 0 | e);
      }, n.c = 1, n.s0 = s(" "), n.s1 = s(" "), n.s2 = s(" "), n.s0 -= s(e), n.s0 < 0 && (n.s0 += 1), n.s1 -= s(e), n.s1 < 0 && (n.s1 += 1), n.s2 -= s(e), n.s2 < 0 && (n.s2 += 1), s = null;
    }

    function r(e, t) {
      return t.c = e.c, t.s0 = e.s0, t.s1 = e.s1, t.s2 = e.s2, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = n.next;
      return i.int32 = function () {
        return 4294967296 * n.next() | 0;
      }, i.double = function () {
        return i() + 11102230246251565e-32 * (2097152 * i() | 0);
      }, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.alea = a;
  }(0, e);
}),
    Ta = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this,
          n = "";
      t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.next = function () {
        var e = t.x ^ t.x << 11;
        return t.x = t.y, t.y = t.z, t.z = t.w, t.w ^= t.w >>> 19 ^ e ^ e >>> 8;
      }, e === (0 | e) ? t.x = e : n += e;

      for (var s = 0; s < n.length + 64; s++) {
        t.x ^= 0 | n.charCodeAt(s), t.next();
      }
    }

    function r(e, t) {
      return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xor128 = a;
  }(0, e);
}),
    Ea = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this,
          n = "";
      t.next = function () {
        var e = t.x ^ t.x >>> 2;
        return t.x = t.y, t.y = t.z, t.z = t.w, t.w = t.v, (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0;
      }, t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.v = 0, e === (0 | e) ? t.x = e : n += e;

      for (var s = 0; s < n.length + 64; s++) {
        t.x ^= 0 | n.charCodeAt(s), s == n.length && (t.d = t.x << 10 ^ t.x >>> 4), t.next();
      }
    }

    function r(e, t) {
      return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t.v = e.v, t.d = e.d, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xorwow = a;
  }(0, e);
}),
    Ra = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this;
      t.next = function () {
        var e,
            n,
            s = t.x,
            r = t.i;
        return e = s[r], n = (e ^= e >>> 7) ^ e << 24, n ^= (e = s[r + 1 & 7]) ^ e >>> 10, n ^= (e = s[r + 3 & 7]) ^ e >>> 3, n ^= (e = s[r + 4 & 7]) ^ e << 7, e = s[r + 7 & 7], s[r] = n ^= (e ^= e << 13) ^ e << 9, t.i = r + 1 & 7, n;
      }, function (e, t) {
        var n,
            s = [];
        if (t === (0 | t)) s[0] = t;else for (t = "" + t, n = 0; n < t.length; ++n) {
          s[7 & n] = s[7 & n] << 15 ^ t.charCodeAt(n) + s[n + 1 & 7] << 13;
        }

        for (; s.length < 8;) {
          s.push(0);
        }

        for (n = 0; n < 8 && 0 === s[n]; ++n) {
          ;
        }

        for (8 == n && (s[7] = -1), e.x = s, e.i = 0, n = 256; n > 0; --n) {
          e.next();
        }
      }(t, e);
    }

    function r(e, t) {
      return t.x = e.x.slice(), t.i = e.i, t;
    }

    function a(e, t) {
      null == e && (e = +new Date());

      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && (a.x && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xorshift7 = a;
  }(0, e);
}),
    Aa = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this;
      t.next = function () {
        var e,
            n,
            s = t.w,
            r = t.X,
            a = t.i;
        return t.w = s = s + 1640531527 | 0, n = r[a + 34 & 127], e = r[a = a + 1 & 127], n ^= n << 13, e ^= e << 17, n = r[a] = (n ^= n >>> 15) ^ (e ^= e >>> 12), t.i = a, n + (s ^ s >>> 16) | 0;
      }, function (e, t) {
        var n,
            s,
            r,
            a,
            i,
            o = [],
            l = 128;

        for (t === (0 | t) ? (s = t, t = null) : (t += "\0", s = 0, l = Math.max(l, t.length)), r = 0, a = -32; a < l; ++a) {
          t && (s ^= t.charCodeAt((a + 32) % t.length)), 0 === a && (i = s), s ^= s << 10, s ^= s >>> 15, s ^= s << 4, s ^= s >>> 13, a >= 0 && (r = 0 == (n = o[127 & a] ^= s + (i = i + 1640531527 | 0)) ? r + 1 : 0);
        }

        for (r >= 128 && (o[127 & (t && t.length || 0)] = -1), r = 127, a = 512; a > 0; --a) {
          s = o[r + 34 & 127], n = o[r = r + 1 & 127], s ^= s << 13, n ^= n << 17, o[r] = (s ^= s >>> 15) ^ (n ^= n >>> 12);
        }

        e.w = i, e.X = o, e.i = r;
      }(t, e);
    }

    function r(e, t) {
      return t.i = e.i, t.w = e.w, t.X = e.X.slice(), t;
    }

    function a(e, t) {
      null == e && (e = +new Date());

      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && (a.X && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xor4096 = a;
  }(0, e);
}),
    Fa = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this,
          n = "";
      t.next = function () {
        var e = t.b,
            n = t.c,
            s = t.d,
            r = t.a;
        return e = e << 25 ^ e >>> 7 ^ n, n = n - s | 0, s = s << 24 ^ s >>> 8 ^ r, r = r - e | 0, t.b = e = e << 20 ^ e >>> 12 ^ n, t.c = n = n - s | 0, t.d = s << 16 ^ n >>> 16 ^ r, t.a = r - e | 0;
      }, t.a = 0, t.b = 0, t.c = -1640531527, t.d = 1367130551, e === Math.floor(e) ? (t.a = e / 4294967296 | 0, t.b = 0 | e) : n += e;

      for (var s = 0; s < n.length + 20; s++) {
        t.b ^= 0 | n.charCodeAt(s), t.next();
      }
    }

    function r(e, t) {
      return t.a = e.a, t.b = e.b, t.c = e.c, t.d = e.d, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.tychei = a;
  }(0, e);
}),
    Da = {
  __proto__: null,
  default: {}
},
    _a = Na(function (e) {
  !function (t, n) {
    var s,
        r = this,
        a = 256,
        i = n.pow(a, 6),
        o = n.pow(2, 52),
        l = 2 * o,
        u = 255;

    function c(e, u, c) {
      var m = [],
          b = f(p((u = 1 == u ? {
        entropy: !0
      } : u || {}).entropy ? [e, g(t)] : null == e ? function () {
        try {
          var e;
          return s && (e = s.randomBytes) ? e = e(a) : (e = new Uint8Array(a), (r.crypto || r.msCrypto).getRandomValues(e)), g(e);
        } catch (e) {
          var n = r.navigator,
              i = n && n.plugins;
          return [+new Date(), r, i, r.screen, g(t)];
        }
      }() : e, 3), m),
          x = new h(m),
          y = function y() {
        for (var e = x.g(6), t = i, n = 0; e < o;) {
          e = (e + n) * a, t *= a, n = x.g(1);
        }

        for (; e >= l;) {
          e /= 2, t /= 2, n >>>= 1;
        }

        return (e + n) / t;
      };

      return y.int32 = function () {
        return 0 | x.g(4);
      }, y.quick = function () {
        return x.g(4) / 4294967296;
      }, y.double = y, f(g(x.S), t), (u.pass || c || function (e, t, s, r) {
        return r && (r.S && d(r, x), e.state = function () {
          return d(x, {});
        }), s ? (n.random = e, t) : e;
      })(y, b, "global" in u ? u.global : this == n, u.state);
    }

    function h(e) {
      var t,
          n = e.length,
          s = this,
          r = 0,
          i = s.i = s.j = 0,
          o = s.S = [];

      for (n || (e = [n++]); r < a;) {
        o[r] = r++;
      }

      for (r = 0; r < a; r++) {
        o[r] = o[i = u & i + e[r % n] + (t = o[r])], o[i] = t;
      }

      (s.g = function (e) {
        for (var t, n = 0, r = s.i, i = s.j, o = s.S; e--;) {
          t = o[r = u & r + 1], n = n * a + o[u & (o[r] = o[i = u & i + t]) + (o[i] = t)];
        }

        return s.i = r, s.j = i, n;
      })(a);
    }

    function d(e, t) {
      return t.i = e.i, t.j = e.j, t.S = e.S.slice(), t;
    }

    function p(e, t) {
      var n,
          s = [],
          r = typeof e;
      if (t && "object" == r) for (n in e) {
        try {
          s.push(p(e[n], t - 1));
        } catch (e) {}
      }
      return s.length ? s : "string" == r ? e : e + "\0";
    }

    function f(e, t) {
      for (var n, s = e + "", r = 0; r < s.length;) {
        t[u & r] = u & (n ^= 19 * t[u & r]) + s.charCodeAt(r++);
      }

      return g(t);
    }

    function g(e) {
      return String.fromCharCode.apply(0, e);
    }

    if (n.seedrandom = c, f(n.random(), t), e.exports) {
      e.exports = c;

      try {
        s = Da;
      } catch (e) {}
    }
  }([], Math);
});

_a.alea = Ca, _a.xor128 = Ta, _a.xorwow = Ea, _a.xorshift7 = Ra, _a.xor4096 = Aa, _a.tychei = Fa;
var Oa = _a;

class Ma {
  constructor(e, t, n, s, r) {
    this.mean = e, this.stdDev = t, this.dtype = n, this.nextVal = NaN, this.truncated = s, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    var a = r || Math.random();
    this.random = Oa.alea(a.toString());
  }

  nextValue() {
    if (!isNaN(this.nextVal)) {
      var _e57 = this.nextVal;
      return this.nextVal = NaN, _e57;
    }

    var e,
        t,
        n = !1;

    for (; !n;) {
      var _s35 = void 0,
          _r28 = void 0,
          _a15 = void 0;

      do {
        _s35 = 2 * this.random() - 1, _r28 = 2 * this.random() - 1, _a15 = _s35 * _s35 + _r28 * _r28;
      } while (_a15 >= 1 || 0 === _a15);

      var _i11 = Math.sqrt(-2 * Math.log(_a15) / _a15);

      e = this.mean + this.stdDev * _s35 * _i11, t = this.mean + this.stdDev * _r28 * _i11, this.truncated && !this.isValidTruncated(e) || (n = !0);
    }

    return this.truncated && !this.isValidTruncated(t) || (this.nextVal = this.convertValue(t)), this.convertValue(e);
  }

  convertValue(e) {
    return null == this.dtype || "float32" === this.dtype ? e : Math.round(e);
  }

  isValidTruncated(e) {
    return e <= this.upper && e >= this.lower;
  }

}

class La {
  constructor() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    if (this.canReturnFloat = () => null == this.dtype || "float32" === this.dtype, this.min = e, this.range = t - e, this.dtype = n, null == s && (s = Math.random()), "number" == typeof s && (s = s.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between ".concat(e, " - ").concat(t, " <= 1 and dtype is not float"));
    this.random = Oa.alea(s);
  }

  convertValue(e) {
    return this.canReturnFloat() ? e : Math.round(e);
  }

  nextValue() {
    return this.convertValue(this.min + this.range * this.random());
  }

}

var za = Ft({
  randomNormal_: function randomNormal_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    if (null != s && "bool" === s) throw new Error("Unsupported data type ".concat(s));
    var a = new Ma(t, n, s, !1, r),
        i = pn(e, s);

    for (var _e58 = 0; _e58 < i.values.length; _e58++) {
      i.values[_e58] = a.nextValue();
    }

    return i.toTensor();
  }
}),
    Ba = Ft({
  randomUniform_: function randomUniform_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "float32";
    var r = arguments.length > 4 ? arguments[4] : undefined;
    var a = pn(e, s),
        i = new La(t, n, null, r);

    for (var _e59 = 0; _e59 < a.values.length; _e59++) {
      a.values[_e59] = i.nextValue();
    }

    return a.toTensor();
  }
});

function Pa(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "float32";
  if (0 === n) throw new Error("Cannot have a step of zero");
  return vt.runKernel("Range", {}, {
    start: e,
    stop: t,
    step: n,
    dtype: s
  });
}

var Wa = Ft({
  real_: function real_(e) {
    var t = Rt(e, "input", "real");
    return vt.runKernel("Real", {
      input: t
    });
  }
}),
    Ua = Ft({
  reciprocal_: function reciprocal_(e) {
    var t = Rt(e, "x", "reciprocal");
    return vt.runKernel("Reciprocal", {
      x: t
    });
  }
}),
    Va = Ft({
  relu_: function relu_(e) {
    var t = Rt(e, "x", "relu");
    return vt.runKernel("Relu", {
      x: t
    });
  }
}),
    Ga = Ft({
  relu6_: function relu6_(e) {
    var t = Rt(e, "x", "relu6");
    return vt.runKernel("Relu6", {
      x: t
    });
  }
}),
    Ha = Ft({
  reverse_: function reverse_(e, t) {
    var n = Rt(e, "x", "reverse");
    return vt.runKernel("Reverse", {
      x: n
    }, {
      dims: t
    });
  }
}),
    qa = Ft({
  round_: function round_(e) {
    var t = Rt(e, "x", "round");
    return vt.runKernel("Round", {
      x: t
    });
  }
}),
    ja = Ft({
  rsqrt_: function rsqrt_(e) {
    var t = Rt(e, "x", "rsqrt");
    return vt.runKernel("Rsqrt", {
      x: t
    });
  }
});

function Ka(e, t) {
  if (($(e) && "string" !== t || Array.isArray(e)) && "complex64" !== t) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if ("string" === t && $(e) && !(e instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return _t(e, [], [], t);
}

var Xa = Ft({
  selu_: function selu_(e) {
    var t = Rt(e, "x", "selu");
    return vt.runKernel("Selu", {
      x: t
    });
  }
}),
    Ya = Ft({
  separableConv2d_: function separableConv2d_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "NHWC";
    var o = Rt(e, "x", "separableConv2d"),
        u = Rt(t, "depthwiseFilter", "separableConv2d"),
        c = Rt(n, "pointwiseFilter", "separableConv2d");
    var h = o,
        d = !1;
    if (3 === o.rank && (d = !0, h = Rs(o, [1, o.shape[0], o.shape[1], o.shape[2]])), "NCHW" === i) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    l(4 === h.rank, () => "Error in separableConv2d: input must be rank 4, but got rank ".concat(h.rank, ".")), l(4 === u.rank, () => "Error in separableConv2d: depthwise filter must be rank 4, but got rank ".concat(u.rank, ".")), l(4 === c.rank, () => "Error in separableConv2d: pointwise filter must be rank 4, but got rank ".concat(u.rank, ".")), l(1 === c.shape[0], () => "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ".concat(c.shape[0], ".")), l(1 === c.shape[1], () => "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ".concat(c.shape[1], "."));
    var p = u.shape[2],
        f = u.shape[3];
    l(c.shape[2] === p * f, () => "Error in separableConv2d: the third dimension of pointwise filter must be ".concat(p * f, ", but got ").concat(c.shape[2], "."));
    var g = or(h, u, s, r, i, a),
        m = Ys(g, c, 1, "valid", i);
    return d ? Rs(m, [m.shape[1], m.shape[2], m.shape[3]]) : m;
  }
}),
    Ja = Ft({
  sign_: function sign_(e) {
    var t = Rt(e, "x", "sign");
    return vt.runKernel("Sign", {
      x: t
    });
  }
}),
    Za = Ft({
  sin_: function sin_(e) {
    var t = Rt(e, "x", "sin");
    return vt.runKernel("Sin", {
      x: t
    });
  }
}),
    Qa = Ft({
  sinh_: function sinh_(e) {
    var t = Rt(e, "x", "sinh");
    return vt.runKernel("Sinh", {
      x: t
    });
  }
}),
    ei = Ft({
  slice1d_: function slice1d_(e, t, n) {
    var s = Rt(e, "x", "slice1d");
    return l(1 === s.rank, () => "slice1d expects a rank-1 tensor, but got a rank-".concat(s.rank, " tensor")), Os(s, [t], [n]);
  }
}),
    ti = Ft({
  slice2d_: function slice2d_(e, t, n) {
    var s = Rt(e, "x", "slice2d");
    return l(2 === s.rank, () => "slice2d expects a rank-2 tensor, but got a rank-".concat(s.rank, " tensor")), Os(s, t, n);
  }
}),
    ni = Ft({
  slice3d_: function slice3d_(e, t, n) {
    var s = Rt(e, "x", "slice3d");
    return l(3 === s.rank, () => "slice3d expects a rank-3 tensor, but got a rank-".concat(s.rank, " tensor")), Os(s, t, n);
  }
}),
    si = Ft({
  slice4d_: function slice4d_(e, t, n) {
    var s = Rt(e, "x", "slice4d");
    return l(4 === s.rank, () => "slice4d expects a rank-4 tensor, but got a rank-".concat(s.rank, " tensor")), Os(s, t, n);
  }
}),
    ri = Ft({
  softmax_: function softmax_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var n = Rt(e, "logits", "softmax", "float32");
    if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(n.rank, " and dim was ").concat(t));
    return vt.runKernel("Softmax", {
      logits: n
    }, {
      dim: t
    });
  }
}),
    ai = Ft({
  fft_: function fft_(e) {
    return l("complex64" === e.dtype, () => "The dtype for tf.spectral.fft() must be complex64 but got ".concat(e.dtype, ".")), vt.runKernel("FFT", {
      input: e
    });
  }
}),
    ii = Ft({
  ifft_: function ifft_(e) {
    return l("complex64" === e.dtype, () => "The dtype for tf.spectral.ifft() must be complex64 but got ".concat(e.dtype, ".")), vt.runKernel("IFFT", {
      input: e
    });
  }
}),
    oi = Ft({
  irfft_: function irfft_(e) {
    var t = e.shape[e.shape.length - 1],
        n = e.size / t;
    var s;

    if (t <= 2) {
      var _r29 = Rs(e, [n, t]);

      s = ii(_r29);
    } else {
      var _r30 = [n, 2 * (t - 1)],
          _a16 = Rs(Wa(e), [n, t]),
          _i12 = Rs(Er(e), [n, t]),
          _o10 = Ha(Os(_a16, [0, 1], [n, t - 2]), 1),
          _l5 = rs(Ha(Os(_i12, [0, 1], [n, t - 2]), 1), Ka(-1)),
          _u4 = Ds([_a16, _o10], 1),
          _c3 = Ds([_i12, _l5], 1),
          _h2 = Rs(Dt(_u4, _c3), [_r30[0], _r30[1]]);

      s = ii(_h2);
    }

    if (s = Wa(s), 3 === e.rank && 0 !== e.shape[0]) {
      var _t60 = s,
          _n30 = e.shape[0];
      s = Rs(s, [_n30, s.shape[0] / _n30, s.shape[1]]), _t60.dispose();
    }

    return s;
  }
}),
    li = Ft({
  split_: function split_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = Rt(e, "x", "split");
    return vt.runKernel("SplitV", {
      x: s
    }, {
      numOrSizeSplits: t,
      axis: n
    });
  }
}),
    ui = Ft({
  rfft_: function rfft_(e, t) {
    l("float32" === e.dtype, () => "The dtype for rfft() must be real value but got ".concat(e.dtype));
    var n = e.shape[e.shape.length - 1];
    var s = e.size / n;
    var r;

    if (null != t && t < n) {
      var _s36 = e.shape.map(e => 0),
          _a17 = e.shape.map(e => e);

      _a17[e.shape.length - 1] = t, r = Os(e, _s36, _a17), n = t;
    } else if (null != t && t > n) {
      var _s37 = e.shape.map(e => e);

      _s37[e.shape.length - 1] = t - n, r = Ds([e, ca(_s37)], e.shape.length - 1), n = t;
    } else r = e;

    var a = fr(r),
        i = Rs(Dt(r, a), [s, n]),
        o = ai(i),
        u = Math.floor(n / 2) + 1,
        c = Wa(o),
        h = Er(o),
        d = li(c, [u, n - u], c.shape.length - 1),
        p = li(h, [u, n - u], h.shape.length - 1),
        f = r.shape.slice();
    return f[r.shape.length - 1] = u, Rs(Dt(d[0], p[0]), f);
  }
}),
    ci = Ft({
  sqrt_: function sqrt_(e) {
    var t = Rt(e, "x", "sqrt");
    return vt.runKernel("Sqrt", {
      x: t
    });
  }
}),
    hi = Ft({
  squaredDifference_: function squaredDifference_(e, t) {
    var n = Rt(e, "a", "squaredDifference"),
        s = Rt(t, "b", "squaredDifference");
    return [n, s] = gt(n, s), hr(n.shape, s.shape), vt.runKernel("SquaredDifference", {
      a: n,
      b: s
    }, {});
  }
}),
    di = Ft({
  squeeze_: function squeeze_(e, t) {
    var n = Rt(e, "x", "squeeze");
    return Rs(n, k(n.shape, t).newShape);
  }
}),
    pi = Ft({
  stack_: function stack_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = At(e, "tensors", "stack", "string_or_numeric");
    return l(n.length >= 1, () => "Pass at least one tensor to tf.stack"), n.length > 0 && l(t <= n[0].rank, () => "Axis must be <= rank of the tensor"), vt.runKernel("Pack", n, {
      axis: t
    });
  }
}),
    fi = Ft({
  step_: function step_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Rt(e, "x", "step");
    return vt.runKernel("Step", {
      x: n
    }, {
      alpha: t
    });
  }
}),
    gi = Ft({
  stridedSlice_: function stridedSlice_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    var u = Rt(e, "x", "stridedSlice", "string_or_numeric");
    return vt.runKernel("StridedSlice", {
      x: u
    }, {
      begin: t,
      end: n,
      strides: s,
      beginMask: r,
      endMask: a,
      ellipsisMask: i,
      newAxisMask: o,
      shrinkAxisMask: l
    });
  }
}),
    mi = Ft({
  tan_: function tan_(e) {
    var t = Rt(e, "x", "tan");
    return vt.runKernel("Tan", {
      x: t
    });
  }
});

function bi(e, t) {
  c(e);
  var n = Ct(e, t);
  if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return _t(e, null, n, t);
}

function xi(e, t, n) {
  if (c(e), null != t && 2 !== t.length) throw new Error("tensor2d() requires shape to have two numbers");
  var s = Ct(e, n);
  if (2 !== s.length && 1 !== s.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (1 === s.length && null == t) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return _t(e, t, s, n);
}

var yi = Ft({
  topk_: function topk_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    var s = Rt(e, "x", "topk");
    if (0 === s.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
    var r = s.shape[s.shape.length - 1];
    if (t < 0) throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));
    if (t > r) throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r, ") but got ").concat(t));
    var a = {
      x: s
    },
        i = {
      k: t,
      sorted: n
    },
        [o, l] = vt.runKernel("TopK", a, i);
    return {
      values: o,
      indices: l
    };
  }
}),
    ki = Ft({
  truncatedNormal_: function truncatedNormal_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    if (null != s && "bool" === s) throw new Error("Unsupported data type $ { dtype }");
    var a = new Ma(t, n, s, !0, r),
        i = pn(e, s);

    for (var _e60 = 0; _e60 < i.values.length; _e60++) {
      i.values[_e60] = a.nextValue();
    }

    return i.toTensor();
  }
}),
    wi = Ft({
  unique_: function unique_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Rt(e, "x", "unique", "string_or_numeric");
    l(n.rank > 0, () => "The input tensor must be at least 1D");
    var s = {
      x: n
    },
        r = {
      axis: t
    },
        [a, i] = vt.runKernel("Unique", s, r);
    return {
      values: a,
      indices: i
    };
  }
}),
    vi = Ft({
  unsortedSegmentSum_: function unsortedSegmentSum_(e, t, n) {
    var s = Rt(e, "x", "unsortedSegmentSum"),
        r = Rt(t, "segmentIds", "unsortedSegmentSum", "int32");
    return l(f(n), () => "numSegments must be of dtype int"), vt.runKernel("UnsortedSegmentSum", {
      x: s,
      segmentIds: r
    }, {
      numSegments: n
    });
  }
}),
    Ii = Ft({
  unstack_: function unstack_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Rt(e, "x", "unstack", "string_or_numeric");
    return l(t >= -n.shape.length && t < n.shape.length, () => "Axis = ".concat(t, " is not in [-").concat(n.shape.length, ", ").concat(n.shape.length, ")")), vt.runKernel("Unpack", {
      value: n
    }, {
      axis: t
    });
  }
});

function $i(e, t) {
  var n = [];

  for (var _e61 = 0; _e61 < t.length; _e61++) {
    t[_e61] && n.push(_e61);
  }

  var s = pn(e, "int32"),
      r = pn([n.length, e.length], "int32");

  for (var _t61 = 0; _t61 < n.length; _t61++) {
    var _a18 = s.indexToLoc(n[_t61]);

    r.values.set(_a18, _t61 * e.length);
  }

  return r.toTensor();
}

function Si(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (0 === e.rank) return as(e);
  if (1 !== e.rank && null === n) return Si(Rs(e, [-1]), t, n);

  if (1 === e.rank || "number" == typeof n || Array.isArray(n) && 1 === n.length) {
    if (1 === t) return Hr(as(e), n);
    if (Infinity === t) return Vr(as(e), n);
    if (-Infinity === t) return da(as(e), n);
    if ("euclidean" === t || 2 === t) return ci(Hr(Ia(as(e), Ka(2, "int32")), n));
    throw new Error("Error in norm: invalid ord value: ".concat(t));
  }

  if (Array.isArray(n) && 2 === n.length) {
    if (1 === t) return Vr(Hr(as(e), n[0]), n[1] - 1);
    if (Infinity === t) return Vr(Hr(as(e), n[1]), n[0]);
    if (-Infinity === t) return da(Hr(as(e), n[1]), n[0]);
    if ("fro" === t || "euclidean" === t) return ci(Hr(ma(e), n));
    throw new Error("Error in norm: invalid ord value: ".concat(t));
  }

  throw new Error("Error in norm: invalid axis: ".concat(n));
}

var Ni = Ft({
  norm_: function norm_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "euclidean";
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Si(e = Rt(e, "x", "norm"), t, n);
    var a = r.shape;

    if (s) {
      var _t62 = y(n, e.shape);

      a = Yr(r.shape, _t62);
    }

    return Rs(r, a);
  }
}),
    Ci = Ft({
  dropout_: function dropout_(e, t, n, s) {
    var r = Rt(e, "x", "dropout");
    if (l("float32" === r.dtype, () => "x has to be a floating point tensor since it's going to be scaled, but got a ".concat(r.dtype, " tensor instead.")), l(t >= 0 && t < 1, () => "rate must be a float in the range [0, 1), but got ".concat(t, ".")), 0 === t) return e instanceof rt ? r.clone() : r;

    var a = function (e, t) {
      if (null == t) return e.shape.slice();
      if (p(e.shape, t)) return t;

      if (e.shape.length === t.length) {
        var _n31 = [];

        for (var _s38 = 0; _s38 < e.shape.length; _s38++) {
          _n31.push(null == t[_s38] && null != e.shape[_s38] ? e.shape[_s38] : t[_s38]);
        }

        return _n31;
      }

      return t;
    }(r, n),
        i = 1 - t,
        o = ss(Sr(ts(Ba(a, 0, 1, "float32", s), i)), i);

    return rs(r, o);
  }
});

function Ti(e, t, n) {
  var s = 1 - e % 2,
      r = new Float32Array(e);

  for (var _a19 = 0; _a19 < e; ++_a19) {
    var _i13 = 2 * Math.PI * _a19 / (e + s - 1);

    r[_a19] = t - n * Math.cos(_i13);
  }

  return bi(r, "float32");
}

var Ei = Ft({
  conv2DBackpropFilter_: function conv2DBackpropFilter_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NHWC";
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = e;
    3 === e.rank && (o = Rs(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
    var u = t;
    3 === u.rank && (u = Rs(t, [1, t.shape[0], t.shape[1], t.shape[2]])), l(4 === o.rank, () => "Error in conv2dDerFilter: input must be rank 4, but got shape ".concat(o.shape, ".")), l(4 === u.rank, () => "Error in conv2dDerFilter: dy must be rank 4, but got shape ".concat(u.shape, ".")), l(4 === n.length, () => "Error in conv2dDerFilter: filterShape must be length 4, but got ".concat(n, "."));
    var c = "NHWC" === a ? o.shape[3] : o.shape[1],
        h = "NHWC" === a ? u.shape[3] : u.shape[1];
    return l(c === n[2], () => "Error in conv2dDerFilter: depth of input ".concat(c, ") must match input depth in filter (").concat(n[2], ".")), l(h === n[3], () => "Error in conv2dDerFilter: depth of dy (".concat(h, ") must match output depth for filter (").concat(n[3], ").")), null != i && l(f(r), () => "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(r, ".")), vt.runKernel("Conv2DBackpropFilter", {
      x: o,
      dy: u
    }, {
      strides: s,
      pad: r,
      dataFormat: a,
      dimRoundingMode: i,
      filterShape: n
    });
  }
});

function Ri(e, t, n) {
  if (null == n || "linear" === n) return e;
  if ("relu" === n) return rs(e, fi(t));
  throw new Error("Cannot compute gradient for fused activation ".concat(n, "."));
}

function Ai(e, t) {
  var n = t;
  var s = cr(e.shape, t.shape);
  return s.length > 0 && (n = Hr(n, s)), Rs(n, e.shape);
}

function Fi(e, t, n, s) {
  if ("linear" === t) return e;
  if ("relu" === t) return Va(e);
  if ("elu" === t) return br(e);
  if ("relu6" === t) return Ga(e);
  if ("prelu" === t) return $a(e, n);
  if ("leakyrelu" === t) return Dr(e, s);
  if ("sigmoid" === t) return _s(e);
  throw new Error("Unknown fused activation ".concat(t, "."));
}

var Di = (e, t) => !(e > 0) || "linear" === t,
    _i = Ft({
  fusedConv2d_: function fusedConv2d_(_ref3) {
    var {
      x: e,
      filter: t,
      strides: n,
      pad: s,
      dataFormat: r = "NHWC",
      dilations: a = [1, 1],
      dimRoundingMode: i,
      bias: o,
      activation: u = "linear",
      preluActivationWeights: c,
      leakyreluAlpha: h
    } = _ref3;

    if (!1 === Di(vt.state.gradientDepth, u = u || "linear")) {
      var _l6 = Ys(e, t, n, s, r, a, i);

      return null != o && (_l6 = ts(_l6, o)), Fi(_l6, u, c, h);
    }

    var d = Rt(e, "x", "conv2d"),
        p = Rt(t, "filter", "conv2d");
    var g = d,
        m = !1;
    3 === d.rank && (m = !0, g = Rs(d, [1, d.shape[0], d.shape[1], d.shape[2]])), l(4 === g.rank, () => "Error in fused conv2d: input must be rank 4, but got rank ".concat(g.rank, ".")), l(4 === p.rank, () => "Error in fused conv2d: filter must be rank 4, but got rank ".concat(p.rank, ".")), null != i && l(f(s), () => "Error in fused conv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, ".")), l(g.shape[3] === p.shape[2], () => "Error in conv2d: depth of input (".concat(g.shape[3], ") must match input depth for filter ").concat(p.shape[2], ".")), l(Ts(n, a), () => "Error in conv2D: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '").concat(a, "'")), l("NHWC" === r, () => "Error in conv2d: got dataFormat of ".concat(r, " but only NHWC is currently supported."));
    var b = ks(g.shape, p.shape, n, a, s, i);
    var x, y;
    null != o && (x = Rt(o, "bias", "fused conv2d"), [x] = gt(x, d), hr(b.outShape, x.shape)), null != c && (y = Rt(c, "prelu weights", "fused conv2d"));

    var k = (e, t) => {
      var [r, i, o, c] = t,
          h = Ri(e, o, u);
      l(Cs(a), () => "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(a, "'"));
      var d = [Zs(i.shape, h, r, n, s), Ei(i, h, r.shape, n, s)];

      if (null != c) {
        var _e62 = Ai(c, h);

        d.push(_e62);
      }

      return d;
    },
        w = {
      x: g,
      filter: p,
      bias: x,
      preluActivationWeights: y
    },
        v = {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a,
      dimRoundingMode: i,
      activation: u,
      leakyreluAlpha: h
    };

    return null == o ? Br((e, t, n) => {
      var s = vt.runKernel("FusedConv2D", w, v);
      return n([t, e, s]), m && (s = Rs(s, [s.shape[1], s.shape[2], s.shape[3]])), {
        value: s,
        gradFunc: k
      };
    })(g, p) : Br((e, t, n, s) => {
      var r = vt.runKernel("FusedConv2D", w, v);
      return s([t, e, r, n]), m && (r = Rs(r, [r.shape[1], r.shape[2], r.shape[3]])), {
        value: r,
        gradFunc: k
      };
    })(g, p, x);
  }
}),
    Oi = Ft({
  depthwiseConv2dNativeBackpropFilter_: function depthwiseConv2dNativeBackpropFilter_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = e;
    3 === e.rank && (o = Rs(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
    var l = t;
    return 3 === l.rank && (l = Rs(t, [1, t.shape[0], t.shape[1], t.shape[2]])), vt.runKernel("DepthwiseConv2dNativeBackpropFilter", {
      x: o,
      dy: l
    }, {
      strides: s,
      pad: r,
      dimRoundingMode: i,
      dilations: a,
      filterShape: n
    });
  }
}),
    Mi = Ft({
  depthwiseConv2dNativeBackpropInput_: function depthwiseConv2dNativeBackpropInput_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = t,
        l = !1;
    3 === t.rank && (l = !0, o = Rs(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
    var u = vt.runKernel("DepthwiseConv2dNativeBackpropInput", {
      dy: o,
      filter: n
    }, {
      strides: s,
      pad: r,
      dimRoundingMode: i,
      dilations: a,
      inputShape: e
    });
    return l ? Rs(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    Li = Ft({
  fusedMatMul_: function fusedMatMul_(_ref4) {
    var {
      a: e,
      b: t,
      transposeA: n = !1,
      transposeB: s = !1,
      bias: r,
      activation: a = "linear",
      preluActivationWeights: i,
      leakyreluAlpha: o
    } = _ref4;

    if (!1 === Di(vt.state.gradientDepth, a)) {
      var _l7 = In(e, t, n, s);

      return null != r && (_l7 = ts(_l7, r)), Fi(_l7, a, i, o);
    }

    var u = Rt(e, "a", "fused matMul"),
        c = Rt(t, "b", "fused matMul");
    [u, c] = gt(u, c);
    var h = n ? u.shape[u.rank - 2] : u.shape[u.rank - 1],
        f = s ? c.shape[c.rank - 1] : c.shape[c.rank - 2],
        g = n ? u.shape[u.rank - 1] : u.shape[u.rank - 2],
        m = s ? c.shape[c.rank - 2] : c.shape[c.rank - 1],
        b = u.shape.slice(0, -2),
        x = c.shape.slice(0, -2),
        y = d(b),
        k = d(x);
    l(u.rank >= 2 && c.rank >= 2 && u.rank === c.rank, () => "Error in fused matMul: inputs must have the same rank of at least 2, got ranks ".concat(u.rank, " and ").concat(c.rank, ".")), l(p(b, x), () => "Error in fused matMul: outer dimensions (".concat(b, ") and (").concat(x, ") of Tensors with shapes ").concat(u.shape, " and ").concat(c.shape, " must match.")), l(h === f, () => "Error in fused matMul: inner shapes (".concat(h, ") and (").concat(f, ") of Tensors with shapes ").concat(u.shape, " and ").concat(c.shape, " and transposeA=").concat(n, " and transposeB=").concat(s, " must match."));
    var w = u.shape.slice(0, -2).concat([g, m]),
        v = Rs(u, n ? [y, h, g] : [y, g, h]),
        I = Rs(c, s ? [k, m, f] : [k, f, m]);
    var $, S;
    null != r && ($ = Rt(r, "bias", "fused matMul"), [$] = gt($, u), hr(w, $.shape)), null != i && (S = Rt(i, "prelu weights", "fused matMul"));

    var N = (e, t) => {
      var [i, o, l, u] = t,
          c = Ri(Rs(e, l.shape), l, a);
      var h, d;
      return n || s ? !n && s ? (h = In(c, o, !1, !1), d = In(c, i, !0, !1)) : n && !s ? (h = In(o, c, !1, !0), d = In(i, c, !1, !1)) : (h = In(o, c, !0, !0), d = In(c, i, !0, !0)) : (h = In(c, o, !1, !0), d = In(i, c, !0, !1)), null != r ? [h, d, Ai(u, c)] : [h, d];
    },
        C = {
      a: v,
      b: I,
      bias: $,
      preluActivationWeights: S
    },
        T = {
      transposeA: n,
      transposeB: s,
      activation: a,
      leakyreluAlpha: o
    };

    return null == r ? Br((e, t, n) => {
      var s = vt.runKernel("_FusedMatMul", C, T);
      return n([e, t, s]), {
        value: Rs(s, w),
        gradFunc: N
      };
    })(v, I) : Br((e, t, n, s) => {
      var r = vt.runKernel("_FusedMatMul", C, T);
      return s([e, t, r, n]), {
        value: Rs(r, w),
        gradFunc: N
      };
    })(v, I, $);
  }
});

Ft({
  hammingWindow_: function hammingWindow_(e) {
    return Ti(e, .54, .46);
  }
});
var zi = Ft({
  hannWindow_: function hannWindow_(e) {
    return Ti(e, .5, .5);
  }
}),
    Bi = Ft({
  frame_: function frame_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var a = 0;
    var i = [];

    for (; a + t <= e.size;) {
      i.push(Os(e, a, t)), a += n;
    }

    if (s) for (; a < e.size;) {
      var _s39 = a + t - e.size,
          _o11 = Ds([Os(e, a, t - _s39), $r([_s39], r)]);

      i.push(_o11), a += n;
    }
    return 0 === i.length ? xi([], [0, t]) : Rs(Ds(i), [i.length, t]);
  }
});
Ft({
  stft_: function stft_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : zi;
    null == s && (s = Math.floor(Math.pow(2, Math.ceil(Math.log(t) / Math.log(2)))));
    var a = Bi(e, t, n),
        i = rs(a, r(t));
    return ui(i, s);
  }
});
var Pi = Ft({
  cropAndResize_: function cropAndResize_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "bilinear";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var i = Rt(e, "image", "cropAndResize"),
        o = Rt(t, "boxes", "cropAndResize", "float32"),
        u = Rt(n, "boxInd", "cropAndResize", "int32"),
        c = o.shape[0];
    return l(4 === i.rank, () => "Error in cropAndResize: image must be rank 4,but got rank ".concat(i.rank, ".")), l(2 === o.rank && 4 === o.shape[1], () => "Error in cropAndResize: boxes must be have size [".concat(c, ",4] but had shape ").concat(o.shape, ".")), l(1 === u.rank && u.shape[0] === c, () => "Error in cropAndResize: boxInd must be have size [".concat(c, "] but had shape ").concat(o.shape, ".")), l(2 === s.length, () => "Error in cropAndResize: cropSize must be of length 2, but got length ".concat(s.length, ".")), l(s[0] >= 1 && s[1] >= 1, () => "cropSize must be atleast [1,1], but was ".concat(s)), l("bilinear" === r || "nearest" === r, () => "method must be bilinear or nearest, but was ".concat(r)), vt.runKernel("CropAndResize", {
      image: i,
      boxes: o,
      boxInd: u
    }, {
      method: r,
      extrapolationValue: a,
      cropSize: s
    });
  }
}),
    Wi = Ft({
  flipLeftRight_: function flipLeftRight_(e) {
    var t = Rt(e, "image", "flipLeftRight", "float32");
    return l(4 === t.rank, () => "Error in flipLeftRight: image must be rank 4,but got rank ".concat(t.rank, ".")), vt.runKernel("FlipLeftRight", {
      image: t
    }, {});
  }
}),
    Ui = Ft({
  grayscaleToRGB_: function grayscaleToRGB_(e) {
    var t = Rt(e, "image", "grayscaleToRGB"),
        n = t.rank - 1,
        s = t.shape[n];
    l(t.rank >= 2, () => "Error in grayscaleToRGB: images must be at least rank 2, but got rank ".concat(t.rank, ".")), l(1 === s, () => "Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ".concat(s, "."));
    var r = new Array(t.rank);
    return r.fill(1, 0, n), r[n] = 3, vr(t, r);
  }
}),
    Vi = Ft({
  rotateWithOffset_: function rotateWithOffset_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = Rt(e, "image", "rotateWithOffset", "float32");
    return l(4 === r.rank, () => "Error in rotateWithOffset: image must be rank 4,but got rank ".concat(r.rank, ".")), vt.runKernel("RotateWithOffset", {
      image: r
    }, {
      radians: t,
      fillValue: n,
      center: s
    });
  }
});

function Gi(e, t, n, s, r, a) {
  null == s && (s = .5), null == r && (r = Number.NEGATIVE_INFINITY), null == a && (a = 0);
  var i = e.shape[0];
  return n = Math.min(n, i), l(0 <= s && s <= 1, () => "iouThreshold must be in [0, 1], but was '".concat(s, "'")), l(2 === e.rank, () => "boxes must be a 2D tensor, but was of rank '".concat(e.rank, "'")), l(4 === e.shape[1], () => "boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1])), l(1 === t.rank, () => "scores must be a 1D tensor"), l(t.shape[0] === i, () => "scores has incompatible shape with boxes. Expected ".concat(i, ", but was ").concat(t.shape[0])), l(0 <= a && a <= 1, () => "softNmsSigma must be in [0, 1], but was '".concat(a, "'")), {
    maxOutputSize: n,
    iouThreshold: s,
    scoreThreshold: r,
    softNmsSigma: a
  };
}

var Hi = Ft({
  nonMaxSuppression_: function nonMaxSuppression_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
    var a = Rt(e, "boxes", "nonMaxSuppression"),
        i = Rt(t, "scores", "nonMaxSuppression"),
        o = Gi(a, i, n, s, r);
    return vt.runKernel("NonMaxSuppressionV3", {
      boxes: a,
      scores: i
    }, {
      maxOutputSize: n = o.maxOutputSize,
      iouThreshold: s = o.iouThreshold,
      scoreThreshold: r = o.scoreThreshold
    });
  }
});

function qi(e, t, n) {
  var s = function (e, t, n) {
    return function (e, t, n) {
      var s = 0,
          r = e.length,
          a = 0,
          i = !1;

      for (; s < r;) {
        a = s + (r - s >>> 1);

        var _o12 = n(t, e[a]);

        _o12 > 0 ? s = a + 1 : (r = a, i = !_o12);
      }

      return i ? s : -s - 1;
    }(e, t, n || ji);
  }(e, t, n);

  e.splice(s < 0 ? -(s + 1) : s, 0, t);
}

function ji(e, t) {
  return e > t ? 1 : e < t ? -1 : 0;
}

function Ki(e, t, n, s, r) {
  return Ji(e, t, n, s, r, 0);
}

function Xi(e, t, n, s, r, a) {
  return Ji(e, t, n, s, r, 0, !1, a, !0);
}

function Yi(e, t, n, s, r, a) {
  return Ji(e, t, n, s, r, a, !0);
}

function Ji(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : !1;
  var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : !1;
  var u = [];

  for (var _e63 = 0; _e63 < t.length; _e63++) {
    t[_e63] > r && u.push({
      score: t[_e63],
      boxIndex: _e63,
      suppressBeginIndex: 0
    });
  }

  u.sort(eo);
  var c = a > 0 ? -.5 / a : 0,
      h = [],
      d = [];

  for (; h.length < n && u.length > 0;) {
    var _t63 = u.pop(),
        {
      score: _n32,
      boxIndex: _a20,
      suppressBeginIndex: _i14
    } = _t63;

    if (_n32 < r) break;

    var _o13 = !1;

    for (var _n33 = h.length - 1; _n33 >= _i14; --_n33) {
      var _i15 = Zi(e, _a20, h[_n33]);

      if (_i15 >= s) {
        _o13 = !0;
        break;
      }

      if (_t63.score = _t63.score * Qi(s, c, _i15), _t63.score <= r) break;
    }

    _t63.suppressBeginIndex = h.length, _o13 || (_t63.score === _n32 ? (h.push(_a20), d.push(_t63.score)) : _t63.score > r && qi(u, _t63, eo));
  }

  var p = h.length,
      f = n - p;
  o && f > 0 && (h.push(...new Array(f).fill(0)), d.push(...new Array(f).fill(0)));
  var g = {
    selectedIndices: h
  };
  return i && (g.selectedScores = d), l && (g.validOutputs = p), g;
}

function Zi(e, t, n) {
  var s = e.subarray(4 * t, 4 * t + 4),
      r = e.subarray(4 * n, 4 * n + 4),
      a = Math.min(s[0], s[2]),
      i = Math.min(s[1], s[3]),
      o = Math.max(s[0], s[2]),
      l = Math.max(s[1], s[3]),
      u = Math.min(r[0], r[2]),
      c = Math.min(r[1], r[3]),
      h = Math.max(r[0], r[2]),
      d = Math.max(r[1], r[3]),
      p = (o - a) * (l - i),
      f = (h - u) * (d - c);
  if (p <= 0 || f <= 0) return 0;
  var g = Math.max(a, u),
      m = Math.max(i, c),
      b = Math.min(o, h),
      x = Math.min(l, d),
      y = Math.max(b - g, 0) * Math.max(x - m, 0);
  return y / (p + f - y);
}

function Qi(e, t, n) {
  var s = Math.exp(t * n * n);
  return n <= e ? s : 0;
}

function eo(e, t) {
  return e.score - t.score || e.score === t.score && t.boxIndex - e.boxIndex;
}

var to = Ft({
  nonMaxSuppressionWithScore_: function nonMaxSuppressionWithScore_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var i = Rt(e, "boxes", "nonMaxSuppression"),
        o = Rt(t, "scores", "nonMaxSuppression"),
        l = Gi(i, o, n, s, r, a),
        u = vt.runKernel("NonMaxSuppressionV5", {
      boxes: i,
      scores: o
    }, {
      maxOutputSize: n = l.maxOutputSize,
      iouThreshold: s = l.iouThreshold,
      scoreThreshold: r = l.scoreThreshold,
      softNmsSigma: a = l.softNmsSigma
    });
    return {
      selectedIndices: u[0],
      selectedScores: u[1]
    };
  }
}),
    no = Ft({
  nonMaxSuppressionPadded_: function nonMaxSuppressionPadded_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
    var i = Rt(e, "boxes", "nonMaxSuppression"),
        o = Rt(t, "scores", "nonMaxSuppression"),
        l = Gi(i, o, n, s, r, null),
        u = vt.runKernel("NonMaxSuppressionV4", {
      boxes: i,
      scores: o
    }, {
      maxOutputSize: l.maxOutputSize,
      iouThreshold: l.iouThreshold,
      scoreThreshold: l.scoreThreshold,
      padToMaxOutputSize: a
    });
    return {
      selectedIndices: u[0],
      validOutputs: u[1]
    };
  }
}),
    so = Ft({
  resizeBilinear_: function resizeBilinear_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Rt(e, "images", "resizeBilinear");
    l(3 === r.rank || 4 === r.rank, () => "Error in resizeBilinear: x must be rank 3 or 4, but got rank ".concat(r.rank, ".")), l(2 === t.length, () => "Error in resizeBilinear: new shape must 2D, but got shape ".concat(t, ".")), l(!1 === s || !1 === n, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
    var a = r,
        i = !1;
    3 === r.rank && (i = !0, a = Rs(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
    var o = vt.runKernel("ResizeBilinear", {
      images: a
    }, {
      alignCorners: n,
      halfPixelCenters: s,
      size: t
    });
    return i ? Rs(o, [o.shape[1], o.shape[2], o.shape[3]]) : o;
  }
}),
    ro = Ft({
  resizeNearestNeighbor_: function resizeNearestNeighbor_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Rt(e, "images", "resizeNearestNeighbor");
    l(3 === r.rank || 4 === r.rank, () => "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ".concat(r.rank, ".")), l(2 === t.length, () => "Error in resizeNearestNeighbor: new shape must 2D, but got shape ".concat(t, ".")), l("float32" === r.dtype || "int32" === r.dtype, () => "`images` must have `int32` or `float32` as dtype"), l(!1 === s || !1 === n, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
    var a = r,
        i = !1;
    3 === r.rank && (i = !0, a = Rs(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
    var o = vt.runKernel("ResizeNearestNeighbor", {
      images: a
    }, {
      alignCorners: n,
      halfPixelCenters: s,
      size: t
    });
    return i ? Rs(o, [o.shape[1], o.shape[2], o.shape[3]]) : o;
  }
}),
    ao = Ft({
  threshold_: function threshold_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "binary";
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = Rt(e, "image", "threshold"),
        a = r.shape[0] * r.shape[1];
    var i,
        o,
        u,
        c,
        h = rs(bi([s]), 255);

    if (l(3 === r.rank, () => "Error in threshold: image must be rank 3,but got rank ".concat(r.rank, ".")), l(3 === r.shape[2] || 1 === r.shape[2], () => "Error in threshold: image color channel must be equal to 3 or 1but got ".concat(r.shape[2], ".")), l("int32" === r.dtype || "float32" === r.dtype, () => "Error in dtype: image dtype must be int32 or float32,but got dtype ".concat(r.dtype, ".")), l("otsu" === t || "binary" === t, () => "Method must be binary or otsu, but was ".concat(t)), 3 === r.shape[2]) {
      [i, o, u] = li(r, [1, 1, 1], -1);

      var _e64 = rs(i, .2989),
          _t64 = rs(o, .587),
          _n34 = rs(u, .114);

      c = ts(ts(_e64, _t64), _n34);
    } else c = e;

    "otsu" === t && (h = function (e, t) {
      var n,
          s,
          r,
          a,
          i,
          o,
          l = bi([-1]),
          u = bi([0]),
          c = bi([0]);

      for (var _h3 = 0; _h3 < e.size - 1; _h3++) {
        n = Os(e, 0, _h3 + 1), s = Os(e, _h3 + 1), i = ss(Hr(n), t), o = ss(Hr(s), t);

        var _d4 = Hr(rs(n, Pa(0, n.size)));

        r = ss(_d4, Hr(n));

        var _p4 = $r(s.shape, n.size),
            _f3 = ts(Pa(0, s.size), _p4),
            _g4 = rs(s, _f3);

        a = ss(Hr(_g4), Hr(s));

        var _m3 = Gr(r, a),
            _b3 = Gr(r, a),
            _x9 = rs(i, o);

        c = rs(rs(_x9, _m3), _b3);

        var _y3 = Cr(c, u);

        u = pr(_y3, c, u), l = pr(_y3, bi([_h3]), l);
      }

      return l;
    }(Us(fn(qa(c), "int32"), Ot([]), 256), a));
    var d = n ? Or(c, h) : Cr(c, h);
    return fn(rs(d, 255), "int32");
  }
}),
    io = Ft({
  transform_: function transform_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "nearest";
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "constant";
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var a = arguments.length > 5 ? arguments[5] : undefined;
    var i = Rt(e, "image", "transform", "float32"),
        o = Rt(t, "transforms", "transform", "float32");
    return l(4 === i.rank, () => "Error in transform: image must be rank 4,but got rank ".concat(i.rank, ".")), l(2 === o.rank && (o.shape[0] === i.shape[0] || 1 === o.shape[0]) && 8 === o.shape[1], () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), l(null == a || 2 === a.length, () => "Error in transform: outputShape must be [height, width] or null, but got ".concat(a, ".")), vt.runKernel("Transform", {
      image: i,
      transforms: o
    }, {
      interpolation: n,
      fillMode: s,
      fillValue: r,
      outputShape: a
    });
  }
}),
    oo = Ft({
  bandPart_: function bandPart_(e, t, n) {
    l(t % 1 == 0, () => "bandPart(): numLower must be an integer, got ".concat(t, ".")), l(n % 1 == 0, () => "bandPart(): numUpper must be an integer, got ".concat(n, "."));
    var s = Rt(e, "a", "bandPart");
    l(s.rank >= 2, () => "bandPart(): Rank must be at least 2, got ".concat(s.rank, "."));
    var r = s.shape,
        [a, i] = s.shape.slice(-2);
    if (!(t <= a)) throw new Error("bandPart(): numLower (".concat(t, ") must not be greater than the number of rows (").concat(a, ")."));
    if (!(n <= i)) throw new Error("bandPart(): numUpper (".concat(n, ") must not be greater than the number of columns (").concat(i, ")."));
    t < 0 && (t = a), n < 0 && (n = i);
    var o = Rs(Pa(0, a, 1, "int32"), [-1, 1]),
        u = Pa(0, i, 1, "int32"),
        c = Gr(o, u),
        h = na(Or(c, Ka(+t, "int32")), Tr(c, Ka(-n, "int32"))),
        d = ca([a, i], s.dtype);
    return Rs(pi(Ii(Rs(s, [-1, a, i])).map(e => pr(h, e, d))), r);
  }
}),
    lo = Ft({
  gramSchmidt_: function gramSchmidt_(e) {
    var t;

    if (Array.isArray(e)) {
      (function () {
        t = !1, l(null != e && e.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
        var n = e[0].shape[0];

        var _loop6 = function _loop6(_t65) {
          l(e[_t65].shape[0] === n, () => "Gram-Schmidt: Non-unique lengths found in the input vectors: (".concat(e[_t65].shape[0], " vs. ").concat(n, ")"));
        };

        for (var _t65 = 1; _t65 < e.length; ++_t65) {
          _loop6(_t65);
        }
      })();
    } else t = !0, e = li(e, e.shape[0], 0).map(e => di(e, [0]));

    l(e.length <= e[0].shape[0], () => "Gram-Schmidt: Number of vectors (".concat(e.length, ") exceeds number of dimensions (").concat(e[0].shape[0], ")."));
    var n = [],
        s = e;

    var _loop7 = function _loop7(_t66) {
      n.push(vt.tidy(() => {
        var e = s[_t66];
        if (_t66 > 0) for (var _s40 = 0; _s40 < _t66; ++_s40) {
          var _t67 = rs(Hr(rs(n[_s40], e)), n[_s40]);

          e = Gr(e, _t67);
        }
        return ss(e, Ni(e, "euclidean"));
      }));
    };

    for (var _t66 = 0; _t66 < e.length; ++_t66) {
      _loop7(_t66);
    }

    return t ? pi(n, 0) : n;
  }
});

function uo(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  return vt.tidy(() => {
    l(2 === e.shape.length, () => "qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length, "D Tensor."));
    var n = e.shape[0],
        s = e.shape[1];
    var r = Ir(n),
        a = gn(e);
    var i = xi([[1]], [1, 1]);
    var o = gn(i);
    var u = n >= s ? s : n;

    var _loop8 = function _loop8(_e65) {
      var t = a,
          l = o,
          u = r;
      [o, a, r] = vt.tidy(() => {
        var t = Os(a, [_e65, _e65], [n - _e65, 1]),
            l = Ni(t),
            u = Os(a, [_e65, _e65], [1, 1]),
            c = pr(Cr(u, 0), xi([[-1]]), xi([[1]])),
            h = Gr(u, rs(c, l)),
            d = ss(t, h);
        o = 1 === d.shape[0] ? gn(i) : Ds([i, Os(d, [1, 0], [d.shape[0] - 1, d.shape[1]])], 0);
        var p = Pr(ss(In(c, h), l)),
            f = Os(a, [_e65, 0], [n - _e65, s]),
            g = rs(p, o),
            m = Sn(o);
        if (0 === _e65) a = Gr(f, In(g, In(m, f)));else {
          var _t68 = Gr(f, In(g, In(m, f)));

          a = Ds([Os(a, [0, 0], [_e65, s]), _t68], 0);
        }
        var b = Sn(g),
            x = Os(r, [0, _e65], [n, r.shape[1] - _e65]);
        if (0 === _e65) r = Gr(x, In(In(x, o), b));else {
          var _t69 = Gr(x, In(In(x, o), b));

          r = Ds([Os(r, [0, 0], [n, _e65]), _t69], 1);
        }
        return [o, a, r];
      }), Zn([t, l, u]);
    };

    for (var _e65 = 0; _e65 < u; ++_e65) {
      _loop8(_e65);
    }

    return !t && n > s && (r = Os(r, [0, 0], [n, s]), a = Os(a, [0, 0], [s, s])), [r, a];
  });
}

var co = Ft({
  qr_: function qr_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    if (l(e.rank >= 2, () => "qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank)), 2 === e.rank) return uo(e, t);
    {
      var _n35 = e.shape.slice(0, e.shape.length - 2).reduce((e, t) => e * t),
          _s41 = Ii(Rs(e, [_n35, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0),
          _r31 = [],
          _a21 = [];

      return _s41.forEach(e => {
        var [n, s] = uo(e, t);
        _r31.push(n), _a21.push(s);
      }), [Rs(pi(_r31, 0), e.shape), Rs(pi(_a21, 0), e.shape)];
    }
  }
});
var ho;
!function (e) {
  e[e.NONE = 0] = "NONE", e[e.MEAN = 1] = "MEAN", e[e.SUM = 2] = "SUM", e[e.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
}(ho || (ho = {}));
var po = Ft({
  computeWeightedLoss_: function computeWeightedLoss_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ho.SUM_BY_NONZERO_WEIGHTS;
    var s = Rt(e, "losses", "computeWeightedLoss");
    var r = null;
    null != t && (r = Rt(t, "weights", "computeWeightedLoss"));
    var a = null == r ? s : rs(s, r);
    if (n === ho.NONE) return a;
    if (n === ho.SUM) return Hr(a);

    if (n === ho.MEAN) {
      if (null == r) return ua(a);
      {
        var _e66 = s.size / r.size,
            _t70 = ss(Hr(a), Hr(r));

        return _e66 > 1 ? ss(_t70, Ka(_e66)) : _t70;
      }
    }

    if (n === ho.SUM_BY_NONZERO_WEIGHTS) {
      if (null == r) return ss(Hr(a), Ka(s.size));
      {
        var _e67 = rs(r, ha(s.shape)),
            _t71 = fn(Hr(xa(_e67, Ka(0))), "float32");

        return ss(Hr(a), _t71);
      }
    }

    throw Error("Unknown reduction: ".concat(n));
  }
});
Ft({
  absoluteDifference_: function absoluteDifference_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ho.SUM_BY_NONZERO_WEIGHTS;
    var r = Rt(e, "labels", "absoluteDifference"),
        a = Rt(t, "predictions", "absoluteDifference");
    var i = null;
    null != n && (i = Rt(n, "weights", "absoluteDifference")), u(r.shape, a.shape, "Error in absoluteDifference: ");
    var o = as(Gr(r, a));
    return po(o, i, s);
  }
}), Ft({
  cosineDistance_: function cosineDistance_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ho.SUM_BY_NONZERO_WEIGHTS;
    var a = Rt(e, "labels", "cosineDistance"),
        i = Rt(t, "predictions", "cosineDistance");
    var o = null;
    null != s && (o = Rt(s, "weights", "cosineDistance")), u(a.shape, i.shape, "Error in cosineDistance: ");
    var l = Ka(1),
        c = Gr(l, Hr(rs(a, i), n, !0));
    return po(c, o, r);
  }
}), Ft({
  hingeLoss_: function hingeLoss_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ho.SUM_BY_NONZERO_WEIGHTS;
    var r = Rt(e, "labels", "hingeLoss");
    var a = Rt(t, "predictions", "hingeLoss");
    var i = null;
    null != n && (i = Rt(n, "weights", "hingeLoss")), u(r.shape, a.shape, "Error in hingeLoss: ");
    var o = Ka(1);
    r = Gr(rs(Ka(2), r), o);
    var l = Va(Gr(o, rs(r, a)));
    return po(l, i, s);
  }
}), Ft({
  huberLoss_: function huberLoss_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ho.SUM_BY_NONZERO_WEIGHTS;
    var a = Rt(e, "labels", "huberLoss"),
        i = Rt(t, "predictions", "huberLoss");
    var o = null;
    null != n && (o = Rt(n, "weights", "huberLoss")), u(a.shape, i.shape, "Error in huberLoss: ");
    var l = Ka(s),
        c = as(Gr(i, a)),
        h = pa(c, l),
        d = Gr(c, h),
        p = ts(rs(Ka(.5), ma(h)), rs(l, d));
    return po(p, o, r);
  }
}), Ft({
  logLoss_: function logLoss_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-7;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ho.SUM_BY_NONZERO_WEIGHTS;
    var a = Rt(e, "labels", "logLoss"),
        i = Rt(t, "predictions", "logLoss");
    var o = null;
    null != n && (o = Rt(n, "weights", "logLoss")), u(a.shape, i.shape, "Error in logLoss: ");
    var l = Ka(1),
        c = Ka(s),
        h = Pr(rs(a, Lr(ts(i, c)))),
        d = rs(Gr(l, a), Lr(ts(Gr(l, i), c))),
        p = Gr(h, d);
    return po(p, o, r);
  }
}), Ft({
  meanSquaredError_: function meanSquaredError_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ho.SUM_BY_NONZERO_WEIGHTS;
    var r = Rt(e, "labels", "meanSquaredError"),
        a = Rt(t, "predictions", "meanSquaredError");
    var i = null;
    null != n && (i = Rt(n, "weights", "meanSquaredError")), u(r.shape, a.shape, "Error in meanSquaredError: ");
    var o = hi(r, a);
    return po(o, i, s);
  }
}), Ft({
  sigmoidCrossEntropy_: function sigmoidCrossEntropy_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ho.SUM_BY_NONZERO_WEIGHTS;
    var a = Rt(e, "multiClassLabels", "sigmoidCrossEntropy");
    var i = Rt(t, "logits", "sigmoidCrossEntropy");
    var o = null;

    if (null != n && (o = Rt(n, "weights", "sigmoidCrossEntropy")), u(a.shape, i.shape, "Error in sigmoidCrossEntropy: "), s > 0) {
      var _e68 = Ka(s),
          _t72 = Ka(1),
          _n36 = Ka(.5);

      a = ts(rs(a, Gr(_t72, _e68)), rs(_n36, _e68));
    }

    var l = function (e, t) {
      var n = Rt(e, "labels", "sigmoidCrossEntropyWithLogits"),
          s = Rt(t, "logits", "sigmoidCrossEntropyWithLogits");
      u(n.shape, s.shape, "Error in sigmoidCrossEntropyWithLogits: ");
      var r = Va(s),
          a = rs(s, n),
          i = zr(yr(Pr(as(s))));
      return ts(Gr(r, a), i);
    }(a, i);

    return po(l, o, r);
  }
}), Ft({
  softmaxCrossEntropy_: function softmaxCrossEntropy_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ho.SUM_BY_NONZERO_WEIGHTS;
    var a = Rt(e, "onehotLabels", "softmaxCrossEntropy");
    var i = Rt(t, "logits", "softmaxCrossEntropy");
    var o = null;

    if (null != n && (o = Rt(n, "weights", "softmaxCrossEntropy")), u(a.shape, i.shape, "Error in softmaxCrossEntropy: "), s > 0) {
      var _e69 = Ka(s),
          _t73 = Ka(1),
          _n37 = Ka(a.shape[1]);

      a = ts(rs(a, Gr(_t73, _e69)), ss(_e69, _n37));
    }

    var l = function (e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      if (-1 === n && (n = t.rank - 1), n !== t.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ".concat(t.rank, " and dim was ").concat(n));
      return Br((e, t, s) => {
        var r = ta(t, [n], !0),
            a = Gr(fn(t, "float32"), r);
        s([e, a]);
        var i = Pr(rs(a, e));
        return {
          value: Hr(i, [n]),
          gradFunc: (e, t) => {
            var [s, r] = t,
                a = Yr(e.shape, [n]);
            return [rs(Rs(e, a), Gr(fn(s, "float32"), yr(r))), rs(Rs(e, a), Gr(yr(r), fn(s, "float32")))];
          }
        };
      })(e, t);
    }(a, i);

    return po(l, o, r);
  }
}), Ft({
  sparseFillEmptyRows_: function sparseFillEmptyRows_(e, t, n, s) {
    var r = Rt(e, "indices", "sparseFillEmptyRows"),
        a = Rt(t, "values", "sparseFillEmptyRows"),
        i = Rt(n, "denseShape", "sparseFillEmptyRows"),
        o = Rt(s, "defaultValue", "sparseFillEmptyRows", a.dtype);
    if (2 !== r.rank) throw new Error("Indices should be Tensor2D but received shape\n        ".concat(r.shape));
    if (1 !== a.rank) throw new Error("Values should be Tensor1D but received shape ".concat(a.shape));
    if (1 !== i.rank) throw new Error("Dense shape should be Tensor1D but received shape ".concat(i.shape));
    if (0 !== o.rank) throw new Error("Default value should be a scalar but received shape ".concat(o.shape));
    var l = vt.runKernel("SparseFillEmptyRows", {
      indices: r,
      values: a,
      denseShape: i,
      defaultValue: o
    });
    return {
      outputIndices: l[0],
      outputValues: l[1],
      emptyRowIndicator: l[2],
      reverseIndexMap: l[3]
    };
  }
}), Ft({
  sparseReshape_: function sparseReshape_(e, t, n) {
    var s = Rt(e, "inputIndices", "sparseReshape"),
        r = Rt(t, "inputShape", "sparseReshape"),
        a = Rt(n, "newShape", "sparseReshape");
    if (2 !== s.rank) throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(s.shape));
    if (1 !== r.rank) throw new Error("Input shape should be Tensor1D but received shape ".concat(r.shape));
    if (1 !== a.rank) throw new Error("New shape should be Tensor1D but received shape ".concat(a.shape));
    var i = vt.runKernel("SparseReshape", {
      inputIndices: s,
      inputShape: r,
      newShape: a
    });
    return {
      outputIndices: i[0],
      outputShape: i[1]
    };
  }
}), Ft({
  sparseSegmentMean_: function sparseSegmentMean_(e, t, n) {
    var s = Rt(e, "data", "sparseSegmentMean"),
        r = Rt(t, "indices", "sparseSegmentMean"),
        a = Rt(n, "segmentIds", "sparseSegmentMean");
    if (s.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.rank) throw new Error("Indices should be Tensor1D but received shape\n          ".concat(r.shape));
    if (1 !== a.rank) throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(a.shape));
    return vt.runKernel("SparseSegmentMean", {
      data: s,
      indices: r,
      segmentIds: a
    });
  }
}), Ft({
  sparseSegmentSum_: function sparseSegmentSum_(e, t, n) {
    var s = Rt(e, "data", "sparseSegmentSum"),
        r = Rt(t, "indices", "sparseSegmentSum"),
        a = Rt(n, "segmentIds", "sparseSegmentSum");
    if (s.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.rank) throw new Error("Indices should be Tensor1D but received shape\n         ".concat(r.shape));
    if (1 !== a.rank) throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(a.shape));
    return vt.runKernel("SparseSegmentSum", {
      data: s,
      indices: r,
      segmentIds: a
    });
  }
}), Ft({
  stringNGrams_: function stringNGrams_(e, t, n, s, r, a, i, o) {
    var l = Rt(e, "data", "stringNGrams", "string");
    if ("string" !== l.dtype) throw new Error("Data must be of datatype string");
    if (1 !== l.shape.length) throw new Error("Data must be a vector, saw: ".concat(l.shape));
    var u = Rt(t, "dataSplits", "stringNGrams");
    if ("int32" !== u.dtype) throw new Error("Data splits must be of datatype int32");
    var c = vt.runKernel("StringNGrams", {
      data: l,
      dataSplits: u
    }, {
      separator: n,
      nGramWidths: s,
      leftPad: r,
      rightPad: a,
      padWidth: i,
      preserveShortSequences: o
    });
    return {
      nGrams: c[0],
      nGramsSplits: c[1]
    };
  }
}), Ft({
  stringSplit_: function stringSplit_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    var s = Rt(e, "input", "stringSplit", "string"),
        r = Rt(t, "delimiter", "stringSplit", "string");
    if (1 !== s.rank) throw new Error("Input should be Tensor1D but received shape ".concat(s.shape));
    if (0 !== r.rank) throw new Error("Delimiter should be a scalar but received shape ".concat(r.shape));
    var a = vt.runKernel("StringSplit", {
      input: s,
      delimiter: r
    }, {
      skipEmpty: n
    });
    return {
      indices: a[0],
      values: a[1],
      shape: a[2]
    };
  }
}), Ft({
  stringToHashBucketFast_: function stringToHashBucketFast_(e, t) {
    var n = Rt(e, "input", "stringToHashBucketFast", "string"),
        s = {
      numBuckets: t
    };
    if (t <= 0) throw new Error("Number of buckets must be at least 1");
    return vt.runKernel("StringToHashBucketFast", {
      input: n
    }, s);
  }
});
var fo = {
  flipLeftRight: Wi,
  grayscaleToRGB: Ui,
  resizeNearestNeighbor: ro,
  resizeBilinear: so,
  rotateWithOffset: Vi,
  cropAndResize: Pi,
  nonMaxSuppression: Hi,
  nonMaxSuppressionAsync: function () {
    var _nonMaxSuppressionAsync = _asyncToGenerator(function* (e, t, n) {
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
      var a = Rt(e, "boxes", "nonMaxSuppressionAsync"),
          i = Rt(t, "scores", "nonMaxSuppressionAsync"),
          o = Gi(a, i, n, s, r);
      n = o.maxOutputSize, s = o.iouThreshold, r = o.scoreThreshold;
      var l = yield Promise.all([a.data(), i.data()]),
          u = l[0],
          c = l[1],
          {
        selectedIndices: h
      } = Ki(u, c, n, s, r);
      return a !== e && a.dispose(), i !== t && i.dispose(), bi(h, "int32");
    });

    function nonMaxSuppressionAsync(_x10, _x11, _x12) {
      return _nonMaxSuppressionAsync.apply(this, arguments);
    }

    return nonMaxSuppressionAsync;
  }(),
  nonMaxSuppressionWithScore: to,
  nonMaxSuppressionWithScoreAsync: function () {
    var _nonMaxSuppressionWithScoreAsync = _asyncToGenerator(function* (e, t, n) {
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
      var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var i = Rt(e, "boxes", "nonMaxSuppressionAsync"),
          o = Rt(t, "scores", "nonMaxSuppressionAsync"),
          l = Gi(i, o, n, s, r, a);
      n = l.maxOutputSize, s = l.iouThreshold, r = l.scoreThreshold, a = l.softNmsSigma;
      var u = yield Promise.all([i.data(), o.data()]),
          c = u[0],
          h = u[1],
          {
        selectedIndices: d,
        selectedScores: p
      } = Yi(c, h, n, s, r, a);
      return i !== e && i.dispose(), o !== t && o.dispose(), {
        selectedIndices: bi(d, "int32"),
        selectedScores: bi(p)
      };
    });

    function nonMaxSuppressionWithScoreAsync(_x13, _x14, _x15) {
      return _nonMaxSuppressionWithScoreAsync.apply(this, arguments);
    }

    return nonMaxSuppressionWithScoreAsync;
  }(),
  nonMaxSuppressionPadded: no,
  nonMaxSuppressionPaddedAsync: function () {
    var _nonMaxSuppressionPaddedAsync = _asyncToGenerator(function* (e, t, n) {
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
      var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
      var i = Rt(e, "boxes", "nonMaxSuppressionAsync"),
          o = Rt(t, "scores", "nonMaxSuppressionAsync"),
          l = Gi(i, o, n, s, r, null),
          u = l.maxOutputSize,
          c = l.iouThreshold,
          h = l.scoreThreshold,
          [d, p] = yield Promise.all([i.data(), o.data()]),
          {
        selectedIndices: f,
        validOutputs: g
      } = Xi(d, p, u, c, h, a);
      return i !== e && i.dispose(), o !== t && o.dispose(), {
        selectedIndices: bi(f, "int32"),
        validOutputs: Ka(g, "int32")
      };
    });

    function nonMaxSuppressionPaddedAsync(_x16, _x17, _x18) {
      return _nonMaxSuppressionPaddedAsync.apply(this, arguments);
    }

    return nonMaxSuppressionPaddedAsync;
  }(),
  threshold: ao,
  transform: io
},
    go = {
  bandPart: oo,
  gramSchmidt: lo,
  qr: co
};

class mo extends qn {
  minimize(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var {
      value: s,
      grads: r
    } = this.computeGradients(e, n);

    if (null != n) {
      var _e70 = n.map(e => ({
        name: e.name,
        tensor: r[e.name]
      }));

      this.applyGradients(_e70);
    } else this.applyGradients(r);

    return Zn(r), t ? s : (s.dispose(), null);
  }

  get iterations() {
    return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
  }

  incrementIterations() {
    this.iterations_ = this.iterations + 1;
  }

  computeGradients(e, t) {
    return function (e, t) {
      l(E(e), () => "The f passed in variableGrads(f) must be a function"), l(null == t || Array.isArray(t) && t.every(e => e instanceof it), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
      var n = null != t;

      if (!n) {
        t = [];

        for (var _e71 in vt.registeredVariables) {
          t.push(vt.registeredVariables[_e71]);
        }
      }

      var s = n ? t.filter(e => !e.trainable) : null,
          r = t.length;
      l((t = t.filter(e => e.trainable)).length > 0, () => "variableGrads() expects at least one of the input variables to be trainable, but none of the ".concat(r, " variables is trainable."));
      var {
        value: a,
        grads: i
      } = vt.gradients(e, t, null, !0);
      l(i.some(e => null != e), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), l(0 === a.rank, () => "The f passed in variableGrads(f) must return a scalar, but it returned a rank-".concat(a.rank, " tensor"));
      var o = {};
      return t.forEach((e, t) => {
        null != i[t] && (o[e.name] = i[t]);
      }), null != s && s.forEach(e => o[e.name] = null), {
        value: a,
        grads: o
      };
    }(e, t);
  }

  dispose() {
    null != this.iterations_ && Zn(this.iterations_);
  }

  saveIterations() {
    var _this23 = this;

    return _asyncToGenerator(function* () {
      return null == _this23.iterations_ && (_this23.iterations_ = 0), {
        name: "iter",
        tensor: Ka(_this23.iterations_, "int32")
      };
    })();
  }

  getWeights() {
    return _asyncToGenerator(function* () {
      throw new Error("getWeights() is not implemented for this optimizer yet.");
    })();
  }

  setWeights(e) {
    var _this24 = this;

    return _asyncToGenerator(function* () {
      throw new Error("setWeights() is not implemented for this optimizer class ".concat(_this24.getClassName()));
    })();
  }

  extractIterations(e) {
    var _this25 = this;

    return _asyncToGenerator(function* () {
      return _this25.iterations_ = (yield e[0].tensor.data())[0], e.slice(1);
    })();
  }

}

Object.defineProperty(mo, Symbol.hasInstance, {
  value: e => null != e.minimize && null != e.computeGradients && null != e.applyGradients
});

class bo extends mo {
  constructor(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    super(), this.learningRate = e, this.rho = t, this.epsilon = n, this.accumulatedGrads = [], this.accumulatedUpdates = [], null == n && (this.epsilon = vt.backend.epsilon());
  }

  applyGradients(e) {
    (Array.isArray(e) ? e.map(e => e.name) : Object.keys(e)).forEach((t, n) => {
      var s = vt.registeredVariables[t];
      null == this.accumulatedGrads[n] && (this.accumulatedGrads[n] = {
        originalName: "".concat(t, "/accum_grad"),
        variable: Jn(() => fr(s).variable(!1))
      }), null == this.accumulatedUpdates[n] && (this.accumulatedUpdates[n] = {
        originalName: "".concat(t, "/accum_var"),
        variable: Jn(() => fr(s).variable(!1))
      });
      var r = Array.isArray(e) ? e[n].tensor : e[t];
      if (null == r) return;
      var a = this.accumulatedGrads[n].variable,
          i = this.accumulatedUpdates[n].variable;
      Jn(() => {
        var e = ts(rs(a, this.rho), rs(ma(r), 1 - this.rho)),
            t = rs(ss(ci(ts(i, this.epsilon)), ci(ts(a, this.epsilon))), r),
            n = ts(rs(i, this.rho), rs(ma(t), 1 - this.rho));
        a.assign(e), i.assign(n);
        var o = ts(rs(t, -this.learningRate), s);
        s.assign(o);
      });
    }), this.incrementIterations();
  }

  dispose() {
    null != this.accumulatedUpdates && (Zn(this.accumulatedGrads.map(e => e.variable)), Zn(this.accumulatedUpdates.map(e => e.variable)));
  }

  getWeights() {
    var _this26 = this;

    return _asyncToGenerator(function* () {
      var e = [..._this26.accumulatedGrads, ..._this26.accumulatedUpdates];
      return [yield _this26.saveIterations()].concat(e.map(e => ({
        name: e.originalName,
        tensor: e.variable
      })));
    })();
  }

  setWeights(e) {
    var _this27 = this;

    return _asyncToGenerator(function* () {
      var t = (e = yield _this27.extractIterations(e)).length / 2;
      _this27.accumulatedGrads = e.slice(0, t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      })), _this27.accumulatedUpdates = e.slice(t, 2 * t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      }));
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      rho: this.rho,
      epsilon: this.epsilon
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.rho, t.epsilon);
  }

}

bo.className = "Adadelta", Kn(bo);

class xo extends mo {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .1;
    super(), this.learningRate = e, this.initialAccumulatorValue = t, this.accumulatedGrads = [];
  }

  applyGradients(e) {
    (Array.isArray(e) ? e.map(e => e.name) : Object.keys(e)).forEach((t, n) => {
      var s = vt.registeredVariables[t];

      if (null == this.accumulatedGrads[n]) {
        var _e72 = !1;

        this.accumulatedGrads[n] = {
          originalName: "".concat(t, "/accumulator"),
          variable: Jn(() => $r(s.shape, this.initialAccumulatorValue).variable(_e72))
        };
      }

      var r = Array.isArray(e) ? e[n].tensor : e[t];
      if (null == r) return;
      var a = this.accumulatedGrads[n].variable;
      Jn(() => {
        var e = ts(a, ma(r));
        a.assign(e);
        var t = ts(rs(ss(r, ci(ts(e, vt.backend.epsilon()))), -this.learningRate), s);
        s.assign(t);
      });
    }), this.incrementIterations();
  }

  dispose() {
    null != this.accumulatedGrads && Zn(this.accumulatedGrads.map(e => e.variable));
  }

  getWeights() {
    var _this28 = this;

    return _asyncToGenerator(function* () {
      return [yield _this28.saveIterations()].concat(_this28.accumulatedGrads.map(e => ({
        name: e.originalName,
        tensor: e.variable
      })));
    })();
  }

  setWeights(e) {
    var _this29 = this;

    return _asyncToGenerator(function* () {
      e = yield _this29.extractIterations(e), _this29.accumulatedGrads = e.map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      }));
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      initialAccumulatorValue: this.initialAccumulatorValue
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.initialAccumulatorValue);
  }

}

xo.className = "Adagrad", Kn(xo);

class yo extends mo {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    super(), this.learningRate = e, this.beta1 = t, this.beta2 = n, this.epsilon = s, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], Jn(() => {
      this.accBeta1 = Ka(t).variable(), this.accBeta2 = Ka(n).variable();
    }), null == s && (this.epsilon = vt.backend.epsilon());
  }

  applyGradients(e) {
    var t = Array.isArray(e) ? e.map(e => e.name) : Object.keys(e);
    Jn(() => {
      var n = Gr(1, this.accBeta1),
          s = Gr(1, this.accBeta2);
      t.forEach((t, r) => {
        var a = vt.registeredVariables[t];
        null == this.accumulatedFirstMoment[r] && (this.accumulatedFirstMoment[r] = {
          originalName: "".concat(t, "/m"),
          variable: Jn(() => fr(a).variable(!1))
        }), null == this.accumulatedSecondMoment[r] && (this.accumulatedSecondMoment[r] = {
          originalName: "".concat(t, "/v"),
          variable: Jn(() => fr(a).variable(!1))
        });
        var i = Array.isArray(e) ? e[r].tensor : e[t];
        if (null == i) return;
        var o = this.accumulatedFirstMoment[r].variable,
            l = this.accumulatedSecondMoment[r].variable,
            u = ts(rs(o, this.beta1), rs(i, 1 - this.beta1)),
            c = ts(rs(l, this.beta2), rs(ma(i), 1 - this.beta2)),
            h = ss(u, n),
            d = ss(c, s);
        o.assign(u), l.assign(c);
        var p = ts(rs(ss(h, ts(ci(d), this.epsilon)), -this.learningRate), a);
        a.assign(p);
      }), this.accBeta1.assign(rs(this.accBeta1, this.beta1)), this.accBeta2.assign(rs(this.accBeta2, this.beta2));
    }), this.incrementIterations();
  }

  dispose() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Zn(this.accumulatedFirstMoment.map(e => e.variable)), null != this.accumulatedSecondMoment && Zn(this.accumulatedSecondMoment.map(e => e.variable));
  }

  getWeights() {
    var _this30 = this;

    return _asyncToGenerator(function* () {
      var e = [..._this30.accumulatedFirstMoment, ..._this30.accumulatedSecondMoment];
      return [yield _this30.saveIterations()].concat(e.map(e => ({
        name: e.originalName,
        tensor: e.variable
      })));
    })();
  }

  setWeights(e) {
    var _this31 = this;

    return _asyncToGenerator(function* () {
      e = yield _this31.extractIterations(e), Jn(() => {
        _this31.accBeta1.assign(Ia(_this31.beta1, _this31.iterations_ + 1)), _this31.accBeta2.assign(Ia(_this31.beta2, _this31.iterations_ + 1));
      });
      var t = e.length / 2;
      _this31.accumulatedFirstMoment = e.slice(0, t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      })), _this31.accumulatedSecondMoment = e.slice(t, 2 * t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      }));
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon);
  }

}

yo.className = "Adam", Kn(yo);

class ko extends mo {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    super(), this.learningRate = e, this.beta1 = t, this.beta2 = n, this.epsilon = s, this.decay = r, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], Jn(() => {
      this.iteration = Ka(0).variable(), this.accBeta1 = Ka(t).variable();
    }), null == s && (this.epsilon = vt.backend.epsilon());
  }

  applyGradients(e) {
    var t = Array.isArray(e) ? e.map(e => e.name) : Object.keys(e);
    Jn(() => {
      var n = Gr(1, this.accBeta1),
          s = ss(-this.learningRate, ts(rs(this.iteration, this.decay), 1));
      t.forEach((t, r) => {
        var a = vt.registeredVariables[t];
        null == this.accumulatedFirstMoment[r] && (this.accumulatedFirstMoment[r] = {
          originalName: "".concat(t, "/m"),
          variable: fr(a).variable(!1)
        }), null == this.accumulatedWeightedInfNorm[r] && (this.accumulatedWeightedInfNorm[r] = {
          originalName: "".concat(t, "/v"),
          variable: fr(a).variable(!1)
        });
        var i = Array.isArray(e) ? e[r].tensor : e[t];
        if (null == i) return;
        var o = this.accumulatedFirstMoment[r].variable,
            l = this.accumulatedWeightedInfNorm[r].variable,
            u = ts(rs(o, this.beta1), rs(i, 1 - this.beta1)),
            c = rs(l, this.beta2),
            h = as(i),
            d = la(c, h);
        o.assign(u), l.assign(d);
        var p = ts(rs(ss(s, n), ss(u, ts(d, this.epsilon))), a);
        a.assign(p);
      }), this.iteration.assign(ts(this.iteration, 1)), this.accBeta1.assign(rs(this.accBeta1, this.beta1));
    }), this.incrementIterations();
  }

  dispose() {
    this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Zn(this.accumulatedFirstMoment.map(e => e.variable)), null != this.accumulatedWeightedInfNorm && Zn(this.accumulatedWeightedInfNorm.map(e => e.variable));
  }

  getWeights() {
    return _asyncToGenerator(function* () {
      throw new Error("getWeights() is not implemented for Adamax yet.");
    })();
  }

  setWeights(e) {
    return _asyncToGenerator(function* () {
      throw new Error("setWeights() is not implemented for Adamax yet.");
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon,
      decay: this.decay
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay);
  }

}

ko.className = "Adamax", Kn(ko);

class wo extends mo {
  constructor(e) {
    super(), this.learningRate = e, this.setLearningRate(e);
  }

  applyGradients(e) {
    (Array.isArray(e) ? e.map(e => e.name) : Object.keys(e)).forEach((t, n) => {
      var s = Array.isArray(e) ? e[n].tensor : e[t];
      if (null == s) return;
      var r = vt.registeredVariables[t];
      Jn(() => {
        var e = ts(rs(this.c, s), r);
        r.assign(e);
      });
    }), this.incrementIterations();
  }

  setLearningRate(e) {
    this.learningRate = e, null != this.c && this.c.dispose(), this.c = Qn(Ka(-e));
  }

  dispose() {
    this.c.dispose();
  }

  getWeights() {
    var _this32 = this;

    return _asyncToGenerator(function* () {
      return [yield _this32.saveIterations()];
    })();
  }

  setWeights(e) {
    var _this33 = this;

    return _asyncToGenerator(function* () {
      if (0 !== (e = yield _this33.extractIterations(e)).length) throw new Error("SGD optimizer does not have settable weights.");
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate);
  }

}

wo.className = "SGD", Kn(wo);

class vo extends wo {
  constructor(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    super(e), this.learningRate = e, this.momentum = t, this.useNesterov = n, this.accumulations = [], this.m = Ka(this.momentum);
  }

  applyGradients(e) {
    (Array.isArray(e) ? e.map(e => e.name) : Object.keys(e)).forEach((t, n) => {
      var s = vt.registeredVariables[t];

      if (null == this.accumulations[n]) {
        var _e73 = !1;

        this.accumulations[n] = {
          originalName: "".concat(t, "/momentum"),
          variable: Jn(() => fr(s).variable(_e73))
        };
      }

      var r = this.accumulations[n].variable,
          a = Array.isArray(e) ? e[n].tensor : e[t];
      null != a && Jn(() => {
        var e;
        var t = ts(rs(this.m, r), a);
        e = ts(rs(this.c, this.useNesterov ? ts(a, rs(t, this.m)) : t), s), r.assign(t), s.assign(e);
      });
    }), this.incrementIterations();
  }

  dispose() {
    this.m.dispose(), null != this.accumulations && Zn(this.accumulations.map(e => e.variable));
  }

  setMomentum(e) {
    this.momentum = e;
  }

  getWeights() {
    var _this34 = this;

    return _asyncToGenerator(function* () {
      return [yield _this34.saveIterations()].concat(_this34.accumulations.map(e => ({
        name: e.originalName,
        tensor: e.variable
      })));
    })();
  }

  setWeights(e) {
    var _this35 = this;

    return _asyncToGenerator(function* () {
      e = yield _this35.extractIterations(e), _this35.accumulations = e.map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      }));
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      momentum: this.momentum,
      useNesterov: this.useNesterov
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.momentum, t.useNesterov);
  }

}

vo.className = "Momentum", Kn(vo);

class Io extends mo {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    if (super(), this.learningRate = e, this.decay = t, this.momentum = n, this.epsilon = s, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = r, null == s && (this.epsilon = vt.backend.epsilon()), null == e) throw new Error("learningRate for RMSPropOptimizer must be defined.");
  }

  applyGradients(e) {
    (Array.isArray(e) ? e.map(e => e.name) : Object.keys(e)).forEach((t, n) => {
      var s = vt.registeredVariables[t],
          r = !1;
      null == this.accumulatedMeanSquares[n] && (this.accumulatedMeanSquares[n] = {
        originalName: "".concat(t, "/rms"),
        variable: Jn(() => fr(s).variable(r))
      }), null == this.accumulatedMoments[n] && (this.accumulatedMoments[n] = {
        originalName: "".concat(t, "/momentum"),
        variable: Jn(() => fr(s).variable(r))
      }), null == this.accumulatedMeanGrads[n] && this.centered && (this.accumulatedMeanGrads[n] = {
        originalName: "".concat(t, "/mg"),
        variable: Jn(() => fr(s).variable(r))
      });
      var a = Array.isArray(e) ? e[n].tensor : e[t];
      if (null == a) return;
      var i = this.accumulatedMeanSquares[n].variable,
          o = this.accumulatedMoments[n].variable;
      Jn(() => {
        var e = ts(rs(i, this.decay), rs(ma(a), 1 - this.decay));

        if (this.centered) {
          var _t74 = this.accumulatedMeanGrads[n].variable,
              _r32 = ts(rs(_t74, this.decay), rs(a, 1 - this.decay)),
              _l8 = ss(rs(a, this.learningRate), ci(Gr(e, ts(ma(_r32), this.epsilon)))),
              _u5 = ts(rs(o, this.momentum), _l8);

          i.assign(e), _t74.assign(_r32), o.assign(_u5);

          var _c4 = Gr(s, _u5);

          s.assign(_c4);
        } else {
          var _e74 = ts(rs(i, this.decay), rs(ma(a), 1 - this.decay)),
              _t75 = ts(rs(o, this.momentum), ss(rs(a, this.learningRate), ci(ts(_e74, this.epsilon))));

          i.assign(_e74), o.assign(_t75);

          var _n38 = Gr(s, _t75);

          s.assign(_n38);
        }
      });
    }), this.incrementIterations();
  }

  dispose() {
    null != this.accumulatedMeanSquares && Zn(this.accumulatedMeanSquares.map(e => e.variable)), null != this.accumulatedMeanGrads && this.centered && Zn(this.accumulatedMeanGrads.map(e => e.variable)), null != this.accumulatedMoments && Zn(this.accumulatedMoments.map(e => e.variable));
  }

  getWeights() {
    var _this36 = this;

    return _asyncToGenerator(function* () {
      var e = [..._this36.accumulatedMeanSquares, ..._this36.accumulatedMoments];
      return _this36.centered && e.push(..._this36.accumulatedMeanGrads), [yield _this36.saveIterations()].concat(e.map(e => ({
        name: e.originalName,
        tensor: e.variable
      })));
    })();
  }

  setWeights(e) {
    var _this37 = this;

    return _asyncToGenerator(function* () {
      e = yield _this37.extractIterations(e);
      var t = _this37.centered ? e.length / 3 : e.length / 2,
          n = !1;
      _this37.accumulatedMeanSquares = e.slice(0, t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(n)
      })), _this37.accumulatedMoments = e.slice(t, 2 * t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(n)
      })), _this37.centered && (_this37.accumulatedMeanGrads = e.slice(2 * t, 3 * t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(n)
      })));
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      decay: this.decay,
      momentum: this.momentum,
      epsilon: this.epsilon,
      centered: this.centered
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered);
  }

}

Io.className = "RMSProp", Kn(Io);

class $o {
  static sgd(e) {
    return new wo(e);
  }

  static momentum(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    return new vo(e, t, n);
  }

  static rmsprop(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    return new Io(e, t, n, s, r);
  }

  static adam() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .001;
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .999;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    return new yo(e, t, n, s);
  }

  static adadelta() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .001;
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .95;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return new bo(e, t, n);
  }

  static adamax() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .002;
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .999;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    return new ko(e, t, n, s, r);
  }

  static adagrad(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .1;
    return new xo(e, t);
  }

}

var So = {
  sgd: $o.sgd,
  momentum: $o.momentum,
  adadelta: $o.adadelta,
  adagrad: $o.adagrad,
  rmsprop: $o.rmsprop,
  adamax: $o.adamax,
  adam: $o.adam
},
    No = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : e => e();

function Co() {
  return new Promise(e => No(() => e()));
}

function To(e, t) {
  var n = e[0].length;
  e.forEach((e, t) => {
    l(e.length === n, () => "Error in concat".concat(n, "D: rank of tensors[").concat(t, "] must be the same as the rank of the rest (").concat(n, ")"));
  }), l(t >= 0 && t < n, () => "Error in concat".concat(n, "D: axis must be between 0 and ").concat(n - 1, "."));
  var s = e[0];
  e.forEach((e, r) => {
    for (var _a22 = 0; _a22 < n; _a22++) {
      l(_a22 === t || e[_a22] === s[_a22], () => "Error in concat".concat(n, "D: Shape of tensors[").concat(r, "] (").concat(e, ") does not match the shape of the rest (").concat(s, ") along the non-concatenated axis ").concat(r, "."));
    }
  });
}

function Eo(e, t) {
  var n = e[0].slice();

  for (var _s42 = 1; _s42 < e.length; _s42++) {
    n[t] += e[_s42][t];
  }

  return n;
}

function Ro(e) {
  return e <= 30 ? e : R(e, Math.floor(Math.sqrt(e)));
}

function Ao(e, t, n) {
  return [n * ("number" == typeof e ? e : e[0]), t * ("number" == typeof e ? e : e[1])];
}

function Fo(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = [];
  if (s) r = r.concat(t.slice(0)), r.push(e[0] / n), r = r.concat(e.slice(1));else {
    r = r.concat(e[0]);
    var _n39 = t.length;

    for (var _s43 = 0; _s43 < _n39; ++_s43) {
      r = r.concat([e[_s43 + 1] / t[_s43], t[_s43]]);
    }

    r = r.concat(e.slice(_n39 + 1));
  }
  return r;
}

function Do(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
  var s = [];

  if (n) {
    s.push(t);

    for (var _n40 = t + 1; _n40 < e; ++_n40) {
      _n40 <= 2 * t ? (s.push(_n40), s.push(_n40 - (t + 1))) : s.push(_n40);
    }
  } else {
    var _n41 = [],
        _r33 = [];

    for (var _s44 = 1; _s44 < e; ++_s44) {
      _s44 >= 2 * t + 1 || _s44 % 2 == 1 ? _r33.push(_s44) : _n41.push(_s44);
    }

    s.push(..._n41), s.push(0), s.push(..._r33);
  }

  return s;
}

function _o(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = [];
  r.push(s ? e[0] / n : e[0] * n);

  for (var _n42 = 1; _n42 < e.length; ++_n42) {
    r.push(_n42 <= t.length ? s ? t[_n42 - 1] * e[_n42] : e[_n42] / t[_n42 - 1] : e[_n42]);
  }

  return r;
}

function Oo(e, t) {
  var n = [0];

  for (var _s45 = 0; _s45 < t; ++_s45) {
    n.push(e[_s45][0]);
  }

  return n;
}

function Mo(e, t, n) {
  var s = e.slice(0, 1);

  for (var _r34 = 0; _r34 < n; ++_r34) {
    s.push(e[_r34 + 1] - t[_r34][0] - t[_r34][1]);
  }

  return s;
}

function Lo(e, t) {
  if (e.length !== t.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:".concat(e.length, ", imag: ").concat(t.length, "."));
  var n = new Float32Array(2 * e.length);

  for (var _s46 = 0; _s46 < n.length; _s46 += 2) {
    n[_s46] = e[_s46 / 2], n[_s46 + 1] = t[_s46 / 2];
  }

  return n;
}

function zo(e) {
  var t = new Float32Array(e.length / 2),
      n = new Float32Array(e.length / 2);

  for (var _s47 = 0; _s47 < e.length; _s47 += 2) {
    t[_s47 / 2] = e[_s47], n[_s47 / 2] = e[_s47 + 1];
  }

  return {
    real: t,
    imag: n
  };
}

function Bo(e) {
  var t = Math.ceil(e.length / 4),
      n = new Float32Array(t),
      s = new Float32Array(t);

  for (var _t76 = 0; _t76 < e.length; _t76 += 4) {
    n[Math.floor(_t76 / 4)] = e[_t76], s[Math.floor(_t76 / 4)] = e[_t76 + 1];
  }

  return {
    real: n,
    imag: s
  };
}

function Po(e) {
  var t = Math.floor(e.length / 4),
      n = new Float32Array(t),
      s = new Float32Array(t);

  for (var _t77 = 2; _t77 < e.length; _t77 += 4) {
    n[Math.floor(_t77 / 4)] = e[_t77], s[Math.floor(_t77 / 4)] = e[_t77 + 1];
  }

  return {
    real: n,
    imag: s
  };
}

function Wo(e, t) {
  return {
    real: e[2 * t],
    imag: e[2 * t + 1]
  };
}

function Uo(e, t, n, s) {
  e[2 * s] = t, e[2 * s + 1] = n;
}

function Vo(e, t) {
  var n = new Float32Array(e / 2),
      s = new Float32Array(e / 2);

  for (var _r35 = 0; _r35 < Math.ceil(e / 2); _r35++) {
    var _a23 = (t ? 2 : -2) * Math.PI * (_r35 / e);

    n[_r35] = Math.cos(_a23), s[_r35] = Math.sin(_a23);
  }

  return {
    real: n,
    imag: s
  };
}

function Go(e, t, n) {
  var s = (n ? 2 : -2) * Math.PI * (e / t);
  return {
    real: Math.cos(s),
    imag: Math.sin(s)
  };
}

var Ho = /->/g;

function qo(e, t) {
  var n = ((e = e.replace(/\s/g, "")).length - e.replace(Ho, "").length) / "->".length;
  if (n < 1) throw new Error("Equations without an arrow are not supported.");
  if (n > 1) throw new Error('Equation must contain exactly one arrow ("->").');
  var [s, r] = e.split("->");
  l(-1 === s.indexOf("..."), () => 'The ellipsis notation ("...") is not supported yet.');
  var a = s.split(","),
      i = a.length;
  if (t !== i) throw new Error("Expected ".concat(i, " input tensors, received ").concat(t));
  if (i > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
  var o = [];

  var _loop9 = function _loop9(_e75) {
    var t = r[_e75];
    if (!a.some(e => -1 !== e.indexOf(t))) throw new Error("Output subscripts contain the label ".concat(t, " not present in the input subscripts."));
    -1 === o.indexOf(t) && o.push(t);
  };

  for (var _e75 = 0; _e75 < r.length; ++_e75) {
    _loop9(_e75);
  }

  for (var _e76 = 0; _e76 < s.length; ++_e76) {
    var _t78 = s[_e76];
    -1 === o.indexOf(_t78) && "," !== _t78 && o.push(_t78);
  }

  var u = new Array(a.length);

  for (var _e77 = 0; _e77 < i; ++_e77) {
    if (new Set(a[_e77].split("")).size !== a[_e77].length) throw new Error("Found duplicate axes in input component ".concat(a[_e77], ". Support for duplicate axes in input is not implemented yet."));
    u[_e77] = [];

    for (var _t79 = 0; _t79 < a[_e77].length; ++_t79) {
      u[_e77].push(o.indexOf(a[_e77][_t79]));
    }
  }

  var c = o.length,
      h = [];

  for (var _e78 = r.length; _e78 < c; ++_e78) {
    h.push(_e78);
  }

  return {
    allDims: o,
    summedDims: h,
    idDims: u
  };
}

function jo(e, t) {
  var n = new Array(e);
  n.fill(-1);

  for (var _e79 = 0; _e79 < t.length; ++_e79) {
    n[t[_e79]] = _e79;
  }

  var s = [];

  for (var _t80 = 0; _t80 < e; ++_t80) {
    -1 === n[_t80] && s.push(_t80);
  }

  return n = n.filter(e => -1 !== e), {
    permutationIndices: n,
    expandDims: s
  };
}

function Ko(e, t, n) {
  var s = new Array(e);

  var _loop10 = function _loop10(_e80) {
    var r = n[_e80].shape;

    var _loop11 = function _loop11(_n43) {
      void 0 === s[t[_e80][_n43]] ? s[t[_e80][_n43]] = r[_n43] : l(s[t[_e80][_n43]] === r[_n43], () => "Expected dimension ".concat(s[t[_e80][_n43]], " at axis ").concat(_n43, " of input shaped ").concat(JSON.stringify(r), ", but got dimension ").concat(r[_n43]));
    };

    for (var _n43 = 0; _n43 < t[_e80].length; ++_n43) {
      _loop11(_n43);
    }
  };

  for (var _e80 = 0; _e80 < n.length; ++_e80) {
    _loop10(_e80);
  }
}

function Xo(e, t) {
  var n = e,
      s = [];
  var r = 0;
  0 === e.length && n.push(-1), r = e.length + 1;

  for (var _e81 = 0; _e81 < r; ++_e81) {
    s.push([]);
  }

  var a = [];

  for (var _e82 = 0; _e82 < n.length; ++_e82) {
    var _r36 = Jo(t, n[_e82]);

    for (var _t81 of _r36) {
      -1 === a.indexOf(_t81) && (s[_e82].push(_t81), a.push(_t81));
    }
  }

  return {
    path: n,
    steps: s
  };
}

function Yo(e) {
  return e.every((e, t) => e === t);
}

function Jo(e, t) {
  var n = [];

  for (var _s48 = 0; _s48 < e.length; ++_s48) {
    0 !== e[_s48].length && -1 === e[_s48].indexOf(t) && -1 !== t || n.push(_s48);
  }

  return n;
}

function Zo(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var s = [];
  if ("number" == typeof t) l(e.shape[n] % t == 0, () => "Number of splits must evenly divide the axis."), s = new Array(t).fill(e.shape[n] / t);else {
    l(t.reduce((e, t) => (-1 === t && (e += 1), e), 0) <= 1, () => "There should be only one negative value in split array.");

    var _r37 = t.indexOf(-1);

    if (-1 !== _r37) {
      var _s49 = t.reduce((e, t) => t > 0 ? e + t : e);

      t[_r37] = e.shape[n] - _s49;
    }

    l(e.shape[n] === t.reduce((e, t) => e + t), () => "The sum of sizes must match the size of the axis dimension."), s = t;
  }
  return s;
}

function Qo(e, t) {
  var n,
      s = !1;

  for (e <= 30 ? (n = e, s = !0) : n = R(e, Math.floor(Math.sqrt(e))); !s;) {
    n > t || n === e ? s = !0 : n = R(e, n + 1);
  }

  return n;
}

function el(e, t, n) {
  var s = [],
      r = e.length;

  for (var _a24 = 0; _a24 < r; _a24++) {
    s.push(_a24 !== t ? e[_a24] : n);
  }

  return s;
}

function tl(e, t, n, s) {
  var r = t.shape.length,
      a = e.shape.length;
  if (0 !== s && (s < -r || s > r)) throw new Error("Expect batchDims in the range of [-".concat(r, ", ").concat(r, "], but got ").concat(s));
  if (s < 0 && (s += r), s > a) throw new Error("batchDims (".concat(s, ") must be less than rank(x) (\n    ").concat(a, ")."));
  if (n < s) throw new Error("batchDims (".concat(s, ") must be less than or equal to axis (").concat(n, ")."));

  for (var _n44 = 0; _n44 < s; ++_n44) {
    if (e.shape[_n44] !== t.shape[_n44]) throw new Error("x.shape[".concat(_n44, "]: ").concat(e.shape[_n44], " should be equal to indices.shape[").concat(_n44, "]: ").concat(t.shape[_n44], "."));
  }

  var i = e.shape[n],
      o = [];
  var l = 1,
      u = 1,
      c = 1;

  for (var _t82 = 0; _t82 < s; ++_t82) {
    o.push(e.shape[_t82]), l *= e.shape[_t82];
  }

  for (var _t83 = s; _t83 < n; _t83++) {
    o.push(e.shape[_t83]), u *= e.shape[_t83];
  }

  for (var _e83 = s; _e83 < r; _e83++) {
    o.push(t.shape[_e83]);
  }

  for (var _t84 = n + 1; _t84 < a; _t84++) {
    o.push(e.shape[_t84]), c *= e.shape[_t84];
  }

  return {
    batchSize: l,
    sliceSize: c,
    outerSize: u,
    dimSize: i,
    outputShape: o
  };
}

function nl(e) {
  try {
    return e.map(e => qe(e));
  } catch (e) {
    throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(e));
  }
}

function sl(e) {
  return e.map(e => He(e));
}

var rl = {
  __proto__: null,
  slice_util: Hn,
  segment_util: {
    __proto__: null,
    segOpComputeOptimalWindowSize: Qo,
    computeOutShape: el,
    collectGatherOpShapeInfo: tl
  },
  fromUint8ToStringArray: nl,
  fromStringArrayToUint8: sl,
  upcastType: pt,
  axesAreInnerMostDims: jr,
  combineLocations: Kr,
  computeOutAndReduceShapes: Xr,
  expandShapeToKeepDim: Yr,
  assertAxesAreInnerMostDims: Jr,
  getAxesPermutation: Zr,
  getUndoAxesPermutation: Qr,
  getInnerMostAxes: ea,
  getBroadcastDims: ur,
  getReductionAxes: cr,
  assertAndGetBroadcastShape: hr,
  assertParamsConsistent: To,
  computeOutShape: Eo,
  computeDilation2DInfo: bs,
  computePool2DInfo: xs,
  computePool3DInfo: ys,
  computeConv2DInfo: ks,
  computeConv3DInfo: ws,
  computeDefaultPad: vs,
  tupleValuesAreOne: Cs,
  eitherStridesOrDilationsAreOne: Ts,
  convertConv2DDataFormat: Es,
  getFusedDyActivation: Ri,
  getFusedBiasGradient: Ai,
  applyActivation: Fi,
  shouldFuse: Di,
  PARALLELIZE_THRESHOLD: 30,
  computeOptimalWindowSize: Ro,
  getImageCenter: Ao,
  getReshaped: Fo,
  getPermuted: Do,
  getReshapedPermuted: _o,
  getSliceBeginCoords: Oo,
  getSliceSize: Mo,
  prepareAndValidate: Nn,
  validateUpdateShape: Cn,
  validateInput: function validateInput(e, t, n) {
    if (t.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ".concat(t.rank, "."));
    if (e.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ".concat(e.rank, "."));
    if ("int32" !== t.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));
    if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));

    if (0 === n.length) {
      if (0 === t.size) throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));
      if (0 === e.size) throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape));
    }

    Cn(n, t, e);
  },
  calculateShapes: Tn,
  SELU_SCALEALPHA: 1.7580993408473768,
  SELU_SCALE: 1.0507009873554805,
  ERF_P: .3275911,
  ERF_A1: .254829592,
  ERF_A2: -.284496736,
  ERF_A3: 1.421413741,
  ERF_A4: -1.453152027,
  ERF_A5: 1.061405429,
  warn: W,
  log: function log() {
    G().getBool("IS_TEST") || G().getBool("PROD") || console.log(...arguments);
  },
  mergeRealAndImagArrays: Lo,
  splitRealAndImagArrays: zo,
  complexWithEvenIndex: Bo,
  complexWithOddIndex: Po,
  getComplexWithIndex: Wo,
  assignToTypedArray: Uo,
  exponents: Vo,
  exponent: Go,
  decodeEinsumEquation: qo,
  getEinsumPermutation: jo,
  checkEinsumDimSizes: Ko,
  getEinsumComputePath: Xo,
  isIdentityPermutation: Yo,
  prepareSplitSize: Zo
};
var al = {
  kernelName: "Abs",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(e, fi(fn(n, "float32"), -1))
    };
  }
},
    il = {
  kernelName: "Acos",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => {
        var t = ma(fn(n, "float32")),
            s = ci(Gr(Ka(1), t));
        return Pr(ss(e, s));
      }
    };
  }
},
    ol = {
  kernelName: "Acosh",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => {
        var t = ci(Gr(ma(fn(n, "float32")), 1));
        return ss(e, t);
      }
    };
  }
},
    ll = {
  kernelName: "Add",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = hr(n.shape, s.shape);
    return {
      a: () => {
        var t = e;
        var s = cr(n.shape, r);
        return s.length > 0 && (t = Hr(t, s)), Rs(t, n.shape);
      },
      b: () => {
        var t = e;
        var n = cr(s.shape, r);
        return n.length > 0 && (t = Hr(t, n)), Rs(t, s.shape);
      }
    };
  }
},
    ul = {
  kernelName: "ArgMax",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => fr(n)
    };
  }
},
    cl = {
  kernelName: "ArgMin",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => fr(n)
    };
  }
},
    hl = {
  kernelName: "Asin",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, ci(Gr(Ka(1), ma(fn(n, "float32")))))
    };
  }
},
    dl = {
  kernelName: "Asinh",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => {
        var t = ci(ts(Ka(1), ma(fn(n, "float32"))));
        return ss(e, t);
      }
    };
  }
},
    pl = {
  kernelName: "Atan2",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = hr(n.shape, s.shape);
    return {
      a: () => {
        var t = ts(ma(n), ma(s));
        var a = rs(e, ss(s, t));
        var i = cr(n.shape, r);
        return i.length > 0 && (a = Hr(a, i)), Rs(a, n.shape);
      },
      b: () => {
        var t = ts(ma(n), ma(s));
        var a = Pr(rs(e, ss(n, t)));
        var i = cr(s.shape, r);
        return i.length > 0 && (a = Hr(a, i)), Rs(a, s.shape);
      }
    };
  }
},
    fl = {
  kernelName: "Atan",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, ts(ma(fn(n, "float32")), 1))
    };
  }
},
    gl = {
  kernelName: "Atanh",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, Gr(Ka(1), ma(fn(n, "float32"))))
    };
  }
},
    ml = Ft({
  avgPool3dGrad_: function avgPool3dGrad_(e, t, n, s, r, a) {
    var i = Rt(e, "dy", "avgPool3dGrad"),
        o = Rt(t, "input", "avgPool3dGrad");
    var u = i,
        c = o,
        h = !1;
    4 === o.rank && (h = !0, u = Rs(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]]), c = Rs(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), l(5 === u.rank, () => "Error in avgPool3dGrad: dy must be rank 5 but got rank ".concat(u.rank, ".")), l(5 === c.rank, () => "Error in avgPool3dGrad: input must be rank 5 but got rank ".concat(c.rank, ".")), null != a && l(f(r), () => "Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ".concat(a, " but got pad ").concat(r, "."));
    var d = vt.runKernel("AvgPool3DGrad", {
      dy: u,
      input: c
    }, {
      filterSize: n,
      strides: s,
      pad: r,
      dimRoundingMode: a
    });
    return h ? Rs(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d;
  }
}),
    bl = {
  kernelName: "AvgPool3D",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      filterSize: r,
      strides: a,
      pad: i,
      dimRoundingMode: o
    } = n;
    return {
      x: () => ml(e, s, r, a, i, o)
    };
  }
},
    xl = Ft({
  avgPoolGrad_: function avgPoolGrad_(e, t, n, s, r) {
    var a = Rt(e, "dy", "avgPoolGrad"),
        i = Rt(t, "input", "avgPoolGrad");
    l(i.rank === a.rank, () => "Rank of input (".concat(i.rank, ") does not match rank of dy (").concat(a.rank, ")"));
    var o = i,
        u = a,
        c = !1;
    3 === i.rank && (c = !0, o = Rs(i, [1, i.shape[0], i.shape[1], i.shape[2]]), u = Rs(a, [1, a.shape[0], a.shape[1], a.shape[2]])), l(4 === u.rank, () => "Error in avgPoolGrad: dy must be rank 4 but got rank ".concat(u.rank, ".")), l(4 === o.rank, () => "Error in avgPoolGrad: input must be rank 4 but got rank ".concat(o.rank, "."));
    var h = vt.runKernel("AvgPoolGrad", {
      dy: u,
      input: o
    }, {
      filterSize: n,
      strides: s,
      pad: r
    });
    return c ? Rs(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
  }
}),
    yl = {
  kernelName: "AvgPool",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      filterSize: r,
      strides: a,
      pad: i
    } = n;
    return {
      x: () => xl(e, s, r, a, i)
    };
  }
},
    kl = {
  kernelName: "BatchMatMul",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      transposeA: a,
      transposeB: i
    } = n;
    return a || i ? !a && i ? {
      a: () => In(e, r, !1, !1),
      b: () => In(e, s, !0, !1)
    } : a && !i ? {
      a: () => In(r, e, !1, !0),
      b: () => In(s, e, !1, !1)
    } : {
      a: () => In(r, e, !0, !0),
      b: () => In(e, s, !0, !0)
    } : {
      a: () => In(e, r, !1, !0),
      b: () => In(s, e, !0, !1)
    };
  }
},
    wl = {
  kernelName: "BatchToSpaceND",
  gradFunc: (e, t, n) => {
    var {
      blockShape: s,
      crops: r
    } = n;
    return {
      x: () => wa(e, s, r)
    };
  }
},
    vl = {
  kernelName: "BroadcastTo",
  gradFunc: (e, t, n) => {
    var s = n.inputShape,
        r = n.shape,
        a = Array.from(r);

    for (var _e84 = s.length - 1; _e84 >= 0; _e84--) {
      if (s[_e84] === r[_e84]) a[_e84] = 1;else if (1 !== s[_e84]) throw new Error("broadcastTo(): [".concat(s, "] cannot be broadcast to [").concat(r, "]."));
    }

    var i = [];

    for (var _e85 = 0; _e85 < a.length; _e85++) {
      a[_e85] > 1 && i.push(_e85);
    }

    return {
      x: () => Hr(e, i, !0)
    };
  }
},
    Il = {
  kernelName: "Ceil",
  gradFunc: e => ({
    x: () => fr(e)
  })
},
    $l = {
  kernelName: "ClipByValue",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      clipValueMin: r,
      clipValueMax: a
    } = n;
    return {
      x: () => pr(na(Tr(s, r), Or(s, a)), e, fr(e))
    };
  }
},
    Sl = {
  kernelName: "ComplexAbs",
  inputsToSave: ["x"],
  gradFunc: al.gradFunc
},
    Nl = {
  kernelName: "Concat",
  saveAllInputs: !0,
  gradFunc: (e, t, n) => {
    var s = t.map(e => e.shape),
        {
      axis: r
    } = n,
        a = y(r, t[0].shape)[0],
        i = s.map(e => e[a]);
    return li(e, i, a).map(e => () => e);
  }
},
    Cl = {
  kernelName: "Conv2D",
  inputsToSave: ["x", "filter"],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      dilations: a,
      strides: i,
      pad: o,
      dataFormat: u
    } = n;
    return l(Cs(a), () => "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(a, "'")), {
      x: () => Zs(s.shape, e, r, i, o, u),
      filter: () => Ei(s, e, r.shape, i, o, u)
    };
  }
},
    Tl = {
  kernelName: "Conv2DBackpropInput",
  inputsToSave: ["dy", "filter"],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      strides: a,
      pad: i,
      dataFormat: o,
      dimRoundingMode: l
    } = n;
    return {
      dy: () => Ys(e, r, a, i, o, 1, l),
      filter: () => Ei(e, s, r.shape, a, i, o, l)
    };
  }
},
    El = Ft({
  conv3DBackpropFilter_: function conv3DBackpropFilter_(e, t, n, s, r) {
    var a = e;
    4 === e.rank && (a = Rs(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]));
    var i = t;
    return 4 === i.rank && (i = Rs(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])), l(5 === a.rank, () => "Error in conv3dDerFilter: input must be rank 5, but got shape ".concat(a.shape, ".")), l(5 === i.rank, () => "Error in conv3dDerFilter: dy must be rank 5, but got shape ".concat(i.shape, ".")), l(5 === n.length, () => "Error in conv3dDerFilter: filterShape must be length 5, but got ".concat(n, ".")), l(a.shape[4] === n[3], () => "Error in conv3dDerFilter: depth of input ".concat(a.shape[4], ") must match input depth in filter (").concat(n[3], ".")), l(i.shape[4] === n[4], () => "Error in conv3dDerFilter: depth of dy (".concat(i.shape[4], ") must match output depth for filter (").concat(n[4], ").")), vt.runKernel("Conv3DBackpropFilterV2", {
      x: a,
      dy: i
    }, {
      strides: s,
      pad: r,
      filterShape: n
    });
  }
}),
    Rl = {
  kernelName: "Conv3D",
  inputsToSave: ["x", "filter"],
  gradFunc: (e, t, n) => {
    var {
      dilations: s,
      strides: r,
      pad: a
    } = n;
    l(Cs(s), () => "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(s, "'"));
    var [i, o] = t;
    return {
      x: () => tr(i.shape, e, o, r, a),
      filter: () => El(i, e, o.shape, r, a)
    };
  }
},
    Al = {
  kernelName: "Cos",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(Pr(Za(fn(n, "float32"))), e)
    };
  }
},
    Fl = {
  kernelName: "Cosh",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(Qa(fn(n, "float32")), e)
    };
  }
},
    Dl = {
  kernelName: "Cumsum",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      axis: r,
      exclusive: a,
      reverse: i
    } = n;
    return {
      x: () => {
        var t = Zr([r], s.rank);
        var n = ar(e, r, a, !i);
        return null != t && (n = Sn(n, t)), n;
      }
    };
  }
},
    _l = {
  kernelName: "DepthwiseConv2dNative",
  inputsToSave: ["x", "filter"],
  gradFunc: (e, t, n) => {
    var {
      dilations: s,
      strides: r,
      pad: a,
      dimRoundingMode: i
    } = n,
        o = null == s ? [1, 1] : s;
    l(Cs(o), () => "Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '".concat(o, "'"));
    var [u, c] = t;
    return l(4 === u.rank, () => "Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ".concat(u.rank, ".")), l(4 === c.rank, () => "Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ".concat(c.rank, ".")), l(u.shape[3] === c.shape[2], () => "Error in gradient of depthwiseConv2d: number of input channels (".concat(u.shape[3], ") must match the inChannels dimension in filter ").concat(c.shape[2], ".")), l(Ts(r, o), () => "Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ".concat(r, " and dilations '").concat(o, "'.")), null != i && l(f(a), () => "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(a, ".")), {
      x: () => Mi(u.shape, e, c, r, a, o, i),
      filter: () => Oi(u, e, c.shape, r, a, o, i)
    };
  }
},
    Ol = {
  kernelName: "Dilation2D",
  inputsToSave: ["x", "filter"],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        a = {
      x: s,
      filter: r,
      dy: e
    },
        i = {
      x: s,
      filter: r,
      dy: e
    };
    return {
      x: () => vt.runKernel("Dilation2DBackpropInput", a, n),
      filter: () => vt.runKernel("Dilation2DBackpropFilter", i, n)
    };
  }
},
    Ml = {
  kernelName: "Elu",
  outputsToSave: [!0],
  gradFunc: (e, t) => {
    var [n] = t,
        s = {
      dy: e,
      y: n
    };
    return {
      x: () => vt.runKernel("EluGrad", s)
    };
  }
},
    Ll = {
  kernelName: "Erf",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t,
        s = rs(yr(Pr(ma(n))), 2 / Math.sqrt(Math.PI));
    return {
      x: () => rs(e, s)
    };
  }
},
    zl = {
  kernelName: "Exp",
  outputsToSave: [!0],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(e, n)
    };
  }
},
    Bl = {
  kernelName: "ExpandDims",
  inputsToSave: ["input"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      input: () => Rs(e, n.shape)
    };
  }
},
    Pl = {
  kernelName: "Expm1",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(e, yr(n))
    };
  }
},
    Wl = {
  kernelName: "Floor",
  gradFunc: e => ({
    x: () => fr(e)
  })
},
    Ul = {
  kernelName: "FloorDiv",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = hr(n.shape, s.shape);
    return {
      a: () => {
        var t = ss(e, fn(s, "float32")),
            a = cr(n.shape, r);
        return a.length > 0 ? Rs(Hr(t, a), n.shape) : t;
      },
      b: () => {
        var t = rs(e, fn(n, "float32"));
        var a = cr(s.shape, r);
        a.length > 0 && (t = Rs(Hr(t, a), s.shape));
        var i = ma(s);
        return Pr(ss(t, fn(i, "float32")));
      }
    };
  }
},
    Vl = {
  kernelName: "FusedBatchNorm",
  inputsToSave: ["x", "mean", "variance", "scale"],
  gradFunc: (e, t, n) => {
    var {
      varianceEpsilon: s
    } = n,
        [r, a, i, o] = t,
        l = null == o ? Ka(1) : o,
        u = cr(a.shape, r.shape),
        c = [];

    if (1 === a.rank) {
      for (var _e86 = 0; _e86 < r.shape.length - 1; ++_e86) {
        c.push(r.shape[_e86]);
      }

      c.push(1);
    }

    var h = Gr(r, a),
        d = rs(e, l),
        p = ja(ts(i, Ka(s))),
        f = rs(rs(rs(p, p), p), Ka(-.5));
    return {
      x: () => Rs(rs(rs(e, 1 === a.rank ? vr(Rs(p, [1, 1, 1, a.shape[0]]), c) : p), l), r.shape),
      mean: () => {
        var e = rs(rs(p, Ka(-1)), d);
        return 1 === a.rank && (e = Hr(e, u)), Rs(e, a.shape);
      },
      variance: () => {
        var e = rs(rs(f, h), d);
        return 1 === a.rank && (e = Hr(e, u)), Rs(e, a.shape);
      },
      scale: () => {
        var t = rs(h, p);
        var n = rs(e, t);
        return 1 === a.rank && (n = Hr(n, u)), Rs(n, a.shape);
      },
      offset: () => {
        var t = e;
        return 1 === a.rank && (t = Hr(t, u)), Rs(t, a.shape);
      }
    };
  }
},
    Gl = {
  kernelName: "GatherV2",
  inputsToSave: ["x", "indices"],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      axis: a
    } = n,
        i = y(a, s.shape)[0];
    return {
      x: () => {
        var t = s.shape,
            n = r.size,
            o = t.slice(0, i),
            l = o.length,
            u = t.slice(a, t.length).slice(1),
            c = u.length,
            h = Hl(0, l),
            d = Hl(l + 1, l + 1 + c),
            p = ql([o, [n], u]),
            f = Rs(e, p),
            g = Rs(r, [n]),
            m = ql([[l], h, d]),
            b = Sn(f, m);
        var x = vi(b, g, s.shape[i]);
        var y = Qr(m);
        return x = Sn(x, y), x;
      },
      indices: () => r
    };
  }
};

function Hl(e, t) {
  var n = [];

  for (var _s50 = e; _s50 < t; ++_s50) {
    n.push(_s50);
  }

  return n;
}

function ql(e) {
  var t = [];

  for (var _n45 = 0; _n45 < e.length; ++_n45) {
    for (var _s51 = 0; _s51 < e[_n45].length; ++_s51) {
      t.push(e[_n45][_s51]);
    }
  }

  return t;
}

var jl = {
  kernelName: "GreaterEqual",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t;
    return {
      a: () => fr(n),
      b: () => fr(s)
    };
  }
},
    Kl = {
  kernelName: "Identity",
  gradFunc: e => ({
    x: () => fn(e, "float32")
  })
},
    Xl = {
  kernelName: "IsFinite",
  gradFunc: e => ({
    x: () => fr(e)
  })
},
    Yl = {
  kernelName: "IsInf",
  gradFunc: e => ({
    x: () => fr(e)
  })
},
    Jl = {
  kernelName: "IsNan",
  gradFunc: e => ({
    x: () => fr(e)
  })
},
    Zl = {
  kernelName: "LeakyRelu",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      alpha: r
    } = n,
        a = Cr(s, 0);
    return {
      x: () => pr(a, e, rs(e, r))
    };
  }
},
    Ql = {
  kernelName: "Log1p",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, ts(n, 1))
    };
  }
},
    eu = {
  kernelName: "Log",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, fn(n, "float32"))
    };
  }
},
    tu = {
  kernelName: "LogSoftmax",
  inputsToSave: [],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      axis: r
    } = n;
    return {
      logits: () => {
        var t = yr(s);
        return Gr(e, rs(Hr(e, r, !0), t));
      }
    };
  }
},
    nu = Ft({
  localResponseNormalizationBackprop_: function localResponseNormalizationBackprop_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : .5;
    return vt.runKernel("LRNGrad", {
      x: e,
      y: t,
      dy: n
    }, {
      depthRadius: s,
      bias: r,
      alpha: a,
      beta: i
    });
  }
}),
    su = {
  kernelName: "LRN",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      depthRadius: a,
      bias: i,
      alpha: o,
      beta: l
    } = n;
    return {
      x: () => nu(s, r, e, a, i, o, l)
    };
  }
};

function ru(e, t, n, s) {
  return t.rank < n.rank && (t = Rs(t, Yr(t.shape, s))), e.rank < n.rank && (e = Rs(e, Yr(e.shape, s))), {
    x: () => rs(e, fn(dr(n, t), e.dtype))
  };
}

var au = {
  kernelName: "Max",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var s = n,
        {
      reductionIndices: r
    } = s,
        a = t[0],
        i = ru(e, t[1], a, y(r, a.shape));
    return {
      x: () => i.x()
    };
  }
},
    iu = {
  kernelName: "Maximum",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t;
    return {
      a: () => rs(e, fn(Tr(n, s), "float32")),
      b: () => rs(e, fn(_r(n, s), "float32"))
    };
  }
},
    ou = Ft({
  maxPool3dGrad_: function maxPool3dGrad_(e, t, n, s, r, a, i) {
    var o = Rt(e, "dy", "maxPool3dGrad"),
        u = Rt(t, "input", "maxPool3dGrad"),
        c = Rt(n, "output", "maxPool3dGrad");
    var h = o,
        d = u,
        p = c,
        g = !1;
    4 === u.rank && (g = !0, h = Rs(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]), d = Rs(u, [1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]]), p = Rs(c, [1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]])), l(5 === h.rank, () => "Error in maxPool3dGrad: dy must be rank 5 but got rank ".concat(h.rank, ".")), l(5 === d.rank, () => "Error in maxPool3dGrad: input must be rank 5 but got rank ".concat(d.rank, ".")), l(5 === p.rank, () => "Error in maxPool3dGrad: output must be rank 5 but got rank ".concat(p.rank, ".")), null != i && l(f(a), () => "Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(a, "."));
    var m = vt.runKernel("MaxPool3DGrad", {
      dy: h,
      input: d,
      output: p
    }, {
      filterSize: s,
      strides: r,
      pad: a,
      dimRoundingMode: i
    });
    return g ? Rs(m, [m.shape[1], m.shape[2], m.shape[3], m.shape[4]]) : m;
  }
}),
    lu = {
  kernelName: "MaxPool3D",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: l
    } = n;
    return {
      x: () => ou(e, s, r, a, i, o, l)
    };
  }
},
    uu = Ft({
  maxPoolGrad_: function maxPoolGrad_(e, t, n, s, r, a, i) {
    var o = Rt(e, "dy", "maxPoolGrad"),
        u = Rt(t, "input", "maxPoolGrad"),
        c = Rt(n, "output", "maxPoolGrad");
    return l(u.rank === o.rank, () => "Rank of input (".concat(u.rank, ") does not match rank of dy (").concat(o.rank, ")")), l(4 === o.rank, () => "Error in maxPoolGrad: dy must be rank 4 but got rank ".concat(o.rank, ".")), l(4 === u.rank, () => "Error in maxPoolGrad: input must be rank 4 but got rank ".concat(u.rank, ".")), null != i && l(f(a), () => "Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(a, ".")), vt.runKernel("MaxPoolGrad", {
      dy: o,
      input: u,
      output: c
    }, {
      filterSize: s,
      strides: r,
      pad: a,
      dimRoundingMode: i
    });
  }
}),
    cu = {
  kernelName: "PadV2",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var s = t[0],
        {
      paddings: r
    } = n,
        a = r.map(e => e[0]);
    return {
      x: () => Os(e, a, s.shape)
    };
  }
},
    hu = {
  kernelName: "SpaceToBatchND",
  gradFunc: (e, t, n) => {
    var {
      blockShape: s,
      paddings: r
    } = n;
    return {
      x: () => Ls(e, s, r)
    };
  }
},
    du = {
  kernelName: "SplitV",
  gradFunc: (e, t, n) => {
    var {
      axis: s
    } = n;
    return {
      x: () => Ds(e, s)
    };
  }
},
    pu = [al, il, ol, ll, {
  kernelName: "AddN",
  saveAllInputs: !0,
  gradFunc: (e, t) => {
    var n = {};
    return t.forEach((t, s) => {
      n[s] = () => e.clone();
    }), n;
  }
}, ul, cl, hl, dl, pl, fl, gl, bl, yl, kl, wl, vl, {
  kernelName: "Cast",
  gradFunc: e => ({
    x: () => e.clone()
  })
}, Il, $l, Sl, Nl, Tl, Cl, Rl, Al, Fl, Dl, _l, Ol, {
  kernelName: "RealDiv",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = hr(n.shape, s.shape);
    return {
      a: () => {
        var t = ss(e, fn(s, "float32")),
            a = cr(n.shape, r);
        return a.length > 0 ? Rs(Hr(t, a), n.shape) : t;
      },
      b: () => {
        var t = rs(e, fn(n, "float32"));
        var a = cr(s.shape, r);
        a.length > 0 && (t = Rs(Hr(t, a), s.shape));
        var i = ma(s);
        return Pr(ss(t, fn(i, "float32")));
      }
    };
  }
}, Ml, Ll, zl, Bl, Pl, Ul, Wl, Vl, Gl, jl, Kl, Xl, Yl, Jl, Zl, Ql, eu, tu, su, au, au, iu, lu, {
  kernelName: "MaxPool",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      filterSize: a,
      strides: i,
      pad: o
    } = n;
    return {
      x: () => uu(e, s, r, a, i, o)
    };
  }
}, {
  kernelName: "Mean",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      axis: r
    } = n,
        a = y(r, s.shape),
        i = d(Xr(s.shape, a)[1]);
    return {
      x: () => {
        var t = s.shape.slice();
        a.forEach(e => {
          t[e] = 1;
        });
        var n = Rs(e, t);
        return ss(rs(n, ha(s.shape, "float32")), i);
      }
    };
  }
}, {
  kernelName: "Min",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var s = n,
        {
      axis: r
    } = s,
        [a, i] = t,
        o = ru(e, i, a, y(r, a.shape));
    return {
      x: () => o.x()
    };
  }
}, {
  kernelName: "Minimum",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t;
    return {
      a: () => rs(e, fn(Or(n, s), "float32")),
      b: () => rs(e, fn(Cr(n, s), "float32"))
    };
  }
}, {
  kernelName: "MirrorPad",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var s = t[0],
        {
      paddings: r
    } = n,
        a = r.map(e => e[0]);
    return {
      x: () => Os(e, a, s.shape)
    };
  }
}, {
  kernelName: "Mod",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = hr(n.shape, s.shape);
    return {
      a: () => {
        var t = cr(n.shape, r);
        return t.length > 0 ? Rs(Hr(e, t), n.shape) : e;
      },
      b: () => {
        var t = rs(e, Pr(Sr(ss(n, s)))),
            a = cr(s.shape, r);
        return a.length > 0 ? Rs(Hr(t, a), s.shape) : t;
      }
    };
  }
}, {
  kernelName: "Multiply",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = hr(n.shape, s.shape);
    return {
      a: () => {
        var t = rs(e, fn(s, "float32")),
            a = cr(n.shape, r);
        return a.length > 0 ? Rs(Hr(t, a), n.shape) : t;
      },
      b: () => {
        var t = rs(e, fn(n, "float32")),
            a = cr(s.shape, r);
        return a.length > 0 ? Rs(Hr(t, a), s.shape) : t;
      }
    };
  }
}, {
  kernelName: "Neg",
  gradFunc: e => ({
    x: () => Pr(e)
  })
}, {
  kernelName: "OneHot",
  inputsToSave: ["indices"],
  gradFunc: (e, t) => {
    var n = t[0];
    return {
      indices: () => ca(n.shape, "float32")
    };
  }
}, {
  kernelName: "OnesLike",
  gradFunc: e => ({
    x: () => fr(e)
  })
}, {
  kernelName: "Pack",
  saveAllInputs: !0,
  gradFunc: (e, t, n) => {
    var {
      axis: s
    } = n;
    return Ii(e, s).map(e => () => e);
  }
}, cu, cu, {
  kernelName: "Pow",
  inputsToSave: ["a", "b"],
  outputsToSave: [!0],
  gradFunc: (e, t) => {
    var [n, s, r] = t,
        _a25 = n,
        i = s,
        o = hr(_a25.shape, i.shape);
    return {
      a: () => {
        var t = fn(i, "float32");
        var n = rs(e, rs(t, Ia(_a25, Gr(t, Ka(1)))));
        var s = cr(_a25.shape, o);
        return s.length > 0 && (n = Hr(n, s)), Rs(n, _a25.shape);
      },
      b: () => {
        var t = Cr(_a25, 0),
            n = pr(t, Lr(_a25), fr(_a25));
        var s = rs(e, rs(r, n));
        var l = cr(i.shape, o);
        return l.length > 0 && (s = Hr(s, l)), Rs(s, i.shape);
      }
    };
  }
}, {
  kernelName: "Prelu",
  inputsToSave: ["x", "alpha"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = Cr(n, 0);
    return {
      x: () => pr(r, e, rs(e, s)),
      alpha: () => {
        var t = pr(r, fr(e), rs(e, n));
        var a = cr(s.shape, e.shape);
        return a.length > 0 && (t = Hr(t, a)), Rs(t, s.shape);
      }
    };
  }
}, {
  kernelName: "Reciprocal",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, Pr(ma(n)))
    };
  }
}, {
  kernelName: "Relu6",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t,
        s = rs(Or(n, 6), fi(n));
    return {
      x: () => rs(e, fn(s, "float32"))
    };
  }
}, {
  kernelName: "Relu",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(e, fn(fi(n), "float32"))
    };
  }
}, {
  kernelName: "Reshape",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => Rs(e, n.shape)
    };
  }
}, {
  kernelName: "ResizeBilinear",
  inputsToSave: ["images"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        r = {
      dy: e,
      images: s
    };
    return {
      images: () => vt.runKernel("ResizeBilinearGrad", r, n)
    };
  }
}, {
  kernelName: "ResizeNearestNeighbor",
  inputsToSave: ["images"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        r = {
      dy: e,
      images: s
    };
    return {
      images: () => vt.runKernel("ResizeNearestNeighborGrad", r, n)
    };
  }
}, {
  kernelName: "Reverse",
  gradFunc: (e, t, n) => {
    var {
      dims: s
    } = n,
        r = y(s, e.shape);
    return {
      x: () => Ha(e, r)
    };
  }
}, {
  kernelName: "Round",
  gradFunc: e => ({
    x: () => fr(e)
  })
}, {
  kernelName: "Rsqrt",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => Pr(ss(e, rs(Ia(n, 1.5), 2)))
    };
  }
}, {
  kernelName: "Select",
  inputsToSave: ["condition"],
  gradFunc: (_e87, t) => {
    var [n] = t;
    return {
      condition: () => fn(fr(n), "float32"),
      t: () => rs(_e87, fn(n, _e87.dtype)),
      e: () => rs(_e87, fn(sa(n), _e87.dtype))
    };
  }
}, {
  kernelName: "Selu",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => {
        var t = Cr(n, Ka(0)),
            s = Ka(1.7580993408473768),
            r = Ka(1.0507009873554805),
            a = rs(e, r),
            i = rs(rs(e, s), yr(fn(n, "float32")));
        return pr(t, a, i);
      }
    };
  }
}, {
  kernelName: "Sigmoid",
  outputsToSave: [!0],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(e, rs(n, Gr(Ka(1), n)))
    };
  }
}, {
  kernelName: "Sign",
  gradFunc: e => ({
    x: () => fr(e)
  })
}, {
  kernelName: "Sin",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(sr(fn(n, "float32")), e)
    };
  }
}, {
  kernelName: "Sinh",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(rr(fn(n, "float32")), e)
    };
  }
}, {
  kernelName: "Slice",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      begin: r,
      size: a
    } = n,
        i = s.shape,
        [o, l] = Vn(s, r, a),
        u = [];

    for (var _t85 = 0; _t85 < e.rank; _t85++) {
      u.push([o[_t85], i[_t85] - o[_t85] - l[_t85]]);
    }

    return {
      x: () => ka(e, u)
    };
  }
}, {
  kernelName: "Softmax",
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      dim: r
    } = n,
        a = rs(e, s);
    return {
      logits: () => Gr(a, rs(Hr(a, [r], !0), s))
    };
  }
}, {
  kernelName: "Softplus",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(e, _s(n))
    };
  }
}, hu, hu, du, du, {
  kernelName: "Sqrt",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, rs(ci(fn(n, "float32")), 2))
    };
  }
}, {
  kernelName: "SquaredDifference",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = Ka(2);
    return {
      a: () => rs(e, rs(r, Gr(n, s))),
      b: () => rs(e, rs(r, Gr(s, n)))
    };
  }
}, {
  kernelName: "Square",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(e, rs(fn(n, "float32"), 2))
    };
  }
}, {
  kernelName: "Step",
  gradFunc: e => ({
    x: () => fr(e)
  })
}, {
  kernelName: "Sub",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = hr(n.shape, s.shape);
    return {
      a: () => {
        var t = e;
        var s = cr(n.shape, r);
        return s.length > 0 && (t = Hr(t, s)), Rs(t, n.shape);
      },
      b: () => {
        var t = e;
        var n = cr(s.shape, r);
        return n.length > 0 && (t = Hr(t, n)), Rs(Pr(t), s.shape);
      }
    };
  }
}, {
  kernelName: "Sum",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        r = s.shape.slice(),
        {
      axis: a
    } = n;
    y(a, s.shape).forEach(e => {
      r[e] = 1;
    });
    var i = Rs(e, r),
        o = rs(i, ha(s.shape, "float32"));
    return {
      x: () => o
    };
  }
}, {
  kernelName: "Tan",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, ma(sr(n)))
    };
  }
}, {
  kernelName: "Tanh",
  outputsToSave: [!0],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => rs(Gr(Ka(1), ma(n)), e)
    };
  }
}, {
  kernelName: "Tile",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      reps: r
    } = n;
    return {
      x: () => {
        var t = fr(s);
        if (1 === s.rank) for (var _n46 = 0; _n46 < r[0]; ++_n46) {
          t = ts(t, Os(e, [_n46 * s.shape[0]], [s.shape[0]]));
        } else if (2 === s.rank) for (var _n47 = 0; _n47 < r[0]; ++_n47) {
          for (var _a26 = 0; _a26 < r[1]; ++_a26) {
            t = ts(t, Os(e, [_n47 * s.shape[0], _a26 * s.shape[1]], [s.shape[0], s.shape[1]]));
          }
        } else if (3 === s.rank) for (var _n48 = 0; _n48 < r[0]; ++_n48) {
          for (var _a27 = 0; _a27 < r[1]; ++_a27) {
            for (var _i16 = 0; _i16 < r[2]; ++_i16) {
              t = ts(t, Os(e, [_n48 * s.shape[0], _a27 * s.shape[1], _i16 * s.shape[2]], [s.shape[0], s.shape[1], s.shape[2]]));
            }
          }
        } else {
          if (4 !== s.rank) throw new Error("Gradient for tile operation is not implemented for rank-".concat(s.rank, " tensors yet."));

          for (var _n49 = 0; _n49 < r[0]; ++_n49) {
            for (var _a28 = 0; _a28 < r[1]; ++_a28) {
              for (var _i17 = 0; _i17 < r[2]; ++_i17) {
                for (var _o14 = 0; _o14 < r[3]; ++_o14) {
                  t = ts(t, Os(e, [_n49 * s.shape[0], _a28 * s.shape[1], _i17 * s.shape[2], _o14 * s.shape[3]], [s.shape[0], s.shape[1], s.shape[2], s.shape[3]]));
                }
              }
            }
          }
        }
        return t;
      }
    };
  }
}, {
  kernelName: "Transpose",
  gradFunc: (e, t, n) => {
    var s = n,
        {
      perm: r
    } = s,
        a = Qr(r);
    return {
      x: () => Sn(e, a)
    };
  }
}, {
  kernelName: "Unpack",
  gradFunc: (e, t, n) => {
    var s = n,
        {
      axis: r
    } = s;
    return {
      value: () => pi(e, r)
    };
  }
}, {
  kernelName: "UnsortedSegmentSum",
  inputsToSave: ["segmentIds"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => function (e, t) {
        var n = la(t, fr(t)),
            s = Nr(e, n);
        var r = Tr(t, Ka(0, "int32"));
        var a = s.rank - r.rank;

        for (var _e88 = 0; _e88 < a; ++_e88) {
          r = kr(r, _e88 + 1);
        }

        r = na(r, ha(s.shape, "bool"));
        var i = fr(s);
        return pr(r, s, i);
      }(e, n)
    };
  }
}, {
  kernelName: "ZerosLike",
  gradFunc: e => ({
    x: () => fr(e)
  })
}];

for (var _e89 of pu) {
  te(_e89);
}

var fu;

function gu() {
  return null == fu && (fu = vt.backend.epsilon()), fu;
}

at().prototype.abs = function () {
  return this.throwIfDisposed(), as(this);
}, at().prototype.acos = function () {
  return this.throwIfDisposed(), is(this);
}, at().prototype.acosh = function () {
  return this.throwIfDisposed(), os(this);
}, at().prototype.add = function (e) {
  return this.throwIfDisposed(), ts(this, e);
}, at().prototype.all = function (e, t) {
  return this.throwIfDisposed(), ls(this, e, t);
}, at().prototype.any = function (e, t) {
  return this.throwIfDisposed(), us(this, e, t);
}, at().prototype.argMax = function (e) {
  return this.throwIfDisposed(), cs(this, e);
}, at().prototype.argMin = function (e) {
  return this.throwIfDisposed(), hs(this, e);
}, at().prototype.asScalar = function () {
  return this.throwIfDisposed(), l(1 === this.size, () => "The array must have only 1 element."), Rs(this, []);
}, at().prototype.asType = function (e) {
  return this.throwIfDisposed(), fn(this, e);
}, at().prototype.as1D = function () {
  return this.throwIfDisposed(), Rs(this, [this.size]);
}, at().prototype.as2D = function (e, t) {
  return this.throwIfDisposed(), Rs(this, [e, t]);
}, at().prototype.as3D = function (e, t, n) {
  return this.throwIfDisposed(), Rs(this, [e, t, n]);
}, at().prototype.as4D = function (e, t, n, s) {
  return this.throwIfDisposed(), Rs(this, [e, t, n, s]);
}, at().prototype.as5D = function (e, t, n, s, r) {
  return this.throwIfDisposed(), Rs(this, [e, t, n, s, r]);
}, at().prototype.asin = function () {
  return this.throwIfDisposed(), ds(this);
}, at().prototype.asinh = function () {
  return this.throwIfDisposed(), ps(this);
}, at().prototype.atan = function () {
  return this.throwIfDisposed(), fs(this);
}, at().prototype.atan2 = function (e) {
  return this.throwIfDisposed(), gs(this, e);
}, at().prototype.atanh = function () {
  return this.throwIfDisposed(), ms(this);
}, at().prototype.avgPool = function (e, t, n, s) {
  return this.throwIfDisposed(), As(this, e, t, n, s);
}, at().prototype.batchToSpaceND = function (e, t) {
  return this.throwIfDisposed(), Ls(this, e, t);
}, at().prototype.batchNorm = function (e, t, n, s, r) {
  return this.throwIfDisposed(), zs(this, e, t, n, s, r);
}, at().prototype.broadcastTo = function (e) {
  return this.throwIfDisposed(), Vs(this, e);
}, at().prototype.cast = function (e) {
  return this.throwIfDisposed(), fn(this, e);
}, at().prototype.ceil = function () {
  return this.throwIfDisposed(), Gs(this);
}, at().prototype.clipByValue = function (e, t) {
  return this.throwIfDisposed(), Hs(this, e, t);
}, at().prototype.concat = function (e, t) {
  return this.throwIfDisposed(), e instanceof rt && (e = [e]), Ds([this, ...e], t);
}, at().prototype.conv1d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), Js(this, e, t, n, s, r, a);
}, at().prototype.conv2dTranspose = function (e, t, n, s, r) {
  return this.throwIfDisposed(), Qs(this, e, t, n, s, r);
}, at().prototype.conv2d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), Ys(this, e, t, n, s, r, a);
}, at().prototype.cos = function () {
  return this.throwIfDisposed(), sr(this);
}, at().prototype.cosh = function () {
  return this.throwIfDisposed(), rr(this);
}, at().prototype.cumsum = function (e, t, n) {
  return this.throwIfDisposed(), ar(this, e, t, n);
}, at().prototype.depthToSpace = function (e, t) {
  return this.throwIfDisposed(), ir(this, e, t);
}, at().prototype.depthwiseConv2d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), or(this, e, t, n, s, r, a);
}, at().prototype.dilation2d = function (e, t, n, s, r) {
  return this.throwIfDisposed(), lr(this, e, t, n, s, r);
}, at().prototype.divNoNan = function (e) {
  return this.throwIfDisposed(), gr(this, e);
}, at().prototype.div = function (e) {
  return this.throwIfDisposed(), ss(this, e);
}, at().prototype.dot = function (e) {
  return this.throwIfDisposed(), mr(this, e);
}, at().prototype.elu = function () {
  return this.throwIfDisposed(), br(this);
}, at().prototype.equal = function (e) {
  return this.throwIfDisposed(), dr(this, e);
}, at().prototype.erf = function () {
  return this.throwIfDisposed(), xr(this);
}, at().prototype.exp = function () {
  return this.throwIfDisposed(), yr(this);
}, at().prototype.expandDims = function (e) {
  return this.throwIfDisposed(), kr(this, e);
}, at().prototype.expm1 = function () {
  return this.throwIfDisposed(), wr(this);
}, at().prototype.fft = function () {
  return this.throwIfDisposed(), ai(this);
}, at().prototype.flatten = function () {
  return this.throwIfDisposed(), Rs(this, [this.size]);
}, at().prototype.floor = function () {
  return this.throwIfDisposed(), Sr(this);
}, at().prototype.floorDiv = function (e) {
  return this.throwIfDisposed(), ns(this, e);
}, at().prototype.gather = function (e, t) {
  return this.throwIfDisposed(), Nr(this, e, t);
}, at().prototype.greaterEqual = function (e) {
  return this.throwIfDisposed(), Tr(this, e);
}, at().prototype.greater = function (e) {
  return this.throwIfDisposed(), Cr(this, e);
}, at().prototype.ifft = function () {
  return this.throwIfDisposed(), ii(this);
}, at().prototype.irfft = function () {
  return this.throwIfDisposed(), oi(this);
}, at().prototype.isFinite = function () {
  return this.throwIfDisposed(), Rr(this);
}, at().prototype.isInf = function () {
  return this.throwIfDisposed(), Ar(this);
}, at().prototype.isNaN = function () {
  return this.throwIfDisposed(), Fr(this);
}, at().prototype.leakyRelu = function (e) {
  return this.throwIfDisposed(), Dr(this, e);
}, at().prototype.lessEqual = function (e) {
  return this.throwIfDisposed(), Or(this, e);
}, at().prototype.less = function (e) {
  return this.throwIfDisposed(), _r(this, e);
}, at().prototype.localResponseNormalization = function (e, t, n, s) {
  return this.throwIfDisposed(), Mr(this, e, t, n, s);
}, at().prototype.logSigmoid = function () {
  return this.throwIfDisposed(), Ur(this);
}, at().prototype.logSoftmax = function (e) {
  return this.throwIfDisposed(), qr(this, e);
}, at().prototype.logSumExp = function (e, t) {
  return this.throwIfDisposed(), ta(this, e, t);
}, at().prototype.log = function () {
  return this.throwIfDisposed(), Lr(this);
}, at().prototype.log1p = function () {
  return this.throwIfDisposed(), zr(this);
}, at().prototype.logicalAnd = function (e) {
  return this.throwIfDisposed(), na(this, e);
}, at().prototype.logicalNot = function () {
  return this.throwIfDisposed(), sa(this);
}, at().prototype.logicalOr = function (e) {
  return this.throwIfDisposed(), ra(this, e);
}, at().prototype.logicalXor = function (e) {
  return this.throwIfDisposed(), aa(this, e);
}, at().prototype.matMul = function (e, t, n) {
  return this.throwIfDisposed(), In(this, e, t, n);
}, at().prototype.maxPool = function (e, t, n, s) {
  return this.throwIfDisposed(), ia(this, e, t, n, s);
}, at().prototype.max = function (e, t) {
  return this.throwIfDisposed(), Vr(this, e, t);
}, at().prototype.maximum = function (e) {
  return this.throwIfDisposed(), la(this, e);
}, at().prototype.mean = function (e, t) {
  return this.throwIfDisposed(), ua(this, e, t);
}, at().prototype.min = function (e, t) {
  return this.throwIfDisposed(), da(this, e, t);
}, at().prototype.minimum = function (e) {
  return this.throwIfDisposed(), pa(this, e);
}, at().prototype.mirrorPad = function (e, t) {
  return this.throwIfDisposed(), fa(this, e, t);
}, at().prototype.mod = function (e) {
  return this.throwIfDisposed(), ga(this, e);
}, at().prototype.mul = function (e) {
  return this.throwIfDisposed(), rs(this, e);
}, at().prototype.neg = function () {
  return this.throwIfDisposed(), Pr(this);
}, at().prototype.norm = function (e, t, n) {
  return this.throwIfDisposed(), Ni(this, e, t, n);
}, at().prototype.notEqual = function (e) {
  return this.throwIfDisposed(), xa(this, e);
}, at().prototype.oneHot = function (e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return this.throwIfDisposed(), $n(this, e, t, n);
}, at().prototype.onesLike = function () {
  return this.throwIfDisposed(), ya(this);
}, at().prototype.pad = function (e, t) {
  return this.throwIfDisposed(), ka(this, e, t);
}, at().prototype.pool = function (e, t, n, s, r) {
  return this.throwIfDisposed(), va(this, e, t, n, s, r);
}, at().prototype.pow = function (e) {
  return this.throwIfDisposed(), Ia(this, e);
}, at().prototype.prelu = function (e) {
  return this.throwIfDisposed(), $a(this, e);
}, at().prototype.prod = function (e, t) {
  return this.throwIfDisposed(), Sa(this, e, t);
}, at().prototype.reciprocal = function () {
  return this.throwIfDisposed(), Ua(this);
}, at().prototype.relu = function () {
  return this.throwIfDisposed(), Va(this);
}, at().prototype.relu6 = function () {
  return this.throwIfDisposed(), Ga(this);
}, at().prototype.reshapeAs = function (e) {
  return this.throwIfDisposed(), Rs(this, e.shape);
}, at().prototype.reshape = function (e) {
  return this.throwIfDisposed(), Rs(this, e);
}, at().prototype.resizeBilinear = function (e, t, n) {
  return this.throwIfDisposed(), so(this, e, t, n);
}, at().prototype.resizeNearestNeighbor = function (e, t, n) {
  return this.throwIfDisposed(), ro(this, e, t, n);
}, at().prototype.reverse = function (e) {
  return this.throwIfDisposed(), Ha(this, e);
}, at().prototype.rfft = function () {
  return this.throwIfDisposed(), ui(this);
}, at().prototype.round = function () {
  return this.throwIfDisposed(), qa(this);
}, at().prototype.rsqrt = function () {
  return this.throwIfDisposed(), ja(this);
}, at().prototype.selu = function () {
  return this.throwIfDisposed(), Xa(this);
}, at().prototype.separableConv2d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), Ya(this, e, t, n, s, r, a);
}, at().prototype.sigmoid = function () {
  return this.throwIfDisposed(), _s(this);
}, at().prototype.sign = function () {
  return this.throwIfDisposed(), Ja(this);
}, at().prototype.sin = function () {
  return this.throwIfDisposed(), Za(this);
}, at().prototype.sinh = function () {
  return this.throwIfDisposed(), Qa(this);
}, at().prototype.slice = function (e, t) {
  return this.throwIfDisposed(), Os(this, e, t);
}, at().prototype.softmax = function (e) {
  return this.throwIfDisposed(), ri(this, e);
}, at().prototype.softplus = function () {
  return this.throwIfDisposed(), Wr(this);
}, at().prototype.spaceToBatchND = function (e, t) {
  return this.throwIfDisposed(), wa(this, e, t);
}, at().prototype.split = function (e, t) {
  return this.throwIfDisposed(), li(this, e, t);
}, at().prototype.sqrt = function () {
  return this.throwIfDisposed(), ci(this);
}, at().prototype.square = function () {
  return this.throwIfDisposed(), ma(this);
}, at().prototype.squaredDifference = function (e) {
  return this.throwIfDisposed(), hi(this, e);
}, at().prototype.squeeze = function (e) {
  return this.throwIfDisposed(), di(this, e);
}, at().prototype.stack = function (e, t) {
  this.throwIfDisposed();
  var n = e instanceof rt ? [this, e] : [this, ...e];
  return pi(n, t);
}, at().prototype.step = function (e) {
  return this.throwIfDisposed(), fi(this, e);
}, at().prototype.stridedSlice = function (e, t, n, s, r, a, i, o) {
  return this.throwIfDisposed(), gi(this, e, t, n, s, r, a, i, o);
}, at().prototype.sub = function (e) {
  return this.throwIfDisposed(), Gr(this, e);
}, at().prototype.sum = function (e, t) {
  return this.throwIfDisposed(), Hr(this, e, t);
}, at().prototype.tan = function () {
  return this.throwIfDisposed(), mi(this);
}, at().prototype.tanh = function () {
  return this.throwIfDisposed(), Ms(this);
}, at().prototype.tile = function (e) {
  return this.throwIfDisposed(), vr(this, e);
}, at().prototype.toBool = function () {
  return this.throwIfDisposed(), fn(this, "bool");
}, at().prototype.toFloat = function () {
  return this.throwIfDisposed(), fn(this, "float32");
}, at().prototype.toInt = function () {
  return this.throwIfDisposed(), fn(this, "int32");
}, at().prototype.topk = function (e, t) {
  return this.throwIfDisposed(), yi(this, e, t);
}, at().prototype.transpose = function (e) {
  return this.throwIfDisposed(), Sn(this, e);
}, at().prototype.unique = function (e) {
  return this.throwIfDisposed(), wi(this, e);
}, at().prototype.unsortedSegmentSum = function (e, t) {
  return this.throwIfDisposed(), vi(this, e, t);
}, at().prototype.unstack = function (e) {
  return this.throwIfDisposed(), Ii(this, e);
}, at().prototype.where = function (e, t) {
  return this.throwIfDisposed(), pr(e, this, t);
}, at().prototype.zerosLike = function () {
  return this.throwIfDisposed(), fr(this);
};

class mu extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, mu.prototype);
  }

}

class bu extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, bu.prototype);
  }

}

class xu extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, xu.prototype);
  }

}

class yu extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, yu.prototype);
  }

}

class ku extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, ku.prototype);
  }

}

function wu(e, t) {
  if (Array.isArray(e)) {
    var _n50 = [];

    for (var _s52 = 0; _s52 < t; _s52++) {
      _n50 = _n50.concat(e);
    }

    return _n50;
  }

  {
    var _n51 = new Array(t);

    return _n51.fill(e), _n51;
  }
}

function vu(e, t) {
  if (!e) throw new ku(t);
}

function Iu(e, t) {
  var n = 0;

  for (var _s53 of e) {
    _s53 === t && n++;
  }

  return n;
}

function $u(e) {
  return 1 === e.length ? e[0] : e;
}

function Su(e) {
  return Array.isArray(e) ? e : [e];
}

function Nu(e) {
  var t = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  return "_" !== t[0] ? t : "private" + t;
}

function Cu(e) {
  return e.length <= 1 || -1 === e.indexOf("_") ? e : e.replace(/[_]+(\w|$)/g, (e, t) => t.toUpperCase());
}

var Tu = {};

function Eu(e) {
  if (null == e) return null;
  var t = {};
  return t.className = e.getClassName(), t.config = e.getConfig(), t;
}

function Ru(e) {
  if (null != e && "object" == typeof e) if (Array.isArray(e)) e.forEach(e => Ru(e));else {
    var _t86 = Object.keys(e);

    for (var _n52 of _t86) {
      var _t87 = e[_n52];
      null != _t87 && "object" == typeof _t87 && (Array.isArray(_t87) || "ndarray" !== _t87.type || "number" != typeof _t87.value ? Ru(_t87) : e[_n52] = _t87.value);
    }
  }
}

function Au(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "object";
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;

  if ("string" == typeof e) {
    var _r38 = e;

    var _a29;

    if (_r38 in n) _a29 = n[_r38];else if (_r38 in Tu) _a29 = Tu[_r38];else if (_a29 = t[_r38], null == _a29) throw new xu("Unknown ".concat(s, ": ").concat(e, ". This may be due to one of the following reasons:\n1. The ").concat(s, " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ").concat(s, " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."));
    return _a29;
  }

  {
    var _a30 = e;
    if (null == _a30.className || null == _a30.config) throw new xu("".concat(s, ": Improper config format: ").concat(JSON.stringify(_a30), ".\n'className' and 'config' must set."));
    var _i18 = _a30.className;

    var _o15, _l9;

    if (_i18 in n ? [_o15, _l9] = n[_i18] : _i18 in Tu ? [_o15, _l9] = Tu.className : _i18 in t && ([_o15, _l9] = t[_i18]), null == _o15) throw new xu("Unknown ".concat(s, ": ").concat(_i18, ". This may be due to one of the following reasons:\n1. The ").concat(s, " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ").concat(s, " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."));

    if (null != _l9) {
      var _e90 = {};

      for (var _t89 of Object.keys(Tu)) {
        _e90[_t89] = Tu[_t89];
      }

      for (var _t90 of Object.keys(n)) {
        _e90[_t90] = n[_t90];
      }

      _a30.config.customObjects = _e90;

      var _t88 = Object.assign({}, Tu);

      for (var _e91 of Object.keys(n)) {
        Tu[_e91] = n[_e91];
      }

      Ru(_a30.config);

      var _s54 = _l9(_o15, _a30.config, n, r);

      return Tu = Object.assign({}, _t88), _s54;
    }

    {
      var _e92 = Object.assign({}, Tu);

      for (var _e93 of Object.keys(n)) {
        Tu[_e93] = n[_e93];
      }

      var _t91 = new _o15(_a30.config);

      return Tu = Object.assign({}, _e92), _t91;
    }
  }
}

function Fu(e, t) {
  return -1 * function (e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
  }(e, t);
}

function Du(e) {
  if (null == e) return e;
  var t = [];

  for (var _n53 of e) {
    -1 === t.indexOf(_n53) && t.push(_n53);
  }

  return t;
}

function _u(e) {
  if (null == e) throw new xu("Invalid value in obj: ".concat(JSON.stringify(e)));

  for (var _t92 in e) {
    if (e.hasOwnProperty(_t92)) return !1;
  }

  return !0;
}

function Ou(e, t, n) {
  if (null != n && e.indexOf(n) < 0) throw new xu("".concat(n, " is not a valid ").concat(t, ".  Valid values are ").concat(e, " or null/undefined."));
}

function Mu(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
  return vu(n >= 0), vu(s >= n), Array.isArray(e) && e.length >= n && e.length <= s && e.every(e => typeof e === t);
}

function Lu(e, t) {
  Array.isArray(e) ? (l(e.length > 0, () => "".concat(t, " is unexpectedly an empty array.")), e.forEach((e, n) => Lu(e, "element ".concat(n + 1, " of ").concat(t)))) : l(Number.isInteger(e) && e > 0, () => "Expected ".concat(t, " to be a positive integer, but got ").concat(zu(e), "."));
}

function zu(e) {
  return null === e ? "null" : Array.isArray(e) ? "[" + e.map(e => zu(e)).join(",") + "]" : "string" == typeof e ? "\"".concat(e, "\"") : "".concat(e);
}

function Bu(e) {
  return "relu" === e ? "relu" : "linear" === e ? "linear" : "elu" === e ? "elu" : null;
}

function Pu(e, t) {
  return Jn(() => ci(Hr(rs(e, e), t, !0)));
}

class Wu extends qn {
  getConfig() {
    return {};
  }

}

class Uu extends Wu {
  constructor(e) {
    super(), this.defaultMaxValue = 2, this.defaultAxis = 0, this.maxValue = null != e.maxValue ? e.maxValue : this.defaultMaxValue, this.axis = null != e.axis ? e.axis : this.defaultAxis;
  }

  apply(e) {
    return Jn(() => {
      var t = Pu(e, this.axis),
          n = Hs(t, 0, this.maxValue);
      return rs(e, ss(n, ts(gu(), t)));
    });
  }

  getConfig() {
    return {
      maxValue: this.maxValue,
      axis: this.axis
    };
  }

}

Uu.className = "MaxNorm", Kn(Uu);

class Vu extends Wu {
  constructor(e) {
    super(), this.defaultAxis = 0, this.axis = null != e.axis ? e.axis : this.defaultAxis;
  }

  apply(e) {
    return Jn(() => ss(e, ts(gu(), Pu(e, this.axis))));
  }

  getConfig() {
    return {
      axis: this.axis
    };
  }

}

Vu.className = "UnitNorm", Kn(Vu);

class Gu extends Wu {
  apply(e) {
    return Va(e);
  }

}

Gu.className = "NonNeg", Kn(Gu);

class Hu extends Wu {
  constructor(e) {
    super(), this.defaultMinValue = 0, this.defaultMaxValue = 1, this.defaultRate = 1, this.defaultAxis = 0, this.minValue = null != e.minValue ? e.minValue : this.defaultMinValue, this.maxValue = null != e.maxValue ? e.maxValue : this.defaultMaxValue, this.rate = null != e.rate ? e.rate : this.defaultRate, this.axis = null != e.axis ? e.axis : this.defaultAxis;
  }

  apply(e) {
    return Jn(() => {
      var t = Pu(e, this.axis),
          n = ts(rs(this.rate, Hs(t, this.minValue, this.maxValue)), rs(1 - this.rate, t));
      return rs(e, ss(n, ts(gu(), t)));
    });
  }

  getConfig() {
    return {
      minValue: this.minValue,
      maxValue: this.maxValue,
      rate: this.rate,
      axis: this.axis
    };
  }

}

Hu.className = "MinMaxNorm", Kn(Hu);
var qu = {
  maxNorm: "MaxNorm",
  minMaxNorm: "MinMaxNorm",
  nonNeg: "NonNeg",
  unitNorm: "UnitNorm"
};

function ju(e) {
  return Eu(e);
}

function Ku(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Au(e, jn.getMap().classNameMap, t, "constraint");
}

function Xu(e) {
  return null == e ? null : "string" == typeof e ? Ku({
    className: e in qu ? qu[e] : e,
    config: {}
  }) : e instanceof Wu ? e : Ku(e);
}

var Yu = ["channelsFirst", "channelsLast"],
    Ju = ["nearest", "bilinear"],
    Zu = ["valid", "same", "causal"],
    Qu = ["max", "avg"],
    ec = ["sum", "mul", "concat", "ave"],
    tc = new Map();

function nc(e) {
  Ou(Yu, "DataFormat", e);
}

function sc(e) {
  Ou(Zu, "PaddingMode", e);
}

function rc(e) {
  Ou(Qu, "PoolMode", e);
}

var ac = [];

function ic(e, t) {
  ac.push(e);

  try {
    var _e94 = t();

    return ac.pop(), _e94;
  } catch (e) {
    throw ac.pop(), e;
  }
}

function oc(e) {
  if (!cc(e)) throw new Error("Not a valid tensor name: '" + e + "'");
  return (0 === ac.length ? "" : ac.join("/") + "/") + e;
}

function lc(e) {
  if (!cc(e)) throw new Error("Not a valid tensor name: '" + e + "'");
  tc.has(e) || tc.set(e, 0);
  var t = tc.get(e);

  if (tc.set(e, tc.get(e) + 1), t > 0) {
    var _n54 = "".concat(e, "_").concat(t);

    return tc.set(_n54, 1), _n54;
  }

  return e;
}

var uc = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);

function cc(e) {
  return !!e.match(uc);
}

function hc(e, t, n) {
  null == t && (t = 0), null == n && (n = e.length);
  var s = 1;

  for (var _r39 = t; _r39 < n; ++_r39) {
    s *= e[_r39];
  }

  return s;
}

function dc(e) {
  if (0 === e.length) return Number.NaN;
  var t = Number.POSITIVE_INFINITY;

  for (var _n55 = 0; _n55 < e.length; _n55++) {
    var _s55 = e[_n55];
    _s55 < t && (t = _s55);
  }

  return t;
}

function pc(e) {
  if (0 === e.length) return Number.NaN;
  var t = Number.NEGATIVE_INFINITY;

  for (var _n56 = 0; _n56 < e.length; _n56++) {
    var _s56 = e[_n56];
    _s56 > t && (t = _s56);
  }

  return t;
}

function fc(e, t) {
  if (t < e) throw new xu("end (".concat(t, ") < begin (").concat(e, ") is forbidden."));
  var n = [];

  for (var _s57 = e; _s57 < t; ++_s57) {
    n.push(_s57);
  }

  return n;
}

function gc(e, t) {
  return fn(e, t);
}

function mc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
  var n = e.shape.slice();
  return t < 0 && (t = n.length + t + 1), n.splice(t, 0, 1), Rs(e, n);
}

function bc(e, t, n) {
  return Jn(() => {
    switch (e.rank) {
      case 1:
        return ei(e, t, n);

      case 2:
        return ti(e, [t, 0], [n, e.shape[1]]);

      case 3:
        return ni(e, [t, 0, 0], [n, e.shape[1], e.shape[2]]);

      case 4:
        return si(e, [t, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3]]);

      case 5:
        return Os(e, [t, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);

      case 6:
        return Os(e, [t, 0, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);

      default:
        throw new xu("sliceAlongFirstAxis() received an unsupported tensor rank: ".concat(e.rank));
    }
  });
}

function xc(e, t, n) {
  return Jn(() => {
    switch (e.rank) {
      case 1:
        return ei(e, t, n);

      case 2:
        return ti(e, [0, t], [e.shape[0], n]);

      case 3:
        return ni(e, [0, 0, t], [e.shape[0], e.shape[1], n]);

      case 4:
        return si(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n]);

      default:
        throw new xu("sliceAlongLastAxis() received an unsupported tensor rank: ".concat(e.rank));
    }
  });
}

function yc(e, t, n, s) {
  return Jn(() => {
    switch (e.rank) {
      case 1:
        return ei(e, t, n);

      case 2:
        switch (s) {
          case 1:
            return bc(e, t, n);

          case 2:
            return xc(e, t, n);

          default:
            throw new xu("The axis is not within the rank of the tensor ".concat(s));
        }

      case 3:
        switch (s) {
          case 1:
            return bc(e, t, n);

          case 2:
            return ni(e, [0, t, 0], [e.shape[0], n, e.shape[2]]);

          case 3:
            return xc(e, t, n);

          default:
            throw new xu("The axis is not within the rank of the tensor ".concat(s));
        }

      case 4:
        switch (s) {
          case 1:
            return bc(e, t, n);

          case 2:
            return si(e, [0, t, 0, 0], [e.shape[0], n, e.shape[2], e.shape[3]]);

          case 3:
            return si(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n, e.shape[3]]);

          case 4:
            return xc(e, t, n);

          default:
            throw new xu("The axis is not within the rank of the tensor ".concat(s));
        }

      default:
        throw new xu("sliceAlongLastAxis() received an unsupported tensor rank: ".concat(e.rank));
    }
  });
}

function kc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
  var n;
  return t < 0 && (n = e[0].rank, t = 0 !== n ? n : 0), t === e[0].rank && (t = -1), Ds(e, t);
}

function wc(e, t) {
  switch (e.rank) {
    case 1:
      return qs([e, t]);

    case 2:
      return js([e, t], 0);

    case 3:
      return Ks([e, t], 0);

    case 4:
      return Xs([e, t], 0);

    default:
      throw new xu("concatAlongFirstAxis() received an unsupported tensor rank: ".concat(e.rank));
  }
}

function vc(e, t) {
  if (Array.isArray(t) || (t = [t]), e.rank !== t.length) throw new xu("The length of input n (".concat(t.length, ") does not match the number of dimensions in input x (").concat(e.rank, ")"));
  return vr(e, t);
}

function Ic(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var s = arguments.length > 3 ? arguments[3] : undefined;
  var r = arguments.length > 4 ? arguments[4] : undefined;
  return za(e, t, n, s, r);
}

function $c(e, t, n, s) {
  if (e.rank < 2 || t.rank < 2) throw new yu("dot requires both inputs to be rank >= 2 but got x shape = ".concat(e.shape, " and y shape = ").concat(t.shape));
  if (t.rank >= 3 && e.shape.slice(-1)[0] !== t.shape.slice(-2)[0]) throw new yu("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ".concat(e.shape, " and  y shape = ").concat(t.shape));
  if (2 === e.rank && 2 === t.rank) return Li({
    a: e,
    b: t,
    transposeA: !1,
    transposeB: !1,
    bias: s ? Cc(e.rank, s, "channelsLast") : null,
    activation: n
  });
  {
    var _r40 = e.shape.slice(),
        _a31 = _r40.pop();

    e = Rs(e, [-1, _a31]);

    var _i19 = t.shape.slice(),
        _o16 = _i19.pop(),
        _l10 = _i19.pop(),
        _u6 = [..._i19, _o16],
        _c5 = Array.from({
      length: t.rank
    }, (e, n) => 0 === n ? t.rank - 2 : n <= t.rank - 2 ? n - 1 : n);

    t = Rs(Sn(t, _c5), [_l10, -1]);
    var _h4 = [..._r40, ..._u6];
    return Rs(Li({
      a: e,
      b: t,
      transposeA: !1,
      transposeB: !1,
      bias: s ? Cc(e.rank, s, "channelsLast") : null,
      activation: n
    }), _h4);
  }
}

function Sc(e, t, n) {
  return Jn(() => (t = Array.isArray(t) ? bi(t, "int32") : fn(t, "int32"), Nr(e, t, n)));
}

function Nc(e) {
  return rs(e, e);
}

function Cc(e, t, n) {
  var s = t.shape;
  if (1 !== t.rank && t.rank !== e) throw new xu("Unexpected bias dimensions: ".concat(t.rank, "; expected it to be 1 or ").concat(e));

  if (5 === e) {
    if ("channelsFirst" === n) return Rs(t, 1 === s.length ? [1, s[0], 1, 1, 1] : [1, s[3], s[0], s[1], s[2]]);
    if ("channelsLast" === n) return Rs(t, 1 === s.length ? [1, 1, 1, 1, s[0]] : [1].concat(s));
  } else if (4 === e) {
    if ("channelsFirst" === n) return Rs(t, 1 === s.length ? [1, s[0], 1, 1] : [1, s[2], s[0], s[1]]);
    if ("channelsLast" === n) return Rs(t, 1 === s.length ? [1, 1, 1, s[0]] : [1].concat(s));
  } else if (3 === e) {
    if ("channelsFirst" === n) return Rs(t, 1 === s.length ? [1, s[0], 1] : [1, s[1], s[0]]);
    if ("channelsLast" === n) return Rs(t, 1 === s.length ? [1, 1, s[0]] : [1].concat(s));
  } else if (e < 3) return t;

  throw new xu("Unsupported input rank by biasAdd: ".concat(t.rank));
}

function Tc(e, t, n) {
  return Jn(() => (null == n && (n = "channelsLast"), nc(n), ts(e, Cc(e.rank, t, n))));
}

function Ec(e, t, n, s) {
  return Jn(() => Ci(e, t, n, s));
}

function Rc(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return n ? e() : t();
}

var Ac = ["fanIn", "fanOut", "fanAvg"],
    Fc = ["normal", "uniform", "truncatedNormal"];

class Dc extends qn {
  fromConfigUsesCustomObjects() {
    return !1;
  }

  getConfig() {
    return {};
  }

}

class _c extends Dc {
  apply(e, t) {
    return ca(e, t);
  }

}

_c.className = "Zeros", Kn(_c);

class Oc extends Dc {
  apply(e, t) {
    return ha(e, t);
  }

}

Oc.className = "Ones", Kn(Oc);

class Mc extends Dc {
  constructor(e) {
    if (super(), "object" != typeof e) throw new xu("Expected argument of type ConstantConfig but got ".concat(e));
    if (void 0 === e.value) throw new xu("config must have value set but got ".concat(e));
    this.value = e.value;
  }

  apply(e, t) {
    return Jn(() => rs(Ka(this.value), ha(e, t)));
  }

  getConfig() {
    return {
      value: this.value
    };
  }

}

Mc.className = "Constant", Kn(Mc);

class Lc extends Dc {
  constructor(e) {
    super(), this.DEFAULT_MINVAL = -.05, this.DEFAULT_MAXVAL = .05, this.minval = e.minval || this.DEFAULT_MINVAL, this.maxval = e.maxval || this.DEFAULT_MAXVAL, this.seed = e.seed;
  }

  apply(e, t) {
    return Ba(e, this.minval, this.maxval, t);
  }

  getConfig() {
    return {
      minval: this.minval,
      maxval: this.maxval,
      seed: this.seed
    };
  }

}

Lc.className = "RandomUniform", Kn(Lc);

class zc extends Dc {
  constructor(e) {
    super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = .05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed;
  }

  apply(e, t) {
    if ("float32" !== (t = t || "float32") && "int32" !== t) throw new yu("randomNormal does not support dType ".concat(t, "."));
    return Ic(e, this.mean, this.stddev, t, this.seed);
  }

  getConfig() {
    return {
      mean: this.mean,
      stddev: this.stddev,
      seed: this.seed
    };
  }

}

zc.className = "RandomNormal", Kn(zc);

class Bc extends Dc {
  constructor(e) {
    super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = .05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed;
  }

  apply(e, t) {
    if ("float32" !== (t = t || "float32") && "int32" !== t) throw new yu("truncatedNormal does not support dType ".concat(t, "."));
    return ki(e, this.mean, this.stddev, t, this.seed);
  }

  getConfig() {
    return {
      mean: this.mean,
      stddev: this.stddev,
      seed: this.seed
    };
  }

}

Bc.className = "TruncatedNormal", Kn(Bc);

class Pc extends Dc {
  constructor(e) {
    super(), this.gain = null != e.gain ? e.gain : 1;
  }

  apply(e, t) {
    return Jn(() => {
      if (2 !== e.length || e[0] !== e[1]) throw new xu("Identity matrix initializer can only be used for 2D square matrices.");
      return rs(this.gain, Ir(e[0]));
    });
  }

  getConfig() {
    return {
      gain: this.gain
    };
  }

}

Pc.className = "Identity", Kn(Pc);

class Wc extends Dc {
  constructor(e) {
    if (super(), e.scale < 0) throw new xu("scale must be a positive float. Got: ".concat(e.scale));
    this.scale = null == e.scale ? 1 : e.scale, this.mode = null == e.mode ? "fanIn" : e.mode, Ou(Ac, "FanMode", this.mode), this.distribution = null == e.distribution ? "normal" : e.distribution, Ou(Fc, "Distribution", this.distribution), this.seed = e.seed;
  }

  apply(e, t) {
    var n = function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "channelsLast";
      var n, s;
      if (nc(t), 2 === e.length) n = e[0], s = e[1];else if (-1 !== [3, 4, 5].indexOf(e.length)) {
        if ("channelsFirst" === t) {
          var _t93 = hc(e, 2);

          n = e[1] * _t93, s = e[0] * _t93;
        } else if ("channelsLast" === t) {
          var _t94 = hc(e, 0, e.length - 2);

          n = e[e.length - 2] * _t94, s = e[e.length - 1] * _t94;
        }
      } else {
        var _t95 = hc(e);

        n = Math.sqrt(_t95), s = Math.sqrt(_t95);
      }
      return [n, s];
    }(e),
        s = n[0],
        r = n[1];

    var a = this.scale;

    if (a /= "fanIn" === this.mode ? Math.max(1, s) : "fanOut" === this.mode ? Math.max(1, r) : Math.max(1, (s + r) / 2), "normal" === this.distribution) {
      var _n57 = Math.sqrt(a);

      if ("float32" !== (t = t || "float32") && "int32" !== t) throw new yu("".concat(this.getClassName(), " does not support dType ").concat(t, "."));
      return ki(e, 0, _n57, t, this.seed);
    }

    {
      var _n58 = Math.sqrt(3 * a);

      return Ba(e, -_n58, _n58, t);
    }
  }

  getConfig() {
    return {
      scale: this.scale,
      mode: this.mode,
      distribution: this.distribution,
      seed: this.seed
    };
  }

}

Wc.className = "VarianceScaling", Kn(Wc);

class Uc extends Wc {
  constructor(e) {
    super({
      scale: 1,
      mode: "fanAvg",
      distribution: "uniform",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Wc.className;
  }

}

Uc.className = "GlorotUniform", Kn(Uc);

class Vc extends Wc {
  constructor(e) {
    super({
      scale: 1,
      mode: "fanAvg",
      distribution: "normal",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Wc.className;
  }

}

Vc.className = "GlorotNormal", Kn(Vc);

class Gc extends Wc {
  constructor(e) {
    super({
      scale: 2,
      mode: "fanIn",
      distribution: "normal",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Wc.className;
  }

}

Gc.className = "HeNormal", Kn(Gc);

class Hc extends Wc {
  constructor(e) {
    super({
      scale: 2,
      mode: "fanIn",
      distribution: "uniform",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Wc.className;
  }

}

Hc.className = "HeUniform", Kn(Hc);

class qc extends Wc {
  constructor(e) {
    super({
      scale: 1,
      mode: "fanIn",
      distribution: "normal",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Wc.className;
  }

}

qc.className = "LeCunNormal", Kn(qc);

class jc extends Wc {
  constructor(e) {
    super({
      scale: 1,
      mode: "fanIn",
      distribution: "uniform",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Wc.className;
  }

}

jc.className = "LeCunNormal", Kn(jc);

class Kc extends Dc {
  constructor(e) {
    if (super(), this.DEFAULT_GAIN = 1, this.gain = null == e.gain ? this.DEFAULT_GAIN : e.gain, this.seed = e.seed, null != this.seed) throw new yu("Random seed is not implemented for Orthogonal Initializer yet.");
  }

  apply(e, t) {
    return Jn(() => {
      if (e.length < 2) throw new yu("Shape must be at least 2D.");
      e[0] * e[1] > 2e3 && console.warn("Orthogonal initializer is being called on a matrix with more than 2000 (".concat(e[0] * e[1], ") elements: Slowness may result."));
      var t = Ic(e[0] > e[1] ? [e[1], e[0]] : e, 0, 1, "float32");
      var n = go.gramSchmidt(t);
      return e[0] > e[1] && (n = Sn(n)), rs(this.gain, n);
    });
  }

  getConfig() {
    return {
      gain: this.gain,
      seed: this.seed
    };
  }

}

Kc.className = "Orthogonal", Kn(Kc);
var Xc = {
  constant: "Constant",
  glorotNormal: "GlorotNormal",
  glorotUniform: "GlorotUniform",
  heNormal: "HeNormal",
  heUniform: "HeUniform",
  identity: "Identity",
  leCunNormal: "LeCunNormal",
  leCunUniform: "LeCunUniform",
  ones: "Ones",
  orthogonal: "Orthogonal",
  randomNormal: "RandomNormal",
  randomUniform: "RandomUniform",
  truncatedNormal: "TruncatedNormal",
  varianceScaling: "VarianceScaling",
  zeros: "Zeros"
};

function Yc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Au(e, jn.getMap().classNameMap, t, "initializer");
}

function Jc(e) {
  return Eu(e);
}

function Zc(e) {
  if ("string" == typeof e) {
    var _t96 = e in Xc ? Xc[e] : e;

    if ("GlorotNormal" === _t96) return new Vc();
    if ("GlorotUniform" === _t96) return new Uc();
    if ("HeNormal" === _t96) return new Gc();
    if ("HeUniform" === _t96) return new Hc();
    if ("LeCunNormal" === _t96) return new qc();
    if ("LeCunUniform" === _t96) return new jc();
    {
      var _e95 = {};
      return _e95.className = _t96, _e95.config = {}, Yc(_e95);
    }
  }

  return e instanceof Dc ? e : Yc(e);
}

var Qc = 0;

function eh() {
  return Qc++;
}

var th = {};

function nh() {
  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  return e in th || (th[e] = 0), th[e] += 1, e + th[e].toString();
}

function sh(e) {
  return Array.isArray(e) && Array.isArray(e[0]);
}

function rh(e) {
  return 0 === e.length ? [] : Array.isArray(e[0]) ? e : [e];
}

function ah(e) {
  var t;

  if (Array.isArray(e)) {
    if (1 !== e.length) throw new xu("Expected Tensor length to be 1; got ".concat(e.length));
    t = e[0];
  } else t = e;

  return t;
}

function ih(e) {
  if (Array.isArray(e) && Array.isArray(e[0])) {
    if (1 === e.length) return (e = e)[0];
    throw new xu("Expected exactly 1 Shape; got ".concat(e.length));
  }

  return e;
}

function oh(e) {
  var t = 0;

  for (var _n59 of e) {
    t += 0 === _n59.shape.length ? 1 : _n59.shape.reduce((e, t) => e * t);
  }

  return t;
}

class lh {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Variable";
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    this.dtype = null == t ? "float32" : t, this.shape = e.shape, this.id = eh(), this.originalName = oc(n = null == n ? "Variable" : n), this.name = lc(this.originalName), this.trainable_ = s, this.constraint = r, this.val = function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var n = arguments.length > 2 ? arguments[2] : undefined;
      var s = arguments.length > 3 ? arguments[3] : undefined;
      return vt.makeVariable(e, t, n, s);
    }(e, this.trainable_, this.name, this.dtype);
  }

  read() {
    return this.assertNotDisposed(), this.val;
  }

  write(e) {
    return this.assertNotDisposed(), function (e, t) {
      if (e.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape));
    }(this.val, e), this.val.id !== e.id && (this.val.assign(e), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this;
  }

  dispose() {
    this.assertNotDisposed(), this.val.dispose();
  }

  assertNotDisposed() {
    if (this.val.isDisposed) throw new Error("LayersVariable ".concat(this.name, " is already disposed."));
  }

  get trainable() {
    return this.trainable_;
  }

  set trainable(e) {
    this.trainable_ = e, this.val.trainable = e;
  }

}

function uh(e) {
  return e.map(e => e.read());
}

function ch(e) {
  e.forEach(e => {
    e[0].write(e[1]);
  });
}

class hh {
  constructor(e) {
    this.dtype = e.dtype, this.shape = e.shape, this.ndim = null != e.shape ? e.shape.length : e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {};
  }

}

class dh {
  constructor(e, t, n, s, r, a, i) {
    this.dtype = e, this.shape = t, this.sourceLayer = n, this.inputs = s, this.callArgs = r, this.outputTensorIndex = i, this.id = eh(), null != a && (this.originalName = oc(a), this.name = lc(this.originalName)), this.rank = t.length;
  }

}

var ph = 0;

class fh {
  constructor(e, t) {
    this.callArgs = t, this.id = ph++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;

    for (var _t97 of e.inboundLayers) {
      null != _t97 && _t97.outboundNodes.push(this);
    }

    e.outboundLayer.inboundNodes.push(this);
  }

  getConfig() {
    var e = [];

    for (var _t98 of this.inboundLayers) {
      e.push(null != _t98 ? _t98.name : null);
    }

    return {
      outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
      inboundLayers: e,
      nodeIndices: this.nodeIndices,
      tensorIndices: this.tensorIndices
    };
  }

}

var gh = 0;

class mh extends qn {
  constructor() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(), this._callHook = null, this._addedWeightNames = [], this._stateful = !1, this.id = gh++, this.activityRegularizer = null, this.inputSpec = null, this.supportsMasking = !1, this._trainableWeights = [], this._nonTrainableWeights = [], this._losses = [], this._updates = [], this._built = !1, this.inboundNodes = [], this.outboundNodes = [];
    var t = e.name;

    if (!t) {
      var _e96 = this.getClassName();

      t = Nu(_e96) + "_" + nh(_e96);
    }

    if (this.name = t, this.trainable_ = null == e.trainable || e.trainable, null != e.inputShape || null != e.batchInputShape) {
      var _t99;

      if (null != e.batchInputShape) _t99 = e.batchInputShape;else if (null != e.inputShape) {
        var _n61 = null;
        null != e.batchSize && (_n61 = e.batchSize), _t99 = [_n61].concat(e.inputShape);
      }
      this.batchInputShape = _t99;
      var _n60 = e.dtype;
      null == _n60 && (_n60 = e.inputDType), null == _n60 && (_n60 = "float32"), this.dtype = _n60;
    }

    this.initialWeights = null != e.weights ? e.weights : null, this._refCount = null, this.fastWeightInitDuringBuild = !1;
  }

  static nodeKey(e, t) {
    return e.name + "_ib-" + t.toString();
  }

  getNodeAtIndex(e, t) {
    if (0 === this.inboundNodes.length) throw new bu("The layer has never been called and thus has no defined ".concat(t, "."));
    if (this.inboundNodes.length <= e) throw new xu("Asked to get ".concat(t, " at node ").concat(e, ", but the layer has only ").concat(this.inboundNodes.length, " inbound nodes."));
    return this.inboundNodes[e];
  }

  getInputAt(e) {
    return $u(this.getNodeAtIndex(e, "input").inputTensors);
  }

  getOutputAt(e) {
    return $u(this.getNodeAtIndex(e, "output").outputTensors);
  }

  get input() {
    if (this.inboundNodes.length > 1) throw new mu("Layer ".concat(this.name, " has multiple inbound nodes, hence the notion of \"layer input\" is ill-defined. Use `getInputAt(nodeIndex)` instead."));
    if (0 === this.inboundNodes.length) throw new mu("Layer ".concat(this.name, " is not connected, no input to return."));
    return $u(this.getNodeAtIndex(0, "input").inputTensors);
  }

  get output() {
    if (0 === this.inboundNodes.length) throw new mu("Layer ".concat(this.name, " has no inbound nodes."));
    if (this.inboundNodes.length > 1) throw new mu("Layer ".concat(this.name, " has multiple inbound nodes, hence the notion of \"layer output\" is ill-defined. Use `getOutputAt(nodeIndex)` instead."));
    return $u(this.getNodeAtIndex(0, "output").outputTensors);
  }

  get losses() {
    return this._losses;
  }

  calculateLosses() {
    return this.losses.map(e => e());
  }

  get updates() {
    return this._updates;
  }

  get built() {
    return this._built;
  }

  set built(e) {
    this._built = e;
  }

  get trainable() {
    return this.trainable_;
  }

  set trainable(e) {
    this._trainableWeights.forEach(t => t.trainable = e), this.trainable_ = e;
  }

  get trainableWeights() {
    return this.trainable_ ? this._trainableWeights.filter(e => e.trainable) : [];
  }

  set trainableWeights(e) {
    this._trainableWeights = e;
  }

  get nonTrainableWeights() {
    return this.trainable ? this._trainableWeights.filter(e => !e.trainable).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
  }

  set nonTrainableWeights(e) {
    this._nonTrainableWeights = e;
  }

  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }

  get stateful() {
    return this._stateful;
  }

  resetStates() {
    if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
  }

  assertInputCompatibility(e) {
    if (e = Su(e), null == this.inputSpec || 0 === this.inputSpec.length) return;
    var t = Su(this.inputSpec);
    if (e.length !== t.length) throw new xu("Layer ".concat(this.name, " expects ").concat(t.length, " inputs, but it received ").concat(e.length, " input tensors. Input received: ").concat(e));

    for (var _n62 = 0; _n62 < e.length; _n62++) {
      var _s58 = e[_n62],
          _r41 = t[_n62];
      if (null == _r41) continue;
      var _a32 = _s58.rank;
      if (null != _r41.ndim && _a32 !== _r41.ndim) throw new xu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, ": expected ndim=").concat(_r41.ndim, ", found ndim=").concat(_a32));
      if (null != _r41.maxNDim && _a32 > _r41.maxNDim) throw new xu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, ": expected max_ndim=").concat(_r41.maxNDim, ", found ndim=").concat(_a32));
      if (null != _r41.minNDim && _a32 < _r41.minNDim) throw new xu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, ": expected min_ndim=").concat(_r41.minNDim, ", found ndim=").concat(_a32, "."));
      if (null != _r41.dtype && _s58.dtype !== _r41.dtype) throw new xu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, " : expected dtype=").concat(_r41.dtype, ", found dtype=").concat(_s58.dtype, "."));

      if (_r41.axes) {
        var _e97 = _s58.shape;

        for (var _t100 in _r41.axes) {
          var _s59 = Number(_t100),
              _a33 = _r41.axes[_t100],
              _i20 = _s59 >= 0 ? _e97[_s59] : _e97[_e97.length + _s59];

          if (null != _a33 && -1 === [_a33, null].indexOf(_i20)) throw new xu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, ": expected axis ").concat(_s59, " of input shape to have value ").concat(_a33, " but got shape ").concat(_e97, "."));
        }
      }

      if (null != _r41.shape) for (var _e98 = 0; _e98 < _r41.shape.length; ++_e98) {
        var _t101 = _r41.shape[_e98],
            _a34 = _s58.shape[_e98];
        if (null != _t101 && null != _a34 && _t101 !== _a34) throw new xu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, ": expected shape=").concat(_r41.shape, ", found shape=").concat(_s58.shape, "."));
      }
    }
  }

  call(e, t) {
    return e;
  }

  invokeCallHook(e, t) {
    null != this._callHook && this._callHook(e, t);
  }

  setCallHook(e) {
    this._callHook = e;
  }

  clearCallHook() {
    this._callHook = null;
  }

  apply(e, t) {
    t = t || {}, this.assertNotDisposed();
    var n = Su(e);
    var s = !0;

    for (var _e99 of n) {
      if (!(_e99 instanceof dh)) {
        s = !1;
        break;
      }
    }

    var r = !0;

    for (var _e100 of n) {
      if (_e100 instanceof dh) {
        r = !1;
        break;
      }
    }

    if (s === r) throw new xu("Arguments to apply() must be all SymbolicTensors or all Tensors");
    return ic(this.name, () => {
      if (!this.built) {
        this.assertInputCompatibility(e);
        var _t102 = [];

        for (var _n63 of Su(e)) {
          _t102.push(_n63.shape);
        }

        this.build($u(_t102)), this.built = !0, this.initialWeights && this.setWeights(this.initialWeights), null === this._refCount && r && (this._refCount = 1);
      }

      if (this.assertInputCompatibility(e), r) {
        var _s60 = this.call(e, t);

        var _r42 = Su(_s60),
            _a35 = [];

        for (var _e101 of _r42) {
          -1 !== n.indexOf(_e101) && (_e101 = _e101.clone()), _a35.push(_e101);
        }

        if (_s60 = $u(_a35), null != this.activityRegularizer) throw new yu("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return _s60;
      }

      {
        var _n64 = function (e) {
          e = Su(e);
          var t = [];

          for (var _n65 of e) {
            t.push(_n65.shape);
          }

          return $u(t);
        }(e),
            _s61 = this.computeOutputShape(_n64);

        var _r43;

        var _a36 = "float32";
        if (this.warnOnIncompatibleInputShape(Array.isArray(e) ? _n64[0] : _n64), _r43 = null != _s61 && _s61.length > 0 && Array.isArray(_s61[0]) ? _s61.map((n, s) => new dh(_a36, n, this, Su(e), t, this.name, s)) : new dh(_a36, _s61, this, Su(e), t, this.name), this.addInboundNode(e, _r43, null, null, _n64, _s61, t), this._refCount++, null != this.activityRegularizer) throw new yu("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return _r43;
      }
    });
  }

  warnOnIncompatibleInputShape(e) {
    if (null != this.batchInputShape) if (e.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: ".concat(JSON.stringify(e), ") does not match that of the batchInputShape (").concat(JSON.stringify(this.batchInputShape), ") of the layer ").concat(this.name));else {
      var _t103 = !1;

      this.batchInputShape.forEach((n, s) => {
        null != n && null != e[s] && e[s] !== n && (_t103 = !0);
      }), _t103 && console.warn("The shape of the input tensor (".concat(JSON.stringify(e), ") does not match the expectation of layer ").concat(this.name, ": ").concat(JSON.stringify(this.batchInputShape)));
    }
  }

  get outputShape() {
    if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new mu("The layer ".concat(this.name, " has never been called and thus has no defined output shape."));
    var e = [];

    for (var _t104 of this.inboundNodes) {
      var _n66 = JSON.stringify(_t104.outputShapes);

      -1 === e.indexOf(_n66) && e.push(_n66);
    }

    if (1 === e.length) {
      var _e102 = this.inboundNodes[0].outputShapes;
      return Array.isArray(_e102) && Array.isArray(_e102[0]) && 1 === _e102.length ? _e102[0] : _e102;
    }

    throw new mu("The layer ".concat(this.name, " has multiple inbound nodes with different output shapes. Hence the notion of \"output shape\" is ill-defined for the layer."));
  }

  countParams() {
    if (!this.built) throw new bu("You tried to call countParams() on ".concat(this.name, ", but the layer is not built yet. Build it first by calling build(batchInputShape)."));
    return oh(this.weights);
  }

  build(e) {
    this.built = !0;
  }

  getWeights() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    return uh(e ? this.trainableWeights : this.weights);
  }

  setWeights(e) {
    Jn(() => {
      var t = this.weights;
      if (t.length !== e.length) throw new xu("You called setWeights(weights) on layer \"".concat(this.name, "\" with a weight list of length ").concat(e.length, ", but the layer was expecting ").concat(t.length, " weights. Provided weights: ").concat(e, "..."));
      if (0 === t.length) return;
      var n = [],
          s = uh(t);

      for (var _r44 = 0; _r44 < s.length; ++_r44) {
        var _a37 = s[_r44],
            _i21 = t[_r44],
            _o17 = e[_r44];
        if (!p(_a37.shape, _o17.shape)) throw new xu("Layer weight shape ".concat(_a37.shape, " not compatible with provided weight shape ").concat(_o17.shape));
        n.push([_i21, _o17]);
      }

      ch(n);
    });
  }

  addWeight(e, t, n, s, r, a, i) {
    if (-1 !== this._addedWeightNames.indexOf(e)) throw new xu("Duplicate weight name ".concat(e, " for layer ").concat(this.name));
    this._addedWeightNames.push(e), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (s = Zc("zeros"));
    var o = s.apply(t, n),
        l = new lh(o, n, e, a, i);
    return o.dispose(), null != r && this.addLoss(() => r.apply(l.read())), null == a && (a = !0), a ? this._trainableWeights.push(l) : this._nonTrainableWeights.push(l), l;
  }

  setFastWeightInitDuringBuild(e) {
    this.fastWeightInitDuringBuild = e;
  }

  addLoss(e) {
    null == e || Array.isArray(e) && 0 === e.length || (e = Su(e), null != this._losses && this.losses.push(...e));
  }

  computeOutputShape(e) {
    return e;
  }

  computeMask(e, t) {
    if (!this.supportsMasking) {
      if (null != t) {
        if (!Array.isArray(t)) throw new TypeError("Layer ".concat(this.name, " does not support masking, but was passed an inputMask."));
        t.forEach(e => {
          if (null != e) throw new TypeError("Layer ".concat(this.name, " does not support masking, but was passed an inputMask."));
        });
      }

      return null;
    }

    return t;
  }

  addInboundNode(e, t, n, s, r, a) {
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var o = Su(e);
    t = Su(t), n = Su(n), s = Su(s), r = rh(r), a = rh(a);
    var l = [],
        u = [],
        c = [];

    for (var _e103 of o) {
      l.push(_e103.sourceLayer), u.push(_e103.nodeIndex), c.push(_e103.tensorIndex);
    }

    new fh({
      outboundLayer: this,
      inboundLayers: l,
      nodeIndices: u,
      tensorIndices: c,
      inputTensors: o,
      outputTensors: t,
      inputMasks: n,
      outputMasks: s,
      inputShapes: r,
      outputShapes: a
    }, i);

    for (var _e104 = 0; _e104 < t.length; _e104++) {
      t[_e104].sourceLayer = this, t[_e104].nodeIndex = this.inboundNodes.length - 1, t[_e104].tensorIndex = _e104;
    }
  }

  getConfig() {
    var e = {
      name: this.name,
      trainable: this.trainable
    };
    return null != this.batchInputShape && (e.batchInputShape = this.batchInputShape), null != this.dtype && (e.dtype = this.dtype), e;
  }

  disposeWeights() {
    return this.weights.forEach(e => e.dispose()), this.weights.length;
  }

  assertNotDisposed() {
    if (0 === this._refCount) throw new Error("Layer '".concat(this.name, "' is already disposed."));
  }

  dispose() {
    if (!this.built) throw new Error("Cannot dispose Layer ".concat(this.name, " because it has not been built yet."));
    if (null === this._refCount) throw new Error("Cannot dispose Layer ".concat(this.name, " because it has not been used yet."));
    this.assertNotDisposed();
    var e = 0;
    return 0 == --this._refCount && (e = this.disposeWeights()), {
      refCountAfterDispose: this._refCount,
      numDisposedVariables: e
    };
  }

}

function bh(e, t, n) {
  if ((null == t || null != n && n > 0) && (t = e.sourceLayer, n = e.nodeIndex), 0 === t.inboundNodes.length) return [e];
  {
    var _e105 = t.inboundNodes[n];
    if (0 === _e105.inboundLayers.length) return _e105.inputTensors;
    {
      var _t105 = [];

      for (var _n67 = 0; _n67 < _e105.inboundLayers.length; _n67++) {
        var _s62 = bh(_e105.inputTensors[_n67], _e105.inboundLayers[_n67], _e105.nodeIndices[_n67]);

        for (var _e106 of _s62) {
          -1 === _t105.indexOf(_e106) && _t105.push(_e106);
        }
      }

      return _t105;
    }
  }
}

class xh extends mh {
  constructor(e) {
    if (super({
      dtype: e.dtype,
      name: null != e.name ? e.name : nh("input").toString()
    }), null == e.batchSize && (e.batchSize = null), null == e.sparse && (e.sparse = !1), this.trainable = !1, this.built = !0, this.sparse = e.sparse, null != e.inputShape && null != e.batchInputShape) throw new xu("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
    var t = e.batchInputShape;

    if (null == t) {
      if (null == e.inputShape) throw new xu("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
      t = [e.batchSize].concat(e.inputShape);
    } else if (null != e.batchSize) throw new xu("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");

    var n = e.dtype || "float32";
    this.batchInputShape = t, this.dtype = n, this.inputSpec = [{
      shape: t
    }];
    var s = new dh(this.dtype, this.batchInputShape, this, [], {}, this.name);
    s.nodeIndex = 0, s.tensorIndex = 0, new fh({
      outboundLayer: this,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: [s],
      outputTensors: [s],
      inputMasks: [null],
      outputMasks: [null],
      inputShapes: [t],
      outputShapes: [t]
    });
  }

  apply(e, t) {
    throw new xu("Cannot pass any input to an InputLayer's apply() method. InputLayer name: ".concat(this.name));
  }

  dispose() {
    return {
      refCountAfterDispose: this._refCount,
      numDisposedVariables: 0
    };
  }

  getConfig() {
    return {
      batchInputShape: this.batchInputShape,
      dtype: this.dtype,
      sparse: this.sparse,
      name: this.name
    };
  }

}

function yh(_x19) {
  return _yh.apply(this, arguments);
}

function _yh() {
  _yh = _asyncToGenerator(function* (e) {
    if (null == e) return;
    var t = [],
        n = [],
        s = [];

    for (var _r175 in e) {
      var _a148 = e[_r175];

      if ("number" != typeof _a148) {
        var _e529 = _a148;
        t.push(_e529.data()), n.push(_r175), s.push(_e529);
      }
    }

    if (t.length > 0) {
      var _r176 = yield Promise.all(t);

      for (var _t429 = 0; _t429 < _r176.length; ++_t429) {
        e[n[_t429]] = _r176[_t429][0];
      }

      Zn(s);
    }
  });
  return _yh.apply(this, arguments);
}

function kh(e) {
  if (null != e) for (var _t106 in e) {
    var _n68 = e[_t106];
    "number" != typeof _n68 && _n68.dispose();
  }
}

var wh;
xh.className = "InputLayer", Kn(xh), function (e) {
  e[e.SILENT = 0] = "SILENT", e[e.VERBOSE = 1] = "VERBOSE";
}(wh || (wh = {}));

class vh {
  constructor() {
    this.validationData = null;
  }

  setParams(e) {
    this.params = e;
  }

  onEpochBegin(e, t) {
    return _asyncToGenerator(function* () {})();
  }

  onEpochEnd(e, t) {
    return _asyncToGenerator(function* () {})();
  }

  onBatchBegin(e, t) {
    return _asyncToGenerator(function* () {})();
  }

  onBatchEnd(e, t) {
    return _asyncToGenerator(function* () {})();
  }

  onTrainBegin(e) {
    return _asyncToGenerator(function* () {})();
  }

  onTrainEnd(e) {
    return _asyncToGenerator(function* () {})();
  }

  setModel(e) {}

}

class Ih {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    null == e && (e = []), this.callbacks = e, this.queueLength = t;
  }

  append(e) {
    this.callbacks.push(e);
  }

  setParams(e) {
    for (var _t107 of this.callbacks) {
      _t107.setParams(e);
    }
  }

  setModel(e) {
    for (var _t108 of this.callbacks) {
      _t108.setModel(e);
    }
  }

  onEpochBegin(e, t) {
    var _this38 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {});

      for (var _n69 of _this38.callbacks) {
        yield _n69.onEpochBegin(e, t);
      }
    })();
  }

  onEpochEnd(e, t) {
    var _this39 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {});

      for (var _n70 of _this39.callbacks) {
        yield _n70.onEpochEnd(e, t);
      }
    })();
  }

  onBatchBegin(e, t) {
    var _this40 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {});

      for (var _n71 of _this40.callbacks) {
        yield _n71.onBatchBegin(e, t);
      }
    })();
  }

  onBatchEnd(e, t) {
    var _this41 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {});

      for (var _n72 of _this41.callbacks) {
        yield _n72.onBatchEnd(e, t);
      }
    })();
  }

  onTrainBegin(e) {
    var _this42 = this;

    return _asyncToGenerator(function* () {
      null == e && (e = {});

      for (var _t109 of _this42.callbacks) {
        yield _t109.onTrainBegin(e);
      }
    })();
  }

  onTrainEnd(e) {
    var _this43 = this;

    return _asyncToGenerator(function* () {
      null == e && (e = {});

      for (var _t110 of _this43.callbacks) {
        yield _t110.onTrainEnd(e);
      }
    })();
  }

}

class $h extends vh {
  constructor() {
    super();
  }

  onEpochBegin(e) {
    var _this44 = this;

    return _asyncToGenerator(function* () {
      _this44.seen = 0, _this44.totals = {};
    })();
  }

  onBatchEnd(e, t) {
    var _this45 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {});
      var n = null == t.size ? 0 : t.size;
      _this45.seen += n;

      var _loop12 = function _loop12(_e107) {
        var s = t[_e107];
        if ("number" == typeof s) _this45.totals.hasOwnProperty(_e107) || (_this45.totals[_e107] = 0), _this45.totals[_e107] = _this45.totals[_e107] + s * n;else {
          var _t111;

          _e107 in _this45.totals ? _t111 = _this45.totals[_e107] : _this45.totals[_e107] = 0;

          var _r45 = Jn(() => ts(_this45.totals[_e107], rs(s, n)));

          _this45.totals[_e107] = _r45, null != _t111 && _t111.dispose();
        }
      };

      for (var _e107 in t) {
        _loop12(_e107);
      }
    })();
  }

  onEpochEnd(e, t) {
    var _this46 = this;

    return _asyncToGenerator(function* () {
      if (null != t) {
        var _loop13 = function _loop13(_e108) {
          null != _this46.totals[_e108] && ("number" == typeof _this46.totals[_e108] ? t[_e108] = _this46.totals[_e108] / _this46.seen : Jn(() => {
            var n = rs(ss(1, _this46.seen), _this46.totals[_e108]);
            t[_e108] = n, _this46.totals[_e108].dispose(), Qn(t[_e108]);
          }));
        };

        for (var _e108 of _this46.params.metrics) {
          _loop13(_e108);
        }
      }
    })();
  }

}

class Sh extends vh {
  onTrainBegin(e) {
    var _this47 = this;

    return _asyncToGenerator(function* () {
      _this47.epoch = [], _this47.history = {};
    })();
  }

  onEpochEnd(e, t) {
    var _this48 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {}), _this48.epoch.push(e);

      for (var _e109 in t) {
        null == _this48.history[_e109] && (_this48.history[_e109] = []), _this48.history[_e109].push(t[_e109]);
      }
    })();
  }

  syncData() {
    var _this49 = this;

    return _asyncToGenerator(function* () {
      var e = [],
          t = [],
          n = [];

      for (var _s63 in _this49.history) {
        var _r46 = _this49.history[_s63];

        for (var _a38 = 0; _a38 < _r46.length; ++_a38) {
          "number" != typeof _r46[_a38] && (e.push(_r46[_a38].data()), t.push(_s63), n.push(_a38));
        }
      }

      var s = yield Promise.all(e);

      for (var _e110 = 0; _e110 < s.length; ++_e110) {
        _this49.history[t[_e110]][n[_e110]].dispose(), _this49.history[t[_e110]][n[_e110]] = s[_e110][0];
      }
    })();
  }

}

class Nh extends vh {
  constructor(e, t) {
    if (super(), this.currentEpoch = 0, this.yieldEvery = t || "auto", "auto" === this.yieldEvery && (this.yieldEvery = 125), "never" === this.yieldEvery && null != e.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
    C(this.yieldEvery) && (this.maybeWait = function (e, t) {
      var n,
          s = Ge();
      return function () {
        var a = Ge();
        return a - s < t || (s = a, n = e(...arguments)), n;
      };
    }(this.maybeWait.bind(this), this.yieldEvery)), this.trainBegin = e.onTrainBegin, this.trainEnd = e.onTrainEnd, this.epochBegin = e.onEpochBegin, this.epochEnd = e.onEpochEnd, this.batchBegin = e.onBatchBegin, this.batchEnd = e.onBatchEnd, this.yield = e.onYield;
  }

  maybeWait(e, t, n) {
    var _this50 = this;

    return _asyncToGenerator(function* () {
      var s = [];
      null != _this50.yield && (yield yh(n), s.push(_this50.yield(e, t, n))), s.push(Co()), yield Promise.all(s);
    })();
  }

  onEpochBegin(e, t) {
    var _this51 = this;

    return _asyncToGenerator(function* () {
      _this51.currentEpoch = e, null != _this51.epochBegin && (yield yh(t), yield _this51.epochBegin(e, t));
    })();
  }

  onEpochEnd(e, t) {
    var _this52 = this;

    return _asyncToGenerator(function* () {
      var n = [];
      null != _this52.epochEnd && (yield yh(t), n.push(_this52.epochEnd(e, t))), "epoch" === _this52.yieldEvery && n.push(Co()), yield Promise.all(n);
    })();
  }

  onBatchBegin(e, t) {
    var _this53 = this;

    return _asyncToGenerator(function* () {
      null != _this53.batchBegin && (yield yh(t), yield _this53.batchBegin(e, t));
    })();
  }

  onBatchEnd(e, t) {
    var _this54 = this;

    return _asyncToGenerator(function* () {
      var n = [];
      null != _this54.batchEnd && (yield yh(t), n.push(_this54.batchEnd(e, t))), "batch" === _this54.yieldEvery ? n.push(Co()) : C(_this54.yieldEvery) && n.push(_this54.maybeWait(_this54.currentEpoch, e, t)), yield Promise.all(n);
    })();
  }

  onTrainBegin(e) {
    var _this55 = this;

    return _asyncToGenerator(function* () {
      null != _this55.trainBegin && (yield yh(e), yield _this55.trainBegin(e));
    })();
  }

  onTrainEnd(e) {
    var _this56 = this;

    return _asyncToGenerator(function* () {
      null != _this56.trainEnd && (yield yh(e), yield _this56.trainEnd(e));
    })();
  }

}

function Ch(e, t) {
  return null == e && (e = {}), e instanceof vh ? [e] : Array.isArray(e) && e[0] instanceof vh ? e : Su(e).map(e => new Nh(e, t));
}

class Th {
  constructor() {}

  static registerCallbackConstructor(e, t) {
    l(e >= 0 && Number.isInteger(e), () => "Verbosity level is expected to be an integer >= 0, but got ".concat(e)), Th.checkForDuplicate(t), null == Th.constructors[e] && (Th.constructors[e] = []), Th.constructors[e].push(t);
  }

  static checkForDuplicate(e) {
    for (var _t112 in Th.constructors) {
      Th.constructors[+_t112].forEach(t => {
        if (t === e) throw new xu("Duplicate callback constructor.");
      });
    }
  }

  static clear() {
    Th.constructors = {};
  }

  static createCallbacks(e) {
    var t = [];

    for (var _n73 in Th.constructors) {
      var _s64 = +_n73;

      e >= _s64 && t.push(...Th.constructors[_s64]);
    }

    return t.map(e => new e());
  }

}

function Eh(e, t, n, s, r, a, i, o, l) {
  var u = new Sh(),
      c = [new $h(), ...Th.createCallbacks(t)];
  null != e && c.push(...e), c.push(u);
  var h = new Ih(c);
  return h.setParams({
    epochs: n,
    initialEpoch: s,
    samples: r,
    steps: a,
    batchSize: i,
    verbose: t,
    doValidation: o,
    metrics: l
  }), {
    callbackList: h,
    history: u
  };
}

function Rh(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return Au(e, jn.getMap().classNameMap, t, "layer", n);
}

function Ah(e, t) {
  return Jn(() => {
    "float32" !== e.dtype && (e = fn(e, "float32"));
    var n = Hr(Nc(e), t, !0),
        s = $r(n.shape, gu()),
        r = ci(la(n, s));
    return ss(e, r);
  });
}

function Fh(e, t) {
  return Jn(() => ua(Nc(Gr(t, e)), -1));
}

function Dh(e, t) {
  return Jn(() => ua(as(Gr(t, e)), -1));
}

function _h(e, t) {
  return Jn(() => {
    var n = Gr(e, t),
        s = Hs(as(e), gu(), Number.MAX_VALUE),
        r = as(ss(n, s));
    return rs(100, ua(r, -1));
  });
}

function Oh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return Jn(() => {
    if (n) t = ri(t);else {
      var _e111 = Hr(t, t.shape.length - 1, !0);

      t = ss(t, _e111);
    }
    return t = Hs(t, gu(), 1 - gu()), Pr(Hr(rs(fn(e, "float32"), Lr(t)), t.shape.length - 1));
  });
}

function Mh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return Jn(() => {
    var s = fn(Sr(function (e) {
      var t = [hc(e.shape)];
      return Rs(e, t);
    }(e)), "int32"),
        r = (t = Hs(t, gu(), 1 - gu())).shape;
    return Oh(Rs($n(s, r[r.length - 1]), r), t, n);
  });
}

function Lh(e, t) {
  return Jn(() => {
    var n;
    return n = Hs(t, gu(), 1 - gu()), n = Lr(ss(n, Gr(1, n))), ua(function (e, t) {
      if (!p(e.shape, t.shape)) throw new xu("logits and labels must have the same shape, but got shapes ".concat(JSON.stringify(e.shape), " and ").concat(JSON.stringify(t.shape)));
      return Jn(() => {
        var n = Va(t),
            s = Pr(as(t));
        return ts(Gr(n, rs(t, e)), zr(yr(s)));
      });
    }(e, n), -1);
  });
}

function zh(e, t) {
  return Jn(() => {
    var n = Ah(e, -1),
        s = Ah(t, -1),
        r = rs(n, s);
    return Pr(Hr(r, -1));
  });
}

Th.constructors = {};
var Bh = {
  meanSquaredError: Fh,
  meanAbsoluteError: Dh,
  meanAbsolutePercentageError: _h,
  meanSquaredLogarithmicError: function meanSquaredLogarithmicError(e, t) {
    return Jn(() => {
      var n = Hs(t, gu(), Number.MAX_VALUE),
          s = Lr(ts(1, n)),
          r = Hs(e, gu(), Number.MAX_VALUE),
          a = Lr(ts(1, r));
      return ua(Nc(Gr(s, a)), -1);
    });
  },
  squaredHinge: function squaredHinge(e, t) {
    return Jn(() => {
      var n = la(0, Gr(1, rs(e, t)));
      return ua(Nc(n), -1);
    });
  },
  hinge: function hinge(e, t) {
    return Jn(() => {
      var n = la(0, Gr(1, rs(e, t)));
      return ua(n, -1);
    });
  },
  categoricalHinge: function categoricalHinge(e, t) {
    return Jn(() => {
      var n = Hr(rs(e, t), -1),
          s = Vr(rs(Gr(1, e), t), -1);
      return la(0, ts(1, Gr(s, n)));
    });
  },
  logcosh: function logcosh(e, t) {
    return Jn(() => {
      var n = Math.log(2),
          s = Gr(t, e),
          r = Gr(ts(s, Wr(rs(-2, s))), n);
      return ua(r, -1);
    });
  },
  categoricalCrossentropy: Oh,
  sparseCategoricalCrossentropy: Mh,
  binaryCrossentropy: Lh,
  kullbackLeiblerDivergence: function kullbackLeiblerDivergence(e, t) {
    return Jn(() => {
      var n = Hs(e, gu(), 1),
          s = Hs(t, gu(), 1);
      return Hr(rs(e, Lr(ss(n, s))), -1);
    });
  },
  poisson: function poisson(e, t) {
    return Jn(() => {
      var n = Lr(ts(gu(), t));
      return ua(Gr(t, rs(e, n)), -1);
    });
  },
  cosineProximity: zh
};

function Ph(e) {
  if ("string" == typeof e) {
    if (e in Bh) return Bh[e];

    var _t113 = "Unknown loss ".concat(e);

    throw e.toLowerCase().includes("softmaxcrossentropy") && (_t113 = "Unknown loss ".concat(e, ". Use \"categoricalCrossentropy\" as the string name for tf.losses.softmaxCrossEntropy")), new xu(_t113);
  }

  return e;
}

function Wh(e, t) {
  return Jn(() => {
    var n = rs(.5, ya(t)),
        s = gc(Cr(t, n), e.dtype);
    return ua(dr(e, s), -1);
  });
}

function Uh(e, t) {
  return Jn(() => gc(dr(cs(e, -1), cs(t, -1)), "float32"));
}

function Vh(e, t) {
  return Lh(e, t);
}

function Gh(e, t) {
  return e.rank === t.rank && (e = di(e, [e.rank - 1])), (t = cs(t, -1)).dtype !== e.dtype && (t = fn(t, e.dtype)), fn(dr(e, t), "float32");
}

var Hh = Oh,
    qh = Mh,
    jh = {
  binaryAccuracy: Wh,
  categoricalAccuracy: Uh,
  precision: function precision(e, t) {
    return Jn(() => {
      var n = function (e, t) {
        return Jn(() => fn(Hr(na(dr(e, 1), dr(t, 1))), "float32"));
      }(e, t),
          s = function (e, t) {
        return Jn(() => fn(Hr(na(dr(e, 0), dr(t, 1))), "float32"));
      }(e, t),
          r = ts(n, s);

      return fn(pr(Cr(r, 0), ss(n, r), 0), "float32");
    });
  },
  categoricalCrossentropy: Hh,
  sparseCategoricalCrossentropy: qh,
  mse: Fh,
  MSE: Fh,
  mae: Dh,
  MAE: Dh,
  mape: _h,
  MAPE: _h,
  cosine: zh
};

function Kh(e) {
  if ("string" == typeof e && e in jh) return jh[e];
  if ("string" != typeof e && null != e) return e;
  throw new xu("Unknown metric ".concat(e));
}

function Xh(e) {
  if (vu(null !== e, "Unknown LossOrMetricFn ".concat(e)), "string" == typeof e) return e;
  {
    var _t114;

    for (var _n74 of Object.keys(Bh)) {
      if (Bh[_n74] === e) {
        _t114 = _n74;
        break;
      }
    }

    if (void 0 !== _t114) return _t114;

    for (var _n75 of Object.keys(jh)) {
      if (jh[_n75] === e) {
        _t114 = _n75;
        break;
      }
    }

    return void 0 !== _t114 ? _t114 : e.name;
  }
}

function Yh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  if (null == e || "object" != typeof e || Object.getPrototypeOf(e) !== Object.prototype || !Jh(e)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");

  if (n) {
    var _n76 = JSON.stringify(e);

    _n76.length > 1048576 && console.warn("User-defined metadata of model \"".concat(t, "\" is too large in size (length=").concat(_n76.length, " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576."));
  }
}

function Jh(e) {
  if (null === e) return !0;

  if ("object" == typeof e) {
    if (Object.getPrototypeOf(e) === Object.prototype) {
      var _t115 = Object.keys(e);

      for (var _n77 of _t115) {
        if ("string" != typeof _n77) return !1;
        if (!Jh(e[_n77])) return !1;
      }

      return !0;
    }

    if (Array.isArray(e)) {
      for (var _t116 of e) {
        if (!Jh(_t116)) return !1;
      }

      return !0;
    }

    return !1;
  }

  {
    var _t117 = typeof e;

    return "string" === _t117 || "number" === _t117 || "boolean" === _t117;
  }
}

function Zh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;
  var s = "";

  for (var _n78 = 0; _n78 < e.length; ++_n78) {
    _n78 > 0 && (s = s.slice(0, s.length - 1) + " "), s += e[_n78], s = s.slice(0, t[_n78]), s += " ".repeat(t[_n78] - s.length);
  }

  n(s);
}

function Qh(e, t, n) {
  var s;

  try {
    s = JSON.stringify(e.outputShape);
  } catch (e) {
    s = "multiple";
  }

  Zh(["".concat(e.name, " (").concat(e.getClassName(), ")"), s, e.countParams().toString()], t, n);
}

function ed(e, t, n, s) {
  var r;

  try {
    r = JSON.stringify(e.outputShape);
  } catch (e) {
    r = "multiple";
  }

  var a = [];

  for (var _t118 of e.inboundNodes) {
    if (!(null != n && n.length > 0 && -1 === n.indexOf(_t118))) for (var _e112 = 0; _e112 < _t118.inboundLayers.length; ++_e112) {
      a.push("".concat(_t118.inboundLayers[_e112].name, "[").concat(_t118.nodeIndices[_e112], "][").concat(_t118.tensorIndices[_e112], "]"));
    }
  }

  var i = e.name,
      o = e.getClassName(),
      l = 0 === a.length ? "" : a[0];
  Zh(["".concat(i, " (").concat(o, ")"), r, e.countParams().toString(), l], t, s);

  for (var _e113 = 1; _e113 < a.length; ++_e113) {
    Zh(["", "", "", a[_e113]], t, s);
  }
}

function td(e, t, n) {
  return ("inboundNodes" === e || "outputLayers" === e || "inputLayers" === e) && 0 === t && "string" == typeof n;
}

function nd(e, t) {
  if (null === e) return null;
  if ("string" == typeof e) return Cu(e);
  if ("number" == typeof e || "boolean" == typeof e) return e;

  if (e instanceof Array) {
    var _n79 = [],
        _s65 = e.length;

    for (var _r47 = 0; _r47 < _s65; ++_r47) {
      var _s66 = e[_r47];
      td(t, _r47, _s66) ? _n79.push(_s66) : _n79.push(nd(_s66, t));
    }

    return _n79;
  }

  {
    var _t119 = {};

    for (var _n80 of Object.keys(e)) {
      var _s67 = e[_n80];
      if ("name" === _n80 && "string" == typeof _s67) _t119[_n80] = _s67;else {
        var _e114 = Cu(_n80);

        _t119[_e114] = nd(_s67, _e114);
      }
    }

    return _t119;
  }
}

function sd(e, t) {
  if (null == e) return null;
  if ("string" == typeof e) return Nu(e);
  if ("number" == typeof e || "boolean" == typeof e) return e;

  if (e instanceof Array) {
    var _n81 = [],
        _s68 = e.length;

    for (var _r48 = 0; _r48 < _s68; ++_r48) {
      var _s69 = e[_r48];
      td(t, _r48, _s69) ? _n81.push(_s69) : _n81.push(sd(_s69, t));
    }

    return _n81;
  }

  {
    var _t120 = {};

    for (var _n82 of Object.keys(e)) {
      var _s70 = e[_n82];
      _t120[Nu(_n82)] = "name" !== _n82 && "className" !== _n82 || "string" != typeof _s70 ? sd(_s70, _n82) : _s70;
    }

    return _t120;
  }
}

class rd {
  constructor(e) {
    if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, e instanceof rd) for (var _t121 in e.id2Value) {
      this.id2Value[_t121] = e.id2Value[_t121], _t121 in e.id2Mask && (this.id2Mask[_t121] = e.id2Mask[_t121]);
    } else {
      if (null == e) return;

      for (var _t122 of e) {
        this.add(_t122.key, _t122.value);
      }
    }
  }

  add(e, t, n) {
    if (null != this.id2Value[e.id]) throw new xu("Duplicate key: name=".concat(e.name, ", id=").concat(e.id));
    return this.id2Value[e.id] = function (e, t) {
      if (null == e.dtype || e.dtype === t.dtype) return t;

      try {
        return fn(t, e.dtype);
      } catch (n) {
        throw new xu("The dtype of the feed (".concat(t.dtype, ") can not be cast to the dtype of the key '").concat(e.name, "' (").concat(e.dtype, ")."));
      }
    }(e, t), this.name2Id[e.name] = e.id, null != n && (this.id2Mask[e.id] = n), this;
  }

  addFeed(e) {
    this.add(e.key, e.value);
  }

  hasKey(e) {
    return null != this.id2Value[e.id];
  }

  names() {
    return Object.keys(this.name2Id);
  }

  getValue(e) {
    if (e instanceof dh) {
      if (null == this.id2Value[e.id]) throw new xu("Nonexistent key: ".concat(e.name));
      return this.id2Value[e.id];
    }

    {
      var _t123 = this.name2Id[e];
      if (null == _t123) throw new xu("Feed dict has no SymbolicTensor name: ".concat(e));
      return this.id2Value[_t123];
    }
  }

  getMask(e) {
    if (e instanceof dh) {
      if (null == this.id2Value[e.id]) throw new xu("Nonexistent key: ".concat(e.name));
      return this.id2Mask[e.id];
    }

    {
      var _t124 = this.name2Id[e];
      if (null == _t124) throw new xu("Feed dict has no SymbolicTensor name: ".concat(e));
      return this.id2Mask[_t124];
    }
  }

  disposeMasks() {
    null != this.id2Mask && Zn(this.id2Mask);
  }

}

var ad = {},
    id = {};

function od(e, t, n, s) {
  var r = null != n && n.training,
      a = Array.isArray(e),
      i = a ? e : [e],
      o = i.map(e => e.name),
      u = [],
      c = t.names();

  for (var _e115 of o) {
    -1 !== c.indexOf(_e115) ? u.push(t.getValue(_e115)) : u.push(null);
  }

  null != s && (s.maxNumTensors = -Infinity, s.minNumTensors = Infinity);
  var h = o.join(",") + "|" + t.names().join(",");
  var d, p;

  if (null == ad[h]) {
    var _e116 = function (e, t) {
      l(null != e && e.length > 0, () => "Expected at least one fetch, got none");
      var n = [],
          s = {};

      if (1 === e.length) {
        var _r49 = ud(e[0], t);

        n = _r49.sorted, s = _r49.recipientMap;
      } else {
        var _r50 = new Set();

        for (var _a39 of e) {
          var {
            sorted: _e117,
            recipientMap: _i22
          } = ud(_a39, t);

          for (var _t125 of _e117) {
            _r50.has(_t125.name) || (n.push(_t125), _r50.add(_t125.name));
          }

          var _loop14 = function _loop14(_e118) {
            null == s[_e118] && (s[_e118] = new Set()), _i22[_e118].forEach(t => s[_e118].add(t));
          };

          for (var _e118 in _i22) {
            _loop14(_e118);
          }
        }
      }

      return {
        sorted: n,
        recipientCounts: ld(s)
      };
    }(i, t);

    d = _e116.sorted, p = _e116.recipientCounts, ad[h] = d, id[h] = p;
  }

  d = ad[h], p = {}, r || Object.assign(p, id[h]);
  var f = new rd(t);

  for (var _e119 = 0; _e119 < d.length; ++_e119) {
    if (null != s) {
      var _e120 = Yn().numTensors;
      _e120 > s.maxNumTensors && (s.maxNumTensors = _e120), _e120 < s.minNumTensors && (s.minNumTensors = _e120);
    }

    var _a40 = d[_e119],
        _i23 = _a40.sourceLayer;
    if (_i23 instanceof xh) continue;
    var _l11 = [],
        _c6 = [],
        _h5 = [];

    var _g5 = !1;

    for (var _e121 of _a40.inputs) {
      var _n83 = f.getValue(_e121),
          _s71 = f.getMask(_e121);

      _l11.push(_n83), _c6.push(_s71), null != _s71 && (_g5 = !0), r || (p[_e121.name]--, 0 !== p[_e121.name] || t.hasKey(_e121) || -1 !== o.indexOf(_e121.name) || _n83.isDisposed || !0 === _e121.sourceLayer.stateful || _h5.push(_n83));
    }

    _g5 && ((n = n || {}).mask = _c6[0]);

    var _m4 = Su(_i23.apply(_l11, n));

    var _b4 = null;
    _i23.supportsMasking && (_b4 = _i23.computeMask(_l11, _c6));

    var _x20 = cd(_a40),
        _y4 = Array.isArray(_x20) ? _x20 : [_x20];

    for (var _e122 = 0; _e122 < _y4.length; ++_e122) {
      f.hasKey(_y4[_e122]) || f.add(_y4[_e122], _m4[_e122], Array.isArray(_b4) ? _b4[0] : _b4);

      var _t126 = o.indexOf(_y4[_e122].name);

      -1 !== _t126 && (u[_t126] = _m4[_e122]);
    }

    r || Zn(_h5);
  }

  return f.disposeMasks(), a ? u : u[0];
}

function ld(e) {
  var t = {};

  for (var _n84 in e) {
    t[_n84] = e[_n84].size;
  }

  return t;
}

function ud(e, t) {
  var n = new Set(),
      s = [],
      r = {};

  for (var _e123 of t.names()) {
    n.add(_e123);
  }

  var a = [],
      i = [];

  for (a.push(e); a.length > 0;) {
    var _e124 = a[a.length - 1];

    if (n.has(_e124.name)) {
      a.pop();
      continue;
    }

    var _t127 = i[i.length - 1] === a.length - 1;

    if (0 === _e124.inputs.length || _t127) a.pop(), s.push(_e124), n.add(_e124.name), _t127 && i.pop();else {
      i.push(a.length - 1);

      for (var _t128 of _e124.inputs) {
        null == r[_t128.name] && (r[_t128.name] = new Set()), r[_t128.name].add(_e124.name), n.has(_t128.name) || a.push(_t128);
      }
    }
  }

  return {
    sorted: s,
    recipientMap: r
  };
}

function cd(e) {
  var t;
  if (1 === e.sourceLayer.inboundNodes.length) t = e.sourceLayer.output;else {
    var _n85 = null;

    for (var _t129 = 0; _t129 < e.sourceLayer.inboundNodes.length; ++_t129) {
      for (var _s72 of e.sourceLayer.inboundNodes[_t129].outputTensors) {
        if (_s72.id === e.id) {
          _n85 = _t129;
          break;
        }
      }
    }

    t = e.sourceLayer.getOutputAt(_n85);
  }
  return t;
}

class hd extends mh {
  constructor(e) {
    if (super({}), this.containerNodes = new Set(), this.name = e.name, null == this.name) {
      var _e125 = this.getClassName().toLowerCase();

      this.name = nh(_e125);
    }

    if (this.supportsMasking = !1, this.trainable_ = !0, this.inputs = Array.isArray(e.inputs) ? e.inputs.slice() : [e.inputs], this.outputs = Array.isArray(e.outputs) ? e.outputs.slice() : [e.outputs], Du(this.inputs).length !== this.inputs.length) throw new xu("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ".concat(this.inputs.map(e => e.name)));
    Du(this.outputs).length !== this.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ".concat(this.outputs.map(e => e.name))), this.inputLayers = [], this.inputLayersNodeIndices = [], this.inputLayersTensorIndices = [], this.outputLayers = [], this.outputLayersNodeIndices = [], this.outputLayersTensorIndices = [], this.layers = [], this.internalContainerRefs = [];

    for (var _e126 of this.outputs) {
      var _t130 = _e126.nodeIndex,
          _n86 = _e126.tensorIndex;
      this.outputLayers.push(_e126.sourceLayer), this.outputLayersNodeIndices.push(_t130), this.outputLayersTensorIndices.push(_n86);
    }

    for (var _e127 of this.inputs) {
      var _t131 = _e127.sourceLayer,
          _n87 = _e127.nodeIndex,
          _s73 = _e127.tensorIndex;
      vu(0 === _n87, "input layer has >1 nodes"), vu(0 === _s73, "input layer has >1 tensors"), this.inputLayers.push(_t131), this.inputLayersNodeIndices.push(_n87), this.inputLayersTensorIndices.push(_s73);
    }

    this.inputNames = [], this.outputNames = [], this.feedInputShapes = [], this.feedInputNames = [], this.feedOutputNames = [];

    for (var _t132 = 0; _t132 < this.inputLayers.length; _t132++) {
      var _n88 = this.inputLayers[_t132];
      if (!(_n88 instanceof xh)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: ".concat(e.inputs, ". Input ").concat(_t132, " (0-based) originates from layer type ").concat(_n88.getClassName(), "."));
      this.inputNames.push(_n88.name), this.feedInputShapes.push(_n88.batchInputShape), this.feedInputNames.push(_n88.name);
    }

    for (var _e128 of this.outputLayers) {
      this.outputNames.push(_e128.name);
    }

    this.internalInputShapes = this.inputs.map(e => e.shape), this.internalOutputShapes = this.outputs.map(e => e.shape);

    var t = {},
        n = {},
        s = {},
        r = {},
        a = {},
        i = [],
        o = (e, t, n, s, r, l) => {
      null != s && null != r && null != l || (s = e.sourceLayer, r = e.nodeIndex, l = e.tensorIndex);
      var u = s.inboundNodes[r];
      if (-1 !== n.indexOf(u)) throw new bu("The tensor ".concat(e.name, " at layer \"").concat(s.name, "\" is part of a cycle."));
      if (-1 !== t.indexOf(u)) return;
      this.containerNodes.add(hd.nodeKey(s, r)), s.id in a || (a[s.id] = Object.keys(a).length), -1 === n.indexOf(u) && n.push(u);
      var c = u.inboundLayers.length;

      for (var _e129 = 0; _e129 < c; _e129++) {
        o(u.inputTensors[_e129], t, n, u.inboundLayers[_e129], u.nodeIndices[_e129], u.tensorIndices[_e129]);
      }

      for (t.push(u); n.indexOf(u) >= 0;) {
        n.splice(n.indexOf(u), 1);
      }

      i.push(u);
    },
        l = [],
        u = [];

    for (var _e130 of this.outputs) {
      o(_e130, l, u);
    }

    var c = i.slice().reverse();

    for (var _e131 of c) {
      n[_e131.id] = _e131, _e131.id in t || (t[_e131.id] = 0);
      var _a41 = t[_e131.id];
      _a41 = Math.max(_a41, null == s[_e131.outboundLayer.id] ? 0 : s[_e131.outboundLayer.id]), s[_e131.outboundLayer.id] = _a41, r[_e131.outboundLayer.id] = _e131.outboundLayer, t[_e131.id] = _a41;

      for (var _s74 = 0; _s74 < _e131.inboundLayers.length; _s74++) {
        var _r51 = _e131.inboundLayers[_s74].inboundNodes[_e131.nodeIndices[_s74]];
        t[_r51.id] = Math.max(_a41 + 1, null == t[_r51.id] ? 0 : t[_r51.id]), n[_r51.id] = _r51;
      }
    }

    var h = {};

    for (var _e132 in t) {
      var _s75 = t[_e132];
      _s75 in h || (h[_s75] = []), h[_s75].push(n[_e132]);
    }

    var d = {};

    for (var _e133 in s) {
      var _t133 = s[_e133];
      _t133 in d || (d[_t133] = []), d[_t133].push(r[_e133]);
    }

    var p = Object.keys(d).map(e => parseInt(e, 10)).sort(Fu);
    this.layers = [];

    for (var _e134 of p) {
      var _t134 = d[_e134];

      _t134.sort((e, t) => {
        var n = a[e.id],
            s = a[t.id];
        return n < s ? -1 : n > s ? 1 : 0;
      });

      for (var _e135 of _t134) {
        _e135 instanceof hd && this.internalContainerRefs.push(_e135), this.layers.push(_e135);
      }
    }

    this.layersByDepth = d, p = Object.keys(h).map(e => parseInt(e, 10)).sort(Fu);
    var f = this.inputs.slice(),
        g = [];

    for (var _e136 of p) {
      for (var _t135 of h[_e136]) {
        var _e137 = _t135.outboundLayer;

        if (null != _e137) {
          for (var _n89 of _t135.inputTensors) {
            if (-1 === f.indexOf(_n89)) throw new bu("Graph disconnected: cannot obtain value for tensor ".concat(_n89, " at layer \"").concat(_e137.name, "\". The following previous layers were accessed without issue: ").concat(g));
          }

          for (var _e138 of _t135.outputTensors) {
            f.push(_e138);
          }

          g.push(_e137.name);
        }
      }
    }

    this.nodesByDepth = h;
    var m = this.layers.map(e => e.name);

    var _loop15 = function _loop15(_e139) {
      var t = m.filter(t => t === _e139).length;
      if (1 !== t) throw new bu("The name \"".concat(_e139, "\" is used ").concat(t, " times in the model. All layer names should be unique. Layer names: ") + JSON.stringify(m));
    };

    for (var _e139 of m) {
      _loop15(_e139);
    }

    this.outboundNodes = [], this.inboundNodes = [], new fh({
      outboundLayer: this,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: this.inputs,
      outputTensors: this.outputs,
      inputMasks: this.inputs.map(e => null),
      outputMasks: this.outputs.map(e => null),
      inputShapes: this.inputs.map(e => e.shape),
      outputShapes: this.outputs.map(e => e.shape)
    }), this.built = !0, this._refCount = 1;
  }

  assertNotDisposed() {
    if (0 === this._refCount) throw new Error("Container '".concat(this.name, "' is already disposed."));
  }

  dispose() {
    this.assertNotDisposed();
    var e = {
      refCountAfterDispose: null,
      numDisposedVariables: 0
    };

    if (0 == --this._refCount) {
      for (var _t136 of this.layers) {
        e.numDisposedVariables += _t136.dispose().numDisposedVariables;
      }

      for (var _t137 of this.internalContainerRefs) {
        e.numDisposedVariables += _t137.dispose().numDisposedVariables;
      }
    }

    return e.refCountAfterDispose = this._refCount, e;
  }

  get trainable() {
    return this.trainable_;
  }

  set trainable(e) {
    this.layers.forEach(t => {
      t._trainableWeights.forEach(t => t.trainable = e);
    }), this.trainable_ = e;
  }

  get trainableWeights() {
    if (this._trainableWeights.length > 0) throw new xu("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
    if (!this.trainable) return [];
    var e = [];

    for (var _t138 of this.layers) {
      e = e.concat(_t138.trainableWeights);
    }

    return e;
  }

  get nonTrainableWeights() {
    var e = [];

    for (var _t139 of this.layers) {
      e.push(..._t139.nonTrainableWeights);
    }

    if (!this.trainable) {
      var _t140 = [];

      for (var _e140 of this.layers) {
        _t140.push(..._e140.trainableWeights);
      }

      return _t140.concat(e);
    }

    return e;
  }

  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }

  loadWeights(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    var n = {};
    var s = 0;

    for (var _e141 of this.layers) {
      for (var _t141 of _e141.weights) {
        if (null != n[_t141.originalName]) throw new xu("Duplicate weight name: ".concat(_t141.originalName));
        n[_t141.originalName] = _t141, s++;
      }
    }

    var r = [];

    for (var _s76 in e) {
      var _a42 = _s76;

      if (null == n[_s76]) {
        var _e142 = _s76.split("/");

        _a42 = _e142.slice(0, -2).concat([_e142[_e142.length - 1]]).join("/");
      }

      if (null != n[_a42]) r.push([n[_a42], e[_s76]]);else if (t) throw new xu("Provided weight data has no target variable: ".concat(_s76));
      delete n[_a42];
    }

    if (t) {
      var _e143 = [];

      for (var _t142 in n) {
        _e143.push(_t142);
      }

      if (_e143.length > 0) throw new xu("".concat(_e143.length, " of ").concat(s, " weights are not set: ").concat(_e143));
    }

    ch(r);
  }

  updatedConfig() {
    var e = this.getConfig(),
        t = {};
    return t.className = this.getClassName(), t.config = e, t.kerasVersion = "tfjs-layers 3.9.0", t.backend = "TensorFlow.js", t;
  }

  toJSON(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    var n = sd(this.updatedConfig());
    return t ? JSON.stringify(n) : n;
  }

  call(e, t) {
    return Jn(() => {
      e = Su(e);
      var n = new rd();

      for (var _t143 = 0; _t143 < this.inputs.length; ++_t143) {
        n.add(this.inputs[_t143], e[_t143]);
      }

      return od(this.outputs, n, t);
    });
  }

  computeMask(e, t) {
    return Jn(() => {
      var n;
      return e = Su(e), n = null == t ? wu(null, e.length) : Su(t), this.runInternalGraph(e, n)[1];
    });
  }

  computeOutputShape(e) {
    var t = rh(e);
    if (t.length !== this.inputLayers.length) throw new xu("Invalid inputShape argument ".concat(e, ": model has ").concat(this.inputLayers.length, " tensor inputs."));
    var n = {};

    for (var _e144 = 0; _e144 < t.length; _e144++) {
      n[this.inputLayers[_e144].name + "_0_0"] = t[_e144];
    }

    var s = Object.keys(this.nodesByDepth).map(e => parseInt(e, 10)).sort(Fu);
    if (s.length > 1) for (var _e145 of s) {
      var _t144 = this.nodesByDepth[_e145];

      for (var _e146 of _t144) {
        var _t145 = _e146.outboundLayer;
        if (-1 !== this.inputLayers.map(e => e.id).indexOf(_t145.id)) continue;
        var _s77 = [];

        for (var _t146 = 0; _t146 < _e146.inboundLayers.length; _t146++) {
          _s77.push(n["".concat(_e146.inboundLayers[_t146].name, "_").concat(_e146.nodeIndices[_t146], "_").concat(_e146.tensorIndices[_t146])]);
        }

        var _r52 = rh(_t145.computeOutputShape($u(_s77))),
            _a43 = _t145.inboundNodes.indexOf(_e146);

        for (var _e147 = 0; _e147 < _r52.length; _e147++) {
          n["".concat(_t145.name, "_").concat(_a43, "_").concat(_e147)] = _r52[_e147];
        }
      }
    }
    var r = [],
        a = [];

    for (var _e148 = 0; _e148 < this.outputLayers.length; _e148++) {
      a.push("".concat(this.outputLayers[_e148].name, "_").concat(this.outputLayersNodeIndices[_e148], "_").concat(this.outputLayersTensorIndices[_e148]));
    }

    for (var _e149 = 0; _e149 < a.length; _e149++) {
      var _t147 = a[_e149];
      vu(_t147 in n), r.push(n[_t147]);
    }

    return $u(r);
  }

  runInternalGraph(e, t) {
    null == t && (t = wu(null, e.length));
    var n = {};

    for (var _s78 = 0; _s78 < this.inputs.length; ++_s78) {
      n[this.inputs[_s78].id] = [e[_s78], t[_s78]];
    }

    var s = Object.keys(this.nodesByDepth).map(e => parseInt(e, 10)).sort(Fu);

    for (var _e150 of s) {
      var _t148 = this.nodesByDepth[_e150];

      for (var _e151 of _t148) {
        var _t149 = _e151.outboundLayer,
            _s79 = _e151.inputTensors,
            _r53 = _e151.outputTensors,
            _a44 = new Array();

        for (var _e152 of _s79) {
          _e152.id in n && _a44.push(n[_e152.id]);
        }

        if (_a44.length === _s79.length) {
          var _s80 = void 0,
              _i24 = void 0,
              _o18 = void 0,
              _l12 = void 0,
              _u7 = {};

          if (null != _e151.callArgs && (_u7 = _e151.callArgs), 1 === _a44.length) {
            var [_e153, _n90] = _a44[0];
            null == _u7.mask && (_u7.mask = _n90), _o18 = Su(_t149.call(_e153, _u7)), _l12 = Su(_t149.computeMask(_e153, _n90)), _s80 = [_e153], _i24 = [_n90];
          } else _s80 = _a44.map(e => e[0]), _i24 = _a44.map(e => e[1]), null == _u7.mask && (_u7.mask = _i24), _o18 = Su(_t149.call(_s80, _u7)), _l12 = Su(_t149.computeMask(_s80, _i24));

          if (_t149.activityRegularizer) throw new yu("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");

          for (var _e154 = 0; _e154 < _r53.length; ++_e154) {
            n[_r53[_e154].id] = [_o18[_e154], _l12[_e154]];
          }
        }
      }
    }

    var r = [],
        a = [],
        i = [];

    for (var _e155 of this.outputs) {
      vu(_e155.id in n, "Could not compute output ".concat(_e155.name, " : ").concat(_e155.id));
      var [_t150, _s81] = n[_e155.id];
      i.push(_t150.shape), r.push(_t150), a.push(_s81);
    }

    return [r, a, i];
  }

  buildNodeConversionMap(e) {
    var t = {};
    var n;

    for (var _e156 of this.layers) {
      n = _e156 instanceof hd ? 1 : 0;

      for (var _s82 = 0; _s82 < _e156.inboundNodes.length; _s82++) {
        var _r54 = hd.nodeKey(_e156, _s82);

        this.containerNodes.has(_r54) && (t[_r54] = n, n += 1);
      }
    }

    return t;
  }

  getLayer(e, t) {
    if (null != t) {
      if (this.layers.length <= t) throw new xu("Was asked to retrieve layer at index ".concat(t, ", but model only has ").concat(this.layers.length, " layer(s)."));
      return this.layers[t];
    }

    if (null == e) throw new xu("Provide either a layer name or layer index");

    for (var _t151 of this.layers) {
      if (_t151.name === e) return _t151;
    }

    throw new xu("No such layer: ".concat(e));
  }

  calculateLosses() {
    return Jn(() => {
      var e = [];

      for (var _t152 of this.layers) {
        for (var _n91 = 0; _n91 < _t152.inboundNodes.length; ++_n91) {
          var _s83 = hd.nodeKey(_t152, _n91);

          this.containerNodes.has(_s83) && e.push(..._t152.calculateLosses());
        }
      }

      return e;
    });
  }

  getConfig() {
    var e = {
      name: this.name
    },
        t = this.buildNodeConversionMap(this.layers),
        n = [];

    for (var _e157 of this.layers) {
      var _s84 = _e157.getClassName(),
          _r55 = _e157.getConfig(),
          _a45 = [];

      for (var _n92 = 0; _n92 < _e157.inboundNodes.length; _n92++) {
        var _s85 = _e157.inboundNodes[_n92],
            _r56 = hd.nodeKey(_e157, _n92);

        var _i26 = {};

        if (this.containerNodes.has(_r56)) {
          if (_s85.callArgs) try {
            JSON.stringify(_s85.callArgs), _i26 = _s85.callArgs;
          } catch (t) {
            console.warn("Layer ".concat(_e157.name, " was passed non-serializable keyword arguments: ").concat(_s85.callArgs, ". They will not be included in the serialized model (and thus will be missing at deserialization time).")), _i26 = {};
          }

          if (_s85.inboundLayers.length > 0) {
            var _e158 = [];

            for (var _n93 = 0; _n93 < _s85.inboundLayers.length; _n93++) {
              var _r57 = _s85.inboundLayers[_n93],
                  _a46 = _s85.tensorIndices[_n93];
              var _o19 = t[hd.nodeKey(_r57, _s85.nodeIndices[_n93])];
              null == _o19 && (_o19 = 0), _e158.push([_r57.name, _o19, _a46, _i26]);
            }

            _a45.push(_e158);
          }
        }
      }

      var _i25 = {};
      _i25.name = _e157.name, _i25.className = _s84, _i25.config = _r55, _i25.inboundNodes = _a45, n.push(_i25);
    }

    e.layers = n;
    var s = [];

    for (var _e159 = 0; _e159 < this.inputLayers.length; _e159++) {
      var _n94 = this.inputLayers[_e159],
          _r58 = hd.nodeKey(_n94, this.inputLayersNodeIndices[_e159]);

      if (!this.containerNodes.has(_r58)) continue;
      var _a47 = t[_r58];
      null == _a47 && (_a47 = 0), s.push([_n94.name, _a47, this.inputLayersTensorIndices[_e159]]);
    }

    e.inputLayers = s;
    var r = [];

    for (var _e160 = 0; _e160 < this.outputLayers.length; _e160++) {
      var _n95 = this.outputLayers[_e160],
          _s86 = hd.nodeKey(_n95, this.outputLayersNodeIndices[_e160]);

      if (!this.containerNodes.has(_s86)) continue;
      var _a48 = t[_s86];
      null == _a48 && (_a48 = 0), r.push([_n95.name, _a48, this.outputLayersTensorIndices[_e160]]);
    }

    return e.outputLayers = r, e;
  }

  static fromConfig(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = {},
        a = {};

    function i(e, t) {
      e.name in a ? a[e.name].push(t) : a[e.name] = [t];
    }

    function o(e, t) {
      var n = [];
      var s;

      for (var _a49 of t) {
        var _o20 = _a49[0],
            _l13 = _a49[1],
            _u8 = _a49[2];
        if (s = null == _a49[3] ? {} : _a49[3], !(_o20 in r)) return void i(e, t);
        var _c7 = r[_o20];
        if (_c7.inboundNodes.length <= _l13) return void i(e, t);
        n.push(_c7.inboundNodes[_l13].outputTensors[_u8]);
      }

      n.length > 0 && e.apply($u(n), s);
    }

    function l(e) {
      var n = e.name,
          a = Rh(e, null != t.customObjects ? t.customObjects : {});
      a.setFastWeightInitDuringBuild(s), r[n] = a, e.inboundNodes.forEach(e => {
        if (!(e instanceof Array)) throw new xu("Corrupted configuration, expected array for nodeData: ".concat(e));
        i(a, e);
      });
    }

    var u = t.name,
        c = t.layers;

    for (var _e161 of c) {
      l(_e161);
    }

    for (; !_u(a);) {
      for (var _e162 of c) {
        var _t153 = r[_e162.name];

        if (_t153.name in a) {
          var _e163 = a[_t153.name];
          delete a[_t153.name];

          for (var _n96 of _e163) {
            o(_t153, _n96);
          }
        }
      }
    }

    var h = [],
        d = [],
        p = t.inputLayers;

    for (var _e164 of p) {
      var _t154 = _e164[0],
          _n97 = _e164[1],
          _s87 = _e164[2];
      vu(_t154 in r), h.push(r[_t154].inboundNodes[_n97].outputTensors[_s87]);
    }

    var f = t.outputLayers;

    for (var _e165 of f) {
      var _t155 = _e165[0],
          _n98 = _e165[1],
          _s88 = _e165[2];
      vu(_t155 in r), d.push(r[_t155].inboundNodes[_n98].outputTensors[_s88]);
    }

    return new e({
      inputs: h,
      outputs: d,
      name: u
    });
  }

  get stateful() {
    if (this._stateful) throw new xu("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");

    for (var _e166 of this.layers) {
      if (_e166.stateful) return !0;
    }

    return !1;
  }

  resetStates() {
    Jn(() => {
      this.layers.forEach(e => {
        e.stateful && e.resetStates();
      });
    });
  }

}

function dd(e, t) {
  return function (e, t, n) {
    var s = t.length;
    if (null == e || Array.isArray(e) && 0 === e.length) return t.map(e => null);
    if (1 === s) return Array.isArray(e) && 1 === e.length ? e : "object" == typeof e && t[0] in e ? [e[t[0]]] : [e];

    if (Array.isArray(e)) {
      if (e.length !== s) throw new Error("Provided classWeight is an array of ".concat(e.length, " element(s), but the model has ").concat(s, " outputs. Make sure a set of weights is provided for each model output."));
      return e;
    }

    if ("object" == typeof e && Object.keys(e).length > 0 && "object" == typeof e[Object.keys(e)[0]]) {
      var _n99 = [];
      return t.forEach(t => {
        _n99.push(t in e ? e[t] : null);
      }), _n99;
    }

    throw new Error("The model has multiple (".concat(s, ") outputs, so classWeight must be either an array with ").concat(s, " elements or an object with ").concat(t, " keys. Provided classWeight not understood: ").concat(JSON.stringify(e)));
  }(e, t);
}

function pd(_x21, _x22, _x23, _x24) {
  return _pd.apply(this, arguments);
}

function _pd() {
  _pd = _asyncToGenerator(function* (e, t, n, s) {
    if (null != t || null != s) throw new Error("Support sampleWeight is not implemented yet");

    if (null != n) {
      var _t430 = Jn(() => {
        if (1 === e.shape.length) return gn(e);

        if (2 === e.shape.length) {
          if (e.shape[1] > 1) return cs(e, 1);
          if (1 === e.shape[1]) return Rs(e, [e.shape[0]]);
          throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1], ") during handling of class weights. The size is expected to be >= 1."));
        }

        throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank, ") during handling of class weights. The rank is expected to be 1 or 2."));
      }),
          _s244 = Array.from(yield _t430.data());

      Zn(_t430);
      var _r177 = [];
      return _s244.forEach(e => {
        if (null == n[e]) throw new Error("classWeight must contain all classes in the training data. The class ".concat(e, " exists in the data but not in classWeight"));

        _r177.push(n[e]);
      }), bi(_r177, "float32");
    }

    return null;
  });
  return _pd.apply(this, arguments);
}

function fd(e, t) {
  return rs(e, t);
}

function gd(e, t) {
  var n, s;
  n = t.xs, s = t.ys, l(null != n && null != s, () => "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ".concat(t));
  var r = md("input", e.inputNames, n),
      a = md("output", e.outputNames, s),
      i = r[0].shape[0];
  l(r.length === e.inputs.length, () => "LayersModel has ".concat(e.inputs.length, " inputs, but the dataset provides ").concat(r.length, " inputs.  (Expected input keys: ").concat(JSON.stringify(e.inputNames), ")")), l(a.length === e.outputs.length, () => "LayersModel has ".concat(e.outputs.length, " outputs, but the dataset provides ").concat(a.length, " outputs.  (Expected output keys: ").concat(JSON.stringify(e.outputNames), ")"));

  var _loop16 = function _loop16(_t156) {
    l(r[_t156].shape[0] === i, () => "Batch size mismatch: input ".concat(e.inputNames[_t156], " has ").concat(r[_t156].shape[0], "; expected  ").concat(i, " based on input ").concat(e.inputNames[0], "."));
  };

  for (var _t156 = 0; _t156 < r.length; _t156++) {
    _loop16(_t156);
  }

  var _loop17 = function _loop17(_t157) {
    l(a[_t157].shape[0] === i, () => "Batch size mismatch: output ".concat(e.outputNames[_t157], " has ").concat(a[_t157].shape[0], "; expected  ").concat(i, " based on input ").concat(e.inputNames[0], "."));
  };

  for (var _t157 = 0; _t157 < a.length; _t157++) {
    _loop17(_t157);
  }

  return {
    xs: r,
    ys: a
  };
}

function md(e, t, n) {
  if (n instanceof rt) return [n];
  if (Array.isArray(n)) return l(n.length === t.length, () => "Received an array of ".concat(n.length, " Tensors, but expected ").concat(t.length, " to match the ").concat(e, " keys ").concat(t, ".")), n;
  {
    var _s89 = [];

    for (var _r59 of t) {
      if (null == n[_r59]) throw new xu("The feature data generated by the dataset lacks the required ".concat(e, " key '").concat(_r59, "'."));

      _s89.push(n[_r59]);
    }

    return _s89;
  }
}

function bd(e) {
  return "function" == typeof e.iterator;
}

function xd(e) {
  l(e > 0 && Number.isInteger(e), () => "batchSize is required to be a positive integer, but got ".concat(e));
}

function yd(e, t, n) {
  return null == e ? [null] : Array.isArray(e) ? e.map(e => bc(e, t, n - t)) : bc(e, t, n - t);
}

function kd(e, t) {
  return Jn(() => null == e ? null : Array.isArray(e) ? e.map(e => kd(e, t)) : Sc(e, "int32" === t.dtype ? t : fn(t, "int32")));
}

function wd(e, t) {
  var n = [];
  var s = 0,
      r = null;

  for (; s < e;) {
    r = s + t, r >= e && (r = e), n.push([s, r]), s = r;
  }

  return n;
}

function vd(e) {
  var t = [];
  e instanceof rt && (e = [e]);

  for (var _n100 = 0; _n100 < e.length; ++_n100) {
    var _s90 = e[_n100];
    if (1 === _s90.rank) t.push(mc(_s90, 1));else {
      if (0 === _s90.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
      t.push(_s90);
    }
  }

  return t;
}

function Id(e, t) {
  if (null == e) return;
  var n = [];
  if (t instanceof rt) n.push(t.id);else if (Array.isArray(t)) t.forEach(e => n.push(e.id));else if (null != t) for (var _e167 in t) {
    n.push(t[_e167].id);
  }
  var s = [];
  if (e instanceof rt) -1 === n.indexOf(e.id) && s.push(e);else if (Array.isArray(e)) e.forEach(e => {
    -1 === n.indexOf(e.id) && s.push(e);
  });else if (null != e) for (var _t158 in e) {
    var _r60 = e[_t158];
    -1 === n.indexOf(_r60.id) && s.push(_r60);
  }
  s.forEach(e => {
    e.isDisposed || e.dispose();
  });
}

function $d(e) {
  return Array.isArray(e);
}

function Sd(e) {
  return !function (e) {
    return e instanceof rt;
  }(e) && !$d(e);
}

function Nd(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";

  if (null == t || 0 === t.length) {
    if (null != e) {
      var _t159 = !1;

      if ($d(e) && e.length > 0) _t159 = !0;else if (Sd(e)) {
        for (var _n101 in e) {
          if (e.hasOwnProperty(_n101)) {
            _t159 = !0;
            break;
          }
        }
      } else _t159 = !0;
      if (_t159) throw new xu("Error when checking model ".concat(r, " expected no data, but got ").concat(e));
    }

    return [];
  }

  if (null == e) return t.map(e => null);
  var a;

  if (Sd(e)) {
    e = e, a = [];

    for (var _n102 of t) {
      if (null == e[_n102]) throw new xu("No data provided for \"".concat(_n102, "\". Need data for each key in: ").concat(t));
      a.push(e[_n102]);
    }
  } else if ($d(e)) {
    if ((e = e).length !== t.length) throw new xu("Error when checking model ".concat(r, ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ").concat(t.length, " Tensor(s), but instead got the following list of Tensor(s): ").concat(e));
    a = e;
  } else {
    if (e = e, t.length > 1) throw new xu("The model ".concat(r, " expects ").concat(t.length, " Tensor(s), but only received one Tensor. Found: Tensor with shape ").concat(e.shape));
    a = [e];
  }

  if (a = vd(a), null != n) for (var _e168 = 0; _e168 < t.length; ++_e168) {
    if (null == n[_e168]) continue;
    var _i27 = a[_e168];
    if (_i27.shape.length !== n[_e168].length) throw new xu("Error when checking ".concat(r, ": expected ").concat(t[_e168], " to have ").concat(n[_e168].length, " dimension(s). but got array with shape ").concat(_i27.shape));

    for (var _t160 = 0; _t160 < n[_e168].length; ++_t160) {
      if (0 === _t160 && !s) continue;
      var _a50 = _i27.shape[_t160],
          _o21 = n[_e168][_t160];
      if (null != _o21 && _o21 >= 0 && _a50 !== _o21) throw new xu("".concat(r, " expected a batch of elements where each example has shape [").concat(n[_e168].slice(1, n[_e168].length), "] (i.e.,tensor shape [*,").concat(n[_e168].slice(1, n[_e168].length), "]) but the ").concat(r, " received an input with ").concat(_i27.shape[0], " examples, each with shape [").concat(_i27.shape.slice(1, _i27.shape.length), "] (tensor shape [").concat(_i27.shape, "])"));
    }
  }
  return a;
}

function Cd(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
  var a;

  if (Array.isArray(e)) {
    if (e.length !== t.length) throw new xu("Error when checking model ".concat(r, ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ").concat(t.length, " Tensor(s), but instead got ").concat(e.length, " Tensors(s)."));
    a = e;
  } else {
    if (t.length > 1) throw new xu("The model expects ".concat(t.length, " ").concat(r, " Tensors, but only received one Tensor. Found: array with shape ").concat(JSON.stringify(e.shape), "."));
    a = [e];
  }

  if (null != n) for (var _e169 = 0; _e169 < t.length; ++_e169) {
    if (null == n[_e169]) continue;
    var _i28 = a[_e169];
    if (_i28.shape.length !== n[_e169].length) throw new xu("Error when checking ".concat(r, ": expected ").concat(t[_e169], " to have ").concat(n[_e169].length, " dimension(s), but got array with shape ").concat(JSON.stringify(_i28.shape)));

    for (var _a51 = 0; _a51 < n[_e169].length; ++_a51) {
      if (0 === _a51 && !s) continue;
      var _o22 = _i28.shape[_a51],
          _l14 = n[_e169][_a51];
      if (null != _l14 && _l14 !== _o22) throw new xu("Error when checking ".concat(r, ": expected ").concat(t[_e169], " to have shape ").concat(JSON.stringify(n[_e169]), " but got array with shape ").concat(JSON.stringify(_i28.shape), "."));
    }
  }
}

class Td extends hd {
  constructor(e) {
    super(e), this.isTraining = !1;
  }

  summary(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;
    if (!this.built) throw new xu("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
    !function (e, t, n) {
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : console.log;

      var r = function (e) {
        var t = !0;
        var n = [],
            s = [];

        for (var _t161 in e.nodesByDepth) {
          n.push(e.nodesByDepth[_t161]);
        }

        for (var _e170 of n) {
          if (_e170.length > 1 || 1 === _e170.length && _e170[0].inboundLayers.length > 1) {
            t = !1;
            break;
          }

          s.push(..._e170);
        }

        if (t) for (var _n103 of e.layers) {
          var _e171 = !1;

          for (var _r61 of _n103.inboundNodes) {
            if (-1 !== s.indexOf(_r61)) {
              if (_e171) {
                t = !1;
                break;
              }

              _e171 = !0;
            }
          }

          if (!t) break;
        }
        return t;
      }(e),
          a = ["Layer (type)", "Output shape", "Param #"];

      var i;

      if (r ? (t = t || 65, n = n || [.45, .85, 1]) : (t = t || 98, n = n || [.33, .55, .67, 1]), n[n.length - 1] <= 1 && (n = n.map(e => Math.floor(t * e))), !r) {
        a.push("Receives inputs"), i = [];

        for (var _t162 in e.nodesByDepth) {
          i.push(...e.nodesByDepth[_t162]);
        }
      }

      s("_".repeat(t)), Zh(a, n, s), s("=".repeat(t));
      var o = e.layers;

      for (var _e172 = 0; _e172 < o.length; ++_e172) {
        r ? Qh(o[_e172], n, s) : ed(o[_e172], n, i, s), s((_e172 === o.length - 1 ? "=" : "_").repeat(t));
      }

      e.checkTrainableWeightsConsistency();

      var l = function (e) {
        var t;
        return t = oh(null != e.collectedTrainableWeights ? e.collectedTrainableWeights : e.trainableWeights), t;
      }(e),
          u = oh(e.nonTrainableWeights);

      s("Total params: ".concat(l + u)), s("Trainable params: ".concat(l)), s("Non-trainable params: ".concat(u)), s("_".repeat(t));
    }(this, e, t, n);
  }

  compile(e) {
    var _this57 = this;

    if (null == e.loss && (e.loss = []), this.loss = e.loss, "string" == typeof e.optimizer) this.optimizer_ = function (e) {
      var t = {
        Adagrad: () => So.adagrad(.01),
        Adadelta: () => So.adadelta(1, .95, gu()),
        Adam: () => So.adam(.001, .9, .999, gu()),
        Adamax: () => So.adamax(.002, .9, .999, gu(), 0),
        RMSProp: () => So.rmsprop(.001, .9, 0, gu()),
        SGD: () => So.sgd(.01)
      };
      if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e in t) return t[e]();
      throw new xu("Unknown Optimizer ".concat(e));
    }(e.optimizer), this.isOptimizerOwned = !0;else {
      if (!(e.optimizer instanceof mo)) throw new xu("User-defined optimizer must be an instance of tf.Optimizer.");
      this.optimizer_ = e.optimizer, this.isOptimizerOwned = !1;
    }
    var t = [];
    if (Array.isArray(e.loss) || "string" == typeof e.loss || "function" == typeof e.loss) {
      if (Array.isArray(e.loss)) {
        if (e.loss.length !== this.outputs.length) throw new xu("When passing an Array as loss, it should have one entry per model output. The model has ".concat(this.outputs.length, " output(s), but you passed loss=").concat(e.loss, "."));
        t = e.loss.map(e => Ph(e));
      } else {
        var _n104 = Ph(e.loss);

        this.outputs.forEach(e => {
          t.push(_n104);
        });
      }
    } else {
      e.loss = e.loss;

      for (var _t163 in e.loss) {
        if (-1 === this.outputNames.indexOf(_t163)) throw new xu("Unknown entry in loss dictionary: \"".concat(_t163, "\". Only expected the following keys: ").concat(this.outputNames));
      }

      for (var _n105 of this.outputNames) {
        null == e.loss[_n105] && console.warn("Output \"".concat(_n105, "\" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ").concat(_n105, " during training")), t.push(Ph(e.loss[_n105]));
      }
    }
    this.lossFunctions = t, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];

    for (var _e173 = 0; _e173 < this.outputs.length; ++_e173) {
      var _t164 = this.internalOutputShapes[_e173];
      this.feedOutputNames.push(this.outputNames[_e173]), this.feedOutputShapes.push(_t164), this.feedLossFns.push(this.lossFunctions[_e173]);
    }

    var n = [];
    this.metrics = e.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], ic("loss", () => {
      for (var _e174 = 0; _e174 < this.outputs.length; ++_e174) {
        if (-1 !== n.indexOf(_e174)) continue;
        var _t165 = this.lossFunctions[_e174];
        this.outputs.length > 1 && (this.metricsTensors.push([_t165, _e174]), this.metricsNames.push(this.outputNames[_e174] + "_loss"));
      }
    });

    var s = function (e, t) {
      if (null == e || Array.isArray(e) && 0 === e.length) return t.map(e => []);
      var n;
      if ("string" == typeof e || "function" == typeof e) n = [e];else {
        if (!Array.isArray(e) && "object" != typeof e) throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ".concat(e));
        n = e;
      }
      if (Array.isArray(n)) return t.map(e => n);
      {
        var _e175 = [];

        for (var _s91 of t) {
          var _t166 = n.hasOwnProperty(_s91) ? n[_s91] : [];

          Array.isArray(_t166) || (_t166 = [_t166]), _e175.push(_t166);
        }

        return _e175;
      }
    }(e.metrics, this.outputNames),
        r = (e, t, n) => {
      this.outputNames.length > 1 && (t = this.outputNames[e] + "_" + t), this.metricsNames.push(t), this.metricsTensors.push([n, e]);
    };

    ic("metric", () => {
      var _loop18 = function _loop18(_e176) {
        -1 === n.indexOf(_e176) && (t => {
          var n, s, a;

          for (var _i29 of t) {
            if ("string" == typeof _i29 && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(_i29)) {
              var _t168 = _this57.internalOutputShapes[_e176];

              var _r62 = void 0;

              1 === _t168[_t168.length - 1] || _this57.lossFunctions[_e176] === Lh ? -1 !== ["accuracy", "acc"].indexOf(_i29) ? s = Wh : -1 !== ["crossentropy", "ce"].indexOf(_i29) && (s = Vh) : _this57.lossFunctions[_e176] === Mh ? -1 !== ["accuracy", "acc"].indexOf(_i29) ? s = Gh : -1 !== ["crossentropy", "ce"].indexOf(_i29) && (s = qh) : -1 !== ["accuracy", "acc"].indexOf(_i29) ? s = Uh : -1 !== ["crossentropy", "ce"].indexOf(_i29) && (s = Hh), -1 !== ["accuracy", "acc"].indexOf(_i29) ? _r62 = "acc" : -1 !== ["crossentropy", "ce"].indexOf(_i29) && (_r62 = "ce"), a = s, n = "" + _r62;
            } else {
              var _e177 = Kh(_i29);

              a = _e177, n = "" + Xh(_i29);
            }

            var _t167 = void 0;

            ic(n, () => {
              _t167 = a;
            }), r(_e176, n, _t167);
          }
        })(s[_e176]);
      };

      for (var _e176 = 0; _e176 < this.outputs.length; ++_e176) {
        _loop18(_e176);
      }
    }), this.collectedTrainableWeights = this.trainableWeights;
  }

  checkTrainableWeightsConsistency() {
    null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
  }

  evaluate(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = null == n.batchSize ? 32 : n.batchSize;
    xd(s);
    var r = this.standardizeUserDataXY(e, t, !0, s);

    try {
      var _a52 = r[0].concat(r[1]);

      return this.makeTestFunction(), $u(this.testLoop(this.testFunction, _a52, s, n.verbose, n.steps));
    } finally {
      Id(r[0], e), Id(r[1], t);
    }
  }

  evaluateDataset(e, t) {
    var _this58 = this;

    return _asyncToGenerator(function* () {
      return _this58.makeTestFunction(), function () {
        var _ref5 = _asyncToGenerator(function* (e, t, n) {
          var s = null != (n = n || {}).batches,
              r = e.testFunction;
          var a = [];
          if (n.verbose > 0) throw new yu("Verbose mode is not implemented yet.");
          l(!s || n.batches > 0 && Number.isInteger(n.batches), () => "Test loop expects `batches` to be a positive integer, but received ".concat(JSON.stringify(n.batches)));
          var i = "function" == typeof t.next ? t : yield t.iterator();
          var o = 0,
              u = 0;

          var _loop19 = function* _loop19() {
            var t = yield i.next();

            if (a = Jn(() => {
              if (t.value) {
                (function () {
                  var {
                    xs: n,
                    ys: s
                  } = gd(e, t.value),
                      i = n.concat(s),
                      l = Jn(() => r(i));
                  if (Zn(i), 0 === u) for (var _e179 = 0; _e179 < l.length; ++_e179) {
                    a.push(Ka(0));
                  }
                  var c = i[0].shape[0];

                  var _loop20 = function _loop20(_e180) {
                    var t = l[_e180],
                        n = a[_e180];
                    a[_e180] = Jn(() => ts(a[_e180], rs(c, t))), u > 0 && Zn(n);
                  };

                  for (var _e180 = 0; _e180 < l.length; ++_e180) {
                    _loop20(_e180);
                  }

                  Zn(l), o += c, ++u;
                })();
              }

              return a;
            }), t.done) {
              s && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, ".concat(n.batches, " batches). You may need to use the repeat() function when building your dataset."));
              return "break";
            }
          };

          for (; !s || u < n.batches;) {
            var _ret = yield* _loop19();

            if (_ret === "break") break;
          }

          for (var _e178 = 0; _e178 < a.length; ++_e178) {
            var _t169 = a[_e178];
            a[_e178] = ss(a[_e178], o), Zn(_t169);
          }

          return $u(a);
        });

        return function (_x25, _x26, _x27) {
          return _ref5.apply(this, arguments);
        };
      }()(_this58, e, t);
    })();
  }

  checkNumSamples(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "steps";
    var r;

    if (null != n) {
      if (r = null, null != t) throw new xu("If ".concat(s, " is set, batchSize must be null or undefined.Got batchSize = ").concat(t));
    } else {
      if (null == e) throw new xu("Either the input data should have a defined shape, or ".concat(s, " shoud be specified."));
      r = Array.isArray(e) ? e[0].shape[0] : e.shape[0];
    }

    return r;
  }

  execute(e, t) {
    if (Array.isArray(t) && 0 === t.length) throw new xu("`outputs` is an empty Array, which is not allowed.");
    var n = Array.isArray(t),
        s = this.retrieveSymbolicTensors(n ? t : [t]),
        r = new rd();

    if (e instanceof rt && (e = [e]), Array.isArray(e)) {
      if (e.length !== this.inputs.length) throw new xu("The number of inputs provided (".concat(e.length, ") does not match the number of inputs of this model (").concat(this.inputs.length, ")."));

      for (var _t170 = 0; _t170 < this.inputs.length; ++_t170) {
        r.add(this.inputs[_t170], e[_t170]);
      }
    } else for (var _t171 of this.inputs) {
      var _n106 = e[_t171.name];
      if (null == _n106) throw new xu("No value is provided for the model's input ".concat(_t171.name));
      r.add(_t171, _n106);
    }

    var a = od(s, r);
    return n ? a : a[0];
  }

  retrieveSymbolicTensors(e) {
    var t = wu(null, e.length);
    var n = e.length;

    for (var _s92 of this.layers) {
      var _r63 = Array.isArray(_s92.output) ? _s92.output : [_s92.output],
          _a53 = _r63.map(e => e.name);

      for (var _s93 = 0; _s93 < e.length; ++_s93) {
        var _i30 = _a53.indexOf(e[_s93]);

        if (-1 !== _i30 && (t[_s93] = _r63[_i30], n--), 0 === n) break;
      }

      if (0 === n) break;
    }

    if (n > 0) {
      var _n107 = [];
      throw t.forEach((t, s) => {
        null == t && _n107.push(e[s]);
      }), new xu("Cannot find SymbolicTensors for output name(s): ".concat(JSON.stringify(_n107)));
    }

    return t;
  }

  predictLoop(e) {
    var _this59 = this;

    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    return Jn(() => {
      var s = this.checkNumSamples(e);
      if (n) throw new yu("Verbose predictLoop() is not implemented yet.");
      var r = wd(s, t),
          a = this.outputs.map(e => []);

      var _loop21 = function _loop21(_t172) {
        Jn(() => {
          var n = yd(e, r[_t172][0], r[_t172][1]),
              s = [];
          if (Array.isArray(n)) for (var _e181 = 0; _e181 < n.length; ++_e181) {
            s.push({
              key: _this59.inputs[_e181],
              value: n[_e181]
            });
          } else s.push({
            key: _this59.inputs[0],
            value: n
          });
          var a = new rd(s);
          return od(_this59.outputs, a);
        }).forEach((e, t) => a[t].push(e));
      };

      for (var _t172 = 0; _t172 < r.length; ++_t172) {
        _loop21(_t172);
      }

      return $u(a.map(e => Ds(e, 0)));
    });
  }

  predict(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var n = vd(e);
    Cd(n, this.inputNames, this.feedInputShapes, !1);

    try {
      var _s94 = null == t.batchSize ? 32 : t.batchSize;

      return xd(_s94), this.predictLoop(n, _s94);
    } finally {
      Id(n, e);
    }
  }

  predictOnBatch(e) {
    Cd(e, this.inputNames, this.feedInputShapes, !0);
    var t = (Array.isArray(e) ? e[0] : e).shape[0];
    return this.predictLoop(e, t);
  }

  standardizeUserDataXY(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    if (null == this.optimizer_) throw new bu("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
    var r = [];

    for (var _e182 = 0; _e182 < this.feedOutputShapes.length; ++_e182) {
      var _t173 = this.feedOutputShapes[_e182];
      r.push(this.feedLossFns[_e182] === Mh ? _t173.slice(0, _t173.length - 1).concat([1]) : _t173);
    }

    if (function (e, t, n) {
      var s = Du(e.map(e => e.shape[0]));
      s.sort();
      var r = Du(t.map(e => e.shape[0]));
      if (r.sort(), s.length > 1) throw new xu("All input Tensors (x) should have the same number of samples. Got array shapes: ".concat(JSON.stringify(e.map(e => e.shape))));
      if (r.length > 1) throw new xu("All target Tensors (y) should have the same number of samples. Got array shapes: ".concat(JSON.stringify(t.map(e => e.shape))));
      if (s.length > 0 && r.length > 0 && !p(s, r)) throw new xu("Input Tensors should have the same number of samples as target Tensors. Found ".concat(s[0], " input sample(s) and ").concat(r[0], " target sample(s)."));
    }(e = Nd(e, this.feedInputNames, this.feedInputShapes, !1, "input"), t = Nd(t, this.feedOutputNames, r, !1, "target")), function (e, t, n) {
      var s = [Fh, Lh, Oh];

      for (var _r64 = 0; _r64 < e.length; ++_r64) {
        var _a54 = e[_r64],
            _i31 = t[_r64],
            _o23 = n[_r64];

        if (null != _i31) {
          if (_i31 === Oh && 1 === _a54.shape[_a54.shape.length - 1]) throw new xu("You are passing a target array of shape ".concat(_a54.shape, " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes]."));

          if (-1 !== s.indexOf(_i31)) {
            var _e183 = _a54.shape.slice(1),
                _t174 = _o23.slice(1);

            for (var _n108 = 0; _n108 < _e183.length; ++_n108) {
              var _s95 = _e183[_n108],
                  _r65 = _t174[_n108];
              if (null != _r65 && _s95 !== _r65) throw new xu("A target Tensor with shape ".concat(_a54.shape, " was passed for an output of shape ").concat(_o23, ", while using a loss function that expects targets to have the same shape as the output."));
            }
          }
        }
      }
    }(t, this.feedLossFns, this.feedOutputShapes), this.stateful && null != s && s > 0 && e[0].shape[0] % s != 0) throw new xu("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ".concat(s, ". Found: ").concat(e[0].shape[0], " sample(s)."));
    return [e, t];
  }

  standardizeUserData(e, t, n, s) {
    var _arguments = arguments,
        _this60 = this;

    return _asyncToGenerator(function* () {
      var r = _arguments.length > 4 && _arguments[4] !== undefined ? _arguments[4] : !0;
      var a = _arguments.length > 5 ? _arguments[5] : undefined;

      var [i, o] = _this60.standardizeUserDataXY(e, t, r, a);

      if (null != n) throw new Error("sample weight is not supported yet.");
      var l = null;

      if (null != s) {
        var _e184 = dd(s, _this60.outputNames);

        l = [];

        for (var _t175 = 0; _t175 < _e184.length; ++_t175) {
          l.push(yield pd(o[_t175], null, _e184[_t175]));
        }
      }

      return [i, o, l];
    })();
  }

  testLoop(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    return Jn(() => {
      var a = this.checkNumSamples(t, n, r, "steps"),
          i = [];
      if (s > 0) throw new yu("Verbose mode is not implemented yet.");
      if (null != r) throw new yu("steps mode in testLoop() is not implemented yet");
      {
        var _s96 = wd(a, n),
            _r66 = bi(fc(0, a));

        for (var _n109 = 0; _n109 < _s96.length; ++_n109) {
          var _a55 = _s96[_n109][0],
              _o24 = _s96[_n109][1],
              _l15 = bc(_r66, _a55, _o24 - _a55),
              _u9 = kd(t, _l15),
              _c8 = e(_u9);

          if (0 === _n109) for (var _e185 = 0; _e185 < _c8.length; ++_e185) {
            i.push(Ka(0));
          }

          for (var _e186 = 0; _e186 < _c8.length; ++_e186) {
            i[_e186] = ts(i[_e186], rs(_o24 - _a55, _c8[_e186]));
          }
        }

        for (var _e187 = 0; _e187 < i.length; ++_e187) {
          i[_e187] = ss(i[_e187], a);
        }
      }
      return i;
    });
  }

  getDedupedMetricsNames() {
    var e = this.metricsNames,
        t = [];

    for (var _n110 = 0; _n110 < e.length; ++_n110) {
      var _s97 = e[_n110];
      var _r67 = _s97;
      Iu(e, _s97) > 1 && (_r67 += "_".concat(Iu(e.slice(0, _n110), _s97))), t.push(_r67);
    }

    return t;
  }

  makeTrainFunction() {
    return e => {
      var t = [],
          n = e.slice(0, this.inputs.length),
          s = e.slice(this.inputs.length, this.inputs.length + this.outputs.length),
          r = e.slice(this.inputs.length + this.outputs.length, this.inputs.length + 2 * this.outputs.length),
          a = [],
          i = this.collectedTrainableWeights.map(e => e.read());
      return [this.optimizer_.minimize(() => {
        var e = [];

        for (var _t176 = 0; _t176 < this.inputs.length; ++_t176) {
          e.push({
            key: this.inputs[_t176],
            value: n[_t176]
          });
        }

        var i = new rd(e),
            o = od(this.outputs, i, {
          training: !0
        });
        var l;

        for (var _e188 = 0; _e188 < this.lossFunctions.length; ++_e188) {
          var _n111 = (0, this.lossFunctions[_e188])(s[_e188], o[_e188]);

          null != r[_e188] && (_n111 = fd(_n111, r[_e188]));

          var _a56 = ua(_n111);

          t.push(_a56), l = 0 === _e188 ? _n111 : ts(l, _n111);
        }

        for (var _e189 = 0; _e189 < this.metricsTensors.length; ++_e189) {
          var _n112 = void 0;

          if (this.outputs.length > 1 && _e189 < this.outputs.length) _n112 = t[_e189];else {
            var _t177 = this.metricsTensors[_e189][1];
            _n112 = ua((0, this.metricsTensors[_e189][0])(s[_t177], o[_t177]));
          }
          Qn(_n112), a.push(_n112);
        }

        return l = ua(l), this.calculateLosses().forEach(e => {
          l = ts(l, e);
        }), l;
      }, !0, i)].concat(a);
    };
  }

  makeTestFunction() {
    this.testFunction = e => Jn(() => {
      var t = [];
      var n;
      var s = e.slice(0, this.inputs.length),
          r = e.slice(this.inputs.length, this.inputs.length + this.outputs.length),
          a = [];

      for (var _e190 = 0; _e190 < this.inputs.length; ++_e190) {
        a.push({
          key: this.inputs[_e190],
          value: s[_e190]
        });
      }

      var i = new rd(a),
          o = od(this.outputs, i);

      for (var _e191 = 0; _e191 < this.lossFunctions.length; ++_e191) {
        var _s98 = ua((0, this.lossFunctions[_e191])(r[_e191], o[_e191]));

        n = 0 === _e191 ? _s98 : ts(n, _s98), t.push(n);
      }

      for (var _e192 = 0; _e192 < this.metricsTensors.length; ++_e192) {
        var _n113 = this.metricsTensors[_e192][1],
            _s99 = ua((0, this.metricsTensors[_e192][0])(r[_n113], o[_n113]));

        t.push(_s99);
      }

      return t;
    });
  }

  fit(e, t) {
    var _arguments2 = arguments,
        _this61 = this;

    return _asyncToGenerator(function* () {
      var n = _arguments2.length > 2 && _arguments2[2] !== undefined ? _arguments2[2] : {};
      return function () {
        var _ref6 = _asyncToGenerator(function* (e, t, n) {
          var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
          if (e.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
          var a, i, o, l, u, c, h;
          e.isTraining = !0;

          try {
            var _d5 = null == s.batchSize ? 32 : s.batchSize;

            xd(_d5);

            var _p5 = !1,
                _f4 = yield e.standardizeUserData(t, n, s.sampleWeight, s.classWeight, _p5, _d5);

            a = _f4[0], i = _f4[1], h = _f4[2];

            var _g6,
                _m5 = !1;

            if (null != s.validationData && s.validationData.length > 0) {
              if (_m5 = !0, 2 !== s.validationData.length) throw 3 === s.validationData.length ? new yu("validationData including sample weights is not supported yet.") : new xu("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ".concat(s.validationData, " is invalid."));
              o = s.validationData[0], l = s.validationData[1];

              var _t178 = !0,
                  _n114 = yield e.standardizeUserData(o, l, null, null, _t178, _d5);

              u = _n114[0], c = _n114[1], _g6 = u.concat(c);
            } else if (null != s.validationSplit && s.validationSplit > 0 && s.validationSplit < 1) {
              _m5 = !0;

              var _e193 = Math.floor(a[0].shape[0] * (1 - s.validationSplit)),
                  _t179 = a[0].shape[0];

              u = yd(a, _e193, _t179), a = yd(a, 0, _e193), c = yd(i, _e193, _t179), i = yd(i, 0, _e193), _g6 = u.concat(c);
            } else null != s.validationSteps && (_m5 = !0);

            var _b5 = a.concat(i).concat(h);

            e.checkTrainableWeightsConsistency();

            var _x31 = e.makeTrainFunction(),
                _y5 = e.getDedupedMetricsNames();

            var _k3, _w2;

            _m5 ? (e.makeTestFunction(), _k3 = e.testFunction, _w2 = _y5.slice().concat(_y5.map(e => "val_" + e))) : (_k3 = null, _g6 = [], _w2 = _y5.slice());

            var _v2 = Ch(s.callbacks, s.yieldEvery);

            return yield function () {
              var _ref7 = _asyncToGenerator(function* (e, t, n, s, a, i, o, l, u, c, h, d, p, f, g) {
                null == a && (a = 32), null == i && (i = 1), null == h && (h = !0), null == p && (p = 0);
                var m = !1;
                null != u && null != c && (m = !0);
                var b = e.checkNumSamples(n, a, null, "steps_per_epoch");
                var x;
                null != b && (x = fc(0, b)), null == o && (o = 1);
                var {
                  callbackList: y,
                  history: k
                } = Eh(l, o, i, p, b, null, a, m, d);
                y.setModel(e), e.history = k, yield y.onTrainBegin(), e.stopTraining_ = !1;

                var _loop22 = function* _loop22(_o25) {
                  yield y.onEpochBegin(_o25);
                  var i = {};
                  {
                    yield* function* () {
                      if ("batch" === h) throw new yu("batch shuffling is not implemneted yet");
                      h && r(x);
                      var o = bi(x),
                          l = wd(b, a);

                      var _loop23 = function* _loop23(_r68) {
                        var h = {};
                        if (yield y.onBatchBegin(_r68, h), Jn(() => {
                          var d = l[_r68][0],
                              p = l[_r68][1],
                              f = bc(o, d, p - d);
                          h.batch = _r68, h.size = p - d;
                          var g = kd(n, f),
                              b = t(g);

                          for (var _e194 = 0; _e194 < s.length; ++_e194) {
                            var _t180 = b[_e194];
                            h[s[_e194]] = _t180, Qn(_t180);
                          }

                          if (_r68 === l.length - 1 && m) {
                            var _t181 = e.testLoop(u, c, a);

                            for (var _e195 = 0; _e195 < s.length; ++_e195) {
                              var _n115 = s[_e195],
                                  _r69 = _t181[_e195];
                              Qn(_r69), i["val_" + _n115] = _r69;
                            }
                          }
                        }), yield y.onBatchEnd(_r68, h), kh(h), e.stopTraining_) return "break";
                      };

                      for (var _r68 = 0; _r68 < l.length; ++_r68) {
                        var _ret3 = yield* _loop23(_r68);

                        if (_ret3 === "break") break;
                      }

                      o.dispose();
                    }();
                  }
                  if (yield y.onEpochEnd(_o25, i), e.stopTraining_) return "break";
                };

                for (var _o25 = p; _o25 < i; ++_o25) {
                  var _ret2 = yield* _loop22(_o25);

                  if (_ret2 === "break") break;
                }

                return yield y.onTrainEnd(), yield e.history.syncData(), e.history;
              });

              return function (_x32, _x33, _x34, _x35, _x36, _x37, _x38, _x39, _x40, _x41, _x42, _x43, _x44, _x45, _x46) {
                return _ref7.apply(this, arguments);
              };
            }()(e, _x31, _b5, _y5, _d5, s.epochs, s.verbose, _v2, _k3, _g6, s.shuffle, _w2, s.initialEpoch);
          } finally {
            e.isTraining = !1, Id(a, t), Id(i, n), Id(u, o), Id(c, l), null != h && Zn(h);
          }
        });

        return function (_x28, _x29, _x30) {
          return _ref6.apply(this, arguments);
        };
      }()(_this61, e, t, n);
    })();
  }

  fitDataset(e, t) {
    var _this62 = this;

    return _asyncToGenerator(function* () {
      return function () {
        var _ref8 = _asyncToGenerator(function* (e, t, n) {
          var s = null != n.batchesPerEpoch;
          if (l(null != e.optimizer, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."), l(null != n, () => "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."), l(null != n.epochs && n.epochs > 0 && Number.isInteger(n.epochs), () => "For fitDataset(), config.epochs is expected to be a positive integer, but got ".concat(n.epochs)), l(!s || n.batchesPerEpoch > 0 && Number.isInteger(n.batchesPerEpoch), () => "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ".concat(n.batchesPerEpoch)), l(null == n.validationSplit, () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."), e.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
          e.isTraining = !0;

          try {
            var _r70 = null != n.validationData;

            var _a57, _i32;

            if (_r70) if (bd(n.validationData)) l(null == n.validationBatches || n.validationBatches > 0 && Number.isInteger(n.validationBatches), () => "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ".concat(n.validationBatches));else {
              var _e196 = function (e) {
                if (3 === e.length) throw new yu("Validation with sample weights is not implemented yet.");
                return {
                  xs: e[0],
                  ys: e[1]
                };
              }(n.validationData);

              _a57 = _e196.xs, _i32 = _e196.ys;
            }

            var _o26 = e.makeTrainFunction(),
                _u10 = e.getDedupedMetricsNames();

            var _c9;

            _c9 = _r70 ? _u10.slice().concat(_u10.map(e => "val_" + e)) : _u10.slice();

            var _h6 = Ch(n.callbacks, n.yieldEvery),
                _d6 = null == n.verbose ? 1 : n.verbose,
                {
              callbackList: _p6,
              history: _f5
            } = Eh(_h6, _d6, n.epochs, null, null, function (e, t) {
              var n = null;
              return null != t.batchesPerEpoch ? n = t.batchesPerEpoch : Number.isFinite(e.size) && (n = e.size), n;
            }(t, n), null, _r70, _c9);

            _p6.setModel(e), e.history = _f5, yield _p6.onTrainBegin(), e.stopTraining_ = !1;

            var _g7 = null == n.initialEpoch ? 0 : n.initialEpoch,
                _m6 = yield t.iterator();

            for (; _g7 < n.epochs;) {
              var _l16 = {};
              yield _p6.onEpochBegin(_g7);
              var _c10 = 0,
                  _h7 = 0;

              for (s || (_m6 = yield t.iterator()); !s || _c10 < n.batchesPerEpoch;) {
                var _t182 = yield _m6.next();

                if (s && _t182.done) {
                  console.warn("You provided `batchesPerEpoch` as ".concat(n.batchesPerEpoch, ", but your dataset iterator ran out of data after ").concat(_c10, " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, ") + n.batchesPerEpoch * n.epochs + " batches). You may need to use the repeat() function when building your dataset.");
                  break;
                }

                if (null != _t182.value) {
                  var {
                    xs: _s100,
                    ys: _r71
                  } = gd(e, _t182.value),
                      _a58 = {};
                  _a58.batch = _h7, _a58.size = _s100[0].shape[0], yield _p6.onBatchBegin(_h7, _a58);
                  var _i33 = [];

                  if (null != n.classWeight) {
                    var _t183 = dd(n.classWeight, e.outputNames);

                    for (var _e197 = 0; _e197 < _t183.length; ++_e197) {
                      _i33.push(yield pd(_r71[_e197], null, _t183[_e197]));
                    }
                  }

                  var _l17 = _s100.concat(_r71).concat(_i33),
                      _d7 = _o26(_l17);

                  Zn(_l17);

                  for (var _e198 = 0; _e198 < _u10.length; ++_e198) {
                    var _t184 = _d7[_e198];
                    _a58[_u10[_e198]] = _t184, Qn(_t184);
                  }

                  yield _p6.onBatchEnd(_h7, _a58), kh(_a58), _h7++, _c10++;
                }

                if (s ? _c10 >= n.batchesPerEpoch : _t182.done) {
                  if (_r70) {
                    var _t185 = void 0;

                    _t185 = bd(n.validationData) ? Su(yield e.evaluateDataset(n.validationData, {
                      batches: n.validationBatches
                    })) : Su(e.evaluate(_a57, _i32, {
                      batchSize: null == n.validationBatchSize ? 32 : n.validationBatchSize,
                      verbose: 0
                    }));

                    for (var _n116 = 0; _n116 < e.metricsNames.length; ++_n116) {
                      _l16["val_".concat(e.metricsNames[_n116])] = _t185[_n116];
                    }
                  }

                  break;
                }

                if (e.stopTraining_) break;
              }

              if (yield _p6.onEpochEnd(_g7, _l16), _g7++, e.stopTraining_) break;
            }

            return yield _p6.onTrainEnd(), yield e.history.syncData(), e.history;
          } finally {
            e.isTraining = !1;
          }
        });

        return function (_x47, _x48, _x49) {
          return _ref8.apply(this, arguments);
        };
      }()(_this62, e, t);
    })();
  }

  trainOnBatch(e, t) {
    var _this63 = this;

    return _asyncToGenerator(function* () {
      var n = yield _this63.standardizeUserData(e, t),
          s = n[0],
          r = n[1],
          a = _this63.makeTrainFunction()(s.concat(r)),
          i = [];

      for (var _e199 of a) {
        var _t186 = yield _e199.data();

        i.push(_t186[0]);
      }

      return Zn(a), $u(i);
    })();
  }

  getNamedWeights(e) {
    var t = [],
        n = null != e && e.trainableOnly,
        s = n ? this.trainableWeights : this.weights,
        r = this.getWeights(n);

    for (var _e200 = 0; _e200 < s.length; ++_e200) {
      n && !s[_e200].trainable || t.push({
        name: s[_e200].originalName,
        tensor: r[_e200]
      });
    }

    return t;
  }

  set stopTraining(e) {
    this.stopTraining_ = e;
  }

  get stopTraining() {
    return this.stopTraining_;
  }

  get optimizer() {
    return this.optimizer_;
  }

  set optimizer(e) {
    this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = !1);
  }

  dispose() {
    var e = super.dispose();

    if (0 === e.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
      var _t187 = Yn().numTensors;
      this.optimizer_.dispose(), e.numDisposedVariables += _t187 - Yn().numTensors;
    }

    return e;
  }

  getLossIdentifiers() {
    var e;
    if ("string" == typeof this.loss) e = Nu(this.loss);else if (Array.isArray(this.loss)) {
      for (var _e201 of this.loss) {
        if ("string" != typeof _e201) throw new Error("Serialization of non-string loss is not supported.");
      }

      e = this.loss.map(e => Nu(e));
    } else {
      var _t188 = Object.keys(this.loss);

      e = {};
      var _n117 = this.loss;

      for (var _s101 of _t188) {
        if ("string" != typeof _n117[_s101]) throw new Error("Serialization of non-string loss is not supported.");
        e[_s101] = Nu(_n117[_s101]);
      }
    }
    return e;
  }

  getMetricIdentifiers() {
    if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [Nu(Xh(this.metrics))];
    if (Array.isArray(this.metrics)) return this.metrics.map(e => Nu(Xh(e)));
    {
      var _e202 = {};

      for (var _t189 in this.metrics) {
        _e202[_t189] = Nu(Xh(this.metrics[_t189]));
      }

      return _e202;
    }
  }

  getTrainingConfig() {
    return {
      loss: this.getLossIdentifiers(),
      metrics: this.getMetricIdentifiers(),
      optimizer_config: {
        class_name: this.optimizer.getClassName(),
        config: this.optimizer.getConfig()
      }
    };
  }

  loadTrainingConfig(e) {
    if (null != e.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
    if (null != e.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
    if (null != e.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
    var t = Rh(nd(e.optimizer_config));
    var n, s;
    if ("string" == typeof e.loss) n = Cu(e.loss);else if (Array.isArray(e.loss)) n = e.loss.map(e => Cu(e));else if (null != e.loss) {
      n = {};

      for (var _t190 in e.loss) {
        n[_t190] = Cu(e.loss[_t190]);
      }
    }
    if (Array.isArray(e.metrics)) s = e.metrics.map(e => Cu(e));else if (null != e.metrics) {
      s = {};

      for (var _t191 in e.metrics) {
        s[_t191] = Cu(e.metrics[_t191]);
      }
    }
    this.compile({
      loss: n,
      metrics: s,
      optimizer: t
    });
  }

  save(e, t) {
    var _this64 = this;

    return _asyncToGenerator(function* () {
      if ("string" == typeof e) {
        var _t192 = Ht.getSaveHandlers(e);

        if (0 === _t192.length) throw new xu("Cannot find any save handlers for URL '".concat(e, "'"));
        if (_t192.length > 1) throw new xu("Found more than one (".concat(_t192.length, ") save handlers for URL '").concat(e, "'"));
        e = _t192[0];
      }

      if (null == e.save) throw new xu("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
      var n = yield Lt(_this64.getNamedWeights(t)),
          s = {
        modelTopology: _this64.toJSON(null, !1),
        format: "layers-model",
        generatedBy: "TensorFlow.js tfjs-layers v3.9.0",
        convertedBy: null
      };

      if (null != t && t.includeOptimizer && null != _this64.optimizer) {
        s.trainingConfig = _this64.getTrainingConfig();
        var _e203 = "optimizer",
            {
          data: _t193,
          specs: _r72
        } = yield Lt(yield _this64.optimizer.getWeights(), _e203);
        n.specs.push(..._r72), n.data = Wt([n.data, _t193]);
      }

      return null != _this64.userDefinedMetadata && (Yh(_this64.userDefinedMetadata, _this64.name, !0), s.userDefinedMetadata = _this64.userDefinedMetadata), s.weightData = n.data, s.weightSpecs = n.specs, e.save(s);
    })();
  }

  setUserDefinedMetadata(e) {
    Yh(e, this.name), this.userDefinedMetadata = e;
  }

  getUserDefinedMetadata() {
    return this.userDefinedMetadata;
  }

}

Td.className = "Model", Kn(Td);

class Ed extends Td {}

Ed.className = "Functional", Kn(Ed);

class Rd extends Td {
  constructor(e) {
    if (super({
      inputs: [],
      outputs: []
    }), e = e || {}, this.trainable = !0, this.built = !1, this.name = null != e.name ? e.name : nh("sequential_"), null != e.layers) for (var _t194 of e.layers) {
      this.add(_t194);
    }
  }

  checkShape(e) {
    if (e.inboundNodes[0].outputTensors[0].shape.some(e => e < 0)) throw new xu("Negative dimension size caused by adding layer ".concat(e.name, " with input shape [").concat(e.inboundNodes[0].inputTensors[0].shape, "]"));
  }

  add(e) {
    var t = e instanceof Rd || e instanceof Td;
    var n;

    if (t) {
      if (n = e, 1 !== n.outputs.length) throw new xu("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      if (1 !== n.inputs.length) throw new xu("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
    }

    if (0 === this.outputs.length) {
      if (0 === e.inboundNodes.length) {
        if (null == e.batchInputShape) throw new xu("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");

        var _t195 = function (e) {
          if (null == e.batchShape && null == e.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
          if (null != e.batchShape && null != e.shape) throw new xu("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
          var t = e.batchShape;
          null != e.shape && null == t && (t = [null].concat(e.shape));
          var n = e.dtype;
          return null == n && (n = "float32"), new xh({
            batchInputShape: t,
            name: e.name,
            dtype: n,
            sparse: e.sparse
          }).inboundNodes[0].outputTensors[0];
        }({
          batchShape: e.batchInputShape,
          dtype: e.dtype,
          name: e.name + "_input"
        });

        e.apply(_t195);
      }

      if (t) this.outputs = n.outputs, this.inputs = n.inputs;else {
        if (1 !== e.inboundNodes.length) throw new xu("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ".concat(e.name, " which has ").concat(e.inboundNodes.length, " pre-existing inbound connections."));
        if (1 !== e.inboundNodes[0].outputTensors.length) throw new xu("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(e), this.outputs = [e.inboundNodes[0].outputTensors[0]], this.inputs = bh(this.outputs[0]);
      }
      this.inboundNodes = [], new fh({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        inputMasks: wu(null, this.inputs.length),
        outputMasks: [null],
        inputShapes: this.inputs.map(e => e.shape),
        outputShapes: this.outputs[0].shape
      });
    } else {
      var _t196 = e.apply(this.outputs[0]);

      if (Array.isArray(_t196)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      this.checkShape(e), this.outputs = [_t196], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }

    this.layers.push(e), this.built = !1;
  }

  pop() {
    if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
    if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];else {
      var _e204 = this.layers.length - 1;

      this.layers[_e204].outboundNodes = [], this.outputs = [this.layers[_e204].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
  }

  call(e, t) {
    return null == this.model && this.build(), this.model.call(e, t);
  }

  build(e) {
    if (ih(e), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
    this.model = new Td({
      inputs: this.inputs,
      outputs: this.outputs[0],
      name: this.name + "_model"
    }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0;
  }

  countParams() {
    return this.built || this.build(), super.countParams();
  }

  summary(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;
    this.built || this.build(), super.summary(e, t, n);
  }

  setWeights(e) {
    null == this.model && this.build(), this.model.setWeights(e);
  }

  evaluate(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!this.built) throw new bu("The model needs to be compiled before being used.");
    return this.model.evaluate(e, t, n);
  }

  evaluateDataset(e, t) {
    var _this65 = this;

    return _asyncToGenerator(function* () {
      if (!_this65.built) throw new bu("The model needs to be compiled before being used.");
      return _this65.model.evaluateDataset(e, t);
    })();
  }

  predict(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return null == this.model && this.build(), this.model.predict(e, t);
  }

  predictOnBatch(e) {
    return null == this.model && this.build(), this.model.predictOnBatch(e);
  }

  compile(e) {
    this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
  }

  get optimizer() {
    return null == this.model ? void 0 : this.model.optimizer;
  }

  set optimizer(e) {
    this.model.optimizer = e;
  }

  fit(e, t) {
    var _arguments3 = arguments,
        _this66 = this;

    return _asyncToGenerator(function* () {
      var n = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : {};
      if (!_this66.built) throw new bu("The model needs to be compiled before being used.");
      return _this66.model.fit(e, t, n);
    })();
  }

  fitDataset(e, t) {
    var _this67 = this;

    return _asyncToGenerator(function* () {
      if (!_this67.built) throw new bu("The model needs to be compiled before being used.");
      return _this67.model.fitDataset(e, t);
    })();
  }

  trainOnBatch(e, t) {
    var _this68 = this;

    return _asyncToGenerator(function* () {
      return _this68.model.trainOnBatch(e, t);
    })();
  }

  static fromConfig(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r,
        a = {};

    if (t instanceof Array) {
      if (null == t[0].className || "Merge" === t[0].className) throw new xu("Legacy serialization format not supported yet.");
      r = t;
    } else l(null != t.layers, () => "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."), r = t.layers, delete t.layers, a = t;

    var i = new e(a);
    if (!(i instanceof Rd)) throw new yu("Sequential.fromConfig called on non-Sequential input: ".concat(i));

    for (var _e205 of r) {
      var _t197 = Rh(_e205, void 0, s);

      s && _t197.setFastWeightInitDuringBuild(!0), i.add(_t197);
    }

    return i;
  }

  set stopTraining(e) {
    if (null == this.model) throw new xu("Cannot set the stopTraining property of a sequential model before it is compiled.");
    this.model.stopTraining = e;
  }

  get stopTraining() {
    if (null == this.model) throw new xu("Cannot get the stopTraining property of a sequential model before it is compiled.");
    return this.model.stopTraining;
  }

  getConfig() {
    var e = [];

    for (var _t198 of this.layers) {
      var _n118 = {};
      _n118.className = _t198.getClassName(), _n118.config = _t198.getConfig(), e.push(_n118);
    }

    return {
      name: this.name,
      layers: e
    };
  }

}

Rd.className = "Sequential", Kn(Rd);

class Ad extends qn {
  getConfig() {
    return {};
  }

}

class Fd extends Ad {
  apply(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (1 !== t) throw new yu("Support for alpha values other than 1 (".concat(t, ") is not implemented yet."));
      return br(e);
    }(e, t);
  }

}

Fd.className = "elu", Kn(Fd);

class Dd extends Ad {
  apply(e) {
    return Xa(e);
  }

}

Dd.className = "selu", Kn(Dd);

class _d extends Ad {
  apply(e) {
    return Va(e);
  }

}

_d.className = "relu", Kn(_d);

class Od extends Ad {
  apply(e) {
    return Jn(() => pa(6, Va(e)));
  }

}

Od.className = "relu6", Kn(Od);

class Md extends Ad {
  apply(e) {
    return e;
  }

}

Md.className = "linear", Kn(Md);

class Ld extends Ad {
  apply(e) {
    return _s(e);
  }

}

Ld.className = "sigmoid", Kn(Ld);

class zd extends Ad {
  apply(e) {
    return function (e) {
      return Jn(() => {
        var t = ts(.5, rs(.2, e));
        return Hs(t, 0, 1);
      });
    }(e);
  }

}

zd.className = "hardSigmoid", Kn(zd);

class Bd extends Ad {
  apply(e) {
    return Wr(e);
  }

}

Bd.className = "softplus", Kn(Bd);

class Pd extends Ad {
  apply(e) {
    return function (e) {
      return Jn(() => ss(e, ts(as(e), 1)));
    }(e);
  }

}

Pd.className = "softsign", Kn(Pd);

class Wd extends Ad {
  apply(e) {
    return Ms(e);
  }

}

Wd.className = "tanh", Kn(Wd);

class Ud extends Ad {
  apply(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    return ri(e, t);
  }

}

Ud.className = "softmax", Kn(Ud);

class Vd extends Ad {
  apply(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    return qr(e, t);
  }

}

Vd.className = "logSoftmax", Kn(Vd);

class Gd extends Ad {
  apply(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return Jn(() => rs(_s(rs(e, t)), e));
  }

}

Gd.className = "swish", Kn(Gd);

class Hd extends Ad {
  apply(e) {
    return Jn(() => rs(e, Ms(Wr(e))));
  }

}

function qd(e) {
  return e.getClassName();
}

function jd(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Au(e, jn.getMap().classNameMap, t, "activation");
}

function Kd(e) {
  if (null == e) return jd({
    className: "linear",
    config: {}
  });

  if ("string" == typeof e) {
    var _t199 = {};
    return _t199.className = e, _t199.config = {}, jd(_t199);
  }

  return e instanceof Ad ? e : jd(e);
}

Hd.className = "mish", Kn(Hd);

class Xd extends qn {}

class Yd extends Xd {
  constructor(e) {
    super(), function (e) {
      if (null != e && "object" != typeof e) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: ".concat(e));
    }(e), this.l1 = null == e || null == e.l1 ? .01 : e.l1, this.l2 = null == e || null == e.l2 ? .01 : e.l2, this.hasL1 = 0 !== this.l1, this.hasL2 = 0 !== this.l2;
  }

  apply(e) {
    return Jn(() => {
      var t = ca([1]);
      return this.hasL1 && (t = ts(t, Hr(rs(this.l1, as(e))))), this.hasL2 && (t = ts(t, Hr(rs(this.l2, Nc(e))))), Rs(t, []);
    });
  }

  getConfig() {
    return {
      l1: this.l1,
      l2: this.l2
    };
  }

  static fromConfig(e, t) {
    return new e({
      l1: t.l1,
      l2: t.l2
    });
  }

}

Yd.className = "L1L2", Kn(Yd);
var Jd = {
  l1l2: "L1L2"
};

function Zd(e) {
  return Eu(e);
}

function Qd(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Au(e, jn.getMap().classNameMap, t, "regularizer");
}

function ep(e) {
  return null == e ? null : "string" == typeof e ? Qd({
    className: e in Jd ? Jd[e] : e,
    config: {}
  }) : e instanceof Xd ? e : Qd(e);
}

class tp extends mh {
  constructor(e) {
    super(null == e ? {} : e), this.supportsMasking = !0, null != e && (this.maxValue = e.maxValue);
  }

  call(e, t) {
    e = ah(e);
    var n = Va(e);
    return null != this.maxValue && (n = Hs(n, 0, this.maxValue)), n;
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = {
      maxValue: this.maxValue
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

tp.className = "ReLU", Kn(tp);

class np extends mh {
  constructor(e) {
    super(null == e ? {} : e), this.DEFAULT_ALPHA = .3, null == e && (e = {}), this.alpha = null == e.alpha ? this.DEFAULT_ALPHA : e.alpha;
  }

  call(e, t) {
    var n = ah(e);
    return Dr(n, this.alpha);
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = {
      alpha: this.alpha
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

np.className = "LeakyReLU", Kn(np);

class sp extends mh {
  constructor(e) {
    if (super(null == e ? {} : e), this.DEFAULT_ALPHA_INITIALIZER = "zeros", null == e && (e = {}), this.supportsMasking = !0, this.alphaInitializer = Zc(e.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER), this.alphaRegularizer = ep(e.alphaRegularizer), this.alphaConstraint = Xu(e.alphaConstraint), null == e.sharedAxes) this.sharedAxes = null;else if (Array.isArray(e.sharedAxes)) this.sharedAxes = e.sharedAxes;else {
      if ("number" != typeof e.sharedAxes) throw new xu("Expected sharedAxes to be a number or an array of numbers, but got ".concat(e.sharedAxes));
      this.sharedAxes = [e.sharedAxes];
    }
  }

  build(e) {
    var t = (e = ih(e)).slice(1);
    if (null != this.sharedAxes) for (var _e206 of this.sharedAxes) {
      t[_e206 - 1] = 1;
    }
    this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
    var n = {};
    if (null != this.sharedAxes) for (var _t200 = 1; _t200 < e.length; ++_t200) {
      n[_t200] = e[_t200];
    }
    this.inputSpec = [new hh({
      ndim: e.length,
      axes: n
    })], this.built = !0;
  }

  call(e, t) {
    return e = ah(e), $a(e, this.alpha.read());
  }

  getConfig() {
    var e = {
      alphaInitializer: Jc(this.alphaInitializer),
      alphaRegularizer: Zd(this.alphaRegularizer),
      alphaConstraint: ju(this.alphaConstraint),
      sharedAxes: this.sharedAxes
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

sp.className = "PReLU", Kn(sp);

class rp extends mh {
  constructor(e) {
    if (super(null == e ? {} : e), this.DEFAULT_ALPHA = 1, null == e && (e = {}), null != e.alpha && e.alpha !== this.DEFAULT_ALPHA) throw new yu("Non-default alpha value (".concat(e.alpha, ") is not supported by the ELU layer yet."));
    this.alpha = null == e.alpha ? this.DEFAULT_ALPHA : e.alpha;
  }

  call(e, t) {
    var n = ah(e);
    return br(n);
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = {
      alpha: this.alpha
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

rp.className = "ELU", Kn(rp);

class ap extends mh {
  constructor(e) {
    super(null == e ? {} : e), this.DEFAULT_THETA = 1, null == e && (e = {}), this.theta = null == e.theta ? this.DEFAULT_THETA : e.theta;
  }

  call(e, t) {
    var n = ah(e);
    return rs(n, fn(Cr(n, this.theta), "float32"));
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = {
      theta: this.theta
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

ap.className = "ThresholdedReLU", Kn(ap);

class ip extends mh {
  constructor(e) {
    super(null == e ? {} : e), this.DEFAULT_AXIS = 1, null == e && (e = {}), this.softmax = new Ud().apply, this.axis = null == e.axis ? this.DEFAULT_AXIS : e.axis;
  }

  call(e, t) {
    var n = ah(e);
    return this.softmax(n, this.axis);
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = {
      axis: this.axis
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

function op(e, t, n) {
  if ("number" == typeof e) return wu(e, t);
  if (e.length !== t) throw new xu("The ".concat(n, " argument must be an integer or tuple of ").concat(t, " integers. Received: ").concat(e.length, " elements."));

  for (var _r73 = 0; _r73 < t; ++_r73) {
    var _a59 = e[_r73];
    if ((s = _a59) !== parseInt(s.toString(), 10)) throw new xu("The ".concat(n, " argument must be an integer or tuple of ").concat(t, " integers. Received: ").concat(JSON.stringify(e), " including a non-integer number ").concat(_a59));
  }

  return e;
  var s;
}

function lp(e, t, n, s) {
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
  if (null == e) return e;
  var a;
  return a = "same" === n ? e : e - (t + (t - 1) * (r - 1)) + 1, Math.floor((a + s - 1) / s);
}

function up(e, t, n, s) {
  if (null == e) return null;
  if ("valid" === s) e = e * t + pc([n - t, 0]);else {
    if ("same" !== s) throw new xu("Unsupport padding mode: ".concat(s, "."));
    e *= t;
  }
  return e;
}

function cp(e, t) {
  return Jn(() => (nc(t), "channelsFirst" === t ? Sn(e, [0, 2, 3, 1]) : e));
}

function hp(e, t) {
  return Jn(() => (nc(t), "channelsFirst" === t ? Sn(e, [0, 2, 3, 4, 1]) : e));
}

function dp(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [1, 1];
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "valid";
  var a = arguments.length > 5 ? arguments[5] : undefined;
  var i = arguments.length > 6 ? arguments[6] : undefined;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
  return Jn(() => {
    if (null == a && (a = "channelsLast"), nc(a), 3 !== e.rank && 4 !== e.rank) throw new xu("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ".concat(e.rank, "."));
    if (3 !== t.rank && 4 !== t.rank) throw new xu("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ".concat(e.rank, "."));
    var l = cp(e, a);
    if ("causal" === r) throw new yu("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    return l = _i({
      x: l,
      filter: t,
      strides: s,
      pad: "same" === r ? "same" : "valid",
      dilations: i,
      dataFormat: "NHWC",
      bias: n,
      activation: o
    }), "channelsFirst" === a && (l = Sn(l, [0, 3, 1, 2])), l;
  });
}

ip.className = "Softmax", Kn(ip);

class pp extends mh {
  constructor(e, t) {
    if (super(t), this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", pp.verifyArgs(t), this.rank = e, Lu(this.rank, "rank"), 1 !== this.rank && 2 !== this.rank && 3 !== this.rank) throw new yu("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank, ") is not implemented yet."));
    if (this.kernelSize = op(t.kernelSize, e, "kernelSize"), this.strides = op(null == t.strides ? 1 : t.strides, e, "strides"), this.padding = null == t.padding ? "valid" : t.padding, sc(this.padding), this.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, nc(this.dataFormat), this.activation = Kd(t.activation), this.useBias = null == t.useBias || t.useBias, this.biasInitializer = Zc(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.biasConstraint = Xu(t.biasConstraint), this.biasRegularizer = ep(t.biasRegularizer), this.activityRegularizer = ep(t.activityRegularizer), this.dilationRate = op(null == t.dilationRate ? 1 : t.dilationRate, e, "dilationRate"), 1 === this.rank && Array.isArray(this.dilationRate) && 1 !== this.dilationRate.length) throw new xu("dilationRate must be a number or an array of a single number for 1D convolution, but received ".concat(JSON.stringify(this.dilationRate)));

    if (2 === this.rank) {
      if ("number" == typeof this.dilationRate) this.dilationRate = [this.dilationRate, this.dilationRate];else if (2 !== this.dilationRate.length) throw new xu("dilationRate must be a number or array of two numbers for 2D convolution, but received ".concat(JSON.stringify(this.dilationRate)));
    } else if (3 === this.rank) if ("number" == typeof this.dilationRate) this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];else if (3 !== this.dilationRate.length) throw new xu("dilationRate must be a number or array of three numbers for 3D convolution, but received ".concat(JSON.stringify(this.dilationRate)));
  }

  static verifyArgs(e) {
    if (vu("kernelSize" in e, "required key 'kernelSize' not in config"), "number" != typeof e.kernelSize && !Mu(e.kernelSize, "number", 1, 3)) throw new xu("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize), "."));
  }

  getConfig() {
    var e = {
      kernelSize: this.kernelSize,
      strides: this.strides,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      activation: qd(this.activation),
      useBias: this.useBias,
      biasInitializer: Jc(this.biasInitializer),
      biasRegularizer: Zd(this.biasRegularizer),
      activityRegularizer: Zd(this.activityRegularizer),
      biasConstraint: ju(this.biasConstraint)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

class fp extends pp {
  constructor(e, t) {
    super(e, t), this.kernel = null, fp.verifyArgs(t), this.filters = t.filters, Lu(this.filters, "filters"), this.kernelInitializer = Zc(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.kernelConstraint = Xu(t.kernelConstraint), this.kernelRegularizer = ep(t.kernelRegularizer);
  }

  build(e) {
    e = ih(e);
    var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[t]) throw new xu("The channel dimension of the input should be defined. Found ".concat(e[t]));
    var n = e[t],
        s = this.kernelSize.concat([n, this.filters]);
    this.kernel = this.addWeight("kernel", s, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{
      ndim: this.rank + 2,
      axes: {
        [t]: n
      }
    }], this.built = !0;
  }

  call(e, t) {
    return Jn(() => {
      var t;
      e = ah(e);
      var n = null == this.bias ? null : this.bias.read(),
          s = Bu(this.activation.getClassName());
      if (null != s && 2 === this.rank) t = dp(e, this.kernel.read(), n, this.strides, this.padding, this.dataFormat, this.dilationRate, s);else {
        if (1 === this.rank) t = function (e, t, n) {
          var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
          var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "valid";
          var a = arguments.length > 5 ? arguments[5] : undefined;
          var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
          return Jn(() => {
            if (null == a && (a = "channelsLast"), nc(a), 3 !== e.shape.length) throw new xu("The input of a conv1dWithBias operation should be 3, but is ".concat(e.shape.length, " instead."));
            if (3 !== t.shape.length) throw new xu("The kernel for a conv1dWithBias operation should be 3, but is ".concat(t.shape.length, " instead"));
            if (null != n && 1 !== n.shape.length) throw new xu("The bias for a conv1dWithBias operation should be 1, but is ".concat(t.shape.length, " instead"));
            if ("channelsFirst" === a && (e = Sn(e, [0, 2, 1])), "causal" === r) throw new yu("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
            var o = Js(e, t, s, "same" === r ? "same" : "valid", "NWC", i);
            return null != n && (o = Tc(o, n)), o;
          });
        }(e, this.kernel.read(), n, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);else if (2 === this.rank) t = dp(e, this.kernel.read(), n, this.strides, this.padding, this.dataFormat, this.dilationRate);else {
          if (3 !== this.rank) throw new yu("convolutions greater than 3D are not implemented yet.");

          t = function (e, t, n) {
            var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [1, 1, 1];
            var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "valid";
            var a = arguments.length > 5 ? arguments[5] : undefined;
            var i = arguments.length > 6 ? arguments[6] : undefined;
            return Jn(() => {
              if (null == a && (a = "channelsLast"), nc(a), 4 !== e.rank && 5 !== e.rank) throw new xu("conv3dWithBias expects input to be of rank 4 or 5, but received ".concat(e.rank, "."));
              if (4 !== t.rank && 5 !== t.rank) throw new xu("conv3dWithBias expects kernel to be of rank 4 or 5, but received ".concat(e.rank, "."));
              var o = hp(e, a);
              if ("causal" === r) throw new yu("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
              return o = er(o, t, s, "same" === r ? "same" : "valid", "NDHWC", i), null != n && (o = Tc(o, n)), "channelsFirst" === a && (o = Sn(o, [0, 4, 1, 2, 3])), o;
            });
          }(e, this.kernel.read(), n, this.strides, this.padding, this.dataFormat, this.dilationRate);
        }
        null != this.activation && (t = this.activation.apply(t));
      }
      return t;
    });
  }

  computeOutputShape(e) {
    e = ih(e);
    var t = [],
        n = "channelsLast" === this.dataFormat ? e.slice(1, e.length - 1) : e.slice(2);

    for (var _e207 = 0; _e207 < n.length; ++_e207) {
      var _s102 = lp(n[_e207], this.kernelSize[_e207], this.padding, this.strides[_e207], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[_e207]);

      t.push(_s102);
    }

    var s = [e[0]];
    return "channelsLast" === this.dataFormat ? (s = s.concat(t), s.push(this.filters)) : (s.push(this.filters), s = s.concat(t)), s;
  }

  getConfig() {
    var e = {
      filters: this.filters,
      kernelInitializer: Jc(this.kernelInitializer),
      kernelRegularizer: Zd(this.kernelRegularizer),
      kernelConstraint: ju(this.kernelConstraint)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

  static verifyArgs(e) {
    if (!("filters" in e) || "number" != typeof e.filters || e.filters < 1) throw new xu("Convolution layer expected config.filters to be a 'number' > 0 but got ".concat(JSON.stringify(e.filters)));
  }

}

class gp extends fp {
  constructor(e) {
    super(2, e), gp.verifyArgs(e);
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.rank, e;
  }

  static verifyArgs(e) {
    if ("number" != typeof e.kernelSize && !Mu(e.kernelSize, "number", 1, 2)) throw new xu("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize), "."));
  }

}

gp.className = "Conv2D", Kn(gp);

class mp extends fp {
  constructor(e) {
    super(3, e), mp.verifyArgs(e);
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.rank, e;
  }

  static verifyArgs(e) {
    if ("number" != typeof e.kernelSize && (!Array.isArray(e.kernelSize) || 1 !== e.kernelSize.length && 3 !== e.kernelSize.length)) throw new xu("Conv3D expects config.kernelSize to be number or [number, number, number], but received ".concat(JSON.stringify(e.kernelSize), "."));
  }

}

mp.className = "Conv3D", Kn(mp);

class bp extends gp {
  constructor(e) {
    if (super(e), this.inputSpec = [new hh({
      ndim: 4
    })], "same" !== this.padding && "valid" !== this.padding) throw new xu("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ".concat(this.padding));
  }

  build(e) {
    if (4 !== (e = ih(e)).length) throw new xu("Input should have rank 4; Received input shape: " + JSON.stringify(e));
    var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[t]) throw new xu("The channel dimension of the inputs should be defined. Found `None`.");
    var n = e[t],
        s = this.kernelSize.concat([this.filters, n]);
    this.kernel = this.addWeight("kernel", s, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new hh({
      ndim: 4,
      axes: {
        [t]: n
      }
    })], this.built = !0;
  }

  call(e, t) {
    return Jn(() => {
      var t = ah(e);
      if (4 !== t.shape.length) throw new xu("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-".concat(t.shape.length));
      var n = t.shape;
      var s, r;
      "channelsFirst" === this.dataFormat ? (s = 2, r = 3) : (s = 1, r = 2);
      var a = n[r],
          i = this.kernelSize[1],
          o = this.strides[1],
          l = [n[0], up(n[s], this.strides[0], this.kernelSize[0], this.padding), up(a, o, i, this.padding), this.filters];
      "channelsLast" !== this.dataFormat && (t = Sn(t, [0, 2, 3, 1]));
      var u = Qs(t, this.kernel.read(), l, this.strides, this.padding);
      return "channelsLast" !== this.dataFormat && (u = Sn(u, [0, 3, 1, 2])), null != this.bias && (u = Tc(u, this.bias.read(), this.dataFormat)), null != this.activation && (u = this.activation.apply(u)), u;
    });
  }

  computeOutputShape(e) {
    var t = (e = ih(e)).slice();
    var n, s, r;
    "channelsFirst" === this.dataFormat ? (n = 1, s = 2, r = 3) : (n = 3, s = 1, r = 2);
    var a = this.kernelSize[0],
        i = this.kernelSize[1],
        o = this.strides[0],
        l = this.strides[1];
    return t[n] = this.filters, t[s] = up(t[s], o, a, this.padding), t[r] = up(t[r], l, i, this.padding), t;
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.dilationRate, e;
  }

}

bp.className = "Conv2DTranspose", Kn(bp);

class xp extends mp {
  constructor(e) {
    if (super(e), this.inputSpec = [new hh({
      ndim: 5
    })], "same" !== this.padding && "valid" !== this.padding) throw new xu("Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ".concat(this.padding));
  }

  build(e) {
    if (5 !== (e = ih(e)).length) throw new xu("Input should have rank 5; Received input shape: " + JSON.stringify(e));
    var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[t]) throw new xu("The channel dimension of the inputs should be defined. Found `None`.");
    var n = e[t],
        s = this.kernelSize.concat([this.filters, n]);
    this.kernel = this.addWeight("kernel", s, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new hh({
      ndim: 5,
      axes: {
        [t]: n
      }
    })], this.built = !0;
  }

  call(e, t) {
    return Jn(() => {
      var t = ah(e);
      if (5 !== t.shape.length) throw new xu("Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-".concat(t.shape.length));
      var n = t.shape;
      var s, r, a;
      "channelsFirst" === this.dataFormat ? (a = 2, s = 3, r = 4) : (a = 1, s = 2, r = 3);
      var i = n[s],
          o = n[r],
          l = this.kernelSize[1],
          u = this.kernelSize[2],
          c = this.strides[1],
          h = this.strides[2],
          d = [n[0], up(n[a], this.strides[0], this.kernelSize[0], this.padding), up(i, c, l, this.padding), up(o, h, u, this.padding), this.filters];
      "channelsLast" !== this.dataFormat && (t = Sn(t, [0, 2, 3, 4, 1]));
      var p = nr(t, this.kernel.read(), d, this.strides, this.padding);
      return "channelsLast" !== this.dataFormat && (p = Sn(p, [0, 4, 1, 2, 3])), null !== this.bias && (p = Tc(p, this.bias.read(), this.dataFormat)), null !== this.activation && (p = this.activation.apply(p)), p;
    });
  }

  computeOutputShape(e) {
    var t = (e = ih(e)).slice();
    var n, s, r, a;
    "channelsFirst" === this.dataFormat ? (n = 1, s = 2, r = 3, a = 4) : (n = 4, s = 1, r = 2, a = 3);
    var i = this.kernelSize[0],
        o = this.kernelSize[1],
        l = this.kernelSize[2],
        u = this.strides[0],
        c = this.strides[1],
        h = this.strides[2];
    return t[n] = this.filters, t[s] = up(t[s], u, i, this.padding), t[r] = up(t[r], c, o, this.padding), t[a] = up(t[a], h, l, this.padding), t;
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.dilationRate, e;
  }

}

xp.className = "Conv3DTranspose", Kn(xp);

class yp extends fp {
  constructor(e, t) {
    if (super(e, t), this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", this.depthwiseKernel = null, this.pointwiseKernel = null, null == t.filters) throw new xu("The `filters` configuration field is required by SeparableConv, but is unspecified.");
    if (null != t.kernelInitializer || null != t.kernelRegularizer || null != t.kernelConstraint) throw new xu("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
    if (null != t.padding && "same" !== t.padding && "valid" !== t.padding) throw new xu("SeparableConv".concat(this.rank, "D supports only padding modes: 'same' and 'valid', but received ").concat(JSON.stringify(t.padding)));
    this.depthMultiplier = null == t.depthMultiplier ? 1 : t.depthMultiplier, this.depthwiseInitializer = Zc(t.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER), this.depthwiseRegularizer = ep(t.depthwiseRegularizer), this.depthwiseConstraint = Xu(t.depthwiseConstraint), this.pointwiseInitializer = Zc(t.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER), this.pointwiseRegularizer = ep(t.pointwiseRegularizer), this.pointwiseConstraint = Xu(t.pointwiseConstraint);
  }

  build(e) {
    if ((e = ih(e)).length < this.rank + 2) throw new xu("Inputs to SeparableConv".concat(this.rank, "D should have rank ").concat(this.rank + 2, ", but received input shape: ").concat(JSON.stringify(e)));
    var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[t] || e[t] < 0) throw new xu("The channel dimension of the inputs should be defined, but found ".concat(JSON.stringify(e[t])));
    var n = e[t],
        s = this.kernelSize.concat([n, this.depthMultiplier]),
        r = [];

    for (var _e208 = 0; _e208 < this.rank; ++_e208) {
      r.push(1);
    }

    r.push(n * this.depthMultiplier, this.filters);
    var a = !0;
    this.depthwiseKernel = this.addWeight("depthwise_kernel", s, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, a, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", r, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, a, this.pointwiseConstraint), this.bias = this.useBias ? this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, a, this.biasConstraint) : null, this.inputSpec = [new hh({
      ndim: this.rank + 2,
      axes: {
        [t]: n
      }
    })], this.built = !0;
  }

  call(e, t) {
    return Jn(() => {
      var t;
      if (e = ah(e), 1 === this.rank) throw new yu("1D separable convolution is not implemented yet.");
      return 2 === this.rank && ("channelsFirst" === this.dataFormat && (e = Sn(e, [0, 2, 3, 1])), t = Ya(e, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC")), this.useBias && (t = Tc(t, this.bias.read(), this.dataFormat)), null != this.activation && (t = this.activation.apply(t)), "channelsFirst" === this.dataFormat && (t = Sn(t, [0, 3, 1, 2])), t;
    });
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.rank, delete e.kernelInitializer, delete e.kernelRegularizer, delete e.kernelConstraint, e.depthwiseInitializer = Jc(this.depthwiseInitializer), e.pointwiseInitializer = Jc(this.pointwiseInitializer), e.depthwiseRegularizer = Zd(this.depthwiseRegularizer), e.pointwiseRegularizer = Zd(this.pointwiseRegularizer), e.depthwiseConstraint = ju(this.depthwiseConstraint), e.pointwiseConstraint = ju(this.pointwiseConstraint), e;
  }

}

yp.className = "SeparableConv";

class kp extends yp {
  constructor(e) {
    super(2, e);
  }

}

kp.className = "SeparableConv2D", Kn(kp);

class wp extends fp {
  constructor(e) {
    super(1, e), wp.verifyArgs(e), this.inputSpec = [{
      ndim: 3
    }];
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.rank, delete e.dataFormat, e;
  }

  static verifyArgs(e) {
    if ("number" != typeof e.kernelSize && !Mu(e.kernelSize, "number", 1, 1)) throw new xu("Conv1D expects config.kernelSize to be number or number[] with length 1, but received ".concat(JSON.stringify(e.kernelSize), "."));
  }

}

wp.className = "Conv1D", Kn(wp);

class vp extends mh {
  constructor(e) {
    super(e), this.cropping = "number" == typeof e.cropping ? [[e.cropping, e.cropping], [e.cropping, e.cropping]] : "number" == typeof e.cropping[0] ? [[e.cropping[0], e.cropping[0]], [e.cropping[1], e.cropping[1]]] : e.cropping, this.dataFormat = void 0 === e.dataFormat ? "channelsLast" : e.dataFormat, this.inputSpec = [{
      ndim: 4
    }];
  }

  computeOutputShape(e) {
    return "channelsFirst" === this.dataFormat ? [e[0], e[1], e[2] - this.cropping[0][0] - this.cropping[0][1], e[3] - this.cropping[1][0] - this.cropping[1][1]] : [e[0], e[1] - this.cropping[0][0] - this.cropping[0][1], e[2] - this.cropping[1][0] - this.cropping[1][1], e[3]];
  }

  call(e, t) {
    return Jn(() => {
      if (e = ah(e), "channelsLast" === this.dataFormat) {
        var _t201 = yc(e, this.cropping[0][0], e.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);

        return yc(_t201, this.cropping[1][0], e.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
      }

      {
        var _t202 = yc(e, this.cropping[0][0], e.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);

        return yc(_t202, this.cropping[1][0], e.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
      }
    });
  }

  getConfig() {
    var e = {
      cropping: this.cropping,
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

vp.className = "Cropping2D", Kn(vp);

class Ip extends mh {
  constructor(e) {
    super(e), this.DEFAULT_SIZE = [2, 2], this.inputSpec = [{
      ndim: 4
    }], this.size = null == e.size ? this.DEFAULT_SIZE : e.size, this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, nc(this.dataFormat), this.interpolation = null == e.interpolation ? "nearest" : e.interpolation, Ou(Ju, "InterpolationFormat", this.interpolation);
  }

  computeOutputShape(e) {
    return "channelsFirst" === this.dataFormat ? [e[0], e[1], null == e[2] ? null : this.size[0] * e[2], null == e[3] ? null : this.size[1] * e[3]] : [e[0], null == e[1] ? null : this.size[0] * e[1], null == e[2] ? null : this.size[1] * e[2], e[3]];
  }

  call(e, t) {
    return Jn(() => {
      var t = ah(e);
      var n = t.shape;

      if ("channelsFirst" === this.dataFormat) {
        t = Sn(t, [0, 2, 3, 1]);

        var _e209 = this.size[0] * n[2],
            _s103 = this.size[1] * n[3],
            _r74 = "nearest" === this.interpolation ? fo.resizeNearestNeighbor(t, [_e209, _s103]) : fo.resizeBilinear(t, [_e209, _s103]);

        return Sn(_r74, [0, 3, 1, 2]);
      }

      {
        var _e210 = this.size[0] * n[1],
            _s104 = this.size[1] * n[2];

        return "nearest" === this.interpolation ? fo.resizeNearestNeighbor(t, [_e210, _s104]) : fo.resizeBilinear(t, [_e210, _s104]);
      }
    });
  }

  getConfig() {
    var e = {
      size: this.size,
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Ip.className = "UpSampling2D", Kn(Ip);

class $p extends pp {
  constructor(e) {
    super(2, e), this.depthwiseKernel = null, this.depthMultiplier = null == e.depthMultiplier ? 1 : e.depthMultiplier, this.depthwiseInitializer = Zc(e.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.depthwiseConstraint = Xu(e.depthwiseConstraint), this.depthwiseRegularizer = ep(e.depthwiseRegularizer);
  }

  build(e) {
    if ((e = ih(e)).length < 4) throw new xu("Inputs to DepthwiseConv2D should have rank 4. Received input shape: ".concat(JSON.stringify(e), "."));
    var t = "channelsFirst" === this.dataFormat ? 1 : 3;
    if (null == e[t] || e[t] < 0) throw new xu("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (".concat(e[t], ")."));
    var n = e[t];
    this.depthwiseKernel = this.addWeight("depthwise_kernel", [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier], null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.bias = this.useBias ? this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : null, this.built = !0;
  }

  call(e, t) {
    return Jn(() => {
      var t = function (e, t) {
        var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1];
        var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "valid";
        var r = arguments.length > 4 ? arguments[4] : undefined;
        var a = arguments.length > 5 ? arguments[5] : undefined;
        return Jn(() => {
          null == r && (r = "channelsLast"), nc(r);
          var i = cp(e, r);
          if (4 !== e.rank) throw new xu("Input for depthwiseConv2d is required to be 4-D, but is instead ".concat(e.rank, "-D"));
          if (4 !== t.rank) throw new xu("depthwiseKernel is required to be 4-D, but is instead ".concat(t.rank, "-D"));
          return i = or(i, t, n, "same" === s ? "same" : "valid", "NHWC", a), "channelsFirst" === r && (i = Sn(i, [0, 3, 1, 2])), i;
        });
      }(e = ah(e), this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);

      return this.useBias && (t = Tc(t, this.bias.read(), this.dataFormat)), null != this.activation && (t = this.activation.apply(t)), t;
    });
  }

  computeOutputShape(e) {
    e = ih(e);
    var t = "channelsFirst" === this.dataFormat ? e[3] : e[2],
        n = "channelsFirst" === this.dataFormat ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier,
        s = lp("channelsFirst" === this.dataFormat ? e[2] : e[1], this.kernelSize[0], this.padding, this.strides[0]),
        r = lp(t, this.kernelSize[1], this.padding, this.strides[1]);
    return "channelsFirst" === this.dataFormat ? [e[0], n, s, r] : [e[0], s, r, n];
  }

  getConfig() {
    var e = super.getConfig();
    return e.depthMultiplier = this.depthMultiplier, e.depthwiseInitializer = Jc(this.depthwiseInitializer), e.depthwiseRegularizer = Zd(this.depthwiseRegularizer), e.depthwiseConstraint = ju(this.depthwiseRegularizer), e;
  }

}

function Sp(e, t, n, s) {
  if (Array.isArray(e)) {
    if (null != t || null != n) throw new xu("When inputs is an array, neither initialState or constants should be provided");
    null != s && (n = e.slice(e.length - s, e.length), e = e.slice(0, e.length - s)), e.length > 1 && (t = e.slice(1, e.length)), e = e[0];
  }

  function r(e) {
    return null == e || Array.isArray(e) ? e : [e];
  }

  return {
    inputs: e,
    initialState: t = r(t),
    constants: n = r(n)
  };
}

function Np(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  var r = arguments.length > 4 ? arguments[4] : undefined;
  var a = arguments.length > 5 ? arguments[5] : undefined;
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : !1;
  return Jn(() => {
    var l = t.shape.length;
    if (l < 3) throw new xu("Input should be at least 3D, but is ".concat(l, "D."));
    var u = [1, 0].concat(fc(2, l));
    if (t = Sn(t, u), null != a) throw new yu("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
    i && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != r && ((r = fn(fn(r, "bool"), "float32")).rank === l - 1 && (r = kr(r, -1)), r = Sn(r, u)), s && (t = Ha(t, 0), null != r && (r = Ha(r, 0)));
    var c = [];
    var h,
        d = n;
    var p = t.shape[0],
        f = Ii(t);
    var g, m;
    null != r && (g = Ii(r));

    var _loop24 = function _loop24(_t203) {
      var n = f[_t203],
          s = Jn(() => e(n, d));
      if (null == r) h = s[0], d = s[1];else {
        var _e211 = Jn(() => {
          var e = g[_t203],
              n = Gr(ya(e), e);
          return {
            output: ts(rs(s[0], e), rs(d[0], n)),
            newStates: d.map((t, r) => ts(rs(s[1][r], e), rs(t, n)))
          };
        });

        h = _e211.output, d = _e211.newStates;
      }
      o && c.push(h);
    };

    for (var _t203 = 0; _t203 < p; ++_t203) {
      _loop24(_t203);
    }

    return o && (m = pi(c, 1)), [h, m, d];
  });
}

$p.className = "DepthwiseConv2D", Kn($p);

class Cp extends mh {
  constructor(e) {
    var t;
    if (super(e), null == e.cell) throw new xu("cell property is missing for the constructor of RNN.");
    if (t = Array.isArray(e.cell) ? new Op({
      cells: e.cell
    }) : e.cell, null == t.stateSize) throw new xu("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
    this.cell = t, this.returnSequences = null != e.returnSequences && e.returnSequences, this.returnState = null != e.returnState && e.returnState, this.goBackwards = null != e.goBackwards && e.goBackwards, this._stateful = null != e.stateful && e.stateful, this.unroll = null != e.unroll && e.unroll, this.supportsMasking = !0, this.inputSpec = [new hh({
      ndim: 3
    })], this.stateSpec = null, this.states_ = null, this.numConstants = null, this.keptStates = [];
  }

  getStates() {
    return null == this.states_ ? fc(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(e => null) : this.states_;
  }

  setStates(e) {
    this.states_ = e;
  }

  computeOutputShape(e) {
    sh(e) && (e = e[0]), e = e;
    var t = this.cell.stateSize;
    Array.isArray(t) || (t = [t]);
    var n = t[0];
    var s;

    if (s = this.returnSequences ? [e[0], e[1], n] : [e[0], n], this.returnState) {
      var _n119 = [];

      for (var _s105 of t) {
        _n119.push([e[0], _s105]);
      }

      return [s].concat(_n119);
    }

    return s;
  }

  computeMask(e, t) {
    return Jn(() => {
      Array.isArray(t) && (t = t[0]);
      var e = this.returnSequences ? t : null;

      if (this.returnState) {
        var _t204 = this.states.map(e => null);

        return [e].concat(_t204);
      }

      return e;
    });
  }

  get states() {
    if (null == this.states_) {
      var _e212 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1,
          _t205 = [];

      for (var _n120 = 0; _n120 < _e212; ++_n120) {
        _t205.push(null);
      }

      return _t205;
    }

    return this.states_;
  }

  set states(e) {
    this.states_ = e;
  }

  build(e) {
    if (null != this.numConstants) throw new yu("Constants support is not implemented in RNN yet.");
    sh(e) && (e = e[0]), e = e;
    var t = this.stateful ? e[0] : null,
        n = e.slice(2);
    this.inputSpec[0] = new hh({
      shape: [t, null, ...n]
    });
    var s = [e[0]].concat(e.slice(2));
    var r;

    if (this.cell.build(s), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
      if (!p(this.stateSpec.map(e => e.shape[e.shape.length - 1]), r)) throw new xu("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=".concat(this.stateSpec, "; However cell.stateSize is ").concat(this.cell.stateSize));
    } else this.stateSpec = r.map(e => new hh({
      shape: [null, e]
    }));

    this.stateful && this.resetStates();
  }

  resetStates(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    Jn(() => {
      if (!this.stateful) throw new mu("Cannot call resetStates() on an RNN Layer that is not stateful.");
      var n = this.inputSpec[0].shape[0];
      if (null == n) throw new xu("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (null == this.states_) this.states_ = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map(e => ca([n, e])) : [ca([n, this.cell.stateSize])];else if (null == e) Zn(this.states_), null != this.keptStates && (Zn(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(e => ca([n, e])) : this.states_[0] = ca([n, this.cell.stateSize]);else {
        if (Array.isArray(e) || (e = [e]), e.length !== this.states_.length) throw new xu("Layer ".concat(this.name, " expects ").concat(this.states_.length, " state(s), but it received ").concat(e.length, " state value(s). Input received: ").concat(e));
        !0 === t ? this.keptStates.push(this.states_.slice()) : Zn(this.states_);

        for (var _t206 = 0; _t206 < this.states_.length; ++_t206) {
          var _s106 = e[_t206],
              _r75 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[_t206] : this.cell.stateSize,
              _a60 = [n, _r75];

          if (!p(_s106.shape, _a60)) throw new xu("State ".concat(_t206, " is incompatible with layer ").concat(this.name, ": expected shape=").concat(_a60, ", received shape=").concat(_s106.shape));
          this.states_[_t206] = _s106;
        }
      }
      this.states_ = this.states_.map(e => Qn(e.clone()));
    });
  }

  apply(e, t) {
    var n = null == t ? null : t.initialState,
        s = null == t ? null : t.constants;
    null == t && (t = {});
    var r = Sp(e, n, s, this.numConstants);
    e = r.inputs, n = r.initialState, s = r.constants;
    var a = [],
        i = [];

    if (null != n) {
      t.initialState = n, a = a.concat(n), this.stateSpec = [];

      for (var _e213 of n) {
        this.stateSpec.push(new hh({
          shape: _e213.shape
        }));
      }

      i = i.concat(this.stateSpec);
    }

    if (null != s && (t.constants = s, a = a.concat(s), this.numConstants = s.length), a[0] instanceof dh) {
      var _n121 = [e].concat(a),
          _s107 = this.inputSpec.concat(i),
          _r76 = this.inputSpec;

      this.inputSpec = _s107;

      var _o27 = super.apply(_n121, t);

      return this.inputSpec = _r76, _o27;
    }

    return super.apply(e, t);
  }

  call(e, t) {
    return Jn(() => {
      var n = null == t ? null : t.mask,
          s = null == t ? null : t.training;
      var r = null == t ? null : t.initialState;
      e = ah(e), null == r && (r = this.stateful ? this.states_ : this.getInitialState(e));
      var a = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      if (r.length !== a) throw new xu("RNN Layer has ".concat(a, " state(s) but was passed ").concat(r.length, " initial state(s)."));
      this.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
      var i = {
        training: s
      },
          o = Np((e, t) => {
        var n = this.cell.call([e].concat(t), i);
        return [n[0], n.slice(1)];
      }, e, r, this.goBackwards, n, null, this.unroll, this.returnSequences),
          l = o[0],
          u = o[1],
          c = o[2];
      this.stateful && this.resetStates(c, s);
      var h = this.returnSequences ? u : l;
      return this.returnState ? [h].concat(c) : h;
    });
  }

  getInitialState(e) {
    return Jn(() => {
      var t = ca(e.shape);
      return t = Hr(t, [1, 2]), t = mc(t), Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map(e => e > 1 ? vc(t, [1, e]) : t) : this.cell.stateSize > 1 ? [vc(t, [1, this.cell.stateSize])] : [t];
    });
  }

  get trainableWeights() {
    return this.trainable ? this.cell.trainableWeights : [];
  }

  get nonTrainableWeights() {
    return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
  }

  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), null != this.cell && this.cell.setFastWeightInitDuringBuild(e);
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      returnSequences: this.returnSequences,
      returnState: this.returnState,
      goBackwards: this.goBackwards,
      stateful: this.stateful,
      unroll: this.unroll
    };
    null != this.numConstants && (t.numConstants = this.numConstants);
    var n = this.cell.getConfig();
    return this.getClassName() === Cp.className && (t.cell = {
      className: this.cell.getClassName(),
      config: n
    }), Object.assign({}, n, e, t);
  }

  static fromConfig(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = Rh(t.cell, n);
    return new e(Object.assign(t, {
      cell: s
    }));
  }

}

Cp.className = "RNN", Kn(Cp);

class Tp extends mh {}

class Ep extends Tp {
  constructor(e) {
    super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, Lu(this.units, "units"), this.activation = Kd(null == e.activation ? this.DEFAULT_ACTIVATION : e.activation), this.useBias = null == e.useBias || e.useBias, this.kernelInitializer = Zc(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Zc(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Zc(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = ep(e.kernelRegularizer), this.recurrentRegularizer = ep(e.recurrentRegularizer), this.biasRegularizer = ep(e.biasRegularizer), this.kernelConstraint = Xu(e.kernelConstraint), this.recurrentConstraint = Xu(e.recurrentConstraint), this.biasConstraint = Xu(e.biasConstraint), this.dropout = dc([1, pc([0, null == e.dropout ? 0 : e.dropout])]), this.recurrentDropout = dc([1, pc([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
  }

  build(e) {
    e = ih(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.bias = this.useBias ? this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : null, this.built = !0;
  }

  call(e, t) {
    return Jn(() => {
      if (2 !== (e = e).length) throw new xu("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length, "."));
      var n = e[1];
      e = e[0];
      var s = null != t.training && t.training;
      var r;
      0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Mp({
        ones: () => ya(e),
        rate: this.dropout,
        training: s
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Mp({
        ones: () => ya(n),
        rate: this.recurrentDropout,
        training: s
      }));
      var a = this.dropoutMask,
          i = this.recurrentDropoutMask;
      r = $c(null != a ? rs(e, a) : e, this.kernel.read()), null != this.bias && (r = Tc(r, this.bias.read())), null != i && (n = rs(n, i));
      var o = ts(r, $c(n, this.recurrentKernel.read()));
      return null != this.activation && (o = this.activation.apply(o)), [o, o];
    });
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      units: this.units,
      activation: qd(this.activation),
      useBias: this.useBias,
      kernelInitializer: Jc(this.kernelInitializer),
      recurrentInitializer: Jc(this.recurrentInitializer),
      biasInitializer: Jc(this.biasInitializer),
      kernelRegularizer: Zd(this.kernelRegularizer),
      recurrentRegularizer: Zd(this.recurrentRegularizer),
      biasRegularizer: Zd(this.biasRegularizer),
      activityRegularizer: Zd(this.activityRegularizer),
      kernelConstraint: ju(this.kernelConstraint),
      recurrentConstraint: ju(this.recurrentConstraint),
      biasConstraint: ju(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout
    };
    return Object.assign({}, e, t);
  }

}

Ep.className = "SimpleRNNCell", Kn(Ep);

class Rp extends Cp {
  constructor(e) {
    e.cell = new Ep(e), super(e);
  }

  call(e, t) {
    return Jn(() => (null != this.cell.dropoutMask && (Zn(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (Zn(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), super.call(e, {
      mask: null == t ? null : t.mask,
      training: null == t ? null : t.training,
      initialState: null == t ? null : t.initialState
    })));
  }

  static fromConfig(e, t) {
    return new e(t);
  }

}

Rp.className = "SimpleRNN", Kn(Rp);

class Ap extends Tp {
  constructor(e) {
    if (super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", e.resetAfter) throw new xu("GRUCell does not support reset_after parameter set to true.");
    this.units = e.units, Lu(this.units, "units"), this.activation = Kd(void 0 === e.activation ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = Kd(void 0 === e.recurrentActivation ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = null == e.useBias || e.useBias, this.kernelInitializer = Zc(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Zc(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Zc(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = ep(e.kernelRegularizer), this.recurrentRegularizer = ep(e.recurrentRegularizer), this.biasRegularizer = ep(e.biasRegularizer), this.kernelConstraint = Xu(e.kernelConstraint), this.recurrentConstraint = Xu(e.recurrentConstraint), this.biasConstraint = Xu(e.biasConstraint), this.dropout = dc([1, pc([0, null == e.dropout ? 0 : e.dropout])]), this.recurrentDropout = dc([1, pc([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), this.implementation = e.implementation, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
  }

  build(e) {
    e = ih(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.bias = this.useBias ? this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : null, this.built = !0;
  }

  call(e, t) {
    return Jn(() => {
      if (2 !== (e = e).length) throw new xu("GRUCell expects 2 input Tensors (inputs, h, c), got ".concat(e.length, "."));
      var n = null != t.training && t.training;
      var s = e[1];
      e = e[0], 0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Mp({
        ones: () => ya(e),
        rate: this.dropout,
        training: n,
        count: 3
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Mp({
        ones: () => ya(s),
        rate: this.recurrentDropout,
        training: n,
        count: 3
      }));
      var r = this.recurrentDropoutMask;
      var a, i, o;
      0 < this.dropout && this.dropout < 1 && (e = rs(e, this.dropoutMask[0]));
      var l = $c(e, this.kernel.read());
      this.useBias && (l = Tc(l, this.bias.read())), 0 < this.recurrentDropout && this.recurrentDropout < 1 && (s = rs(s, r[0]));
      var u = this.recurrentKernel.read(),
          [c, h] = li(u, [2 * this.units, this.units], u.rank - 1),
          d = $c(s, c),
          [p, f, g] = li(l, 3, l.rank - 1),
          [m, b] = li(d, 2, d.rank - 1);
      a = this.recurrentActivation.apply(ts(p, m)), i = this.recurrentActivation.apply(ts(f, b));
      var x = $c(rs(i, s), h);
      o = this.activation.apply(ts(g, x));
      var y = ts(rs(a, s), rs(ts(1, Pr(a)), o));
      return [y, y];
    });
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      units: this.units,
      activation: qd(this.activation),
      recurrentActivation: qd(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: Jc(this.kernelInitializer),
      recurrentInitializer: Jc(this.recurrentInitializer),
      biasInitializer: Jc(this.biasInitializer),
      kernelRegularizer: Zd(this.kernelRegularizer),
      recurrentRegularizer: Zd(this.recurrentRegularizer),
      biasRegularizer: Zd(this.biasRegularizer),
      activityRegularizer: Zd(this.activityRegularizer),
      kernelConstraint: ju(this.kernelConstraint),
      recurrentConstraint: ju(this.recurrentConstraint),
      biasConstraint: ju(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation,
      resetAfter: !1
    };
    return Object.assign({}, e, t);
  }

}

Ap.className = "GRUCell", Kn(Ap);

class Fp extends Cp {
  constructor(e) {
    0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Ap(e), super(e);
  }

  call(e, t) {
    return Jn(() => (null != this.cell.dropoutMask && (Zn(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (Zn(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), super.call(e, {
      mask: null == t ? null : t.mask,
      training: null == t ? null : t.training,
      initialState: null == t ? null : t.initialState
    })));
  }

  static fromConfig(e, t) {
    return 0 === t.implmentation && (t.implementation = 1), new e(t);
  }

}

Fp.className = "GRU", Kn(Fp);

class Dp extends Tp {
  constructor(e) {
    super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, Lu(this.units, "units"), this.activation = Kd(void 0 === e.activation ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = Kd(void 0 === e.recurrentActivation ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = null == e.useBias || e.useBias, this.kernelInitializer = Zc(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Zc(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Zc(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.unitForgetBias = e.unitForgetBias, this.kernelRegularizer = ep(e.kernelRegularizer), this.recurrentRegularizer = ep(e.recurrentRegularizer), this.biasRegularizer = ep(e.biasRegularizer), this.kernelConstraint = Xu(e.kernelConstraint), this.recurrentConstraint = Xu(e.recurrentConstraint), this.biasConstraint = Xu(e.biasConstraint), this.dropout = dc([1, pc([0, null == e.dropout ? 0 : e.dropout])]), this.recurrentDropout = dc([1, pc([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), this.implementation = e.implementation, this.stateSize = [this.units, this.units], this.dropoutMask = null, this.recurrentDropoutMask = null;
  }

  build(e) {
    var t;
    var n;

    if (e = ih(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
      if (this.unitForgetBias) {
        var _e214 = this.biasInitializer,
            _s108 = this.units;
        n = new ((t = class extends Dc {
          apply(t, n) {
            var r = _e214.apply([_s108]),
                a = new Oc().apply([_s108]),
                i = _e214.apply([2 * _s108]);

            return wc(wc(r, a), i);
          }

        }).className = "CustomInit", t)();
      } else n = this.biasInitializer;

      this.bias = this.addWeight("bias", [4 * this.units], null, n, this.biasRegularizer, !0, this.biasConstraint);
    } else this.bias = null;

    this.built = !0;
  }

  call(e, t) {
    return Jn(() => {
      var n = null != t.training && t.training;
      if (3 !== (e = e).length) throw new xu("LSTMCell expects 3 input Tensors (inputs, h, c), got ".concat(e.length, "."));
      var s = e[1];
      var r = e[2];
      e = e[0], 0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Mp({
        ones: () => ya(e),
        rate: this.dropout,
        training: n,
        count: 4
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Mp({
        ones: () => ya(s),
        rate: this.recurrentDropout,
        training: n,
        count: 4
      }));
      var a = this.recurrentDropoutMask;
      var i, o, l, u;
      0 < this.dropout && this.dropout < 1 && (e = rs(e, this.dropoutMask[0]));
      var c = $c(e, this.kernel.read());
      0 < this.recurrentDropout && this.recurrentDropout < 1 && (s = rs(s, a[0])), c = ts(c, $c(s, this.recurrentKernel.read())), this.useBias && (c = Tc(c, this.bias.read()));
      var [h, d, p, f] = li(c, 4, c.rank - 1);
      i = this.recurrentActivation.apply(h), o = this.recurrentActivation.apply(d), l = ts(rs(o, r), rs(i, this.activation.apply(p))), u = this.recurrentActivation.apply(f);
      var g = rs(u, this.activation.apply(l));
      return [g, g, l];
    });
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      units: this.units,
      activation: qd(this.activation),
      recurrentActivation: qd(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: Jc(this.kernelInitializer),
      recurrentInitializer: Jc(this.recurrentInitializer),
      biasInitializer: Jc(this.biasInitializer),
      unitForgetBias: this.unitForgetBias,
      kernelRegularizer: Zd(this.kernelRegularizer),
      recurrentRegularizer: Zd(this.recurrentRegularizer),
      biasRegularizer: Zd(this.biasRegularizer),
      activityRegularizer: Zd(this.activityRegularizer),
      kernelConstraint: ju(this.kernelConstraint),
      recurrentConstraint: ju(this.recurrentConstraint),
      biasConstraint: ju(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    };
    return Object.assign({}, e, t);
  }

}

Dp.className = "LSTMCell", Kn(Dp);

class _p extends Cp {
  constructor(e) {
    0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Dp(e), super(e);
  }

  call(e, t) {
    return Jn(() => (null != this.cell.dropoutMask && (Zn(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (Zn(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), super.call(e, {
      mask: null == t ? null : t.mask,
      training: null == t ? null : t.training,
      initialState: null == t ? null : t.initialState
    })));
  }

  static fromConfig(e, t) {
    return 0 === t.implmentation && (t.implementation = 1), new e(t);
  }

}

_p.className = "LSTM", Kn(_p);

class Op extends Tp {
  constructor(e) {
    super(e), this.cells = e.cells;
  }

  get stateSize() {
    var e = [];

    for (var _t207 of this.cells.slice().reverse()) {
      Array.isArray(_t207.stateSize) ? e.push(..._t207.stateSize) : e.push(_t207.stateSize);
    }

    return e;
  }

  call(e, t) {
    return Jn(() => {
      var n = (e = e).slice(1);
      var s = [];

      for (var _e215 of this.cells.slice().reverse()) {
        Array.isArray(_e215.stateSize) ? s.push(n.splice(0, _e215.stateSize.length)) : s.push(n.splice(0, 1));
      }

      s.reverse();
      var r = [];
      var a;

      for (var _i34 = 0; _i34 < this.cells.length; ++_i34) {
        var _o28 = this.cells[_i34];
        n = s[_i34], a = 0 === _i34 ? [e[0]].concat(n) : [a[0]].concat(n), a = _o28.call(a, t), r.push(a.slice(1));
      }

      n = [];

      for (var _e216 of r.slice().reverse()) {
        n.push(..._e216);
      }

      return [a[0]].concat(n);
    });
  }

  build(e) {
    var t;
    sh(e) && (e = e[0]), e = e, this.cells.forEach((n, s) => {
      ic("RNNCell_".concat(s), () => {
        n.build(e), t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, e = [e[0], t];
      });
    }), this.built = !0;
  }

  getConfig() {
    var e = super.getConfig(),
        t = this.cells.map(e => ({
      className: e.getClassName(),
      config: e.getConfig()
    }));
    return Object.assign({}, e, {
      cells: t
    });
  }

  static fromConfig(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = [];

    for (var _e217 of t.cells) {
      s.push(Rh(_e217, n));
    }

    return new e({
      cells: s
    });
  }

  get trainableWeights() {
    if (!this.trainable) return [];
    var e = [];

    for (var _t208 of this.cells) {
      e.push(..._t208.trainableWeights);
    }

    return e;
  }

  get nonTrainableWeights() {
    var e = [];

    for (var _t209 of this.cells) {
      e.push(..._t209.nonTrainableWeights);
    }

    if (!this.trainable) {
      var _t210 = [];

      for (var _e218 of this.cells) {
        _t210.push(..._e218.trainableWeights);
      }

      return _t210.concat(e);
    }

    return e;
  }

  getWeights() {
    var e = [];

    for (var _t211 of this.cells) {
      e.push(..._t211.weights);
    }

    return uh(e);
  }

  setWeights(e) {
    var t = [];

    for (var _n122 of this.cells) {
      var _s109 = e.splice(_n122.weights.length);

      for (var _e219 = 0; _e219 < _n122.weights.length; ++_e219) {
        t.push([_n122.weights[_e219], _s109[_e219]]);
      }
    }

    ch(t);
  }

}

function Mp(e) {
  var {
    ones: t,
    rate: n,
    training: s = !1,
    count: r = 1
  } = e,
      a = () => Ec(t(), n),
      i = () => Rc(a, t, s);

  return !r || r <= 1 ? Qn(i().clone()) : Array(r).fill(void 0).map(i).map(e => Qn(e.clone()));
}

var Lp, zp, Bp;
Op.className = "StackedRNNCells", Kn(Op);

class Pp extends Cp {
  constructor(e) {
    if (e.unroll) throw new yu("Unrolling is not possible with convolutional RNNs.");
    if (Array.isArray(e.cell)) throw new yu("It is not possible at the moment to stack convolutional cells.");
    super(e), this.inputSpec = [new hh({
      ndim: 5
    })];
  }

  call(e, t) {
    return Jn(() => {
      if (null != this.cell.dropoutMask && (Zn(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (Zn(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), t && t.constants) throw new xu("ConvRNN2D cell does not support constants");
      return super.call(e, {
        mask: null == t ? null : t.mask,
        training: null == t ? null : t.training,
        initialState: null == t ? null : t.initialState
      });
    });
  }

  computeOutputShape(e) {
    var t = this.computeSingleOutputShape(e);
    return this.returnSequences || (t = [t[0], ...t.slice(2)]), this.returnState && (t = [t, ...Array(2).fill([e[0], ...t.slice(-3)])]), t;
  }

  getInitialState(e) {
    return Jn(() => {
      var {
        stateSize: t
      } = this.cell,
          n = this.computeSingleOutputShape(e.shape),
          s = ca([n[0], ...n.slice(2)]);
      return Array.isArray(t) ? Array(t.length).fill(s) : [s];
    });
  }

  resetStates(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    Jn(() => {
      if (!this.stateful) throw new mu("Cannot call resetStates() on an RNN Layer that is not stateful.");
      var n = this.inputSpec[0].shape,
          s = this.computeSingleOutputShape(n),
          r = [s[0], ...s.slice(2)];
      if (null == n[0]) throw new xu("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (null == this.getStates()) this.states_ = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map(() => ca(r)) : [ca(r)];else if (null == e) Zn(this.states_), null != this.keptStates && (Zn(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => ca(r)) : this.states_[0] = ca(r);else {
        if (Array.isArray(e) || (e = [e]), e.length !== this.states_.length) throw new xu("Layer ".concat(this.name, " expects ").concat(this.states_.length, " state(s), but it received ").concat(e.length, " state value(s). Input received: ").concat(e));
        t ? this.keptStates.push(this.states_.slice()) : Zn(this.states_);

        for (var _t212 = 0; _t212 < this.states_.length; ++_t212) {
          var _n123 = e[_t212],
              _s110 = r;
          if (!p(_n123.shape, _s110)) throw new xu("State ".concat(_t212, " is incompatible with layer ").concat(this.name, ": expected shape=").concat(_s110, ", received shape=").concat(_n123.shape));
          this.states_[_t212] = _n123;
        }
      }
      this.states_ = this.states_.map(e => Qn(e.clone()));
    });
  }

  computeSingleOutputShape(e) {
    var {
      dataFormat: t,
      filters: n,
      kernelSize: s,
      padding: r,
      strides: a,
      dilationRate: i
    } = this.cell,
        o = "channelsFirst" === t,
        l = e[o ? 4 : 3],
        u = lp(e[o ? 3 : 2], s[0], r, a[0], i[0]),
        c = lp(l, s[1], r, a[1], i[1]);
    return [...e.slice(0, 2), ...(o ? [n, u, c] : [u, c, n])];
  }

}

Pp.className = "ConvRNN2D";

class Wp extends Dp {
  constructor(e) {
    var {
      filters: t,
      kernelSize: n,
      strides: s,
      padding: r,
      dataFormat: a,
      dilationRate: i
    } = e;
    super(Object.assign({}, e, {
      units: t
    })), this.filters = t, Lu(this.filters, "filters"), this.kernelSize = op(n, 2, "kernelSize"), this.kernelSize.forEach(e => Lu(e, "kernelSize")), this.strides = op(s || 1, 2, "strides"), this.strides.forEach(e => Lu(e, "strides")), this.padding = r || "valid", sc(this.padding), this.dataFormat = a || "channelsLast", nc(this.dataFormat), this.dilationRate = op(i || 1, 2, "dilationRate"), this.dilationRate.forEach(e => Lu(e, "dilationRate"));
  }

  build(e) {
    var t;
    e = ih(e);
    var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[n]) throw new xu("The channel dimension of the input should be defined. Found ".concat(e[n]));
    var s = this.kernelSize.concat([e[n], 4 * this.filters]);
    this.kernel = this.addWeight("kernel", s, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint);
    var r = this.kernelSize.concat([this.filters, 4 * this.filters]);

    if (this.recurrentKernel = this.addWeight("recurrent_kernel", r, null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
      var _e220;

      if (this.unitForgetBias) {
        var _n124 = this.biasInitializer,
            _s111 = this.filters;
        _e220 = new ((t = class extends Dc {
          apply(e, t) {
            return kc([_n124.apply([_s111]), ha([_s111]), _n124.apply([2 * _s111])]);
          }

        }).className = "CustomInit", t)();
      } else _e220 = this.biasInitializer;

      this.bias = this.addWeight("bias", [4 * this.filters], null, _e220, this.biasRegularizer, !0, this.biasConstraint);
    }

    this.built = !0;
  }

  call(e, t) {
    return Jn(() => {
      if (3 !== e.length) throw new xu("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ".concat(e.length, "."));
      var n = t.training || !1,
          s = e[0],
          r = e[1],
          a = e[2];
      0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Mp({
        ones: () => ya(s),
        rate: this.dropout,
        training: n,
        count: 4
      }));

      var i = this.dropoutMask,
          o = (e, t, n) => t && t[n] ? rs(t[n], e) : e;

      var l = o(s, i, 0),
          u = o(s, i, 1),
          c = o(s, i, 2),
          h = o(s, i, 3);
      0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Mp({
        ones: () => ya(r),
        rate: this.recurrentDropout,
        training: n,
        count: 4
      }));
      var d = this.recurrentDropoutMask;
      var p = o(r, d, 0),
          f = o(r, d, 1),
          g = o(r, d, 2),
          m = o(r, d, 3);
      var [b, x, y, k] = li(this.kernel.read(), 4, 3),
          [w, v, I, $] = this.useBias ? li(this.bias.read(), 4) : [null, null, null, null];
      l = this.inputConv(l, b, w, this.padding), u = this.inputConv(u, x, v, this.padding), c = this.inputConv(c, y, I, this.padding), h = this.inputConv(h, k, $, this.padding);
      var [S, N, C, T] = li(this.recurrentKernel.read(), 4, 3);
      p = this.recurrentConv(p, S), f = this.recurrentConv(f, N), g = this.recurrentConv(g, C), m = this.recurrentConv(m, T);
      var E = this.recurrentActivation.apply(ts(l, p)),
          R = this.recurrentActivation.apply(ts(u, f)),
          A = ts(rs(R, a), rs(E, this.activation.apply(ts(c, g)))),
          F = rs(this.recurrentActivation.apply(ts(h, m)), this.activation.apply(A));
      return [F, F, A];
    });
  }

  getConfig() {
    var e = function (e, t) {
      var n = {};

      for (var s in e) {
        Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
      }

      if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
        var r = 0;

        for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) {
          t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]]);
        }
      }

      return n;
    }(super.getConfig(), ["units"]);

    return Object.assign({}, e, {
      filters: this.filters,
      kernelSize: this.kernelSize,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      strides: this.strides
    });
  }

  inputConv(e, t, n, s) {
    var r = Ys(e, t, this.strides, s || "valid", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC", this.dilationRate);
    return n ? Tc(r, n, this.dataFormat) : r;
  }

  recurrentConv(e, t) {
    return Ys(e, t, 1, "same", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC");
  }

}

Wp.className = "ConvLSTM2DCell", Kn(Wp);

class Up extends Pp {
  constructor(e) {
    var t = new Wp(e);
    super(Object.assign({}, e, {
      cell: t
    }));
  }

  static fromConfig(e, t) {
    return new e(t);
  }

}

Up.className = "ConvLSTM2D", Kn(Up);

class Vp extends mh {
  constructor(e) {
    super(e), this.rate = Math.max(Math.min(e.rate, 1), 0), this.noiseShape = e.noiseShape, this.seed = e.seed, this.supportsMasking = !0;
  }

  getNoiseShape(e) {
    if (null == this.noiseShape) return this.noiseShape;
    var t = e.shape,
        n = [];

    for (var _e221 = 0; _e221 < this.noiseShape.length; ++_e221) {
      n.push(null == this.noiseShape[_e221] ? t[_e221] : this.noiseShape[_e221]);
    }

    return n;
  }

  call(e, t) {
    return Jn(() => {
      this.invokeCallHook(e, t);
      var n = ah(e);

      if (0 < this.rate && this.rate < 1) {
        var _e222 = null != t.training && t.training,
            _s112 = this.getNoiseShape(n);

        return Rc(() => Ec(n, this.rate, _s112, this.seed), () => n, _e222);
      }

      return e;
    });
  }

  getConfig() {
    var e = {
      rate: this.rate,
      noiseShape: this.noiseShape,
      seed: this.seed
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

  dispose() {
    return super.dispose();
  }

}

Vp.className = "Dropout", Kn(Vp);

class Gp extends Vp {
  constructor(e) {
    super(e), this.inputSpec = [{
      ndim: 3
    }];
  }

  getNoiseShape(e) {
    var t = e.shape;
    return [t[0], 1, t[2]];
  }

}

Gp.className = "SpatialDropout1D", Kn(Gp);

class Hp extends mh {
  constructor(e) {
    if (super(e), this.activation = null, this.useBias = !0, this.kernel = null, this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", null == e.batchInputShape && null == e.inputShape && null != e.inputDim) {
      var _t213 = null;
      null != e.batchSize && (_t213 = e.batchSize), this.batchInputShape = [_t213, e.inputDim];
    }

    this.units = e.units, Lu(this.units, "units"), this.activation = Kd(e.activation), null != e.useBias && (this.useBias = e.useBias), this.kernelInitializer = Zc(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.biasInitializer = Zc(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelConstraint = Xu(e.kernelConstraint), this.biasConstraint = Xu(e.biasConstraint), this.kernelRegularizer = ep(e.kernelRegularizer), this.biasRegularizer = ep(e.biasRegularizer), this.activityRegularizer = ep(e.activityRegularizer), this.supportsMasking = !0, this.inputSpec = [{
      minNDim: 2
    }];
  }

  build(e) {
    var t = (e = ih(e))[e.length - 1];
    null == this.kernel && (this.kernel = this.addWeight("kernel", [t, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{
      minNDim: 2,
      axes: {
        [-1]: t
      }
    }], this.built = !0;
  }

  computeOutputShape(e) {
    var t = (e = ih(e)).slice();
    return t[t.length - 1] = this.units, t;
  }

  call(e, t) {
    return Jn(() => {
      this.invokeCallHook(e, t);
      var n = ah(e),
          s = Bu(this.activation.getClassName());
      var r;
      return null != s ? r = $c(n, this.kernel.read(), s, this.bias ? this.bias.read() : null) : (r = $c(n, this.kernel.read()), null != this.bias && (r = Tc(r, this.bias.read())), null != this.activation && (r = this.activation.apply(r))), r;
    });
  }

  getConfig() {
    var e = {
      units: this.units,
      activation: qd(this.activation),
      useBias: this.useBias,
      kernelInitializer: Jc(this.kernelInitializer),
      biasInitializer: Jc(this.biasInitializer),
      kernelRegularizer: Zd(this.kernelRegularizer),
      biasRegularizer: Zd(this.biasRegularizer),
      activityRegularizer: Zd(this.activityRegularizer),
      kernelConstraint: ju(this.kernelConstraint),
      biasConstraint: ju(this.biasConstraint)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Hp.className = "Dense", Kn(Hp);

class qp extends mh {
  constructor(e) {
    super(e = e || {}), this.inputSpec = [{
      minNDim: 3
    }], this.dataFormat = e.dataFormat;
  }

  computeOutputShape(e) {
    e = ih(e);

    for (var _t214 of e.slice(1)) {
      if (null == _t214) throw new xu("The shape of the input to \"Flatten\" is not fully defined (got ".concat(e.slice(1), "). Make sure to pass a complete \"input_shape\" or \"batch_input_shape\" argument to the first layer in your model."));
    }

    return [e[0], hc(e, 1)];
  }

  call(e, t) {
    return Jn(() => {
      this.invokeCallHook(e, t);
      var n = ah(e);

      if ("channelsFirst" === this.dataFormat && n.rank > 1) {
        var _e223 = [0];

        for (var _t215 = 2; _t215 < n.rank; ++_t215) {
          _e223.push(_t215);
        }

        _e223.push(1), n = Sn(n, _e223);
      }

      return function (e) {
        if (e.rank <= 1) throw new xu("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank, "."));
        var t = [e.shape[0], hc(e.shape, 1)];
        return Rs(e, t);
      }(n);
    });
  }

  getConfig() {
    var e = {};
    null != this.dataFormat && (e.dataFormat = this.dataFormat);
    var t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

qp.className = "Flatten", Kn(qp);

class jp extends mh {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.activation = Kd(e.activation);
  }

  call(e, t) {
    return Jn(() => {
      this.invokeCallHook(e, t);
      var n = ah(e);
      return this.activation.apply(n);
    });
  }

  getConfig() {
    var e = {
      activation: qd(this.activation)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

jp.className = "Activation", Kn(jp);

class Kp extends mh {
  constructor(e) {
    super(e), this.n = e.n, this.inputSpec = [{
      ndim: 2
    }];
  }

  computeOutputShape(e) {
    return [e[0], this.n, e[1]];
  }

  call(e, t) {
    return Jn(() => {
      return e = ah(e), t = e, n = this.n, Jn(() => {
        if (2 !== t.shape.length) throw new xu("repeat() expects a rank-2 tensor, but received a rank-".concat(t.shape.length, " tensor."));
        return vc(mc(t, 1), [1, n, 1]);
      });
      var t, n;
    });
  }

  getConfig() {
    var e = {
      n: this.n
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Kp.className = "RepeatVector", Kn(Kp);

class Xp extends mh {
  constructor(e) {
    super(e), this.targetShape = e.targetShape;

    for (var _e224 = 0; _e224 < this.targetShape.length; ++_e224) {
      this.isUnknown(this.targetShape[_e224]) && (this.targetShape[_e224] = null);
    }
  }

  isUnknown(e) {
    return e < 0 || null == e;
  }

  fixUnknownDimension(e, t) {
    var n = "Total size of new array must be unchanged.",
        s = t.slice();
    var r = 1,
        a = null;

    for (var _e225 = 0; _e225 < s.length; ++_e225) {
      var _t216 = s[_e225];

      if (this.isUnknown(_t216)) {
        if (null !== a) throw new xu("Can only specifiy one unknown dimension.");
        a = _e225;
      } else r *= _t216;
    }

    var i = hc(e);

    if (null !== a) {
      if (0 === r || i % r != 0) throw new xu(n);
      s[a] = i / r;
    } else if (i !== r) throw new xu(n);

    return s;
  }

  computeOutputShape(e) {
    var t = !1;

    for (var _n125 = 0; _n125 < e.length; ++_n125) {
      if (this.isUnknown(e[_n125])) {
        t = !0;
        break;
      }
    }

    return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
  }

  call(e, t) {
    return Jn(() => {
      this.invokeCallHook(e, t);
      var n = ah(e),
          s = n.shape,
          r = s.slice(0, 1).concat(this.fixUnknownDimension(s.slice(1), this.targetShape));
      return Rs(n, r);
    });
  }

  getConfig() {
    var e = {
      targetShape: this.targetShape
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Xp.className = "Reshape", Kn(Xp);

class Yp extends mh {
  constructor(e) {
    if (super(e), null == e.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
    if (!Array.isArray(e.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received ".concat(e.dims, " instead."));
    var t = fc(1, e.dims.length + 1);
    if (!p(e.dims.slice().sort(), t)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
    this.dims = e.dims, this.dimsIncludingBatch = [0].concat(this.dims), this.inputSpec = [new hh({
      ndim: this.dims.length + 1
    })];
  }

  computeOutputShape(e) {
    var t = (e = ih(e)).slice();
    return this.dims.forEach((n, s) => {
      t[s + 1] = e[n];
    }), t;
  }

  call(e, t) {
    return Sn(ah(e), this.dimsIncludingBatch);
  }

  getConfig() {
    var e = {
      dims: this.dims
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Yp.className = "Permute", Kn(Yp);

class Jp extends mh {
  constructor(e) {
    super(null == e ? {} : e), this.supportsMasking = !0, this.maskValue = null != e ? null == e.maskValue ? 0 : e.maskValue : 0;
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      maskValue: this.maskValue
    };
    return Object.assign(t, e), t;
  }

  computeMask(e, t) {
    var n = ah(e);
    return us(xa(n, this.maskValue), -1);
  }

  call(e, t) {
    return Jn(() => {
      this.invokeCallHook(e, t);
      var n = ah(e),
          s = us(xa(n, this.maskValue), -1, !0);
      return rs(n, fn(s, n.dtype));
    });
  }

}

Jp.className = "Masking", Kn(Jp);

class Zp extends mh {
  constructor(e) {
    if (super(e), this.embeddings = null, this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == e.batchInputShape && null == e.inputShape) {
      var _t217 = null;
      null != e.batchSize && (_t217 = e.batchSize), this.batchInputShape = null == e.inputLength ? [_t217, null] : [_t217].concat(Su(e.inputLength));
    }

    this.inputDim = e.inputDim, Lu(this.inputDim, "inputDim"), this.outputDim = e.outputDim, Lu(this.outputDim, "outputDim"), this.embeddingsInitializer = Zc(e.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER), this.embeddingsRegularizer = ep(e.embeddingsRegularizer), this.activityRegularizer = ep(e.activityRegularizer), this.embeddingsConstraint = Xu(e.embeddingsConstraint), this.maskZero = e.maskZero, this.supportsMasking = e.maskZero, this.inputLength = e.inputLength;
  }

  build(e) {
    this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0;
  }

  warnOnIncompatibleInputShape(e) {}

  computeMask(e, t) {
    return Jn(() => this.maskZero ? (e = ah(e), xa(e, fr(e))) : null);
  }

  computeOutputShape(e) {
    if (e = ih(e), null == this.inputLength) return [...e, this.outputDim];
    var t = Su(this.inputLength);
    if (t.length !== e.length - 1) throw new xu("\"inputLength\" is ".concat(this.inputLength, ", but received input shape has shape ").concat(e));
    {
      var _n126 = 0;

      for (var _s113 = 0; _s113 < t.length; ++_s113) {
        var _r77 = t[_s113],
            _a61 = e[_s113 + 1];
        if (null != _r77 && null != _a61 && _r77 !== _a61) throw new xu("\"inputLength\" is ".concat(this.inputLength, ", but received input shape has shape ").concat(e));
        null == _r77 && (t[_n126] = _a61), _n126++;
      }
    }
    return [e[0], ...t, this.outputDim];
  }

  call(e, t) {
    return Jn(() => {
      this.invokeCallHook(e, t);
      var n = ah(e);
      "int32" !== n.dtype && (n = gc(n, "int32"));
      var s = Sc(this.embeddings.read(), Rs(n, [n.size]));
      return Rs(s, ih(this.computeOutputShape(n.shape)));
    });
  }

  getConfig() {
    var e = {
      inputDim: this.inputDim,
      outputDim: this.outputDim,
      embeddingsInitializer: Jc(this.embeddingsInitializer),
      embeddingsRegularizer: Zd(this.embeddingsRegularizer),
      activityRegularizer: Zd(this.activityRegularizer),
      embeddingsConstraint: ju(this.embeddingsConstraint),
      maskZero: this.maskZero,
      inputLength: this.inputLength
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Zp.className = "Embedding", Kn(Zp);

class Qp extends mh {
  constructor(e) {
    super(e || {}), this.supportsMasking = !0;
  }

  mergeFunction(e) {
    throw new yu();
  }

  computeElementwiseOpOutputShape(e, t) {
    if (null == e || null == t) return null;
    if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
    if (0 === t.length) return e;
    var n = e.slice(0, e.length - t.length);

    for (var _s114 = 0; _s114 < t.length; ++_s114) {
      var _r78 = e[e.length - t.length + _s114],
          _a62 = t[_s114];
      if (null == _r78 || null == _a62 || _r78 < 0 || _a62 < 0) n.push(null);else if (1 === _r78) n.push(_a62);else if (1 === _a62) n.push(_r78);else {
        if (_r78 !== _a62) throw new xu("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
        n.push(_r78);
      }
    }

    return n;
  }

  build(e) {
    if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [ih(e)]), (e = e).length < 2) throw new xu("A merge layer should be called on an Array of at least 2 inputs. Got ".concat(e.length, " input(s)."));
    var t = [];

    for (var _n127 of e) {
      null != _n127 && null !== _n127[0] && t.push(_n127[0]);
    }

    if (t = Du(t), t.length > 1) throw new xu("Can not merge tensors with different batch sizes. Got tensors with shapes: ".concat(JSON.stringify(e), "."));
    var n = null == e[0] ? null : e[0].slice(1);

    for (var _t218 = 1; _t218 < e.length; ++_t218) {
      var _s115 = null == e[_t218] ? null : e[_t218].slice(1);

      n = this.computeElementwiseOpOutputShape(n, _s115);
    }

    var s = e.map(e => e.length);
    this.reshapeRequired = -1 !== e.indexOf(null) || 1 !== Du(s).length;
  }

  call(e, t) {
    return Jn(() => {
      if (e = e, this.reshapeRequired) {
        var _t219 = [],
            _n128 = e.map(e => e.rank);

        if (-1 === _n128.indexOf(null)) {
          var _s116 = pc(_n128);

          for (var _n129 of e) {
            var _e226 = _n129.rank;

            for (var _t220 = 0; _t220 < _s116 - _e226; ++_t220) {
              _n129 = mc(_n129, 1);
            }

            _t219.push(_n129);
          }

          return this.mergeFunction(_t219);
        }

        {
          var _n130 = !1;

          for (var _s118 of e) {
            var _e227 = _s118.rank;

            if (null == _e227) {
              var _e228 = _s118.shape,
                  _r80 = _e228[0],
                  _a63 = _e228.slice(1).concat([_r80]);

              var _i35 = Rs(_s118, [_r80].concat(hc(_e228.slice(1))));

              _i35 = Sn(_i35, [1, 0]), _i35 = Rs(_i35, _a63), _t219.push(_i35), _n130 = !0;
            } else if (_e227 > 1) {
              var _r81 = fc(1, _e227).concat([0]);

              _t219.push(Sn(_s118, _r81)), _n130 = !0;
            } else _t219.push(_s118);
          }

          var _s117 = this.mergeFunction(_t219);

          var _r79 = _s117.rank;
          if (_n130) if (null == _r79) {
            var _e229 = _s117.shape,
                _t221 = _e229[_e229.length - 1],
                _n131 = [_t221].concat(_e229.slice(0, _e229.length - 1));

            _s117 = Rs(Sn(Rs(_s117, [-1, _t221]), [1, 0]), _n131);
          } else if (_r79 > 1) {
            var _e230 = [_r79 - 1].concat(fc(0, _r79 - 1));

            _s117 = Sn(_s117, _e230);
          }
          return _s117;
        }
      }

      return this.mergeFunction(e);
    });
  }

  computeOutputShape(e) {
    var t;
    t = null == (e = e)[0] ? null : e[0].slice(1);

    for (var _n132 = 1; _n132 < e.length; ++_n132) {
      var _s119 = null == e[_n132] ? null : e[_n132].slice(1);

      t = this.computeElementwiseOpOutputShape(t, _s119);
    }

    var n = [];

    for (var _t222 of e) {
      null != _t222 && null !== _t222[0] && n.push(_t222[0]);
    }

    return n = Du(n), t = 1 === n.length ? n.concat(t) : [null].concat(t), t;
  }

  computeMask(e, t) {
    return Jn(() => {
      if (null == t) return null;
      if (!Array.isArray(t)) throw new xu("`mask` should be an Array");
      if (!Array.isArray(e)) throw new xu("`inputs` should be an Array");
      if (t.length !== e.length) throw new xu("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (".concat(e.length, " vs ").concat(t.length, ")"));
      if (t.every(e => null == e)) return null;
      var n = (t = t.map(e => null == e ? e : kr(e, 0)))[0];

      for (var _e231 = 1; _e231 < t.length - 1; ++_e231) {
        n = na(n, t[_e231]);
      }

      return n;
    });
  }

}

class ef extends Qp {
  constructor(e) {
    super(e);
  }

  mergeFunction(e) {
    return Jn(() => {
      var t = e[0].clone();

      for (var _n133 = 1; _n133 < e.length; ++_n133) {
        t = ts(t, e[_n133]);
      }

      return t;
    });
  }

}

ef.className = "Add", Kn(ef);

class tf extends Qp {
  constructor(e) {
    super(e);
  }

  mergeFunction(e) {
    return Jn(() => {
      var t = e[0].clone();

      for (var _n134 = 1; _n134 < e.length; ++_n134) {
        t = rs(t, e[_n134]);
      }

      return t;
    });
  }

}

tf.className = "Multiply", Kn(tf);

class nf extends Qp {
  constructor(e) {
    super(e);
  }

  mergeFunction(e) {
    return Jn(() => {
      var t = e[0].clone();

      for (var _n135 = 1; _n135 < e.length; ++_n135) {
        t = ts(t, e[_n135]);
      }

      return rs(1 / e.length, t);
    });
  }

}

nf.className = "Average", Kn(nf);

class sf extends Qp {
  constructor(e) {
    super(e);
  }

  mergeFunction(e) {
    return Jn(() => {
      var t = e[0];

      for (var _n136 = 1; _n136 < e.length; ++_n136) {
        t = la(t, e[_n136]);
      }

      return t;
    });
  }

}

sf.className = "Maximum", Kn(sf);

class rf extends Qp {
  constructor(e) {
    super(e);
  }

  mergeFunction(e) {
    return Jn(() => {
      var t = e[0];

      for (var _n137 = 1; _n137 < e.length; ++_n137) {
        t = pa(t, e[_n137]);
      }

      return t;
    });
  }

}

rf.className = "Minimum", Kn(rf);

class af extends Qp {
  constructor(e) {
    super(e), this.DEFAULT_AXIS = -1, null == e && (e = {}), this.axis = null == e.axis ? this.DEFAULT_AXIS : e.axis, this.supportsMasking = !0, this.reshapeRequired = !1;
  }

  build(e) {
    if (!Array.isArray(e) || !Array.isArray(e[0]) || 1 === e.length) throw new xu("A `Concatenate` layer should be called on a list of at least 2 inputs");
    e = e;
    var t = !0;

    for (var _n138 of e) {
      if (null != _n138) {
        t = !1;
        break;
      }
    }

    if (t) return;
    var n = [];

    for (var _t223 = 0; _t223 < e.length; ++_t223) {
      var _s120 = e[_t223].slice();

      _s120.splice(this.axis, 1);

      var _r82 = !1;

      for (var _e232 of n) {
        if (p(_e232, _s120)) {
          _r82 = !0;
          break;
        }
      }

      _r82 || n.push(_s120);
    }

    if (n.length > 1) throw new xu("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e));
  }

  mergeFunction(e) {
    return Jn(() => kc(e, this.axis));
  }

  computeOutputShape(e) {
    if (!Array.isArray(e) || !Array.isArray(e[0])) throw new xu("A `Concatenate` layer should be called on a list of inputs.");
    var t = e,
        n = t[0].slice(),
        s = this.axis < 0 ? n.length + this.axis : this.axis;

    for (var _e233 of t.slice(1)) {
      if (null == n[s] || null == _e233[s]) {
        n[s] = null;
        break;
      }

      n[s] += _e233[s];
    }

    return n;
  }

  computeMask(e, t) {
    if (null == t) return null;
    if (!Array.isArray(t)) throw new xu("`mask` should be an array for Concatenate");
    if (!Array.isArray(e)) throw new xu("`inputs` should be an array for Concatenate");
    if (t.length !== e.length) throw new xu("Mismatch in the length of mask (".concat(t.length, ") and the legnth of inputs (").concat(e.length, ")"));
    return Jn(() => {
      var n = !0;
      if (t.forEach(e => {
        null == e || (n = !1);
      }), n) return null;
      var s = [];

      for (var _n139 = 0; _n139 < e.length; ++_n139) {
        s.push(null == t[_n139] ? fn(ya(e[_n139]), "bool") : t[_n139].rank < e[_n139].rank ? kr(t[_n139], -1) : t[_n139]);
      }

      var r = Ds(s, this.axis);
      return ls(r, -1, !1);
    });
  }

  getConfig() {
    var e = {
      axis: this.axis
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

function of(e, t) {
  for (; e < 0;) {
    e += t;
  }

  return e;
}

af.className = "Concatenate", Kn(af);

class lf extends Qp {
  constructor(e) {
    super(e), this.axes = e.axes, this.normalize = null != e.normalize && e.normalize, this.supportsMasking = !0, this.reshapeRequired = !1;
  }

  build(e) {
    l(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    var t = e[0],
        n = e[1];
    if (t.length > 3 || n.length > 3) throw new yu("Dot layer does not support tensors of 4D or higher rank yet.");
    var s = this.interpretAxes(t, n);
    if (t[s[0]] !== n[s[1]]) throw new xu("Dimension incompatibility: ".concat(t[s[0]], " !== ").concat(n[s[1]]));
  }

  mergeFunction(e) {
    if (2 !== e.length) throw new xu("A `Dot` layer must be called on exactly 2 inputs, but received ".concat(e.length, " input(s)."));
    var t,
        n = e[0],
        s = e[1];
    return t = Array.isArray(this.axes) ? this.axes.map((t, n) => of(t, e[n].shape.length)) : [of(this.axes, n.shape.length), of(this.axes, s.shape.length)], this.normalize && (n = Ah(n, t[0]), s = Ah(s, t[1])), function (e, t, n) {
      if (e.shape.length > 3 || t.shape.length > 3) throw new yu("batchDot is not implemented for tensors of 4D or higher rank yet");
      if (l(e.shape.length >= 2, () => "batchDot requires the rank of x to be >= 2, but got ".concat(e.shape.length)), l(e.shape.length >= 2, () => "batchDot requires the rank of y to be >= 2, but got ".concat(t.shape.length)), "number" == typeof n && (n = [n, n]), "complex64" === e.dtype || "complex64" === t.dtype) throw new yu("batchDot is not implemented for complex64-type Tensors yet.");
      var s = e.shape.length,
          r = t.shape.length;
      null == n && (n = [s - 1, r - 2]);
      var a = n;
      return Jn(() => {
        var n, i;

        if (s > r) {
          n = s - r;
          var _e234 = [];

          for (var _t224 = 0; _t224 < n; ++_t224) {
            _e234.push(1);
          }

          t = Rs(t, t.shape.concat(_e234));
        } else if (r > s) {
          n = r - s;
          var _t225 = [];

          for (var _e235 = 0; _e235 < n; ++_e235) {
            _t225.push(1);
          }

          e = Rs(e, e.shape.concat(_t225));
        } else n = 0;

        if (i = 2 === e.shape.length && 2 === t.shape.length ? a[0] === a[1] ? Hr(rs(e, t), a[0]) : Hr(rs(Sn(e, [1, 0]), t), a[1]) : In(e, t, a[0] !== e.shape.length - 1, a[1] === t.shape.length - 1), n > 0) {
          var _e236;

          _e236 = s > r ? s + r - 3 : s - 1;
          var _t226 = [];

          for (var _s121 = _e236; _s121 < _e236 + n; ++_s121) {
            _t226.push(_s121);
          }

          i = di(i, _t226);
        }

        return 1 === i.shape.length && (i = kr(i, 1)), i;
      });
    }(n, s, t);
  }

  interpretAxes(e, t) {
    var n;
    return n = Array.isArray(this.axes) ? this.axes : [of(this.axes, e.length), of(this.axes, t.length)], n;
  }

  computeOutputShape(e) {
    l(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    var t = e[0].slice(),
        n = e[1].slice();
    if (t.length > 3 || n.length > 3) throw new yu("Dot layer does not support tensors of 4D or higher rank yet.");
    var s = this.interpretAxes(t, n);
    t.splice(s[0], 1), n.splice(s[1], 1), n.splice(0, 1);
    var r = t.concat(n);
    return 1 === r.length && r.push(1), r;
  }

  computeMask(e, t) {
    return null;
  }

  getConfig() {
    var e = {
      axes: this.axes,
      normalize: this.normalize
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

lf.className = "Dot", Kn(lf);

class uf extends mh {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.stddev = e.stddev;
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      stddev: this.stddev
    };
    return Object.assign(t, e), t;
  }

  call(e, t) {
    return Jn(() => {
      this.invokeCallHook(e, t);
      var n = ah(e);
      return Rc(() => ts(Ic(n.shape, 0, this.stddev), n), () => n, t.training || !1);
    });
  }

}

uf.className = "GaussianNoise", Kn(uf);

class cf extends mh {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.rate = e.rate;
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      rate: this.rate
    };
    return Object.assign(t, e), t;
  }

  call(e, t) {
    return Jn(() => {
      this.invokeCallHook(e, t);
      var n = ah(e);
      return this.rate > 0 && this.rate < 1 ? Rc(() => {
        var e = Math.sqrt(this.rate / (1 - this.rate));
        return rs(n, Ic(n.shape, 1, e));
      }, () => n, t.training || !1) : n;
    });
  }

}

cf.className = "GaussianDropout", Kn(cf);

class hf extends mh {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.rate = e.rate, this.noiseShape = e.noiseShape;
  }

  _getNoiseShape(e) {
    return this.noiseShape || ah(e).shape;
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      rate: this.rate
    };
    return Object.assign(t, e), t;
  }

  call(e, t) {
    return Jn(() => {
      if (this.rate < 1 && this.rate > 0) {
        var _n140 = this._getNoiseShape(e);

        return Rc(() => {
          var t = ah(e),
              s = -1.7580993408473766;
          var r = Tr(Ba(_n140), this.rate);
          r = gc(r, "float32");
          var a = ((1 - this.rate) * (1 + this.rate * s ** 2)) ** -.5,
              i = -a * s * this.rate,
              o = ts(rs(t, r), rs(ts(r, -1), s));
          return ts(rs(o, a), i);
        }, () => ah(e), t.training || !1);
      }

      return e;
    });
  }

}

function df(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : .001;
  var i;
  if (2 === e.rank) i = Bs(e, t, n, s, r, a);else if (3 === e.rank) i = Ps(e, t, n, s, r, a);else {
    if (4 !== e.rank) throw new yu("batchNormalization is not implemented for array of rank ".concat(e.rank, " yet"));
    i = Ws(e, t, n, s, r, a);
  }
  return i;
}

hf.className = "AlphaDropout", Kn(hf);

class pf extends mh {
  constructor(e) {
    null == e && (e = {}), super(e), this.supportsMasking = !0, this.axis = null == e.axis ? -1 : e.axis, this.momentum = null == e.momentum ? .99 : e.momentum, this.epsilon = null == e.epsilon ? .001 : e.epsilon, this.center = null == e.center || e.center, this.scale = null == e.scale || e.scale, this.betaInitializer = Zc(e.betaInitializer || "zeros"), this.gammaInitializer = Zc(e.gammaInitializer || "ones"), this.movingMeanInitializer = Zc(e.movingMeanInitializer || "zeros"), this.movingVarianceInitializer = Zc(e.movingVarianceInitializer || "ones"), this.betaConstraint = Xu(e.betaConstraint), this.gammaConstraint = Xu(e.gammaConstraint), this.betaRegularizer = ep(e.betaRegularizer), this.gammaRegularizer = ep(e.gammaRegularizer);
  }

  build(e) {
    e = ih(e);
    var t = this.axis >= 0 ? this.axis : this.axis + e.length,
        n = e[t];
    if (null == n) throw new xu("Axis ".concat(t, " of input tensor should have a defined dimension but the layer received an input with shape ").concat(JSON.stringify(e), "."));
    this.inputSpec = [new hh({
      ndim: e.length,
      axes: {
        [t]: n
      }
    })];
    var s = [n];
    this.scale && (this.gamma = this.addWeight("gamma", s, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", s, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", s, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", s, null, this.movingVarianceInitializer, null, !1), this.built = !0;
  }

  call(e, t) {
    return Jn(() => {
      var n = null != t.training && t.training,
          s = ah(e),
          r = s.shape,
          a = r.length,
          i = fc(0, a),
          o = this.axis >= 0 ? this.axis : this.axis + a;
      i.splice(o, 1);
      var l = wu(1, a);
      l[o] = r[o];
      var u = i.slice();
      u.sort();
      var c = !p(u, fc(0, a).slice(0, a - 1));
      if (!n) return (() => {
        if (c) {
          var _e237 = Rs(this.movingMean.read(), l),
              _t227 = Rs(this.movingVariance.read(), l),
              _n141 = this.center ? Rs(this.beta.read(), l) : null,
              _r83 = this.scale ? Rs(this.gamma.read(), l) : null;

          return df(s, _e237, _t227, _n141, _r83, this.epsilon);
        }

        return df(s, this.movingMean.read(), this.movingVariance.read(), null == this.beta ? null : this.beta.read(), null == this.gamma ? null : this.gamma.read(), this.epsilon);
      })();

      var [h, d, f] = function (e, t, n, s) {
        var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .001;
        return p(s.slice().sort(), fc(0, e.rank - 1)) ? function (e, t, n, s) {
          var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .001;
          return Jn(() => {
            var a = ba(e, s),
                i = a.mean,
                o = a.variance;
            return [df(e, i, o, n, t, r), i, o];
          });
        }(e, t, n, s, r) : function (e, t, n, s) {
          var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .001;
          return Jn(() => {
            var a = ba(e, s),
                i = a.mean,
                o = a.variance,
                l = [];

            for (var _t228 of fc(0, e.rank)) {
              -1 !== s.indexOf(_t228) ? l.push(1) : l.push(e.shape[_t228]);
            }

            var u = Rs(i, l),
                c = Rs(o, l),
                h = null == t ? null : Rs(t, l),
                d = null == n ? null : Rs(n, l);
            return [df(e, u, c, d, h, r), i, o];
          });
        }(e, t, n, s, r);
      }(s, this.gamma.read(), this.beta.read(), i, this.epsilon),
          g = (e, t, n) => {
        Jn(() => {
          var s = 1 - n,
              r = e.read(),
              a = rs(Gr(r, t), s);
          e.write(Gr(r, a));
        });
      };

      return (() => {
        g(this.movingMean, d, this.momentum), g(this.movingVariance, f, this.momentum);
      })(), h;
    });
  }

  getConfig() {
    var e = {
      axis: this.axis,
      momentum: this.momentum,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: Jc(this.betaInitializer),
      gammaInitializer: Jc(this.gammaInitializer),
      movingMeanInitializer: Jc(this.movingMeanInitializer),
      movingVarianceInitializer: Jc(this.movingVarianceInitializer),
      betaRegularizer: Zd(this.betaRegularizer),
      gammaRegularizer: Zd(this.gammaRegularizer),
      betaConstraint: ju(this.betaConstraint),
      gammaConstraint: ju(this.gammaConstraint)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

pf.className = "BatchNormalization", Kn(pf);

class ff extends mh {
  constructor(e) {
    if (null == e && (e = {}), super(e), this.axis = null == e.axis ? -1 : e.axis, "number" == typeof this.axis) {
      if (!Number.isInteger(this.axis)) throw new Error("Expected axis to be an integer, but received ".concat(this.axis));
    } else {
      if (!Array.isArray(this.axis)) throw new Error("Expected axis to be an integer or an array of integers, but received ".concat(JSON.stringify(this.axis)));

      for (var _e238 of this.axis) {
        if (!Number.isInteger(_e238)) throw new Error("Expected axis to be an array of integers, but received ".concat(JSON.stringify(this.axis)));
      }
    }

    this.epsilon = null == e.epsilon ? .001 : e.epsilon, this.center = null == e.center || e.center, this.scale = null == e.scale || e.scale, this.betaInitializer = Zc(e.betaInitializer || "zeros"), this.gammaInitializer = Zc(e.gammaInitializer || "ones"), this.betaRegularizer = ep(e.betaRegularizer), this.gammaRegularizer = ep(e.gammaRegularizer), this.supportsMasking = !0;
  }

  build(e) {
    var t = (e = ih(e)).length;
    "number" == typeof this.axis && (this.axis = [this.axis]);

    for (var _e239 = 0; _e239 < this.axis.length; ++_e239) {
      this.axis[_e239] < 0 && (this.axis[_e239] += t);
    }

    for (var _e240 of this.axis) {
      if (_e240 < 0 || _e240 >= t) throw new Error("Invalid axis: ".concat(_e240));
    }

    if (this.axis.length !== Du(this.axis).length) throw new Error("Found duplicate axes in: ".concat(this.axis));
    var n = this.axis.map(t => e[t]);
    this.gamma = this.scale ? this.addWeight("gamma", n, "float32", this.gammaInitializer, this.gammaRegularizer, !0) : null, this.beta = this.center ? this.addWeight("beta", n, "float32", this.betaInitializer, this.betaRegularizer, !0) : null, this.built = !0;
  }

  call(e, t) {
    var n = ah(e),
        s = n.shape,
        r = s.length;
    return Jn(() => {
      var {
        mean: e,
        variance: t
      } = ba(n, this.axis, !0);
      var a = wu(1, r);

      for (var _e241 of this.axis) {
        a[_e241] = s[_e241];
      }

      var i = e => null != e && e.shape.length !== r && this.axis !== [r - 1] ? Rs(e, a) : e;

      var o = i(this.gamma.read()),
          l = i(this.beta.read());
      var u = [],
          c = [];

      for (var _e242 = 0; _e242 < r; ++_e242) {
        -1 !== this.axis.indexOf(_e242) ? (u.push(s[_e242]), c.push(1)) : (u.push(1), c.push(s[_e242]));
      }

      return e = vr(e, u), t = vr(t, u), o = vr(o, c), l = vr(l, c), df(n, e, t, l, o, this.epsilon);
    });
  }

  getConfig() {
    var e = {
      axis: this.axis,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: Jc(this.betaInitializer),
      gammaInitializer: Jc(this.gammaInitializer),
      betaRegularizer: Zd(this.betaRegularizer),
      gammaRegularizer: Zd(this.gammaRegularizer)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

ff.className = "LayerNormalization", Kn(ff);

class gf extends mh {
  constructor(e) {
    if (null == e && (e = {}), super(e), this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, null == e.padding) this.padding = [[1, 1], [1, 1]];else if ("number" == typeof e.padding) this.padding = [[e.padding, e.padding], [e.padding, e.padding]];else {
      if (e.padding = e.padding, 2 !== e.padding.length) throw new xu("ZeroPadding2D expects padding to be a length-2 array, but received a length-".concat(e.padding.length, " array."));

      var _t229, _n142;

      if ("number" == typeof e.padding[0]) _t229 = [e.padding[0], e.padding[0]], _n142 = [e.padding[1], e.padding[1]];else {
        if (e.padding = e.padding, 2 !== e.padding[0].length) throw new xu("ZeroPadding2D expects height padding to be a length-2 array, but received a length-".concat(e.padding[0].length, " array."));
        if (_t229 = e.padding[0], 2 !== e.padding[1].length) throw new xu("ZeroPadding2D expects width padding to be a length-2 array, but received a length-".concat(e.padding[1].length, " array."));
        _n142 = e.padding[1];
      }
      this.padding = [_t229, _n142];
    }
    this.inputSpec = [new hh({
      ndim: 4
    })];
  }

  computeOutputShape(e) {
    var t, n;
    return e = ih(e), "channelsFirst" === this.dataFormat ? (t = null != e[2] && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[3] && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null, [e[0], e[1], t, n]) : (t = null != e[1] && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[2] && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null, [e[0], t, n, e[3]]);
  }

  call(e, t) {
    return Jn(() => {
      return t = ah(e), n = this.padding, s = this.dataFormat, Jn(() => {
        if (4 !== t.rank) throw new xu("temporalPadding expects input tensor to be 4-D, but received a ".concat(t.rank, "-D tensor."));
        if (null == n && (n = [[1, 1], [1, 1]]), 2 !== n.length || 2 !== n[0].length || 2 !== n[1].length) throw new xu("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
        if (null == s && (s = "channelsLast"), "channelsLast" !== s && "channelsFirst" !== s) throw new xu("Unknown data format: ".concat(s, ". Supported data formats are 'channelsLast' and 'channelsFirst."));
        var e;
        return e = "channelsFirst" === s ? [[0, 0], [0, 0], n[0], n[1]] : [[0, 0], n[0], n[1], [0, 0]], ka(t, e);
      });
      var t, n, s;
    });
  }

  getConfig() {
    var e = {
      padding: this.padding,
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

function mf(e, t, n, s, r, a) {
  return Jn(() => {
    var i;
    nc(r), rc(a), sc(s), null == n && (n = [1, 1]), null == s && (s = "valid"), null == r && (r = "channelsLast"), null == a && (a = "max"), e = cp(e, r);
    var o = "same" === s ? "same" : "valid";
    return i = "max" === a ? ia(e, t, n, o) : As(e, t, n, o), "channelsFirst" === r && (i = Sn(i, [0, 3, 1, 2])), i;
  });
}

function bf(e, t, n, s, r, a) {
  return Jn(() => {
    var i;
    nc(r), rc(a), sc(s), null == n && (n = [1, 1, 1]), null == s && (s = "valid"), null == r && (r = "channelsLast"), null == a && (a = "max"), e = hp(e, r);
    var o = "same" === s ? "same" : "valid";
    return i = "max" === a ? oa(e, t, n, o) : Fs(e, t, n, o), "channelsFirst" === r && (i = Sn(i, [0, 4, 1, 2, 3])), i;
  });
}

gf.className = "ZeroPadding2D", Kn(gf);

class xf extends mh {
  constructor(e) {
    if (null == e.poolSize && (e.poolSize = 2), super(e), "number" == typeof e.poolSize) this.poolSize = [e.poolSize];else {
      if (!Array.isArray(e.poolSize) || 1 !== e.poolSize.length || "number" != typeof e.poolSize[0]) throw new xu("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ".concat(JSON.stringify(e.poolSize)));
      this.poolSize = e.poolSize;
    }
    if (Lu(this.poolSize, "poolSize"), null == e.strides) this.strides = this.poolSize;else if ("number" == typeof e.strides) this.strides = [e.strides];else {
      if (!Array.isArray(e.strides) || 1 !== e.strides.length || "number" != typeof e.strides[0]) throw new xu("strides for 1D convolutional layer must be a number or an Array of a single number, but received ".concat(JSON.stringify(e.strides)));
      this.strides = e.strides;
    }
    Lu(this.strides, "strides"), this.padding = null == e.padding ? "valid" : e.padding, sc(this.padding), this.inputSpec = [new hh({
      ndim: 3
    })];
  }

  computeOutputShape(e) {
    var t = lp((e = ih(e))[1], this.poolSize[0], this.padding, this.strides[0]);
    return [e[0], t, e[2]];
  }

  call(e, t) {
    return Jn(() => {
      this.invokeCallHook(e, t), e = mc(ah(e), 2);
      var n = this.poolingFunction(ah(e), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
      return di(n, [2]);
    });
  }

  getConfig() {
    var e = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

class yf extends xf {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return nc(r), sc(s), mf(e, t, n, s, r, "max");
  }

}

yf.className = "MaxPooling1D", Kn(yf);

class kf extends xf {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return nc(r), sc(s), mf(e, t, n, s, r, "avg");
  }

}

kf.className = "AveragePooling1D", Kn(kf);

class wf extends mh {
  constructor(e) {
    if (null == e.poolSize && (e.poolSize = [2, 2]), super(e), this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize], null == e.strides) this.strides = this.poolSize;else if (Array.isArray(e.strides)) {
      if (2 !== e.strides.length) throw new xu("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ".concat(e.strides.length, "."));
      this.strides = e.strides;
    } else this.strides = [e.strides, e.strides];
    Lu(this.poolSize, "poolSize"), Lu(this.strides, "strides"), this.padding = null == e.padding ? "valid" : e.padding, this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, nc(this.dataFormat), sc(this.padding), this.inputSpec = [new hh({
      ndim: 4
    })];
  }

  computeOutputShape(e) {
    e = ih(e);
    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
        n = "channelsFirst" === this.dataFormat ? e[3] : e[2];
    return t = lp(t, this.poolSize[0], this.padding, this.strides[0]), n = lp(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n] : [e[0], t, n, e[3]];
  }

  call(e, t) {
    return Jn(() => (this.invokeCallHook(e, t), this.poolingFunction(ah(e), this.poolSize, this.strides, this.padding, this.dataFormat)));
  }

  getConfig() {
    var e = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

class vf extends wf {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return nc(r), sc(s), mf(e, t, n, s, r, "max");
  }

}

vf.className = "MaxPooling2D", Kn(vf);

class If extends wf {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return nc(r), sc(s), mf(e, t, n, s, r, "avg");
  }

}

If.className = "AveragePooling2D", Kn(If);

class $f extends mh {
  constructor(e) {
    if (null == e.poolSize && (e.poolSize = [2, 2, 2]), super(e), this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize, e.poolSize], null == e.strides) this.strides = this.poolSize;else if (Array.isArray(e.strides)) {
      if (3 !== e.strides.length) throw new xu("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ".concat(e.strides.length, "."));
      this.strides = e.strides;
    } else this.strides = [e.strides, e.strides, e.strides];
    Lu(this.poolSize, "poolSize"), Lu(this.strides, "strides"), this.padding = null == e.padding ? "valid" : e.padding, this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, nc(this.dataFormat), sc(this.padding), this.inputSpec = [new hh({
      ndim: 5
    })];
  }

  computeOutputShape(e) {
    e = ih(e);
    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
        n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
        s = "channelsFirst" === this.dataFormat ? e[4] : e[3];
    return t = lp(t, this.poolSize[0], this.padding, this.strides[0]), n = lp(n, this.poolSize[1], this.padding, this.strides[1]), s = lp(s, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n, s] : [e[0], t, n, s, e[4]];
  }

  call(e, t) {
    return Jn(() => (this.invokeCallHook(e, t), this.poolingFunction(ah(e), this.poolSize, this.strides, this.padding, this.dataFormat)));
  }

  getConfig() {
    var e = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

class Sf extends $f {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return nc(r), sc(s), bf(e, t, n, s, r, "max");
  }

}

Sf.className = "MaxPooling3D", Kn(Sf);

class Nf extends $f {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return nc(r), sc(s), bf(e, t, n, s, r, "avg");
  }

}

Nf.className = "AveragePooling3D", Kn(Nf);

class Cf extends mh {
  constructor(e) {
    super(e), this.inputSpec = [new hh({
      ndim: 3
    })];
  }

  computeOutputShape(e) {
    return [e[0], e[2]];
  }

  call(e, t) {
    throw new yu();
  }

}

class Tf extends Cf {
  constructor(e) {
    super(e || {});
  }

  call(e, t) {
    return Jn(() => {
      var t = ah(e);
      return ua(t, 1);
    });
  }

}

Tf.className = "GlobalAveragePooling1D", Kn(Tf);

class Ef extends Cf {
  constructor(e) {
    super(e || {});
  }

  call(e, t) {
    return Jn(() => {
      var t = ah(e);
      return Vr(t, 1);
    });
  }

}

Ef.className = "GlobalMaxPooling1D", Kn(Ef);

class Rf extends mh {
  constructor(e) {
    super(e), this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, nc(this.dataFormat), this.inputSpec = [new hh({
      ndim: 4
    })];
  }

  computeOutputShape(e) {
    return e = e, "channelsLast" === this.dataFormat ? [e[0], e[3]] : [e[0], e[1]];
  }

  call(e, t) {
    throw new yu();
  }

  getConfig() {
    var e = {
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

class Af extends Rf {
  call(e, t) {
    return Jn(() => {
      var t = ah(e);
      return ua(t, "channelsLast" === this.dataFormat ? [1, 2] : [2, 3]);
    });
  }

}

Af.className = "GlobalAveragePooling2D", Kn(Af);

class Ff extends Rf {
  call(e, t) {
    return Jn(() => {
      var t = ah(e);
      return Vr(t, "channelsLast" === this.dataFormat ? [1, 2] : [2, 3]);
    });
  }

}

Ff.className = "GlobalMaxPooling2D", Kn(Ff);

class Df extends mh {
  constructor(e) {
    super(e), this.layer = e.layer;
  }

  build(e) {
    this.built = !0;
  }

  get trainable() {
    return null != this.layer && this.layer.trainable;
  }

  set trainable(e) {
    null != this.layer && (this.layer.trainable = e);
  }

  get trainableWeights() {
    return this.layer.trainableWeights;
  }

  get nonTrainableWeights() {
    return this.layer.nonTrainableWeights;
  }

  get updates() {
    return this.layer._updates;
  }

  get losses() {
    return this.layer.losses;
  }

  getWeights() {
    return this.layer.getWeights();
  }

  setWeights(e) {
    this.layer.setWeights(e);
  }

  getConfig() {
    var e = {
      layer: {
        className: this.layer.getClassName(),
        config: this.layer.getConfig()
      }
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), null != this.layer && this.layer.setFastWeightInitDuringBuild(e);
  }

  static fromConfig(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = Rh(t.layer, n);
    delete t.layer;
    var r = {
      layer: s
    };
    return Object.assign(r, t), new e(r);
  }

}

class _f extends Df {
  constructor(e) {
    super(e), this.supportsMasking = !0;
  }

  build(e) {
    if ((e = ih(e)).length < 3) throw new xu("TimeDistributed layer expects an input shape >= 3D, but received input shape ".concat(JSON.stringify(e)));
    this.inputSpec = [{
      shape: e
    }];
    var t = [e[0]].concat(e.slice(2));
    this.layer.built || (this.layer.build(t), this.layer.built = !0), super.build(e);
  }

  computeOutputShape(e) {
    var t = [(e = ih(e))[0]].concat(e.slice(2)),
        n = this.layer.computeOutputShape(t);
    return [n[0], e[1]].concat(n.slice(1));
  }

  call(e, t) {
    return Jn(() => Np((e, n) => [ah(this.layer.call(e, t)), []], e = ah(e), [], !1, null, null, !1, !0)[1]);
  }

}

_f.className = "TimeDistributed", Kn(_f);

class Of extends Df {
  constructor(e) {
    super(e);
    var t = e.layer.getConfig(),
        n = {};
    n.className = e.layer.getClassName(), n.config = t, this.forwardLayer = Rh(n), t.goBackwards = !0 !== t.goBackwards;
    var s = {};
    if (s.className = e.layer.getClassName(), s.config = t, this.backwardLayer = Rh(s), this.forwardLayer.name = "forward_" + this.forwardLayer.name, this.backwardLayer.name = "backward_" + this.backwardLayer.name, this.mergeMode = void 0 === e.mergeMode ? "concat" : e.mergeMode, Ou(ec, "BidirectionalMergeMode", this.mergeMode), e.weights) throw new yu("weights support is not implemented for Bidirectional layer yet.");
    this._stateful = e.layer.stateful, this.returnSequences = e.layer.returnSequences, this.returnState = e.layer.returnState, this.supportsMasking = !0, this._trainable = !0, this.inputSpec = e.layer.inputSpec, this.numConstants = null;
  }

  get trainable() {
    return this._trainable;
  }

  set trainable(e) {
    this._trainable = e, null != this.forwardLayer && (this.forwardLayer.trainable = e), null != this.backwardLayer && (this.backwardLayer.trainable = e);
  }

  getWeights() {
    return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
  }

  setWeights(e) {
    var t = Math.floor(e.length / 2);
    this.forwardLayer.setWeights(e.slice(0, t)), this.backwardLayer.setWeights(e.slice(t));
  }

  computeOutputShape(e) {
    var t,
        n,
        s,
        r = this.forwardLayer.computeOutputShape(e);
    return Array.isArray(r) && Array.isArray(r[0]) || (r = [r]), r = r, this.returnState ? (s = r.slice(1), t = r[0]) : t = r[0], t = t, "concat" === this.mergeMode ? (t[t.length - 1] *= 2, n = [t]) : n = null == this.mergeMode ? [t, t.slice()] : [t], this.returnState ? null == this.mergeMode ? n.concat(s).concat(s.slice()) : [t].concat(s).concat(s.slice()) : $u(n);
  }

  apply(e, t) {
    var n = null == t ? null : t.initialState,
        s = null == t ? null : t.constants;
    null == t && (t = {});
    var r = Sp(e, n, s, this.numConstants);
    if (e = r.inputs, n = r.initialState, s = r.constants, Array.isArray(e) && (n = e.slice(1), e = e[0]), (null == n || 0 === n.length) && null == s) return super.apply(e, t);
    var a = [],
        i = [];

    if (null != n) {
      var _e243 = n.length;
      if (_e243 % 2 > 0) throw new xu("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
      t.initialState = n, a.push(...n);

      var _s122 = n.map(e => new hh({
        shape: e.shape
      }));

      this.forwardLayer.stateSpec = _s122.slice(0, _e243 / 2), this.backwardLayer.stateSpec = _s122.slice(_e243 / 2), i.push(..._s122);
    }

    if (null != s) throw new yu("Support for constants in Bidirectional layers is not implemented yet.");
    var o = a[0] instanceof dh;

    for (var _e244 of a) {
      if (_e244 instanceof dh !== o) throw new xu("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
    }

    if (o) {
      var _n143 = [e].concat(a),
          _s123 = this.inputSpec.concat(i),
          _r84 = this.inputSpec;

      this.inputSpec = _s123;

      var _o29 = super.apply(_n143, t);

      return this.inputSpec = _r84, _o29;
    }

    return super.apply(e, t);
  }

  call(e, t) {
    return Jn(() => {
      var n = t.initialState;
      var s, r, a, i;
      if (null == n) s = this.forwardLayer.call(e, t), r = this.backwardLayer.call(e, t);else {
        var _a64 = n.slice(0, n.length / 2),
            _i36 = n.slice(n.length / 2);

        s = this.forwardLayer.call(e, Object.assign(t, {
          initialState: _a64
        })), r = this.backwardLayer.call(e, Object.assign(t, {
          initialState: _i36
        }));
      }
      return this.returnState && (Array.isArray(s) && (a = s.slice(1).concat(r.slice(1))), s = s[0], r = r[0]), this.returnSequences && (r = Ha(r, 1)), "concat" === this.mergeMode ? i = kc([s, r]) : "sum" === this.mergeMode ? i = ts(s, r) : "ave" === this.mergeMode ? i = rs(.5, ts(s, r)) : "mul" === this.mergeMode ? i = rs(s, r) : null == this.mergeMode && (i = [s, r]), this.returnState ? null == this.mergeMode ? i.concat(a) : [i].concat(a) : i;
    });
  }

  resetStates(e) {
    this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
  }

  build(e) {
    ic(this.forwardLayer.name, () => {
      this.forwardLayer.build(e);
    }), ic(this.backwardLayer.name, () => {
      this.backwardLayer.build(e);
    }), this.built = !0;
  }

  computeMask(e, t) {
    var n;

    if (Array.isArray(t) && (t = t[0]), n = this.returnSequences ? null == this.mergeMode ? [t, t] : t : null == this.mergeMode ? [null, null] : null, this.returnState) {
      var _e245 = this.forwardLayer.states.map(e => null);

      return Array.isArray(n) ? n.concat(_e245).concat(_e245) : [n].concat(_e245).concat(_e245);
    }

    return n;
  }

  get trainableWeights() {
    return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
  }

  get nonTrainableWeights() {
    return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
  }

  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(e), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(e);
  }

  getConfig() {
    var e = {
      mergeMode: this.mergeMode
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

  static fromConfig(e, t) {
    var n = Rh(t.layer);
    if (delete t.layer, null != t.numConstants) throw new yu("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
    var s = t;
    return s.layer = n, new e(s);
  }

}

function Mf(e) {
  return new wp(e);
}

function Lf(e) {
  return new Vp(e);
}

function zf(e) {
  return new yf(e);
}

function Bf(e, t) {
  Array.isArray(e) || (e = [e]), e.forEach(e => {
    null != e && l("complex64" !== e.dtype, () => "".concat(t, " does not support complex64 tensors in the CPU backend."));
  });
}

Of.className = "Bidirectional", Kn(Of), function (e) {
  e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
}(Lp || (Lp = {})), function (e) {
  var t;
  (t = e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}))[t.LEGACY = 0] = "LEGACY", t[t.V1 = 1] = "V1", t[t.V2 = 2] = "V2";
}(zp || (zp = {})), function (e) {
  e[e.FAIL = 0] = "FAIL", e[e.SHORTEST = 1] = "SHORTEST", e[e.LONGEST = 2] = "LONGEST";
}(Bp || (Bp = {}));
var Pf = $i;

class Wf extends n {
  constructor() {
    super(), this.blockSize = 48, this.firstUse = !0, this.data = new t(this, Xn());
  }

  nextDataId() {
    return Wf.nextDataId++;
  }

  write(e, t, n) {
    this.firstUse && (this.firstUse = !1, G().get("IS_NODE") && W("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
    var s = {
      id: this.nextDataId()
    };
    return this.data.set(s, {
      values: e,
      dtype: n,
      refCount: 1
    }), s;
  }

  makeTensorInfo(e, t, n) {
    var s;

    if ("string" === t && null != n && n.length > 0 && N(n[0])) {
      var _r85 = n.map(e => He(e));

      s = this.write(_r85, e, t);
    } else s = this.write(n, e, t);

    return {
      dataId: s,
      shape: e,
      dtype: t
    };
  }

  refCount(e) {
    return this.data.has(e) ? this.data.get(e).refCount : 0;
  }

  incRef(e) {
    this.data.get(e).refCount++;
  }

  decRef(e) {
    this.data.has(e) && this.data.get(e).refCount--;
  }

  move(e, t, n, s, r) {
    this.data.set(e, {
      values: t,
      dtype: s,
      refCount: r
    });
  }

  numDataIds() {
    return this.data.numDataIds();
  }

  read(e) {
    var _this69 = this;

    return _asyncToGenerator(function* () {
      return _this69.readSync(e);
    })();
  }

  readSync(e) {
    var {
      dtype: t,
      complexTensorInfos: n
    } = this.data.get(e);
    return "complex64" === t ? Lo(this.readSync(n.real.dataId), this.readSync(n.imag.dataId)) : this.data.get(e).values;
  }

  bufferSync(e) {
    var t = this.readSync(e.dataId);
    var n = t;
    if ("string" === e.dtype) try {
      n = t.map(e => qe(e));
    } catch (e) {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return pn(e.shape, e.dtype, n);
  }

  makeOutput(e, t, n) {
    var s = this.write(e, t, n);
    return Xn().makeTensorFromDataId(s, t, n, this);
  }

  disposeData(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;

    if (this.data.has(e)) {
      if (this.data.get(e).refCount--, !t && this.data.get(e).refCount > 0) return !1;
      var {
        complexTensorInfos: _n144
      } = this.data.get(e);
      null != _n144 && (this.disposeData(_n144.real.dataId, !0), this.disposeData(_n144.imag.dataId, !0)), this.data.delete(e);
    }

    return !0;
  }

  disposeIntermediateTensorInfo(e) {
    this.disposeData(e.dataId);
  }

  time(e) {
    return _asyncToGenerator(function* () {
      var t = Ge();
      return e(), {
        kernelMs: Ge() - t
      };
    })();
  }

  memory() {
    return {
      unreliable: !0,
      reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
    };
  }

  where(e) {
    Bf([e], "where");
    var t = this.readSync(e.dataId);
    return Pf(e.shape, t);
  }

  dispose() {}

  floatPrecision() {
    return 32;
  }

  epsilon() {
    return super.epsilon();
  }

}

function Uf(e) {
  var t = new Float32Array(e.length);

  for (var _n145 = 0; _n145 < e.length; ++_n145) {
    t[_n145] = Math.abs(e[_n145]);
  }

  return t;
}

Wf.nextDataId = 0;
var Vf = {
  kernelName: "Abs",
  backendName: "cpu",
  kernelFunc: e => {
    var {
      x: t
    } = e.inputs,
        n = e.backend;
    Bf(t, "abs");
    var s = new Float32Array(d(t.shape));
    return s = Uf(n.data.get(t.dataId).values), n.makeOutput(s, t.shape, "float32");
  }
};

function Gf(e) {
  return (t, n, s, r, a) => {
    var i = hr(t, n),
        o = i.length,
        l = A(i),
        u = w(a, d(i)),
        c = t.length,
        h = n.length,
        p = A(t),
        f = A(n),
        g = ur(t, i),
        m = ur(n, i);
    if (g.length + m.length === 0) for (var _t230 = 0; _t230 < u.length; ++_t230) {
      u[_t230] = e(s[_t230 % s.length], r[_t230 % r.length]);
    } else {
      var _loop25 = function _loop25(_t231) {
        var n = B(_t231, o, l),
            a = n.slice(-c);
        g.forEach(e => a[e] = 0);
        var i = z(a, c, p),
            d = n.slice(-h);
        m.forEach(e => d[e] = 0);
        var b = z(d, h, f);
        u[_t231] = e(s[i], r[b]);
      };

      for (var _t231 = 0; _t231 < u.length; ++_t231) {
        _loop25(_t231);
      }
    }
    return [u, i];
  };
}

function Hf(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    real: s,
    imag: r
  } = t,
      a = n.data.get(s.dataId).values,
      i = n.data.get(r.dataId).values,
      o = n.makeTensorInfo(s.shape, "complex64");
  return n.data.get(o.dataId).complexTensorInfos = {
    real: n.makeTensorInfo(s.shape, "float32", a),
    imag: n.makeTensorInfo(r.shape, "float32", i)
  }, o;
}

var qf = {
  kernelName: "Complex",
  backendName: "cpu",
  kernelFunc: Hf
};

function jf(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "float32";
  if ("complex64" === n) return Hf({
    inputs: {
      real: jf(e, t, "float32"),
      imag: jf(e, t, "float32")
    },
    backend: e
  });
  var s = O(d(t), n);
  return e.makeTensorInfo(t, n, s);
}

function Kf(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    x: s
  } = t;
  return n.incRef(s.dataId), {
    dataId: s.dataId,
    shape: s.shape,
    dtype: s.dtype
  };
}

var Xf = {
  kernelName: "Identity",
  backendName: "cpu",
  kernelFunc: Kf
};

function Yf(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    input: s
  } = t,
      r = n.data.get(s.dataId).complexTensorInfos.real,
      a = n.data.get(r.dataId).values;
  return n.makeTensorInfo(r.shape, r.dtype, a);
}

var Jf = {
  kernelName: "Real",
  backendName: "cpu",
  kernelFunc: Yf
};

function Zf(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    dtype: a
  } = s;

  if ("complex64" === a) {
    if ("complex64" === r.dtype) return Kf({
      inputs: {
        x: r
      },
      backend: n
    });

    var _e246 = jf(n, r.shape, r.dtype),
        _t232 = Zf({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        dtype: "float32"
      }
    }),
        _s124 = Hf({
      inputs: {
        real: _t232,
        imag: _e246
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_e246), n.disposeIntermediateTensorInfo(_t232), _s124;
  }

  if ("complex64" === r.dtype) {
    var _e247 = Yf({
      inputs: {
        input: r
      },
      backend: n
    }),
        _t233 = Zf({
      inputs: {
        x: _e247
      },
      backend: n,
      attrs: {
        dtype: a
      }
    });

    return n.disposeIntermediateTensorInfo(_e247), _t233;
  }

  if (!I(r.dtype, a)) {
    var _e248 = Kf({
      inputs: {
        x: r
      },
      backend: n
    });

    return {
      dataId: _e248.dataId,
      shape: _e248.shape,
      dtype: a
    };
  }

  if ("int32" === a) {
    var _e249 = n.data.get(r.dataId).values,
        _t234 = Int32Array.from(_e249);

    return n.makeTensorInfo(r.shape, "int32", _t234);
  }

  if ("bool" === a) {
    var _e250 = n.data.get(r.dataId).values,
        _t235 = Ve([0], r.dtype),
        [_s125, _a65] = Gf((e, t) => e !== t ? 1 : 0)(r.shape, [], _e250, _t235, "bool");

    return n.makeTensorInfo(_a65, "bool", _s125);
  }

  throw new Error("Error in Cast: failed to cast ".concat(r.dtype, " to ").concat(a));
}

var Qf = {
  kernelName: "Cast",
  backendName: "cpu",
  kernelFunc: Zf
};

function eg(e, t, n, s) {
  return null == n ? _ref9 => {
    var {
      inputs: n,
      backend: r
    } = _ref9;
    var {
      a,
      b: i
    } = n,
        o = r;
    Bf([a, i], e);
    var l = o.data.get(a.dataId).values,
        u = o.data.get(i.dataId).values,
        c = "string" === a.dtype ? nl(l) : l,
        h = "string" === a.dtype ? nl(u) : u,
        d = s || a.dtype,
        [p, f] = t(a.shape, i.shape, c, h, d);
    return o.makeTensorInfo(f, d, p);
  } : _ref10 => {
    var {
      inputs: e,
      backend: r
    } = _ref10;
    var {
      a,
      b: i
    } = e,
        o = r;

    if ("complex64" === a.dtype || "complex64" === i.dtype) {
      var _e251 = Zf({
        inputs: {
          x: a
        },
        backend: o,
        attrs: {
          dtype: "complex64"
        }
      }),
          _t236 = o.data.get(_e251.dataId),
          _s126 = _t236.complexTensorInfos.imag,
          _r86 = o.data.get(_t236.complexTensorInfos.real.dataId).values,
          _l18 = o.data.get(_s126.dataId).values,
          _u11 = Zf({
        inputs: {
          x: i
        },
        backend: o,
        attrs: {
          dtype: "complex64"
        }
      }),
          _c11 = o.data.get(_u11.dataId),
          _h8 = _c11.complexTensorInfos.imag,
          _d8 = o.data.get(_c11.complexTensorInfos.real.dataId).values,
          _p7 = o.data.get(_h8.dataId).values,
          [_f6, _g8, _m7] = n(a.shape, i.shape, _r86, _l18, _d8, _p7),
          _b6 = o.makeTensorInfo(_m7, "float32", _f6),
          _x50 = o.makeTensorInfo(_m7, "float32", _g8),
          _y6 = Hf({
        inputs: {
          real: _b6,
          imag: _x50
        },
        backend: o
      });

      return o.disposeIntermediateTensorInfo(_e251), o.disposeIntermediateTensorInfo(_u11), o.disposeIntermediateTensorInfo(_b6), o.disposeIntermediateTensorInfo(_x50), _y6;
    }

    {
      var _e252 = o.data.get(a.dataId).values,
          _n146 = o.data.get(i.dataId).values,
          _r87 = s || a.dtype,
          [_l19, _u12] = t(a.shape, i.shape, _e252, _n146, _r87);

      return o.makeTensorInfo(_u12, _r87, _l19);
    }
  };
}

function tg(e) {
  return (t, n, s, r, a, i) => {
    var o = hr(t, n),
        l = d(o),
        u = o.length,
        c = A(o),
        h = w("float32", l),
        p = w("float32", l),
        f = ur(t, o),
        g = ur(n, o),
        m = Lo(s, r),
        b = Lo(a, i),
        x = t.length,
        y = A(t),
        k = n.length,
        v = A(n);
    if (f.length + g.length === 0) for (var _t237 = 0; _t237 < h.length; _t237++) {
      var _n147 = _t237 % m.length,
          _s127 = _t237 % b.length,
          _r88 = e(m[2 * _n147], m[2 * _n147 + 1], b[2 * _s127], b[2 * _s127 + 1]);

      h[_t237] = _r88.real, p[_t237] = _r88.imag;
    } else {
      var _loop26 = function _loop26(_t238) {
        var n = B(_t238, u, c),
            s = n.slice(-x);
        f.forEach(e => s[e] = 0);
        var r = z(s, x, y),
            a = n.slice(-k);
        g.forEach(e => a[e] = 0);
        var i = z(a, k, v),
            o = e(m[2 * r], m[2 * r + 1], b[2 * i], b[2 * i + 1]);
        h[_t238] = o.real, p[_t238] = o.imag;
      };

      for (var _t238 = 0; _t238 < h.length; _t238++) {
        _loop26(_t238);
      }
    }
    return [h, p, o];
  };
}

var ng = Gf((e, t) => e + t),
    sg = eg("Add", ng, tg((e, t, n, s) => ({
  real: e + n,
  imag: t + s
}))),
    rg = {
  kernelName: "Add",
  backendName: "cpu",
  kernelFunc: sg
};

function ag(e, t, n, s, r) {
  var a = d(s),
      i = O(r, n);

  for (var _n148 = 0; _n148 < e.length; _n148++) {
    var _s128 = e[_n148];
    if (_s128 < 0) throw new Error("Input x must be non-negative!");
    _s128 >= r || (i[_s128] += a > 0 ? t[_n148] : 1);
  }

  return i;
}

function ig(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  var r = e.shape[0],
      a = e.shape[1],
      i = pn([r, n], t.dtype);

  for (var _o30 = 0; _o30 < r; _o30++) {
    for (var _r89 = 0; _r89 < a; _r89++) {
      var _a66 = e.get(_o30, _r89);

      if (_a66 < 0) throw new Error("Input x must be non-negative!");
      _a66 >= n || i.set(s ? 1 : t.size > 0 ? i.get(_o30, _a66) + t.get(_o30, _r89) : i.get(_o30, _a66) + 1, _o30, _a66);
    }
  }

  return i;
}

function og(e) {
  return (t, n, s) => {
    var r = w(n, t.length);

    for (var _n149 = 0; _n149 < t.length; ++_n149) {
      r[_n149] = e(t[_n149], s);
    }

    return r;
  };
}

function lg(e, t, n) {
  return _ref11 => {
    var {
      inputs: s,
      attrs: r,
      backend: a
    } = _ref11;
    var {
      x: i
    } = s;
    if (Bf(i, e), "string" === i.dtype || "string" === n) throw new Error("unaryKernelFunc does not support string input/output");
    var o = a,
        l = o.data.get(i.dataId).values,
        u = d(i.shape),
        c = n || i.dtype,
        h = v(c, u);

    for (var _e253 = 0; _e253 < u; ++_e253) {
      h[_e253] = t(l[_e253], r);
    }

    return o.makeTensorInfo(i.shape, c, h);
  };
}

function ug(e, t, n) {
  return _ref12 => {
    var {
      inputs: s,
      attrs: r,
      backend: a
    } = _ref12;
    var {
      x: i
    } = s;
    if (Bf(i, e), "string" === i.dtype || "string" === n) throw new Error("unaryKernelFunc does not support string input/output");
    var o = a,
        l = o.data.get(i.dataId).values,
        u = n || i.dtype,
        c = t(l, u, r);
    return o.makeTensorInfo(i.shape, u, c);
  };
}

var cg = og(e => Math.ceil(e)),
    hg = {
  kernelName: "Ceil",
  backendName: "cpu",
  kernelFunc: ug("Ceil", cg)
};

function dg(e, t, n, s) {
  var r = v(n, d(t));

  if (s && "string" !== n) {
    var _t239 = 0;
    e.forEach(e => {
      var n = d(e.shape);
      r.set(e.vals, _t239), _t239 += n;
    });
  } else {
    var _s129 = 0;
    e.forEach(e => {
      var a = "string" === n ? nl(e.vals) : e.vals;
      var i = 0;

      for (var _n150 = 0; _n150 < e.shape[0]; ++_n150) {
        var _o31 = _n150 * t[1] + _s129;

        for (var _t240 = 0; _t240 < e.shape[1]; ++_t240) {
          r[_o31 + _t240] = a[i++];
        }
      }

      _s129 += e.shape[1];
    });
  }

  return r;
}

var pg = Gf((e, t) => e === t ? 1 : 0),
    fg = eg("Equal", pg, null, "bool"),
    gg = {
  kernelName: "Equal",
  backendName: "cpu",
  kernelFunc: fg
},
    mg = og(e => Math.exp(e)),
    bg = ug("Exp", mg),
    xg = {
  kernelName: "Exp",
  backendName: "cpu",
  kernelFunc: bg
},
    yg = og(e => Math.expm1(e)),
    kg = {
  kernelName: "Expm1",
  backendName: "cpu",
  kernelFunc: ug("Expm1", yg)
},
    wg = og(e => Math.floor(e)),
    vg = {
  kernelName: "Floor",
  backendName: "cpu",
  kernelFunc: ug("Floor", wg)
};

function Ig(e, t, n, s, r, a, i, o, l) {
  var u = pn([s, a], n);

  for (var _n151 = 0; _n151 < s; _n151++) {
    var _s130 = [];
    var _c12 = 0;

    for (var _t241 = 0; _t241 < r; _t241++) {
      var _a67 = e[_n151 * r + _t241];
      _c12 += _a67 * i[_t241], _s130.push(_a67);
    }

    if (_c12 < 0 || _c12 >= l / a) throw new Error("Invalid indices: ".concat(_s130, " does not index into ").concat(o));

    for (var _e254 = 0; _e254 < a; _e254++) {
      u.values[_n151 * a + _e254] = t.get(...t.indexToLoc(_c12 * a + _e254));
    }
  }

  return u;
}

function $g(e, t, n) {
  var s = pn(n, e.dtype);

  for (var _n152 = 0; _n152 < s.size; ++_n152) {
    var _r90 = s.indexToLoc(_n152).slice(),
        _a68 = t.locToIndex([_r90[0], _r90[2]]);

    _r90[2] = t.values[_a68];

    var _i37 = e.locToIndex(_r90);

    s.values[_n152] = e.values[_i37];
  }

  return s;
}

var Sg = Gf((e, t) => e > t ? 1 : 0),
    Ng = {
  kernelName: "Greater",
  backendName: "cpu",
  kernelFunc: eg("Greater", Sg, null, "bool")
},
    Cg = Gf((e, t) => e >= t ? 1 : 0),
    Tg = {
  kernelName: "GreaterEqual",
  backendName: "cpu",
  kernelFunc: eg("GreaterEqual", Cg, null, "bool")
},
    Eg = Gf((e, t) => e < t ? 1 : 0),
    Rg = {
  kernelName: "Less",
  backendName: "cpu",
  kernelFunc: eg("Less", Eg, null, "bool")
},
    Ag = Gf((e, t) => e <= t ? 1 : 0),
    Fg = {
  kernelName: "LessEqual",
  backendName: "cpu",
  kernelFunc: eg("LessEqual", Ag, null, "bool")
};

function Dg(e, t, n) {
  var s = (t - e) / (n - 1),
      r = O(n, "float32");
  r[0] = e;

  for (var _e255 = 1; _e255 < r.length; _e255++) {
    r[_e255] = r[_e255 - 1] + s;
  }

  return r;
}

var _g = og(e => Math.log(e)),
    Og = {
  kernelName: "Log",
  backendName: "cpu",
  kernelFunc: ug("Log", _g)
};

function Mg(e, t, n, s) {
  var r = w(s, d(n));

  for (var _n153 = 0; _n153 < r.length; ++_n153) {
    var _s131 = _n153 * t;

    var _a69 = e[_s131];

    for (var _n154 = 0; _n154 < t; ++_n154) {
      var _t242 = e[_s131 + _n154];
      (Number.isNaN(_t242) || _t242 > _a69) && (_a69 = _t242);
    }

    r[_n153] = _a69;
  }

  return r;
}

var Lg = Gf((e, t) => Math.max(e, t)),
    zg = {
  kernelName: "Maximum",
  backendName: "cpu",
  kernelFunc: eg("Maximum", Lg)
},
    Bg = Gf((e, t) => Math.min(e, t)),
    Pg = {
  kernelName: "Minimum",
  backendName: "cpu",
  kernelFunc: eg("Minimum", Bg)
},
    Wg = Gf((e, t) => e * t),
    Ug = tg((e, t, n, s) => ({
  real: e * n - t * s,
  imag: e * s + t * n
})),
    Vg = eg("Multiply", Wg, Ug),
    Gg = {
  kernelName: "Multiply",
  backendName: "cpu",
  kernelFunc: Vg
};

function Hg(e, t, n) {
  var s = Ue(-1, n);
  return Wg([], t, s, e, n);
}

var qg = {
  kernelName: "Neg",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t;
    Bf(s, "neg");
    var r = n.data.get(s.dataId).values,
        [a, i] = Hg(r, s.shape, s.dtype);
    return n.makeTensorInfo(i, s.dtype, a);
  }
},
    jg = Gf((e, t) => e !== t ? 1 : 0),
    Kg = {
  kernelName: "NotEqual",
  backendName: "cpu",
  kernelFunc: eg("NotEqual", jg, null, "bool")
};

function Xg(e, t, n, s, r) {
  var a = t.length,
      i = d(t),
      o = A(t),
      l = A(r),
      u = w(n, d(r));

  for (var _t243 = 0; _t243 < i; ++_t243) {
    var _n155 = B(_t243, a, o),
        _r91 = new Array(_n155.length);

    for (var _e256 = 0; _e256 < _r91.length; _e256++) {
      _r91[_e256] = _n155[s[_e256]];
    }

    u[z(_r91, a, l)] = e[_t243];
  }

  return u;
}

function Yg(e) {
  var {
    inputs: t,
    attrs: n,
    backend: s
  } = e,
      {
    x: r
  } = t,
      {
    perm: a
  } = n;
  Bf(r, "transpose");
  var i = new Array(r.shape.length);

  for (var _e257 = 0; _e257 < i.length; _e257++) {
    i[_e257] = r.shape[a[_e257]];
  }

  var o = Xg(s.data.get(r.dataId).values, r.shape, r.dtype, a, i);
  return {
    dataId: s.write(o, i, r.dtype),
    shape: i,
    dtype: r.dtype
  };
}

var Jg = {
  kernelName: "Transpose",
  backendName: "cpu",
  kernelFunc: Yg
};

function Zg(e, t, n, s) {
  var [r, a] = Xr(e, s),
      i = pt(t, "int32"),
      o = O(d(r), i),
      l = d(a);

  for (var _e258 = 0; _e258 < o.length; ++_e258) {
    var _t244 = _e258 * l;

    var _s132 = 1;

    for (var _e259 = 0; _e259 < l; ++_e259) {
      _s132 *= n[_t244 + _e259];
    }

    o[_e258] = _s132;
  }

  return {
    outVals: o,
    outShape: r,
    outDtype: i
  };
}

var Qg = {
  kernelName: "Prod",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s;
    Bf(r, "prod");
    var o = r.shape.length,
        l = y(a, r.shape),
        u = Zr(l, o);
    var c = l,
        h = r;
    var d = [];
    null != u && (h = Yg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), d.push(h), c = ea(c.length, o));
    var p = n.data.get(h.dataId).values,
        {
      outVals: f,
      outShape: g,
      outDtype: m
    } = Zg(h.shape, h.dtype, p, c);
    var b = g;
    return i && (b = Yr(g, l)), d.forEach(e => n.disposeIntermediateTensorInfo(e)), n.makeTensorInfo(b, m, f);
  }
};

function em(e, t, n, s) {
  if (e === t || e < t && n < 0 || t < e && n > 1) return O(0, s);
  var r = O(Math.abs(Math.ceil((t - e) / n)), s);
  t < e && 1 === n && (n = -1), r[0] = e;

  for (var _e260 = 1; _e260 < r.length; _e260++) {
    r[_e260] = r[_e260 - 1] + n;
  }

  return r;
}

var tm = og(e => 1 / Math.sqrt(e)),
    nm = {
  kernelName: "Rsqrt",
  backendName: "cpu",
  kernelFunc: ug("Rsqrt", tm)
},
    sm = og(e => 1 / (1 + Math.exp(-e))),
    rm = lg("Sigmoid", e => 1 / (1 + Math.exp(-e))),
    am = {
  kernelName: "Sigmoid",
  backendName: "cpu",
  kernelFunc: rm
};

function im(e, t, n, s, r) {
  var a = Wn(s, t, n),
      i = d(n),
      o = A(s);

  if (a) {
    var _n156 = Un(t, o);

    return "string" === r ? e.slice(_n156, _n156 + i) : e.subarray(_n156, _n156 + i);
  }

  var l = pn(s, r, "string" === r ? nl(e) : e),
      u = pn(n, r);

  for (var _e261 = 0; _e261 < u.size; ++_e261) {
    var _n157 = u.indexToLoc(_e261),
        _s133 = _n157.map((e, n) => e + t[n]);

    u.set(l.get(..._s133), ..._n157);
  }

  return "string" === r ? sl(u.values) : u.values;
}

function om(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    begin: a,
    size: i
  } = s;
  Bf(r, "slice");
  var [o, l] = Vn(r, a, i);
  En(r, o, l);
  var u = im(n.data.get(r.dataId).values, o, l, r.shape, r.dtype);
  return n.makeTensorInfo(l, r.dtype, u);
}

var lm = {
  kernelName: "Slice",
  backendName: "cpu",
  kernelFunc: om
};

function um(e, t, n, s, r, a, i) {
  var o = t[0],
      l = a[0],
      u = new Array(l),
      c = new Array(o),
      h = t[1];

  if (0 === l) {
    if (0 !== o) throw new Error("Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ".concat(o));
    return [v(n, 0), [0, h], v(r, 0), u, c];
  }

  var d = !0,
      p = 0;
  var f = new Array(l).fill(0);

  for (var _t245 = 0; _t245 < o; ++_t245) {
    var _n158 = e[_t245 * h];
    if (_n158 < 0) throw new Error("indices(".concat(_t245, ", 0) is invalid: ").concat(_n158, " < 0"));
    if (_n158 >= l) throw new Error("indices(".concat(_t245, ", 0) is invalid: ").concat(_n158, " >= ").concat(l));
    ++f[_n158], d = d && _n158 >= p, p = _n158;
  }

  var g = !0;

  for (var _e262 = 0; _e262 < l; ++_e262) {
    var _t246 = 0 === f[_e262];

    u[_e262] = _t246, g = g && !_t246, f[_e262] = Math.max(f[_e262], 1), _e262 > 0 && (f[_e262] += f[_e262 - 1]);
  }

  if (g && d) {
    var _t247 = e,
        _n159 = s;

    for (var _e263 = 0; _e263 < o; ++_e263) {
      c[_e263] = _e263;
    }

    return [_t247, [o, h], _n159, u, c];
  }

  {
    var _t248 = f[l - 1],
        _a70 = v(n, _t248 * h),
        _d9 = v(r, _t248),
        _p8 = new Array(l).fill(0);

    for (var _t249 = 0; _t249 < o; ++_t249) {
      var _n160 = e[_t249 * h],
          _r92 = (0 === _n160 ? 0 : f[_n160 - 1]) + _p8[_n160];

      _p8[_n160]++;

      for (var _n161 = 0; _n161 < h; ++_n161) {
        _a70[_r92 * h + _n161] = e[_t249 * h + _n161];
      }

      _d9[_r92] = s[_t249], c[_t249] = _r92;
    }

    for (var _e264 = 0; _e264 < l; ++_e264) {
      if (0 === _p8[_e264]) {
        var _t250 = 0 === _e264 ? 0 : f[_e264 - 1];

        _a70[_t250 * h + 0] = _e264;

        for (var _e265 = 1; _e265 < h; ++_e265) {
          _a70[_t250 * h + _e265] = 0;
        }

        _d9[_t250] = i;
      }
    }

    return [_a70, [_t248, h], _d9, u, c];
  }
}

function cm(e, t, n, s, r) {
  var a = d(s),
      i = t[0],
      o = r.length,
      l = [];
  var u = 1,
      c = -1;

  for (var _e266 = 0; _e266 < o; ++_e266) {
    var _t251 = r[_e266];

    if (-1 === _t251) {
      if (-1 !== c) throw new Error("only one output dimension may be -1, not both ".concat(c, " and ").concat(_e266));
      c = _e266, l.push(1);
    } else {
      if (_t251 < 0) throw new Error("size ".concat(_e266, " must be non-negative, not ").concat(_t251));
      u *= _t251, l.push(_t251);
    }
  }

  if (-1 !== c) {
    if (u <= 0) throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");

    var _e267 = Math.trunc(a / u);

    if (u * _e267 !== a) throw new Error("Input to reshape is a SparseTensor with ".concat(a, "\n          dense values, but the requested shape requires a multiple of ").concat(u, ". inputShape=").concat(s, " outputShape= ").concat(l));
    l[c] = _e267;
  }

  var h = d(l);
  if (h !== a) throw new Error("Input to reshape is a tensor with ".concat(a, " dense values, but the requested shape has ").concat(h, ". inputShape=").concat(s, " outputShape=").concat(l));
  var p = s.length,
      f = [];

  if (p > 0) {
    f[p - 1] = 1;

    for (var _e268 = p - 2; _e268 >= 0; --_e268) {
      f[_e268] = f[_e268 + 1] * s[_e268 + 1];
    }
  }

  var g = [];

  if (o > 0) {
    g[o - 1] = 1;

    for (var _e269 = o - 2; _e269 >= 0; --_e269) {
      g[_e269] = g[_e269 + 1] * l[_e269 + 1];
    }
  }

  var m = v(n, i * o);

  for (var _t252 = 0; _t252 < i; ++_t252) {
    var _n162 = 0;

    for (var _s134 = 0; _s134 < p; ++_s134) {
      _n162 += e[_t252 * p + _s134] * f[_s134];
    }

    for (var _e270 = 0; _e270 < o; ++_e270) {
      m[_t252 * o + _e270] = Math.trunc(_n162 / g[_e270]), _n162 %= g[_e270];
    }
  }

  return [m, [i, o], l];
}

function hm(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var o = s.length;
  if (o !== r.length) throw new Error("segmentIds and indices should have same size.");
  var l = [t[0], e.length / t[0]],
      u = l[1],
      c = o > 0 ? r[o - 1] + 1 : 0;
  if (c < 0) throw new Error("segment ids must be >= 0");
  var h = t.slice();
  h[0] = c;
  var d = v(n, h.reduce((e, t) => e * t, 1));
  if (0 === o) return c > 0 && d.fill(i), [d, h];
  if (c <= 0) throw new Error("segment ids must be >= 0");
  var p = 0,
      f = 1,
      g = 0,
      m = r[p];

  for (;;) {
    var _t253 = 0;

    if (f < o) {
      if (_t253 = r[f], m === _t253) {
        ++f;
        continue;
      }

      if (m >= _t253) throw new Error("segment ids are not increasing");
    }

    if (m < 0 || m >= c) throw new Error("Segment id ".concat(m, " out of range [0, ").concat(c, "), possibly because segmentIds input is not sorted."));
    m > g && d.fill(i, g * u, m * u);

    for (var _t254 = p; _t254 < f; ++_t254) {
      var _n163 = s[_t254];
      if (_n163 < 0 || _n163 >= l[0]) throw new Error("Bad: indices[".concat(_t254, "] == ").concat(s[_t254], " out of range [0, ").concat(l[0], ")"));

      for (var _t255 = 0; _t255 < u; _t255++) {
        d[m * u + _t255] += e[_n163 * u + _t255];
      }
    }

    if (a) for (var _e271 = 0; _e271 < u; _e271++) {
      d[m * u + _e271] /= f - p;
    }
    if (p = f, ++f, g = m + 1, m = _t253, f > o) break;
  }

  return g < c && d.fill(i, g * u, c * u), [d, h];
}

var dm = og(e => Math.sqrt(e)),
    pm = {
  kernelName: "Sqrt",
  backendName: "cpu",
  kernelFunc: lg("Sqrt", e => Math.sqrt(e))
},
    fm = Gf((e, t) => {
  var n = e - t;
  return n * n;
}),
    gm = {
  kernelName: "SquaredDifference",
  backendName: "cpu",
  kernelFunc: eg("SquaredDifference", fm)
};

function mm(e, t, n, s) {
  var r = pn(e, t.dtype);

  for (var _e272 = 0; _e272 < r.size; _e272++) {
    var _a71 = r.indexToLoc(_e272),
        _i38 = new Array(_a71.length);

    for (var _e273 = 0; _e273 < _i38.length; _e273++) {
      _i38[_e273] = _a71[_e273] * n[_e273] + s[_e273];
    }

    r.set(t.get(..._i38), ..._a71);
  }

  return r;
}

class bm {
  constructor(e, t, n, s, r, a) {
    this.separator = He(e), this.nGramWidths = t, this.leftPad = He(n), this.rightPad = He(s), this.padWidth = r, this.preserveShort = a;
  }

  getPadWidth(e) {
    return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
  }

  getNumNGrams(e, t) {
    var n = this.getPadWidth(t);
    return Math.max(0, e + 2 * n - t + 1);
  }

  createNGrams(e, t, n, s, r, a) {
    var _this70 = this;

    var _loop27 = function _loop27(_i39) {
      var o = _this70.getPadWidth(a),
          l = Math.max(0, o - _i39),
          u = Math.max(0, o - (r - (_i39 + 1))),
          c = a - (l + u),
          h = t + (l > 0 ? 0 : _i39 - o);

      var d = 0;
      d += l * _this70.leftPad.length;

      for (var _t256 = 0; _t256 < c; ++_t256) {
        d += e[h + _t256].length;
      }

      d += u * _this70.rightPad.length, d += (l + u + c - 1) * _this70.separator.length, n[s + _i39] = new Uint8Array(d);
      var p = n[s + _i39];
      var f = 0;

      var g = e => e.forEach(e => p[f++] = e);

      for (var _e274 = 0; _e274 < l; ++_e274) {
        g(_this70.leftPad), g(_this70.separator);
      }

      for (var _t257 = 0; _t257 < c - 1; ++_t257) {
        g(e[h + _t257]), g(_this70.separator);
      }

      if (c > 0) {
        g(e[h + c - 1]);

        for (var _e275 = 0; _e275 < u; ++_e275) {
          g(_this70.separator), g(_this70.rightPad);
        }
      } else {
        for (var _e276 = 0; _e276 < u - 1; ++_e276) {
          g(_this70.rightPad), g(_this70.separator);
        }

        g(_this70.rightPad);
      }
    };

    for (var _i39 = 0; _i39 < r; ++_i39) {
      _loop27(_i39);
    }
  }

  compute(e, t) {
    var _this71 = this;

    var n = e.length,
        s = t.length;

    if (s > 0) {
      var _e277 = t[0];
      if (0 !== _e277) throw new Error("First split value must be 0, got ".concat(_e277));

      for (var _r93 = 1; _r93 < s; ++_r93) {
        var _s135 = t[_r93] >= _e277;

        if (_s135 = _s135 && t[_r93] <= n, !_s135) throw new Error("Invalid split value ".concat(t[_r93], ", must be in [").concat(_e277, ", ").concat(n, "]"));
        _e277 = t[_r93];
      }

      if (_e277 !== n) throw new Error("Last split value must be data size. Expected ".concat(n, ", got ").concat(_e277));
    }

    var r = s - 1,
        a = v("int32", s);

    if (0 === n || 0 === s) {
      var _e278 = new Array(n);

      for (var _e279 = 0; _e279 <= r; ++_e279) {
        a[_e279] = 0;
      }

      return [_e278, a];
    }

    a[0] = 0;

    var _loop28 = function _loop28(_e280) {
      var n = t[_e280] - t[_e280 - 1];
      var s = 0;
      _this71.nGramWidths.forEach(e => {
        s += _this71.getNumNGrams(n, e);
      }), _this71.preserveShort && n > 0 && 0 === s && (s = 1), a[_e280] = a[_e280 - 1] + s;
    };

    for (var _e280 = 1; _e280 <= r; ++_e280) {
      _loop28(_e280);
    }

    var i = new Array(a[r]);

    var _loop29 = function _loop29(_n164) {
      var s = t[_n164];
      var r = a[_n164];

      if (_this71.nGramWidths.forEach(a => {
        var o = _this71.getNumNGrams(t[_n164 + 1] - t[_n164], a);

        _this71.createNGrams(e, s, i, r, o, a), r += o;
      }), _this71.preserveShort && r === a[_n164]) {
        var _a72 = t[_n164 + 1] - t[_n164];

        if (0 === _a72) return "continue";

        _this71.createNGrams(e, s, i, r, 1, _a72 + 2 * _this71.padWidth);
      }
    };

    for (var _n164 = 0; _n164 < r; ++_n164) {
      var _ret4 = _loop29(_n164);

      if (_ret4 === "continue") continue;
    }

    return [i, a];
  }

}

function xm(e, t, n, s, r, a, i, o) {
  return new bm(n, s, r, a, i, o).compute(e, t);
}

function ym(e, t, n, s) {
  if (!e.length) return;

  if (0 === t.length) {
    for (var _t258 = 0; _t258 < e.length; ++_t258) {
      s.push(e.subarray(_t258, _t258 + 1));
    }

    return;
  }

  if (1 === t.length) {
    var _r94 = t[0];

    var _a73 = e.indexOf(_r94);

    for (; -1 !== _a73;) {
      var _t259 = e.subarray(0, _a73);

      n && 0 === _t259.length || s.push(_t259), _a73 = (e = e.subarray(_a73 + 1)).indexOf(_r94);
    }

    return void (n && 0 === e.length || s.push(e));
  }

  var r = 0;

  for (var _a74 = 0; _a74 < e.length + 1; _a74++) {
    if (_a74 === e.length || -1 !== t.indexOf(e[_a74])) {
      var _t260 = e.subarray(r, _a74);

      n && 0 === _t260.length || s.push(_t260), r = _a74 + 1;
    }
  }
}

function km(e, t, n) {
  var s = e.length,
      r = [];
  var a = 0,
      i = 0;
  var o = new Array(s);

  for (var _l20 = 0; _l20 < s; ++_l20) {
    var _s136 = r.length;
    ym(e[_l20], t, n, r);

    var _u13 = r.length - _s136;

    o[_l20] = _u13, a += _u13, i = Math.max(i, _u13);
  }

  var l = v("int32", 2 * a),
      u = new Array(a),
      c = [s, i];
  var h = 0;

  for (var _e281 = 0; _e281 < s; ++_e281) {
    for (var _t261 = 0; _t261 < o[_e281]; ++_t261) {
      l[2 * h] = _e281, l[2 * h + 1] = _t261, u[h] = r[h], ++h;
    }
  }

  return [l, u, c];
}

function wm(e, t) {
  var n = v("int32", e.length);

  for (var _s137 = 0; _s137 < e.length; ++_s137) {
    n[_s137] = We(e[_s137]).modulo(t).getLowBitsUnsigned();
  }

  return n;
}

var vm = Gf((e, t) => e - t),
    Im = eg("Sub", vm, tg((e, t, n, s) => ({
  real: e - n,
  imag: t - s
}))),
    $m = {
  kernelName: "Sub",
  backendName: "cpu",
  kernelFunc: Im
};

function Sm(e, t) {
  var n = new Array(e.rank);

  for (var _s138 = 0; _s138 < n.length; _s138++) {
    n[_s138] = e.shape[_s138] * t[_s138];
  }

  var s = pn(n, e.dtype);

  for (var _t262 = 0; _t262 < s.values.length; ++_t262) {
    var _n165 = s.indexToLoc(_t262),
        _r95 = new Array(e.rank);

    for (var _t263 = 0; _t263 < _r95.length; _t263++) {
      _r95[_t263] = _n165[_t263] % e.shape[_t263];
    }

    var _a75 = e.locToIndex(_r95);

    s.values[_t262] = e.values[_a75];
  }

  return s;
}

var Nm = (e, t) => {
  var n = t.value - e.value;
  return 0 === n ? e.index - t.index : n;
};

function Cm(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : e.length - 1;

  for (; s > n;) {
    if (s - n > 600) {
      var _r97 = s - n + 1,
          _a77 = t - n + 1,
          _i41 = Math.log(_r97),
          _o32 = .5 * Math.exp(2 * _i41 / 3),
          _l21 = .5 * Math.sqrt(_i41 * _o32 * (_r97 - _o32) / _r97) * Math.sign(_a77 - _r97 / 2);

      Cm(e, t, Math.max(n, Math.floor(t - _a77 * _o32 / _r97 + _l21)), Math.min(s, Math.floor(t + (_r97 - _a77) * _o32 / _r97 + _l21)));
    }

    var _r96 = e[t];
    var _a76 = n,
        _i40 = s;

    for (o(e, n, t), Nm(e[s], _r96) > 0 && o(e, n, s); _a76 < _i40;) {
      for (o(e, _a76, _i40), _a76++, _i40--; Nm(e[_a76], _r96) < 0;) {
        _a76 += 1;
      }

      for (; Nm(e[_i40], _r96) > 0;) {
        _i40 -= 1;
      }
    }

    0 === Nm(e[n], _r96) ? o(e, n, _i40) : (_i40 += 1, o(e, _i40, s)), _i40 <= t && (n = _i40 + 1), t <= _i40 && (s = _i40 - 1);
  }
}

function Tm(e, t, n, s, r) {
  var a = t[t.length - 1],
      [i, o] = [e.length / a, a],
      l = w(n, i * s),
      u = w("int32", i * s);

  var _loop30 = function _loop30(_t264) {
    var n = _t264 * o,
        a = e.subarray(n, n + o);
    var i = new Array(a.length);
    a.forEach((e, t) => i[t] = {
      value: e,
      index: t
    }), s < i.length && (Cm(i, s), i = i.slice(0, s)), r && i.sort(Nm);
    var c = _t264 * s,
        h = l.subarray(c, c + s),
        d = u.subarray(c, c + s);

    for (var _e282 = 0; _e282 < s; _e282++) {
      h[_e282] = i[_e282].value, d[_e282] = i[_e282].index;
    }
  };

  for (var _t264 = 0; _t264 < i; _t264++) {
    _loop30(_t264);
  }

  var c = t.slice();
  return c[c.length - 1] = s, [pn(c, n, l), pn(c, "int32", u)];
}

function Em(e, t, n, s) {
  var r = y(t, n)[0],
      a = [1, n[0], 1];

  for (var _e283 = 0; _e283 < r; _e283++) {
    a[0] *= n[_e283];
  }

  a[1] = n[r];

  for (var _e284 = r + 1; _e284 < n.length; _e284++) {
    a[2] *= n[_e284];
  }

  var i = {},
      o = new Int32Array(n[r]),
      l = new tt(a, s, e),
      u = [],
      c = 1 === a[0] && 1 === a[2];

  for (var _t265 = 0; _t265 < n[r]; _t265++) {
    var _n166 = void 0;

    if (c) _n166 = e[_t265].toString();else {
      var _e285 = [];

      for (var _n167 = 0; _n167 < a[0]; _n167++) {
        for (var _s139 = 0; _s139 < a[2]; _s139++) {
          _e285.push(l.get(_n167, _t265, _s139));
        }
      }

      _n166 = _e285.join(",");
    }
    if (void 0 !== i[_n166]) o[_t265] = i[_n166];else {
      var _e286 = Object.keys(i).length;
      i[_n166] = _e286, o[_t265] = _e286, u.push(_t265);
    }
  }

  var h = a.slice();
  h[1] = Object.keys(i).length;
  var d = new tt(h, s);
  u.forEach((e, t) => {
    for (var _n168 = 0; _n168 < a[0]; _n168++) {
      for (var _s140 = 0; _s140 < a[2]; _s140++) {
        d.set(l.get(_n168, e, _s140), _n168, t, _s140);
      }
    }
  });
  var p = n.slice();
  return p[r] = h[1], {
    outputValues: d.values,
    outputShape: p,
    indices: o
  };
}

var Rm = {
  __proto__: null,
  simpleAbsImpl: Uf,
  addImpl: ng,
  bincountImpl: ag,
  bincountReduceImpl: ig,
  ceilImpl: cg,
  concatImpl: dg,
  equalImpl: pg,
  expImpl: mg,
  expm1Impl: yg,
  floorImpl: wg,
  gatherNdImpl: Ig,
  gatherV2Impl: $g,
  greaterImpl: Sg,
  greaterEqualImpl: Cg,
  lessImpl: Eg,
  lessEqualImpl: Ag,
  linSpaceImpl: Dg,
  logImpl: _g,
  maxImpl: Mg,
  maximumImpl: Lg,
  minimumImpl: Bg,
  multiplyImpl: Wg,
  negImpl: Hg,
  notEqualImpl: jg,
  prodImpl: Zg,
  rangeImpl: em,
  rsqrtImpl: tm,
  sigmoidImpl: sm,
  sliceImpl: im,
  sparseFillEmptyRowsImpl: um,
  sparseReshapeImpl: cm,
  sparseSegmentReductionImpl: hm,
  sqrtImpl: dm,
  squaredDifferenceImpl: fm,
  stridedSliceImpl: mm,
  stringNGramsImpl: xm,
  stringSplitImpl: km,
  stringToHashBucketFastImpl: wm,
  subImpl: vm,
  tileImpl: Sm,
  topKImpl: Tm,
  transposeImpl: Xg,
  uniqueImpl: Em
};
es("cpu", () => new Wf(), 1);
var Am = lg("Elu", e => e >= 0 ? e : Math.exp(e) - 1),
    Fm = {
  kernelName: "Elu",
  backendName: "cpu",
  kernelFunc: Am
};

function Dm(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    alpha: a
  } = s;
  Bf([r], "leakyRelu");
  var i = d(r.shape),
      o = n.data.get(r.dataId).values,
      l = w("float32", i);

  for (var _e287 = 0; _e287 < o.length; _e287++) {
    l[_e287] = o[_e287] < 0 ? a * o[_e287] : o[_e287];
  }

  return n.makeTensorInfo(r.shape, "float32", l);
}

var _m = {
  kernelName: "LeakyRelu",
  backendName: "cpu",
  kernelFunc: Dm
},
    Om = Gf((e, t) => e < 0 ? t * e : e);

function Mm(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    x: s,
    alpha: r
  } = t;
  Bf([s, r], "prelu");
  var a = n.data.get(s.dataId).values,
      i = n.data.get(r.dataId).values,
      [o, l] = Om(s.shape, r.shape, a, i, s.dtype);
  return n.makeTensorInfo(l, s.dtype, o);
}

var Lm = {
  kernelName: "Prelu",
  backendName: "cpu",
  kernelFunc: Mm
},
    zm = lg("Relu", e => Math.max(0, e)),
    Bm = {
  kernelName: "Relu",
  backendName: "cpu",
  kernelFunc: zm
},
    Pm = lg("Relu6", e => Math.min(Math.max(0, e), 6)),
    Wm = {
  kernelName: "Relu6",
  backendName: "cpu",
  kernelFunc: Pm
};

function Um(e, t, n, s, r) {
  if ("linear" === n) return Kf({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("relu" === n) return zm({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("elu" === n) return Am({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("relu6" === n) return Pm({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("prelu" === n) return Mm({
    inputs: {
      x: t,
      alpha: s
    },
    backend: e
  });
  if ("leakyrelu" === n) return Dm({
    inputs: {
      x: t
    },
    backend: e,
    attrs: {
      alpha: r
    }
  });
  if ("sigmoid" === n) return rm({
    inputs: {
      x: t
    },
    backend: e
  });
  throw new Error("Activation ".concat(n, " has not been implemented for the CPU backend."));
}

function Vm(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    shape: a
  } = s,
      i = d(r.shape),
      o = x(a, i),
      u = d(o);
  l(i === u, () => "The new shape (".concat(o, ") has ").concat(u, " elements and the old shape (").concat(r.shape, ") has ").concat(i, " elements. The new shape and old shape must have the same number of elements.")), n.incRef(r.dataId);
  var c = n.data.get(r.dataId);

  if (null != c.complexTensorInfos) {
    var _e288 = c.complexTensorInfos.imag;
    c.complexTensorInfos.real.shape = o, _e288.shape = o;
  }

  return {
    dataId: r.dataId,
    shape: o,
    dtype: r.dtype
  };
}

var Gm = {
  kernelName: "Reshape",
  backendName: "cpu",
  kernelFunc: Vm
};

function Hm(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    a: r,
    b: a
  } = t,
      {
    transposeA: i,
    transposeB: o
  } = s;
  Bf([r, a], "matMul");
  var u = r.shape.length,
      c = a.shape.length,
      h = i ? r.shape[u - 2] : r.shape[u - 1],
      p = o ? a.shape[c - 1] : a.shape[c - 2],
      f = i ? r.shape[u - 1] : r.shape[u - 2],
      g = o ? a.shape[c - 2] : a.shape[c - 1],
      m = r.shape.slice(0, -2),
      b = a.shape.slice(0, -2),
      x = d(m),
      y = d(b);
  l(u >= 2 && c >= 2 && (x === y || 1 === x || 1 === y), () => "Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (".concat(m, ") and (").concat(b, ")."));
  var k = (x > y ? r.shape.slice(0, -2) : a.shape.slice(0, -2)).concat([f, g]);
  l(h === p, () => "Error in matMul: inner shapes (".concat(h, ") and (").concat(p, ") of Tensors with shapes ").concat(r.shape, " and ").concat(a.shape, " and transposeA=").concat(i, " and transposeB=").concat(o, " must match."));
  var w = o ? [y, g, p] : [y, p, g],
      v = Vm({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      shape: i ? [x, h, f] : [x, f, h]
    }
  }),
      I = Vm({
    inputs: {
      x: a
    },
    backend: n,
    attrs: {
      shape: w
    }
  }),
      $ = i ? v.shape[1] : v.shape[2],
      S = i ? v.shape[2] : v.shape[1],
      N = o ? I.shape[1] : I.shape[2],
      C = Math.max(x, y),
      T = n.data.get(v.dataId).values,
      E = n.data.get(I.dataId).values,
      R = A(v.shape),
      F = A(I.shape),
      [D, _, O] = i ? [R[0], 1, R[1]] : [R[0], R[1], 1],
      [M, L, z] = o ? [1, F[1], F[0]] : [F[1], 1, F[0]],
      B = S * N,
      P = pn([C, S, N], v.dtype),
      W = P.values,
      U = n.blockSize;

  for (var _e289 = 0; _e289 < C; _e289++) {
    for (var _t266 = 0; _t266 < S; _t266 += U) {
      for (var _n169 = 0; _n169 < N; _n169 += U) {
        for (var _s141 = 0; _s141 < $; _s141 += U) {
          var _r98 = Math.min(_t266 + U, S),
              _a78 = Math.min(_n169 + U, N),
              _i42 = Math.min(_s141 + U, $);

          for (var _o33 = _t266; _o33 < _r98; _o33++) {
            for (var _t267 = _n169; _t267 < _a78; _t267++) {
              var _n170 = 0;

              for (var _r99 = _s141; _r99 < _i42; _r99++) {
                var _s142 = Math.min(_e289, x - 1) * D,
                    _a79 = Math.min(_e289, y - 1) * z;

                _n170 += T[_s142 + _o33 * _ + _r99 * O] * E[_r99 * M + _t267 * L + _a79];
              }

              W[_e289 * B + (_o33 * N + _t267)] += _n170;
            }
          }
        }
      }
    }
  }

  return n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(I), n.makeTensorInfo(k, P.dtype, P.values);
}

var qm = {
  kernelName: "BatchMatMul",
  backendName: "cpu",
  kernelFunc: Hm
},
    jm = {
  kernelName: "_FusedMatMul",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      a: r,
      b: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      transposeA: l,
      transposeB: u,
      activation: c,
      leakyreluAlpha: h
    } = s;
    var d, p, f;
    var g = [];
    d = Hm({
      inputs: {
        a: r,
        b: a
      },
      attrs: {
        transposeA: l,
        transposeB: u
      },
      backend: n
    }), i && (p = sg({
      inputs: {
        a: d,
        b: i
      },
      backend: n
    }), g.push(d), d = p), c && (f = Um(n, d, c, o, h), g.push(d), d = f);

    for (var _e290 of g) {
      n.disposeIntermediateTensorInfo(_e290);
    }

    return d;
  }
},
    Km = {
  kernelName: "Acos",
  backendName: "cpu",
  kernelFunc: lg("Acos", e => Math.acos(e))
},
    Xm = {
  kernelName: "Acosh",
  backendName: "cpu",
  kernelFunc: lg("Acosh", e => Math.acosh(e))
},
    Ym = {
  kernelName: "AddN",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        s = t;
    Bf(t, "addN");
    var r = s.map(e => n.data.get(e.dataId).values),
        a = pn(s[0].shape, s[0].dtype),
        i = a.values;

    for (var _e291 = 0; _e291 < s.length; _e291++) {
      var _t268 = r[_e291];

      for (var _e292 = 0; _e292 < i.length; _e292++) {
        i[_e292] += _t268[_e292];
      }
    }

    return n.makeTensorInfo(a.shape, a.dtype, a.values);
  }
},
    Jm = {
  kernelName: "All",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s;
    Bf(r, "all");
    var o = y(a, r.shape);
    var l = o;
    var u = Zr(l, r.shape.length);
    var c = r;
    null != u && (c = Yg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), l = ea(l.length, r.shape.length)), Jr("all", l, c.shape.length);
    var [h, p] = Xr(c.shape, l),
        f = d(p),
        g = O(d(h), c.dtype),
        m = n.data.get(c.dataId).values;

    for (var _e293 = 0; _e293 < g.length; ++_e293) {
      var _t269 = _e293 * f;

      var _n171 = m[_t269];

      for (var _e294 = 0; _e294 < f; ++_e294) {
        var _s143 = m[_t269 + _e294];
        _n171 = _n171 && _s143;
      }

      g[_e293] = _n171;
    }

    null != u && n.disposeIntermediateTensorInfo(c);
    var b = n.makeTensorInfo(h, c.dtype, g);

    if (i) {
      var _e295 = Vm({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: Yr(h, o)
        }
      });

      return n.disposeIntermediateTensorInfo(b), _e295;
    }

    return b;
  }
},
    Zm = {
  kernelName: "Any",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s;
    Bf(r, "any");
    var o = y(a, r.shape);
    var l = o;
    var u = Zr(l, r.shape.length);
    var c = r;
    null != u && (c = Yg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), l = ea(l.length, r.shape.length)), Jr("any", l, c.shape.length);
    var [h, p] = Xr(c.shape, l),
        f = d(p),
        g = O(d(h), c.dtype),
        m = n.data.get(c.dataId).values;

    for (var _e296 = 0; _e296 < g.length; ++_e296) {
      var _t270 = _e296 * f;

      var _n172 = m[_t270];

      for (var _e297 = 0; _e297 < f; ++_e297) {
        var _s144 = m[_t270 + _e297];
        _n172 = _n172 || _s144;
      }

      g[_e296] = _n172;
    }

    null != u && n.disposeIntermediateTensorInfo(c);
    var b = n.makeTensorInfo(h, c.dtype, g);

    if (i) {
      var _e298 = Vm({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: Yr(h, o)
        }
      });

      return n.disposeIntermediateTensorInfo(b), _e298;
    }

    return b;
  }
},
    Qm = {
  kernelName: "ArgMax",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a
    } = s;
    Bf(r, "argMax");
    var i = y(a, r.shape);
    var o = Zr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = Yg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = ea(i.length, l.shape.length)), i = [i[0]], Jr("argMax", i, l.shape.length);
    var [c, h] = Xr(l.shape, i),
        p = O(d(c), "int32"),
        f = d(h),
        g = n.data.get(l.dataId).values;

    for (var _e299 = 0; _e299 < p.length; ++_e299) {
      var _t271 = _e299 * f;

      var _n173 = g[_t271],
          _s145 = 0;

      for (var _e300 = 0; _e300 < f; ++_e300) {
        var _r100 = g[_t271 + _e300];
        _r100 > _n173 && (_n173 = _r100, _s145 = _e300);
      }

      p[_e299] = _s145;
    }

    return u.forEach(e => n.disposeIntermediateTensorInfo(e)), n.makeTensorInfo(c, "int32", p);
  }
},
    eb = {
  kernelName: "ArgMin",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a
    } = s;
    Bf(r, "argMin");
    var i = y(a, r.shape);
    var o = Zr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = Yg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = ea(i.length, l.shape.length)), i = [i[0]], Jr("argMin", i, l.shape.length);
    var [c, h] = Xr(l.shape, i),
        p = O(d(c), "int32"),
        f = d(h),
        g = n.data.get(l.dataId).values;

    for (var _e301 = 0; _e301 < p.length; ++_e301) {
      var _t272 = _e301 * f;

      var _n174 = g[_t272],
          _s146 = 0;

      for (var _e302 = 0; _e302 < f; ++_e302) {
        var _r101 = g[_t272 + _e302];
        _r101 < _n174 && (_n174 = _r101, _s146 = _e302);
      }

      p[_e301] = _s146;
    }

    return u.forEach(e => n.disposeIntermediateTensorInfo(e)), n.makeTensorInfo(c, "int32", p);
  }
},
    tb = {
  kernelName: "Asin",
  backendName: "cpu",
  kernelFunc: lg("Asin", e => Math.asin(e))
},
    nb = {
  kernelName: "Asinh",
  backendName: "cpu",
  kernelFunc: lg("Asinh", e => Math.asinh(e))
},
    sb = {
  kernelName: "Atan",
  backendName: "cpu",
  kernelFunc: lg("Atan", e => Math.atan(e))
},
    rb = {
  kernelName: "Atan2",
  backendName: "cpu",
  kernelFunc: eg("Atan2", Gf((e, t) => Math.atan2(e, t)))
},
    ab = {
  kernelName: "Atanh",
  backendName: "cpu",
  kernelFunc: lg("Atanh", e => Math.atanh(e))
};

function ib(e, t, n, s, r, a) {
  var i = r.strideHeight,
      o = r.strideWidth,
      l = r.dilationHeight,
      u = r.dilationWidth,
      c = r.effectiveFilterHeight,
      h = r.effectiveFilterWidth,
      d = r.padInfo.top,
      p = r.padInfo.left,
      f = "max" === a ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      g = pn(r.outShape, n),
      m = g.values,
      b = r.outShape[1] * r.outShape[2] * r.outShape[3],
      x = r.outShape[2] * r.outShape[3],
      y = r.outShape[3];

  for (var _t273 = 0; _t273 < r.batchSize; ++_t273) {
    var _n175 = _t273 * b,
        _g9 = _t273 * s[0];

    for (var _t274 = 0; _t274 < r.inChannels; ++_t274) {
      for (var _b7 = 0; _b7 < r.outHeight; ++_b7) {
        var _k4 = _b7 * i - d,
            _w3 = Math.max(0, _k4),
            _v3 = Math.min(r.inHeight, c + _k4),
            _I2 = _n175 + _b7 * x;

        for (var _n176 = 0; _n176 < r.outWidth; ++_n176) {
          var _i43 = _n176 * o - p,
              _c13 = Math.max(0, _i43),
              _d10 = Math.min(r.inWidth, h + _i43);

          var _b8 = f,
              _x51 = 0,
              _k5 = 0;

          for (var _n177 = _w3; _n177 < _v3; _n177 += l) {
            var _r102 = _g9 + _n177 * s[1];

            for (var _n178 = _c13; _n178 < _d10; _n178 += u) {
              var _i44 = e[_r102 + _n178 * s[2] + _t274];
              "max" === a && _i44 > _b8 ? _b8 = _i44 : "avg" === a && (_x51 += _i44, _k5++);
            }

            if (isNaN(_b8)) break;
          }

          m[_I2 + _n176 * y + _t274] = "avg" === a ? _x51 / _k5 : _b8;
        }
      }
    }
  }

  return g;
}

function ob(e, t, n, s) {
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
  var i = pn(s.outShape, "int32"),
      o = s.strideHeight,
      l = s.strideWidth,
      u = s.dilationHeight,
      c = s.dilationWidth,
      h = s.effectiveFilterHeight,
      d = s.effectiveFilterWidth,
      p = s.padInfo.top,
      f = s.padInfo.left,
      g = pn(t, n, e);

  for (var _e303 = 0; _e303 < s.batchSize; ++_e303) {
    for (var _t275 = 0; _t275 < s.inChannels; ++_t275) {
      for (var _n179 = 0; _n179 < s.outHeight; ++_n179) {
        var _m8 = _n179 * o - p;

        var _b9 = _m8;

        for (; _b9 < 0;) {
          _b9 += u;
        }

        var _x52 = Math.min(s.inHeight, h + _m8);

        for (var _o34 = 0; _o34 < s.outWidth; ++_o34) {
          var _h9 = _o34 * l - f;

          var _p9 = _h9;

          for (; _p9 < 0;) {
            _p9 += c;
          }

          var _y7 = Math.min(s.inWidth, d + _h9);

          var _k6 = Number.NEGATIVE_INFINITY,
              _w4 = -1;

          for (var _n180 = _b9; _n180 < _x52; _n180 += u) {
            var _i45 = _n180 - _m8;

            for (var _o35 = _p9; _o35 < _y7; _o35 += c) {
              var _l22 = _o35 - _h9,
                  _u14 = g.get(_e303, _n180, _o35, _t275);

              _u14 > _k6 && (_k6 = _u14, _w4 = r ? a ? ((_e303 * s.inHeight + _n180) * s.inWidth + _o35) * s.inChannels + _t275 : (_n180 * s.inWidth + _o35) * s.inChannels + _t275 : _i45 * d + _l22);
            }
          }

          i.set(_w4, _e303, _n179, _o34, _t275);
        }
      }
    }
  }

  return i;
}

function lb(e, t, n, s, r, a) {
  var i = r.strideDepth,
      o = r.strideHeight,
      l = r.strideWidth,
      u = r.dilationDepth,
      c = r.dilationHeight,
      h = r.dilationWidth,
      d = r.effectiveFilterDepth,
      p = r.effectiveFilterHeight,
      f = r.effectiveFilterWidth,
      g = r.padInfo.front,
      m = r.padInfo.top,
      b = r.padInfo.left,
      x = "max" === a ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      y = pn(r.outShape, n),
      k = y.values,
      w = r.outShape[1] * r.outShape[2] * r.outShape[3] * r.outShape[4],
      v = r.outShape[2] * r.outShape[3] * r.outShape[4],
      I = r.outShape[3] * r.outShape[4],
      $ = r.outShape[4];

  for (var _t276 = 0; _t276 < r.batchSize; ++_t276) {
    var _n181 = _t276 * w,
        _y8 = _t276 * s[0];

    for (var _t277 = 0; _t277 < r.inChannels; ++_t277) {
      for (var _w5 = 0; _w5 < r.outDepth; ++_w5) {
        var _S2 = _w5 * i - g;

        var _N2 = _S2;

        for (; _N2 < 0;) {
          _N2 += u;
        }

        var _C = Math.min(r.inDepth, d + _S2),
            _T = _n181 + _w5 * v;

        for (var _n182 = 0; _n182 < r.outHeight; ++_n182) {
          var _i46 = _n182 * o - m;

          var _d11 = _i46;

          for (; _d11 < 0;) {
            _d11 += c;
          }

          var _g10 = Math.min(r.inHeight, p + _i46),
              _w6 = _T + _n182 * I;

          for (var _n183 = 0; _n183 < r.outWidth; ++_n183) {
            var _i47 = _n183 * l - b;

            var _o36 = _i47;

            for (; _o36 < 0;) {
              _o36 += h;
            }

            var _p10 = Math.min(r.inWidth, f + _i47),
                _m9 = _w6 + _n183 * $;

            var _v4 = x,
                _I3 = 0,
                _S3 = 0;

            for (var _n184 = _N2; _n184 < _C; _n184 += u) {
              var _r103 = _y8 + _n184 * s[1];

              for (var _n185 = _d11; _n185 < _g10; _n185 += c) {
                var _i48 = _r103 + _n185 * s[2];

                for (var _n186 = _o36; _n186 < _p10; _n186 += h) {
                  var _r104 = e[_i48 + _n186 * s[3] + _t277];
                  if ("max" === a && _r104 > _v4 ? _v4 = _r104 : "avg" === a && (_I3 += _r104, _S3++), isNaN(_v4)) break;
                }

                if (isNaN(_v4)) break;
              }

              if (isNaN(_v4)) break;
            }

            k[_m9 + _t277] = "avg" === a ? _I3 / _S3 : _v4;
          }
        }
      }
    }
  }

  return y;
}

var ub = {
  kernelName: "AvgPool",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t;
    Bf(r, "avgPool");
    var {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: u
    } = s;
    l(Ts(i, 1), () => "Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'"));
    var c = xs(r.shape, a, i, 1, o, u);
    var h;
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) h = Kf({
      inputs: {
        x: r
      },
      backend: n
    });else {
      var _e304 = n.data.get(r.dataId).values,
          _t278 = A(r.shape),
          _s147 = ib(_e304, 0, r.dtype, _t278, c, "avg");

      h = n.makeTensorInfo(c.outShape, r.dtype, _s147.values);
    }
    return h;
  }
},
    cb = {
  kernelName: "AvgPool3D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: l,
      dataFormat: u
    } = s;
    Bf(r, "avgPool3d");
    var c = ys(r.shape, a, i, 1, o, l, u),
        h = lb(n.data.get(r.dataId).values, 0, r.dtype, A(r.shape), c, "avg");
    return n.makeTensorInfo(h.shape, "float32", h.values);
  }
},
    hb = {
  kernelName: "AvgPool3DGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        {
      filterSize: i,
      strides: o,
      pad: l,
      dimRoundingMode: u
    } = s;
    Bf([r, a], "avgPool3DGrad");
    var c = ys(a.shape, i, o, 1, l, u),
        h = c.strideDepth,
        d = c.strideHeight,
        p = c.strideWidth,
        f = c.filterDepth,
        g = c.filterHeight,
        m = c.filterWidth,
        b = c.dilationDepth,
        x = c.dilationHeight,
        y = c.dilationWidth,
        k = c.effectiveFilterDepth,
        w = c.effectiveFilterHeight,
        v = c.effectiveFilterWidth,
        I = k - 1 - c.padInfo.front,
        $ = v - 1 - c.padInfo.left,
        S = w - 1 - c.padInfo.top,
        N = pn(a.shape, "float32"),
        C = 1 / (f * g * m),
        T = n.bufferSync(r);

    for (var _e305 = 0; _e305 < c.batchSize; ++_e305) {
      for (var _t279 = 0; _t279 < c.inChannels; ++_t279) {
        for (var _n187 = 0; _n187 < c.inDepth; ++_n187) {
          for (var _s148 = 0; _s148 < c.inHeight; ++_s148) {
            for (var _r105 = 0; _r105 < c.inWidth; ++_r105) {
              var _a80 = _n187 - I,
                  _i49 = _s148 - S,
                  _o37 = _r105 - $;

              var _l23 = 0;

              for (var _n188 = 0; _n188 < k; _n188 += b) {
                var _s149 = (_a80 + _n188) / h;

                if (!(_s149 < 0 || _s149 >= c.outDepth || Math.floor(_s149) !== _s149)) for (var _n189 = 0; _n189 < w; _n189 += x) {
                  var _r106 = (_i49 + _n189) / d;

                  if (!(_r106 < 0 || _r106 >= c.outHeight || Math.floor(_r106) !== _r106)) for (var _n190 = 0; _n190 < v; _n190 += y) {
                    var _a81 = (_o37 + _n190) / p;

                    _a81 < 0 || _a81 >= c.outWidth || Math.floor(_a81) !== _a81 || (_l23 += T.get(_e305, _s149, _r106, _a81, _t279));
                  }
                }
              }

              N.set(_l23 * C, _e305, _n187, _s148, _r105, _t279);
            }
          }
        }
      }
    }

    return n.makeTensorInfo(N.shape, N.dtype, N.values);
  }
},
    db = {
  kernelName: "AvgPoolGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        i = a;
    Bf([r, a], "avgPoolGrad");
    var {
      filterSize: o,
      strides: l,
      pad: u
    } = s,
        c = xs(i.shape, o, l, 1, u),
        h = c.strideHeight,
        d = c.strideWidth,
        p = c.filterHeight,
        f = c.filterWidth,
        g = c.dilationHeight,
        m = c.dilationWidth,
        b = c.effectiveFilterHeight,
        x = c.effectiveFilterWidth,
        y = x - 1 - c.padInfo.left,
        k = b - 1 - c.padInfo.top,
        w = pn(i.shape, "float32"),
        v = 1 / (p * f),
        I = n.data.get(r.dataId).values,
        $ = pn(r.shape, "float32", I);

    for (var _e306 = 0; _e306 < c.batchSize; ++_e306) {
      for (var _t280 = 0; _t280 < c.inChannels; ++_t280) {
        for (var _n191 = 0; _n191 < c.inHeight; ++_n191) {
          for (var _s150 = 0; _s150 < c.inWidth; ++_s150) {
            var _r107 = _n191 - k,
                _a82 = _s150 - y;

            var _i50 = 0;

            for (var _n192 = 0; _n192 < b; _n192 += g) {
              var _s151 = (_r107 + _n192) / h;

              if (!(_s151 < 0 || _s151 >= c.outHeight || Math.floor(_s151) !== _s151)) for (var _n193 = 0; _n193 < x; _n193 += m) {
                var _r108 = (_a82 + _n193) / d;

                _r108 < 0 || _r108 >= c.outWidth || Math.floor(_r108) !== _r108 || (_i50 += $.get(_e306, _s151, _r108, _t280));
              }
            }

            w.set(_i50 * v, _e306, _n191, _s150, _t280);
          }
        }
      }
    }

    return n.makeTensorInfo(w.shape, w.dtype, w.values);
  }
},
    pb = {
  kernelName: "FusedBatchNorm",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      scale: a,
      offset: i,
      mean: o,
      variance: u
    } = t;
    l(o.shape.length === u.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), l(null == i || o.shape.length === i.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), l(null == a || o.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), Bf([r, o, u, a, i], "batchNorm");
    var {
      varianceEpsilon: c
    } = s;
    null == c && (c = .001);
    var h = n.data.get(r.dataId).values,
        d = n.data.get(o.dataId).values,
        p = n.data.get(u.dataId).values,
        f = a ? n.data.get(a.dataId).values : new Float32Array([1]),
        g = i ? n.data.get(i.dataId).values : new Float32Array([0]),
        m = new Float32Array(h.length),
        b = g.length,
        x = f.length,
        y = p.length,
        k = d.length;
    var w = 0,
        v = 0,
        I = 0,
        $ = 0;

    for (var _e307 = 0; _e307 < h.length; ++_e307) {
      m[_e307] = g[w++] + (h[_e307] - d[v++]) * f[I++] / Math.sqrt(p[$++] + c), w >= b && (w = 0), v >= k && (v = 0), I >= x && (I = 0), $ >= y && ($ = 0);
    }

    return n.makeTensorInfo(r.shape, r.dtype, m);
  }
},
    fb = {
  kernelName: "BatchToSpaceND",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockShape: a,
      crops: i
    } = s;
    Bf([r], "batchToSpaceND");

    var o = a.reduce((e, t) => e * t),
        l = Fo(r.shape, a, o),
        u = Do(l.length, a.length),
        c = _o(r.shape, a, o),
        h = Oo(i, a.length),
        d = Mo(c, i, a.length),
        p = Vm({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: l
      }
    }),
        f = Yg({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        perm: u
      }
    }),
        g = Vm({
      inputs: {
        x: f
      },
      backend: n,
      attrs: {
        shape: c
      }
    }),
        m = om({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        begin: h,
        size: d
      }
    });

    return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
  }
},
    gb = {
  kernelName: "Bincount",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      weights: a
    } = t,
        {
      size: i
    } = s,
        o = ag(n.data.get(r.dataId).values, n.data.get(a.dataId).values, a.dtype, a.shape, i);
    return n.makeTensorInfo([i], a.dtype, o);
  }
},
    mb = {
  kernelName: "BroadcastArgs",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      s0: s,
      s1: r
    } = t,
        a = n.data.get(s.dataId).values,
        i = n.data.get(r.dataId).values,
        o = hr(Array.from(a), Array.from(i));
    return n.makeTensorInfo([o.length], "int32", Int32Array.from(o));
  }
},
    bb = {
  kernelName: "ClipByValue",
  backendName: "cpu",
  kernelFunc: lg("ClipByValue", (e, t) => e > t.clipValueMax ? t.clipValueMax : e < t.clipValueMin ? t.clipValueMin : e)
},
    xb = {
  kernelName: "ComplexAbs",
  backendName: "cpu",
  kernelFunc: e => {
    var {
      x: t
    } = e.inputs,
        n = e.backend,
        s = new Float32Array(d(t.shape)),
        r = n.data.get(t.dataId),
        a = r.complexTensorInfos.imag,
        i = n.data.get(r.complexTensorInfos.real.dataId).values,
        o = n.data.get(a.dataId).values;

    for (var _e308 = 0; _e308 < i.length; _e308++) {
      s[_e308] = Math.hypot(i[_e308], o[_e308]);
    }

    return n.makeOutput(s, t.shape, "float32");
  }
};

function yb(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    input: s
  } = t,
      r = n.data.get(s.dataId).complexTensorInfos.imag,
      a = n.data.get(r.dataId).values;
  return n.makeTensorInfo(r.shape, r.dtype, a);
}

var kb = {
  kernelName: "Imag",
  backendName: "cpu",
  kernelFunc: yb
};

function wb(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    axis: r
  } = s,
      a = y(r, t[0].shape)[0];
  var i = Eo(t.map(e => e.shape), a);
  if (0 === d(i)) return n.makeTensorInfo(i, t[0].dtype, []);
  var o = t.filter(e => d(e.shape) > 0);
  if (1 === o.length) return Kf({
    inputs: {
      x: o[0]
    },
    backend: n
  });

  if (To(o.map(e => e.shape), a), "complex64" === o[0].dtype) {
    var _e309 = o.map(e => Yf({
      inputs: {
        input: e
      },
      backend: n
    })),
        _t281 = o.map(e => yb({
      inputs: {
        input: e
      },
      backend: n
    })),
        _s152 = wb({
      inputs: _e309,
      backend: n,
      attrs: {
        axis: a
      }
    }),
        _r109 = wb({
      inputs: _t281,
      backend: n,
      attrs: {
        axis: a
      }
    }),
        _i51 = Hf({
      inputs: {
        real: _s152,
        imag: _r109
      },
      backend: n
    });

    return _e309.forEach(e => n.disposeIntermediateTensorInfo(e)), _t281.forEach(e => n.disposeIntermediateTensorInfo(e)), n.disposeIntermediateTensorInfo(_s152), n.disposeIntermediateTensorInfo(_r109), _i51;
  }

  var l = o.map(e => {
    var t = d(e.shape.slice(a));
    return Vm({
      inputs: {
        x: e
      },
      backend: n,
      attrs: {
        shape: [-1, t]
      }
    });
  }),
      u = l.map(e => ({
    vals: n.data.get(e.dataId).values,
    shape: e.shape
  }));
  i = Eo(l.map(e => e.shape), 1);
  var c = dg(u, i, t[0].dtype, 1 === l[0].shape[0]),
      h = Eo(o.map(e => e.shape), a),
      p = n.makeTensorInfo(h, t[0].dtype, c);
  return l.forEach(e => n.disposeIntermediateTensorInfo(e)), p;
}

var vb = {
  kernelName: "Concat",
  backendName: "cpu",
  kernelFunc: wb
};

function Ib(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r,
    filter: a
  } = t,
      {
    strides: i,
    pad: o,
    dataFormat: l,
    dilations: u,
    dimRoundingMode: c
  } = s;
  Bf([r, a], "conv2d");
  var h = Es(l),
      d = ks(r.shape, a.shape, i, u, o, c, !1, h),
      p = d.filterHeight,
      f = d.filterWidth,
      g = d.dilationHeight,
      m = d.dilationWidth,
      b = d.padInfo.left,
      x = d.padInfo.top,
      y = "channelsLast" === d.dataFormat,
      k = new tt(d.outShape, r.dtype),
      w = A(r.shape),
      v = A(a.shape),
      I = w[0],
      $ = y ? w[1] : w[2],
      S = y ? w[2] : 1,
      N = y ? 1 : w[1],
      C = k.strides[0],
      T = y ? k.strides[1] : k.strides[2],
      E = y ? k.strides[2] : 1,
      R = y ? 1 : k.strides[1],
      F = n.data.get(r.dataId).values,
      D = n.data.get(a.dataId).values,
      _ = k.values;

  for (var _e310 = 0; _e310 < d.batchSize; ++_e310) {
    var _t282 = _e310 * I,
        _n194 = _e310 * C;

    for (var _e311 = 0; _e311 < d.outHeight; ++_e311) {
      var _s153 = _n194 + _e311 * T,
          _r110 = _e311 * d.strideHeight - x;

      for (var _e312 = 0; _e312 < p; ++_e312) {
        var _n195 = _r110 + _e312 * g;

        if (_n195 < 0 || _n195 >= d.inHeight) continue;

        var _a83 = _e312 * v[0],
            _i52 = _t282 + _n195 * $;

        for (var _e313 = 0; _e313 < d.outWidth; ++_e313) {
          var _t283 = _s153 + _e313 * E,
              _n196 = _e313 * d.strideWidth - b;

          for (var _e314 = 0; _e314 < f; ++_e314) {
            var _s154 = _n196 + _e314 * m;

            if (_s154 < 0 || _s154 >= d.inWidth) continue;

            var _r111 = _i52 + _s154 * S;

            var _o38 = _a83 + _e314 * v[1];

            for (var _e315 = 0; _e315 < d.inChannels; ++_e315) {
              var _n197 = F[_r111 + _e315 * N];

              for (var _e316 = 0; _e316 < d.outChannels; ++_e316) {
                _[_t283 + _e316 * R] += _n197 * D[_o38 + _e316];
              }

              _o38 += d.outChannels;
            }
          }
        }
      }
    }
  }

  return n.makeTensorInfo(k.shape, k.dtype, _);
}

var $b = {
  kernelName: "Conv2D",
  backendName: "cpu",
  kernelFunc: Ib
},
    Sb = {
  kernelName: "Conv2DBackpropFilter",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      pad: o,
      dataFormat: l,
      dimRoundingMode: u,
      filterShape: c
    } = s;
    Bf([r, a], "conv2dBackpropFilter");
    var h = Es(l),
        d = ks(r.shape, c, i, 1, o, u, !1, h),
        {
      strideHeight: p,
      strideWidth: f,
      filterHeight: g,
      filterWidth: m
    } = d,
        b = "channelsLast" === d.dataFormat,
        x = new tt(d.filterShape, "float32"),
        y = d.padInfo.left,
        k = d.padInfo.top,
        w = n.data.get(r.dataId).values,
        v = n.data.get(a.dataId).values,
        I = new tt(r.shape, r.dtype, w),
        $ = new tt(a.shape, a.dtype, v);

    for (var _e317 = 0; _e317 < g; ++_e317) {
      var _t284 = Math.max(0, Math.ceil((k - _e317) / p)),
          _n198 = Math.min(d.outHeight, (d.inHeight + k - _e317) / p);

      for (var _s155 = 0; _s155 < m; ++_s155) {
        var _r112 = Math.max(0, Math.ceil((y - _s155) / f)),
            _a84 = Math.min(d.outWidth, (d.inWidth + y - _s155) / f);

        for (var _i53 = 0; _i53 < d.inChannels; ++_i53) {
          for (var _o39 = 0; _o39 < d.outChannels; ++_o39) {
            var _l24 = 0;

            for (var _u15 = 0; _u15 < d.batchSize; ++_u15) {
              for (var _c14 = _t284; _c14 < _n198; ++_c14) {
                var _t285 = _e317 + _c14 * p - k;

                for (var _e318 = _r112; _e318 < _a84; ++_e318) {
                  var _n199 = _s155 + _e318 * f - y;

                  _l24 += b ? I.get(_u15, _t285, _n199, _i53) * $.get(_u15, _c14, _e318, _o39) : I.get(_u15, _i53, _t285, _n199) * $.get(_u15, _o39, _c14, _e318);
                }
              }
            }

            x.set(_l24, _e317, _s155, _i53, _o39);
          }
        }
      }
    }

    return n.makeTensorInfo(x.shape, x.dtype, x.values);
  }
},
    Nb = {
  kernelName: "Conv2DBackpropInput",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      inputShape: i,
      strides: o,
      pad: l,
      dataFormat: u,
      dimRoundingMode: c
    } = s;
    Bf([r, a], "conv2dBackpropInput");
    var h = A(a.shape),
        d = A(r.shape);
    var p = Es(u);
    var f = ks(i, a.shape, o, 1, l, c, !1, p),
        g = new tt(f.inShape, "float32"),
        m = g.values,
        b = n.data.get(r.dataId).values,
        x = n.data.get(a.dataId).values,
        [y, k, w] = h,
        {
      batchSize: v,
      filterHeight: I,
      filterWidth: $,
      inChannels: S,
      inHeight: N,
      inWidth: C,
      outChannels: T,
      outHeight: E,
      outWidth: R,
      strideHeight: F,
      strideWidth: D
    } = f;
    p = f.dataFormat;

    var _ = I - 1 - f.padInfo.top,
        O = $ - 1 - f.padInfo.left,
        M = "channelsLast" === p,
        L = g.strides[0],
        z = M ? g.strides[1] : g.strides[2],
        B = M ? g.strides[2] : 1,
        P = M ? 1 : g.strides[1],
        W = d[0],
        U = M ? d[1] : d[2],
        V = M ? d[2] : 1,
        G = M ? 1 : d[1];

    for (var _e319 = 0; _e319 < v; ++_e319) {
      for (var _t286 = 0; _t286 < S; ++_t286) {
        for (var _n200 = 0; _n200 < N; ++_n200) {
          var _s156 = _n200 - _,
              _r113 = Math.max(0, Math.ceil(_s156 / F)),
              _a85 = Math.min(E, (I + _s156) / F);

          for (var _i54 = 0; _i54 < C; ++_i54) {
            var _o40 = _i54 - O,
                _l25 = Math.max(0, Math.ceil(_o40 / D)),
                _u16 = Math.min(R, ($ + _o40) / D);

            var _c15 = 0;

            for (var _n201 = _r113; _n201 < _a85; ++_n201) {
              var _r114 = _n201 * F - _s156;

              for (var _s157 = _l25; _s157 < _u16; ++_s157) {
                var _a86 = W * _e319 + U * _n201 + V * _s157,
                    _i55 = y * (I - 1 - _r114) + k * ($ - 1 - (_s157 * D - _o40)) + w * _t286;

                for (var _e320 = 0; _e320 < T; ++_e320) {
                  _c15 += b[_a86 + G * _e320] * x[_i55 + _e320];
                }
              }
            }

            m[L * _e319 + z * _n200 + B * _i54 + P * _t286] = _c15;
          }
        }
      }
    }

    return n.makeTensorInfo(g.shape, g.dtype, g.values);
  }
},
    Cb = {
  kernelName: "Conv3D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a
    } = t,
        {
      strides: i,
      pad: o,
      dilations: l
    } = s;
    Bf([r, a], "conv3d");
    var u = ws(r.shape, a.shape, i, l, o),
        {
      filterDepth: c,
      filterHeight: h,
      filterWidth: d,
      dilationDepth: p,
      dilationHeight: f,
      dilationWidth: g,
      padInfo: m
    } = u,
        b = m.front,
        x = m.left,
        y = m.top,
        k = new tt(u.outShape, r.dtype),
        w = n.data.get(r.dataId).values,
        v = n.data.get(a.dataId).values,
        I = k.values,
        $ = A(r.shape),
        S = A(a.shape);

    for (var _e321 = 0; _e321 < u.batchSize; ++_e321) {
      var _t287 = _e321 * $[0],
          _n202 = _e321 * k.strides[0];

      for (var _e322 = 0; _e322 < u.outDepth; ++_e322) {
        var _s158 = _n202 + _e322 * k.strides[1],
            _r115 = _e322 * u.strideDepth - b;

        for (var _e323 = 0; _e323 < c; ++_e323) {
          var _n203 = _r115 + _e323 * p;

          if (_n203 < 0 || _n203 >= u.inDepth) continue;

          var _a87 = _e323 * S[0],
              _i56 = _t287 + _n203 * $[1];

          for (var _e324 = 0; _e324 < u.outHeight; ++_e324) {
            var _t288 = _s158 + _e324 * k.strides[2],
                _n204 = _e324 * u.strideHeight - y;

            for (var _e325 = 0; _e325 < h; ++_e325) {
              var _s159 = _n204 + _e325 * f;

              if (_s159 < 0 || _s159 >= u.inHeight) continue;

              var _r116 = _a87 + _e325 * S[1],
                  _o41 = _i56 + _s159 * $[2];

              for (var _e326 = 0; _e326 < u.outWidth; ++_e326) {
                var _n205 = _t288 + _e326 * u.outChannels,
                    _s160 = _e326 * u.strideWidth - x;

                for (var _e327 = 0; _e327 < d; ++_e327) {
                  var _t289 = _s160 + _e327 * g;

                  if (_t289 < 0 || _t289 >= u.inWidth) continue;

                  var _a88 = _o41 + _t289 * u.inChannels;

                  var _i57 = _r116 + _e327 * S[2];

                  for (var _e328 = 0; _e328 < u.inChannels; ++_e328) {
                    var _t290 = w[_a88 + _e328];

                    for (var _e329 = 0; _e329 < u.outChannels; ++_e329) {
                      I[_n205 + _e329] += _t290 * v[_i57 + _e329];
                    }

                    _i57 += u.outChannels;
                  }
                }
              }
            }
          }
        }
      }
    }

    return n.makeTensorInfo(k.shape, k.dtype, k.values);
  }
},
    Tb = {
  kernelName: "Conv3DBackpropFilterV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      pad: o,
      filterShape: l
    } = s;
    Bf([r, a], "conv3dBackpropFilterV2");
    var u = A(r.shape),
        c = A(a.shape),
        h = ws(r.shape, l, i, 1, o),
        d = h.strideDepth,
        p = h.strideHeight,
        f = h.strideWidth,
        g = h.filterDepth,
        m = h.filterHeight,
        b = h.filterWidth,
        x = new tt(h.filterShape, "float32"),
        y = x.values,
        [k, w, v, I] = x.strides,
        $ = n.data.get(a.dataId).values,
        [S, N, C, T] = c,
        E = n.data.get(r.dataId).values,
        [R, F, D, _] = u,
        O = h.padInfo.front,
        M = h.padInfo.left,
        L = h.padInfo.top;

    for (var _e330 = 0; _e330 < g; ++_e330) {
      var _t291 = Math.max(0, Math.ceil((O - _e330) / d)),
          _n206 = Math.min(h.outDepth, (h.inDepth + O - _e330) / d),
          _s161 = _e330 * k;

      for (var _r117 = 0; _r117 < m; ++_r117) {
        var _a89 = Math.max(0, Math.ceil((L - _r117) / p)),
            _i58 = Math.min(h.outHeight, (h.inHeight + L - _r117) / p),
            _o42 = _r117 * w + _s161;

        for (var _s162 = 0; _s162 < b; ++_s162) {
          var _l26 = Math.max(0, Math.ceil((M - _s162) / f)),
              _u17 = Math.min(h.outWidth, (h.inWidth + M - _s162) / f),
              _c16 = _s162 * v + _o42;

          for (var _o43 = 0; _o43 < h.inChannels; ++_o43) {
            var _g11 = _o43 * I + _c16;

            for (var _c17 = 0; _c17 < h.outChannels; ++_c17) {
              var _m10 = 0;

              for (var _g12 = 0; _g12 < h.batchSize; ++_g12) {
                var _h10 = _g12 * R,
                    _b10 = _g12 * S;

                for (var _g13 = _t291; _g13 < _n206; ++_g13) {
                  var _t292 = (_e330 + _g13 * d - O) * F + _h10,
                      _n207 = _g13 * N + _b10;

                  for (var _e331 = _a89; _e331 < _i58; ++_e331) {
                    var _a90 = (_r117 + _e331 * p - L) * D + _t292,
                        _i59 = _e331 * C + _n207;

                    for (var _e332 = _l26; _e332 < _u17; ++_e332) {
                      _m10 += E[(_s162 + _e332 * f - M) * _ + _a90 + _o43] * $[_e332 * T + _i59 + _c17];
                    }
                  }
                }
              }

              y[_g11 + _c17] = _m10;
            }
          }
        }
      }
    }

    return n.makeTensorInfo(x.shape, x.dtype, x.values);
  }
},
    Eb = {
  kernelName: "Conv3DBackpropInputV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      pad: i,
      strides: o,
      inputShape: l
    } = s;
    Bf([r], "conv3dBackpropInputV2");
    var u = A(r.shape),
        c = A(a.shape),
        h = ws(l, a.shape, o, 1, i),
        d = new tt(h.inShape, "float32"),
        p = d.values,
        [f, g, m, b] = d.strides,
        x = n.data.get(r.dataId).values,
        [y, k, w, v] = u,
        I = n.data.get(a.dataId).values,
        [$, S, N, C] = c,
        {
      batchSize: T,
      filterDepth: E,
      filterHeight: R,
      filterWidth: F,
      inChannels: D,
      inDepth: _,
      inHeight: O,
      inWidth: M,
      outChannels: L,
      outDepth: z,
      outHeight: B,
      outWidth: P,
      strideDepth: W,
      strideHeight: U,
      strideWidth: V
    } = h,
        G = E - 1 - h.padInfo.front,
        H = R - 1 - h.padInfo.top,
        q = F - 1 - h.padInfo.left;

    for (var _e333 = 0; _e333 < T; ++_e333) {
      for (var _t293 = 0; _t293 < D; ++_t293) {
        for (var _n208 = 0; _n208 < _; ++_n208) {
          var _s163 = _n208 - G,
              _r118 = Math.max(0, Math.ceil(_s163 / W)),
              _a91 = Math.min(z, (E + _s163) / W);

          for (var _i60 = 0; _i60 < O; ++_i60) {
            var _o44 = _i60 - H,
                _l27 = Math.max(0, Math.ceil(_o44 / U)),
                _u18 = Math.min(B, (R + _o44) / U);

            for (var _c18 = 0; _c18 < M; ++_c18) {
              var _h11 = _c18 - q,
                  _d12 = Math.max(0, Math.ceil(_h11 / V)),
                  _T2 = Math.min(P, (F + _h11) / V);

              var _A = 0;

              for (var _n209 = _r118; _n209 < _a91; ++_n209) {
                var _r119 = _n209 * W - _s163;

                for (var _s164 = _l27; _s164 < _u18; ++_s164) {
                  var _a92 = _s164 * U - _o44;

                  for (var _i61 = _d12; _i61 < _T2; ++_i61) {
                    var _o45 = y * _e333 + k * _n209 + w * _s164 + v * _i61,
                        _l28 = $ * (E - 1 - _r119) + S * (R - 1 - _a92) + N * (F - 1 - (_i61 * V - _h11)) + C * _t293;

                    for (var _e334 = 0; _e334 < L; ++_e334) {
                      _A += x[_o45 + _e334] * I[_l28 + _e334];
                    }
                  }
                }
              }

              p[f * _e333 + g * _n208 + m * _i60 + b * _c18 + _t293] = _A;
            }
          }
        }
      }
    }

    return n.makeTensorInfo(d.shape, d.dtype, d.values);
  }
},
    Rb = {
  kernelName: "Cos",
  backendName: "cpu",
  kernelFunc: lg("Cos", e => Math.cos(e))
},
    Ab = {
  kernelName: "Cosh",
  backendName: "cpu",
  kernelFunc: lg("Cosh", e => Math.cosh(e))
},
    Fb = {
  kernelName: "CropAndResize",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      image: r,
      boxes: a,
      boxInd: i
    } = t,
        {
      cropSize: o,
      method: l,
      extrapolationValue: u
    } = s,
        [c, h, d, p] = r.shape,
        f = a.shape[0],
        [g, m] = o,
        b = pn([f, g, m, p], "float32"),
        x = n.data.get(a.dataId).values,
        y = n.data.get(i.dataId).values,
        k = n.data.get(r.dataId).values,
        w = A(r.shape),
        v = A(b.shape);

    for (var _e335 = 0; _e335 < f; _e335++) {
      var _t294 = 4 * _e335,
          _n210 = x[_t294],
          _s165 = x[_t294 + 1],
          _r120 = x[_t294 + 2],
          _a93 = x[_t294 + 3],
          _i62 = y[_e335];

      if (_i62 >= c) continue;

      var _o46 = g > 1 ? (_r120 - _n210) * (h - 1) / (g - 1) : 0,
          _f7 = m > 1 ? (_a93 - _s165) * (d - 1) / (m - 1) : 0;

      for (var _t295 = 0; _t295 < g; _t295++) {
        var _c19 = g > 1 ? _n210 * (h - 1) + _t295 * _o46 : .5 * (_n210 + _r120) * (h - 1);

        if (_c19 < 0 || _c19 > h - 1) for (var _n211 = 0; _n211 < m; _n211++) {
          for (var _s166 = 0; _s166 < p; _s166++) {
            b.values[_s166 + _n211 * v[2] + _t295 * v[1] + _e335 * v[0]] = u;
          }
        } else if ("bilinear" === l) {
          var _n212 = Math.floor(_c19),
              _r121 = Math.ceil(_c19),
              _o47 = _c19 - _n212;

          for (var _l29 = 0; _l29 < m; _l29++) {
            var _c20 = m > 1 ? _s165 * (d - 1) + _l29 * _f7 : .5 * (_s165 + _a93) * (d - 1);

            if (_c20 < 0 || _c20 > d - 1) {
              for (var _n213 = 0; _n213 < p; _n213++) {
                b.values[_n213 + _l29 * v[2] + _t295 * v[1] + _e335 * v[0]] = u;
              }

              continue;
            }

            var _h12 = Math.floor(_c20),
                _g14 = Math.ceil(_c20),
                _x53 = _c20 - _h12;

            for (var _s167 = 0; _s167 < p; _s167++) {
              var _a94 = _s167 + _h12 * w[2] + _n212 * w[1] + _i62 * w[0];

              var _u19 = k[_a94];
              _a94 = _s167 + _g14 * w[2] + _n212 * w[1] + _i62 * w[0];
              var _c21 = k[_a94];
              _a94 = _s167 + _h12 * w[2] + _r121 * w[1] + _i62 * w[0];
              var _d13 = k[_a94];
              _a94 = _s167 + _g14 * w[2] + _r121 * w[1] + _i62 * w[0];

              var _p11 = k[_a94],
                  _f8 = _u19 + (_c21 - _u19) * _x53;

              _a94 = _s167 + _l29 * v[2] + _t295 * v[1] + _e335 * v[0], b.values[_a94] = _f8 + (_d13 + (_p11 - _d13) * _x53 - _f8) * _o47;
            }
          }
        } else for (var _n214 = 0; _n214 < m; ++_n214) {
          var _r122 = m > 1 ? _s165 * (d - 1) + _n214 * _f7 : .5 * (_s165 + _a93) * (d - 1);

          if (_r122 < 0 || _r122 > d - 1) {
            for (var _s168 = 0; _s168 < p; _s168++) {
              b.values[_s168 + _n214 * v[2] + _t295 * v[1] + _e335 * v[0]] = u;
            }

            continue;
          }

          var _o48 = Math.round(_r122),
              _l30 = Math.round(_c19);

          for (var _s169 = 0; _s169 < p; _s169++) {
            b.values[_s169 + _n214 * v[2] + _t295 * v[1] + _e335 * v[0]] = k[_s169 + _o48 * w[2] + _l30 * w[1] + _i62 * w[0]];
          }
        }
      }
    }

    return n.makeTensorInfo(b.shape, b.dtype, b.values);
  }
},
    Db = {
  kernelName: "Cumsum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      exclusive: i,
      reverse: o
    } = s;
    Bf(r, "cumsum");
    var l = Zr([a], r.shape.length);
    var u = r;
    null != l && (u = Yg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: l
      }
    }));
    var c = ea(1, r.shape.length)[0];
    if (c !== u.shape.length - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=".concat(u.shape.length - 1, " but got axis=").concat(c));
    var h = pt(u.dtype, "int32"),
        p = O(d(u.shape), h),
        f = n.data.get(u.dataId).values,
        g = u.shape[u.shape.length - 1],
        m = o ? (e, t) => e + g - t - 1 : (e, t) => e + t;

    for (var _e336 = 0; _e336 < f.length; _e336 += g) {
      for (var _t296 = 0; _t296 < g; _t296++) {
        var _n215 = m(_e336, _t296);

        if (0 === _t296) p[_n215] = i ? 0 : f[_n215];else {
          var _s170 = m(_e336, _t296 - 1);

          p[_n215] = i ? f[_s170] + p[_s170] : f[_n215] + p[_s170];
        }
      }
    }

    var b = n.makeTensorInfo(u.shape, h, p);

    if (null != l) {
      var _e337 = Yg({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          perm: Qr(l)
        }
      });

      return n.disposeIntermediateTensorInfo(b), n.disposeIntermediateTensorInfo(u), _e337;
    }

    return b;
  }
},
    _b = {
  kernelName: "DenseBincount",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      weights: a
    } = t,
        {
      size: i,
      binaryOutput: o
    } = s;

    if (1 === r.shape.length) {
      var _e338 = ag(n.data.get(r.dataId).values, n.data.get(a.dataId).values, a.dtype, a.shape, i);

      return n.makeTensorInfo([i], a.dtype, _e338);
    }

    if (2 === r.shape.length) {
      var _e339 = ig(n.bufferSync(r), n.bufferSync(a), i, o);

      return n.makeTensorInfo(_e339.shape, a.dtype, _e339.values);
    }

    throw new Error("Error in denseBincount: input must be at most rank 2, but got rank".concat(r.shape.length, "."));
  }
},
    Ob = {
  kernelName: "DepthToSpace",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockSize: a,
      dataFormat: i
    } = s;
    l("NHWC" === i, () => "Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(i)), l(a > 1, () => "blockSize should be > 1 for depthToSpace, but was: ".concat(a));
    var o = r.shape[0],
        u = r.shape[1],
        c = r.shape[2],
        h = r.shape[3],
        d = u * a,
        p = c * a,
        f = h / (a * a),
        g = n.data.get(r.dataId).values,
        m = new Float32Array(o * d * p * f);
    var b = 0;

    for (var _e340 = 0; _e340 < o; ++_e340) {
      for (var _t297 = 0; _t297 < d; ++_t297) {
        var _n216 = Math.floor(_t297 / a),
            _s171 = _t297 % a;

        for (var _t298 = 0; _t298 < p; ++_t298) {
          var _r123 = Math.floor(_t298 / a),
              _i63 = (_s171 * a + _t298 % a) * f;

          for (var _t299 = 0; _t299 < f; ++_t299) {
            m[b++] = g[_t299 + _i63 + h * (_r123 + c * (_n216 + u * _e340))];
          }
        }
      }
    }

    return n.makeTensorInfo([o, d, p, f], r.dtype, m);
  }
};

function Mb(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r,
    filter: a
  } = t,
      {
    strides: i,
    pad: o,
    dilations: u,
    dimRoundingMode: c
  } = s;
  Bf([r, a], "depthwiseConv2DNative");
  var h = A(r.shape),
      d = A(a.shape);
  var p = u;
  null == p && (p = [1, 1]), l(Ts(i, p), () => "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '").concat(p, "'"));
  var f = ks(r.shape, a.shape, i, p, o, c, !0),
      {
    filterHeight: g,
    filterWidth: m,
    dilationHeight: b,
    dilationWidth: x,
    padInfo: y
  } = f,
      k = y.left,
      w = y.top,
      v = f.outChannels / f.inChannels,
      I = new tt(f.outShape, r.dtype),
      $ = n.data.get(r.dataId).values,
      S = n.data.get(a.dataId).values,
      N = I.values;

  for (var _e341 = 0; _e341 < f.batchSize; ++_e341) {
    var _t300 = _e341 * h[0],
        _n217 = _e341 * I.strides[0];

    for (var _e342 = 0; _e342 < f.outHeight; ++_e342) {
      var _s172 = _n217 + _e342 * I.strides[1],
          _r124 = _e342 * f.strideHeight - w;

      for (var _e343 = 0; _e343 < g; ++_e343) {
        var _n218 = _r124 + _e343 * b;

        if (_n218 < 0 || _n218 >= f.inHeight) continue;

        var _a95 = _e343 * d[0],
            _i64 = _t300 + _n218 * h[1];

        for (var _e344 = 0; _e344 < f.outWidth; ++_e344) {
          var _t301 = _s172 + _e344 * I.strides[2],
              _n219 = _e344 * f.strideWidth - k;

          for (var _e345 = 0; _e345 < m; ++_e345) {
            var _s173 = _n219 + _e345 * x;

            if (_s173 < 0 || _s173 >= f.inWidth) continue;

            var _r125 = _i64 + _s173 * f.inChannels;

            var _o49 = _t301,
                _l31 = _a95 + _e345 * d[1];

            for (var _e346 = 0; _e346 < f.inChannels; ++_e346) {
              var _t302 = $[_r125 + _e346];

              for (var _e347 = 0; _e347 < v; ++_e347) {
                N[_o49 + _e347] += _t302 * S[_l31 + _e347];
              }

              _o49 += v, _l31 += v;
            }
          }
        }
      }
    }
  }

  return n.makeTensorInfo(I.shape, I.dtype, I.values);
}

var Lb = {
  kernelName: "DepthwiseConv2dNative",
  backendName: "cpu",
  kernelFunc: Mb
},
    zb = {
  kernelName: "DepthwiseConv2dNativeBackpropFilter",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      dilations: o,
      pad: l,
      dimRoundingMode: u,
      filterShape: c
    } = s;
    Bf([r, a], "depthwiseConv2dNativeBackpropFilter");
    var h = ks(r.shape, c, i, o, l, u, !0),
        {
      strideHeight: d,
      strideWidth: p,
      filterHeight: f,
      filterWidth: g
    } = h,
        m = new tt(h.filterShape, "float32"),
        b = h.padInfo.left,
        x = h.padInfo.top,
        y = h.outChannels / h.inChannels,
        k = n.data.get(r.dataId).values,
        w = new tt(r.shape, r.dtype, k),
        v = n.data.get(a.dataId).values,
        I = new tt(a.shape, a.dtype, v);

    for (var _e348 = 0; _e348 < f; ++_e348) {
      var _t303 = Math.max(0, Math.ceil((x - _e348) / d)),
          _n220 = Math.min(h.outHeight, (h.inHeight + x - _e348) / d);

      for (var _s174 = 0; _s174 < g; ++_s174) {
        var _r126 = Math.max(0, Math.ceil((b - _s174) / p)),
            _a96 = Math.min(h.outWidth, (h.inWidth + b - _s174) / p);

        for (var _i65 = 0; _i65 < h.outChannels; ++_i65) {
          var _o50 = Math.trunc(_i65 / y),
              _l32 = _i65 % y;

          var _u20 = 0;

          for (var _l33 = 0; _l33 < h.batchSize; ++_l33) {
            for (var _c22 = _t303; _c22 < _n220; ++_c22) {
              var _t304 = _e348 + _c22 * d - x;

              for (var _e349 = _r126; _e349 < _a96; ++_e349) {
                _u20 += w.get(_l33, _t304, _s174 + _e349 * p - b, _o50) * I.get(_l33, _c22, _e349, _i65);
              }
            }
          }

          m.set(_u20, _e348, _s174, _o50, _l32);
        }
      }
    }

    return n.makeTensorInfo(m.shape, m.dtype, m.values);
  }
},
    Bb = {
  kernelName: "DepthwiseConv2dNativeBackpropInput",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      strides: i,
      dilations: o,
      pad: l,
      dimRoundingMode: u,
      inputShape: c
    } = s;
    Bf([r, a], "depthwiseConv2DNativeBackpropInput");
    var h = A(r.shape),
        d = A(a.shape),
        p = ks(c, a.shape, i, o, l, u, !0),
        f = new tt(p.inShape, "float32"),
        g = f.values,
        [m, b, x] = f.strides,
        y = n.data.get(r.dataId).values,
        [k, w, v] = h,
        I = n.data.get(a.dataId).values,
        [$, S, N] = d,
        {
      batchSize: C,
      filterHeight: T,
      filterWidth: E,
      inChannels: R,
      inHeight: F,
      inWidth: D,
      outChannels: _,
      outHeight: O,
      outWidth: M,
      strideHeight: L,
      strideWidth: z
    } = p,
        B = T - 1 - p.padInfo.top,
        P = E - 1 - p.padInfo.left,
        W = _ / R;

    for (var _e350 = 0; _e350 < C; ++_e350) {
      for (var _t305 = 0; _t305 < R; ++_t305) {
        for (var _n221 = 0; _n221 < F; ++_n221) {
          var _s175 = _n221 - B,
              _r127 = Math.max(0, Math.ceil(_s175 / L)),
              _a97 = Math.min(O, (T + _s175) / L);

          for (var _i66 = 0; _i66 < D; ++_i66) {
            var _o51 = _i66 - P,
                _l34 = Math.max(0, Math.ceil(_o51 / z)),
                _u21 = Math.min(M, (E + _o51) / z);

            var _c23 = 0;

            for (var _n222 = _r127; _n222 < _a97; ++_n222) {
              var _r128 = _n222 * L - _s175;

              for (var _s176 = _l34; _s176 < _u21; ++_s176) {
                var _a98 = k * _e350 + w * _n222 + v * _s176,
                    _i67 = $ * (T - 1 - _r128) + S * (E - 1 - (_s176 * z - _o51)) + N * _t305;

                for (var _e351 = 0; _e351 < W; ++_e351) {
                  _c23 += y[_a98 + (_t305 * W + _e351)] * I[_i67 + _e351];
                }
              }
            }

            g[m * _e350 + b * _n221 + x * _i66 + _t305] = _c23;
          }
        }
      }
    }

    return n.makeTensorInfo(f.shape, f.dtype, f.values);
  }
},
    Pb = {
  kernelName: "Diag",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t,
        r = d(s.shape),
        a = n.data.get(s.dataId).values,
        i = pn([r, r], s.dtype),
        o = i.values;

    for (var _e352 = 0; _e352 < a.length; _e352++) {
      o[_e352 * r + _e352] = a[_e352];
    }

    var l = [...s.shape, ...s.shape];
    return n.makeTensorInfo(l, i.dtype, i.values);
  }
},
    Wb = {
  kernelName: "Dilation2D",
  backendName: "cpu",
  kernelFunc: _ref13 => {
    var {
      inputs: e,
      backend: t,
      attrs: n
    } = _ref13;
    var {
      x: s,
      filter: r
    } = e,
        {
      strides: a,
      pad: i,
      dilations: o
    } = n,
        l = t,
        u = l.data.get(s.dataId).values,
        c = s.shape.length,
        h = l.data.get(r.dataId).values,
        p = r.shape.length,
        {
      batchSize: f,
      inHeight: g,
      inWidth: m,
      inChannels: b,
      outHeight: x,
      outWidth: y,
      padInfo: k,
      strideHeight: w,
      strideWidth: I,
      filterHeight: $,
      filterWidth: S,
      dilationHeight: N,
      dilationWidth: C,
      outShape: T
    } = bs(s.shape, r.shape, a, i, "NHWC", o),
        E = d(T),
        R = T.length,
        F = v(s.dtype, E);

    for (var _e353 = 0; _e353 < f; ++_e353) {
      for (var _t306 = 0; _t306 < x; ++_t306) {
        var _n223 = _t306 * w - k.top;

        for (var _a99 = 0; _a99 < y; ++_a99) {
          var _i68 = _a99 * I - k.left;

          for (var _o52 = 0; _o52 < b; ++_o52) {
            var _l35 = Number.MIN_SAFE_INTEGER;

            for (var _t307 = 0; _t307 < $; ++_t307) {
              var _a100 = _n223 + _t307 * N;

              if (_a100 >= 0 && _a100 < g) for (var _n224 = 0; _n224 < S; ++_n224) {
                var _d14 = _i68 + _n224 * C;

                if (_d14 >= 0 && _d14 < m) {
                  var _i69 = z([_e353, _a100, _d14, _o52], c, A(s.shape)),
                      _f9 = z([_t307, _n224, _o52], p, A(r.shape)),
                      _g15 = u[_i69] + h[_f9];

                  _g15 > _l35 && (_l35 = _g15);
                }
              }
            }

            F[z([_e353, _t306, _a99, _o52], R, A(T))] = _l35;
          }
        }
      }
    }

    return {
      dataId: l.write(Ve(F, s.dtype), T, s.dtype),
      shape: T,
      dtype: s.dtype
    };
  }
},
    Ub = {
  kernelName: "Dilation2DBackpropFilter",
  backendName: "cpu",
  kernelFunc: _ref14 => {
    var {
      inputs: e,
      backend: t,
      attrs: n
    } = _ref14;
    var {
      x: s,
      filter: r,
      dy: a
    } = e,
        {
      strides: i,
      pad: o,
      dilations: u
    } = n,
        c = t,
        h = D(s.shape, c.data.get(s.dataId).values),
        d = D(r.shape, c.data.get(r.dataId).values),
        {
      batchSize: p,
      inHeight: f,
      inWidth: g,
      inChannels: m,
      outHeight: b,
      outWidth: x,
      padInfo: y,
      strideHeight: k,
      strideWidth: w,
      filterHeight: v,
      filterWidth: I,
      dilationHeight: $,
      dilationWidth: S,
      outShape: N
    } = bs(s.shape, r.shape, i, o, "NHWC", u);
    l(a.rank === N.length, () => "Error in Dilation2DBackpropFilter, dy must have the same rank as output ".concat(N.length, ", but got ").concat(a.rank));
    var C = D(N, c.data.get(a.dataId).values),
        T = M(r.shape, r.dtype);

    for (var _e354 = 0; _e354 < p; ++_e354) {
      for (var _t308 = 0; _t308 < b; ++_t308) {
        var _n225 = _t308 * k - y.top;

        for (var _s177 = 0; _s177 < x; ++_s177) {
          var _r129 = _s177 * w - y.left;

          for (var _a101 = 0; _a101 < m; ++_a101) {
            var _i70 = Number.MIN_SAFE_INTEGER,
                _o53 = 0,
                _l36 = 0;

            for (var _t309 = 0; _t309 < v; ++_t309) {
              var _s178 = _n225 + _t309 * $;

              if (_s178 >= 0 && _s178 < f) for (var _n226 = 0; _n226 < I; ++_n226) {
                var _u22 = _r129 + _n226 * S;

                if (_u22 >= 0 && _u22 < g) {
                  var _r130 = h[_e354][_s178][_u22][_a101] + d[_t309][_n226][_a101];

                  _r130 > _i70 && (_i70 = _r130, _o53 = _t309, _l36 = _n226);
                }
              }
            }

            T[_o53][_l36][_a101] += C[_e354][_t308][_s177][_a101];
          }
        }
      }
    }

    return {
      dataId: c.write(Ve(T, s.dtype), r.shape, r.dtype),
      shape: r.shape,
      dtype: r.dtype
    };
  }
},
    Vb = {
  kernelName: "Dilation2DBackpropInput",
  backendName: "cpu",
  kernelFunc: _ref15 => {
    var {
      inputs: e,
      backend: t,
      attrs: n
    } = _ref15;
    var {
      x: s,
      filter: r,
      dy: a
    } = e,
        {
      strides: i,
      pad: o,
      dilations: u
    } = n,
        c = t,
        h = D(s.shape, c.data.get(s.dataId).values),
        d = D(r.shape, c.data.get(r.dataId).values),
        {
      batchSize: p,
      inHeight: f,
      inWidth: g,
      inChannels: m,
      outHeight: b,
      outWidth: x,
      padInfo: y,
      strideHeight: k,
      strideWidth: w,
      filterHeight: v,
      filterWidth: I,
      dilationHeight: $,
      dilationWidth: S,
      outShape: N
    } = bs(s.shape, r.shape, i, o, "NHWC", u);
    l(a.rank === N.length, () => "Error in Dilation2DBackpropInput, dy must have the same rank as output ".concat(N.length, ", but got ").concat(a.rank));
    var C = D(N, c.data.get(a.dataId).values),
        T = M(s.shape, s.dtype);

    for (var _e355 = 0; _e355 < p; ++_e355) {
      for (var _t310 = 0; _t310 < b; ++_t310) {
        var _n227 = _t310 * k - y.top;

        for (var _s179 = 0; _s179 < x; ++_s179) {
          var _r131 = _s179 * w - y.left;

          for (var _a102 = 0; _a102 < m; ++_a102) {
            var _i71 = Number.MIN_SAFE_INTEGER,
                _o54 = _n227 < 0 ? 0 : _n227,
                _l37 = _r131 < 0 ? 0 : _r131;

            for (var _t311 = 0; _t311 < v; ++_t311) {
              var _s180 = _n227 + _t311 * $;

              if (_s180 >= 0 && _s180 < f) for (var _n228 = 0; _n228 < I; ++_n228) {
                var _u23 = _r131 + _n228 * S;

                if (_u23 >= 0 && _u23 < g) {
                  var _r132 = h[_e355][_s180][_u23][_a102] + d[_t311][_n228][_a102];

                  _r132 > _i71 && (_i71 = _r132, _o54 = _s180, _l37 = _u23);
                }
              }
            }

            T[_e355][_o54][_l37][_a102] += C[_e355][_t310][_s179][_a102];
          }
        }
      }
    }

    return {
      dataId: c.write(Ve(T, s.dtype), s.shape, s.dtype),
      shape: s.shape,
      dtype: s.dtype
    };
  }
};

function Gb(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    axis: a,
    keepDims: i
  } = s;
  var o;
  Bf(r, "sum"), o = "bool" === r.dtype ? Zf({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      dtype: "int32"
    }
  }) : Kf({
    inputs: {
      x: r
    },
    backend: n
  });
  var l = o.shape.length,
      u = y(a, o.shape),
      c = Zr(u, l);
  var h = u,
      p = o;
  null != c && (p = Yg({
    inputs: {
      x: o
    },
    backend: n,
    attrs: {
      perm: c
    }
  }), h = ea(h.length, l)), Jr("sum", h, p.shape.length);
  var [f, g] = Xr(p.shape, h);
  var m = jf(n, f, pt(p.dtype, "int32"));
  var b = d(g),
      x = n.data.get(m.dataId).values,
      k = n.data.get(p.dataId).values;

  for (var _e356 = 0; _e356 < x.length; ++_e356) {
    var _t312 = _e356 * b;

    var _n229 = 0;

    for (var _e357 = 0; _e357 < b; ++_e357) {
      _n229 += k[_t312 + _e357];
    }

    x[_e356] = _n229;
  }

  if (i) {
    var _e358 = m;
    m = Vm({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Yr(m.shape, u)
      }
    }), n.disposeIntermediateTensorInfo(_e358);
  }

  return n.disposeIntermediateTensorInfo(o), null != c && n.disposeIntermediateTensorInfo(p), m;
}

var Hb = {
  kernelName: "Sum",
  backendName: "cpu",
  kernelFunc: Gb
},
    qb = {
  kernelName: "Einsum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      equation: r
    } = s,
        a = t,
        {
      allDims: i,
      summedDims: o,
      idDims: l
    } = qo(r, a.length);
    Ko(i.length, l, a);
    var {
      path: u,
      steps: c
    } = Xo(o, l),
        h = c.length;
    var d = null,
        f = i.length;
    var g = [];

    for (var _e359 = 0; _e359 < h; ++_e359) {
      for (var _t313 of c[_e359]) {
        var {
          permutationIndices: _e360,
          expandDims: _s181
        } = jo(f, l[_t313]);

        var _r133 = void 0;

        Yo(_e360) ? _r133 = a[_t313] : (_r133 = Yg({
          inputs: {
            x: a[_t313]
          },
          backend: n,
          attrs: {
            perm: _e360
          }
        }), g.push(_r133));

        var _i72 = _r133.shape.slice();

        for (var _e361 = 0; _e361 < _s181.length; ++_e361) {
          _i72.splice(_s181[_e361], 0, 1);
        }

        p(_r133.shape, _i72) || (_r133 = Vm({
          inputs: {
            x: _r133
          },
          backend: n,
          attrs: {
            shape: _i72
          }
        }), g.push(_r133)), null === d ? d = _r133 : (d = Vg({
          inputs: {
            a: _r133,
            b: d
          },
          backend: n
        }), g.push(d));
      }

      _e359 < h - 1 && (u[_e359] >= 0 && (d = Gb({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          axis: u[_e359] - (i.length - f),
          keepDims: !1
        }
      }), g.push(d)), f--);
    }

    for (var _e362 of g) {
      _e362 !== d && n.disposeIntermediateTensorInfo(_e362);
    }

    return d;
  }
},
    jb = {
  kernelName: "EluGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      dy: s,
      y: r
    } = t;
    Bf([s, r], "eluGrad");
    var a = new Float32Array(d(r.shape)),
        i = n.data.get(r.dataId).values,
        o = n.data.get(s.dataId).values;

    for (var _e363 = 0; _e363 < i.length; ++_e363) {
      var _t314 = i[_e363];
      a[_e363] = _t314 >= 1 ? o[_e363] : o[_e363] * (_t314 + 1);
    }

    return n.makeTensorInfo(r.shape, "float32", a);
  }
},
    Kb = {
  kernelName: "Erf",
  backendName: "cpu",
  kernelFunc: lg("Erf", e => {
    var t = Math.sign(e),
        n = Math.abs(e),
        s = 1 / (1 + .3275911 * n);
    return t * (1 - ((((1.061405429 * s - 1.453152027) * s + 1.421413741) * s - .284496736) * s + .254829592) * s * Math.exp(-n * n));
  })
};

function Xb(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    input: r
  } = t,
      {
    dim: a
  } = s,
      i = r.shape.length,
      o = r.shape.slice();
  var u = a;
  return a < 0 && (l(-(i + 1) <= a, () => "Axis must be in the interval [".concat(-(i + 1), ", ").concat(i, "]")), u = i + a + 1), o.splice(u, 0, 1), Vm({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      shape: o
    }
  });
}

var Yb = {
  kernelName: "ExpandDims",
  backendName: "cpu",
  kernelFunc: Xb
},
    Jb = eg("RealDiv", Gf((e, t) => e / t)),
    Zb = {
  kernelName: "RealDiv",
  backendName: "cpu",
  kernelFunc: Jb
};

function Qb(e, t, n) {
  var s = e.shape,
      r = s[0],
      a = s[1],
      i = n.data.get(e.dataId),
      o = i.complexTensorInfos.real,
      l = i.complexTensorInfos.imag,
      u = [r, a],
      c = d(u),
      h = w("float32", c),
      p = w("float32", c);

  for (var _e364 = 0; _e364 < r; _e364++) {
    var _s182 = om({
      inputs: {
        x: o
      },
      backend: n,
      attrs: {
        begin: [_e364, 0],
        size: [1, a]
      }
    }),
        _r134 = om({
      inputs: {
        x: l
      },
      backend: n,
      attrs: {
        begin: [_e364, 0],
        size: [1, a]
      }
    }),
        _i73 = Hf({
      inputs: {
        real: _s182,
        imag: _r134
      },
      backend: n
    }),
        {
      real: _u24,
      imag: _c24
    } = ex(_i73, t, n),
        _d15 = Lo(_u24, _c24);

    for (var _t315 = 0; _t315 < a; _t315++) {
      var _n230 = Wo(_d15, _t315);

      h[_e364 * a + _t315] = _n230.real, p[_e364 * a + _t315] = _n230.imag;
    }

    n.disposeIntermediateTensorInfo(_s182), n.disposeIntermediateTensorInfo(_r134), n.disposeIntermediateTensorInfo(_i73);
  }

  var f = n.makeTensorInfo(u, "float32", h),
      g = n.makeTensorInfo(u, "float32", p),
      m = Hf({
    inputs: {
      real: f,
      imag: g
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
}

function ex(e, t, n) {
  var s = d(e.shape),
      r = n.data.get(e.dataId),
      a = n.data.get(r.complexTensorInfos.real.dataId).values,
      i = n.data.get(r.complexTensorInfos.imag.dataId).values;

  if (0 == ((o = s) & o - 1)) {
    var _r135 = tx(a, i, s, t, n),
        _o55 = [e.shape[0], e.shape[1]];

    if (t) {
      var _e365 = n.makeTensorInfo(_o55, "float32", _r135.real),
          _t316 = n.makeTensorInfo(_o55, "float32", _r135.imag),
          _a103 = n.makeTensorInfo([], "float32", Ue(s, "float32")),
          _i74 = Kf({
        inputs: {
          x: _a103
        },
        backend: n
      }),
          _l38 = Zb.kernelFunc({
        inputs: {
          a: _e365,
          b: _a103
        },
        backend: n
      }),
          _u25 = Zb.kernelFunc({
        inputs: {
          a: _t316,
          b: _i74
        },
        backend: n
      }),
          _c25 = n.data.get(_l38.dataId).values,
          _h13 = n.data.get(_u25.dataId).values;

      return n.disposeIntermediateTensorInfo(_e365), n.disposeIntermediateTensorInfo(_t316), n.disposeIntermediateTensorInfo(_a103), n.disposeIntermediateTensorInfo(_i74), n.disposeIntermediateTensorInfo(_l38), n.disposeIntermediateTensorInfo(_u25), {
        real: _c25,
        imag: _h13
      };
    }

    return _r135;
  }

  return zo(function (e, t, n) {
    var s = new Float32Array(2 * t);

    for (var _r136 = 0; _r136 < t; _r136++) {
      var _a104 = 0,
          _i75 = 0;

      for (var _s183 = 0; _s183 < t; _s183++) {
        var _o56 = Go(_r136 * _s183, t, n),
            _l39 = Wo(e, _s183);

        _a104 += _l39.real * _o56.real - _l39.imag * _o56.imag, _i75 += _l39.real * _o56.imag + _l39.imag * _o56.real;
      }

      n && (_a104 /= t, _i75 /= t), Uo(s, _a104, _i75, _r136);
    }

    return s;
  }(Lo(a, i), s, t));
  var o;
}

function tx(e, t, n, s, r) {
  if (1 === n) return {
    real: e,
    imag: t
  };

  var a = Lo(e, t),
      i = n / 2,
      o = Bo(a),
      l = o.real,
      u = o.imag,
      c = [l.length],
      h = r.makeTensorInfo(c, "float32", l),
      d = r.makeTensorInfo(c, "float32", u),
      p = Hf({
    inputs: {
      real: h,
      imag: d
    },
    backend: r
  }),
      f = Po(a),
      g = f.real,
      m = f.imag,
      b = [g.length],
      x = r.makeTensorInfo(b, "float32", g),
      y = r.makeTensorInfo(b, "float32", m),
      k = Hf({
    inputs: {
      real: x,
      imag: y
    },
    backend: r
  }),
      w = tx(l, u, i, s, r),
      v = w.real,
      I = w.imag,
      $ = [v.length],
      S = r.makeTensorInfo($, "float32", v),
      N = r.makeTensorInfo($, "float32", I),
      C = Hf({
    inputs: {
      real: S,
      imag: N
    },
    backend: r
  }),
      T = tx(g, m, i, s, r),
      E = T.real,
      R = T.imag,
      A = [E.length],
      F = r.makeTensorInfo(A, "float32", E),
      D = r.makeTensorInfo(A, "float32", R),
      _ = Hf({
    inputs: {
      real: F,
      imag: D
    },
    backend: r
  }),
      O = Vo(n, s),
      M = [O.real.length],
      L = r.makeTensorInfo(M, "float32", O.real),
      z = r.makeTensorInfo(M, "float32", O.imag),
      B = Hf({
    inputs: {
      real: L,
      imag: z
    },
    backend: r
  }),
      P = Vg({
    inputs: {
      a: B,
      b: _
    },
    backend: r
  }),
      W = sg({
    inputs: {
      a: C,
      b: P
    },
    backend: r
  }),
      U = Im({
    inputs: {
      a: C,
      b: P
    },
    backend: r
  }),
      V = Yf({
    inputs: {
      input: W
    },
    backend: r
  }),
      G = Yf({
    inputs: {
      input: U
    },
    backend: r
  }),
      H = yb({
    inputs: {
      input: W
    },
    backend: r
  }),
      q = yb({
    inputs: {
      input: U
    },
    backend: r
  }),
      j = wb({
    inputs: [V, G],
    backend: r,
    attrs: {
      axis: 0
    }
  }),
      K = wb({
    inputs: [H, q],
    backend: r,
    attrs: {
      axis: 0
    }
  }),
      X = r.data.get(j.dataId).values,
      Y = r.data.get(K.dataId).values;

  return r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(d), r.disposeIntermediateTensorInfo(p), r.disposeIntermediateTensorInfo(x), r.disposeIntermediateTensorInfo(y), r.disposeIntermediateTensorInfo(k), r.disposeIntermediateTensorInfo(S), r.disposeIntermediateTensorInfo(N), r.disposeIntermediateTensorInfo(C), r.disposeIntermediateTensorInfo(F), r.disposeIntermediateTensorInfo(D), r.disposeIntermediateTensorInfo(_), r.disposeIntermediateTensorInfo(L), r.disposeIntermediateTensorInfo(z), r.disposeIntermediateTensorInfo(B), r.disposeIntermediateTensorInfo(P), r.disposeIntermediateTensorInfo(W), r.disposeIntermediateTensorInfo(U), r.disposeIntermediateTensorInfo(V), r.disposeIntermediateTensorInfo(H), r.disposeIntermediateTensorInfo(G), r.disposeIntermediateTensorInfo(q), r.disposeIntermediateTensorInfo(j), r.disposeIntermediateTensorInfo(K), {
    real: X,
    imag: Y
  };
}

var nx = {
  kernelName: "FFT",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      input: s
    } = t,
        r = d(s.shape),
        a = s.shape[s.shape.length - 1],
        i = Vm({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [r / a, a]
      }
    }),
        o = Qb(i, !1, n),
        l = Vm({
      inputs: {
        x: o
      },
      backend: n,
      attrs: {
        shape: s.shape
      }
    });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), l;
  }
};

function sx(e) {
  var {
    backend: t,
    attrs: n
  } = e,
      {
    shape: s,
    value: r,
    dtype: a
  } = n,
      i = a || T(r),
      o = v(i, d(s));
  return function (e, t, n) {
    e.fill(t);
  }(o, r), t.makeTensorInfo(s, i, o);
}

var rx = {
  kernelName: "Fill",
  backendName: "cpu",
  kernelFunc: sx
},
    ax = {
  kernelName: "FlipLeftRight",
  backendName: "cpu",
  kernelFunc: _ref16 => {
    var {
      inputs: e,
      backend: t
    } = _ref16;
    var {
      image: n
    } = e,
        s = t,
        r = w(n.dtype, d(n.shape)),
        [a, i, o, l] = n.shape,
        u = s.data.get(n.dataId).values;

    for (var _e366 = 0; _e366 < a; _e366++) {
      var _t317 = _e366 * o * i * l;

      for (var _e367 = 0; _e367 < i; _e367++) {
        var _n231 = _e367 * (o * l);

        for (var _e368 = 0; _e368 < o; _e368++) {
          var _s184 = _e368 * l;

          for (var _a105 = 0; _a105 < l; _a105++) {
            var _i76 = Math.round(o - _e368 - 1),
                _c26 = _t317 + _n231 + _s184 + _a105;

            var _h14 = u[_c26];
            _i76 >= 0 && _i76 < o && (_h14 = u[_t317 + _n231 + _i76 * l + _a105]), r[_c26] = _h14;
          }
        }
      }
    }

    return {
      dataId: s.write(r, n.shape, n.dtype),
      shape: n.shape,
      dtype: n.dtype
    };
  }
},
    ix = {
  kernelName: "FloorDiv",
  backendName: "cpu",
  kernelFunc: eg("FloorDiv", Gf((e, t) => Math.floor(e / t)), null, "int32")
},
    ox = {
  kernelName: "FusedConv2D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      strides: l,
      pad: u,
      dataFormat: c,
      dilations: h,
      dimRoundingMode: d,
      activation: p,
      leakyreluAlpha: f
    } = s;
    var g = Ib({
      inputs: {
        x: r,
        filter: a
      },
      backend: n,
      attrs: {
        strides: l,
        pad: u,
        dataFormat: c,
        dilations: h,
        dimRoundingMode: d
      }
    });

    if (i) {
      var _e369 = g;
      g = sg({
        inputs: {
          a: g,
          b: i
        },
        backend: n
      }), n.disposeIntermediateTensorInfo(_e369);
    }

    if (p) {
      var _e370 = g;
      g = Um(n, g, p, o, f), n.disposeIntermediateTensorInfo(_e370);
    }

    return g;
  }
},
    lx = {
  kernelName: "FusedDepthwiseConv2D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      strides: l,
      pad: u,
      dataFormat: c,
      dilations: h,
      dimRoundingMode: d,
      activation: p,
      leakyreluAlpha: f
    } = s;
    var g = Mb({
      inputs: {
        x: r,
        filter: a
      },
      backend: n,
      attrs: {
        strides: l,
        pad: u,
        dataFormat: c,
        dilations: h,
        dimRoundingMode: d
      }
    });

    if (i) {
      var _e371 = g;
      g = sg({
        inputs: {
          a: g,
          b: i
        },
        backend: n
      }), n.disposeIntermediateTensorInfo(_e371);
    }

    if (p) {
      var _e372 = g;
      g = Um(n, g, p, o, f), n.disposeIntermediateTensorInfo(_e372);
    }

    return g;
  }
},
    ux = {
  kernelName: "GatherNd",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      params: s,
      indices: r
    } = t,
        a = d(s.shape),
        i = r.shape,
        o = i[i.length - 1],
        [l, u, c, h] = Nn(s, r);
    if (0 === u) return n.makeTensorInfo(l, s.dtype, []);
    var p = Ig(n.data.get(r.dataId).values, n.bufferSync(s), s.dtype, u, o, c, h, s.shape, a);
    return n.makeTensorInfo(l, s.dtype, p.values);
  }
},
    cx = {
  kernelName: "GatherV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      indices: a
    } = t,
        {
      axis: i,
      batchDims: o
    } = s;
    Bf([r, a], "gatherV2");
    var l = o;
    null == o && (l = 0);
    var u = d(a.shape),
        c = tl(r, a, y(i, r.shape)[0], l),
        h = Vm({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [c.batchSize, c.outerSize, c.dimSize, c.sliceSize]
      }
    }),
        p = Vm({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: [c.batchSize, u / c.batchSize]
      }
    }),
        f = [c.batchSize, c.outerSize, u / c.batchSize, c.sliceSize],
        g = n.bufferSync(p),
        m = $g(n.bufferSync(h), g, f);
    return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p), n.makeTensorInfo(c.outputShape, m.dtype, m.values);
  }
},
    hx = {
  kernelName: "IFFT",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      input: s
    } = t,
        r = d(s.shape),
        a = s.shape[s.shape.length - 1],
        i = Vm({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [r / a, a]
      }
    }),
        o = Qb(i, !0, n),
        l = Vm({
      inputs: {
        x: o
      },
      backend: n,
      attrs: {
        shape: s.shape
      }
    });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), l;
  }
},
    dx = {
  kernelName: "IsFinite",
  backendName: "cpu",
  kernelFunc: lg("IsFinite", e => Number.isFinite(e) ? 1 : 0, "bool")
},
    px = {
  kernelName: "IsInf",
  backendName: "cpu",
  kernelFunc: lg("IsInf", e => Infinity === Math.abs(e) ? 1 : 0, "bool")
},
    fx = {
  kernelName: "IsNan",
  backendName: "cpu",
  kernelFunc: lg("IsNan", e => Number.isNaN(e) ? 1 : 0, "bool")
},
    gx = {
  kernelName: "LinSpace",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      backend: t,
      attrs: n
    } = e,
        {
      start: s,
      stop: r,
      num: a
    } = n,
        i = Dg(s, r, a);
    return t.makeTensorInfo([i.length], "float32", i);
  }
},
    mx = {
  kernelName: "Log1p",
  backendName: "cpu",
  kernelFunc: lg("Log1p", e => Math.log1p(e))
},
    bx = {
  kernelName: "LogicalAnd",
  backendName: "cpu",
  kernelFunc: eg("LogicalAnd", Gf((e, t) => e && t), null, "bool")
},
    xx = {
  kernelName: "LogicalNot",
  backendName: "cpu",
  kernelFunc: lg("LogicalNot", e => e ? 0 : 1, "bool")
},
    yx = {
  kernelName: "LogicalOr",
  backendName: "cpu",
  kernelFunc: eg("LogicalOr", Gf((e, t) => e || t), null, "bool")
},
    kx = {
  kernelName: "LRN",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      depthRadius: a,
      bias: i,
      alpha: o,
      beta: l
    } = s;
    Bf(r, "LRN");
    var u = r.shape[3],
        c = u - 1,
        h = n.data.get(r.dataId).values,
        p = d(r.shape),
        f = new Float32Array(p);

    function g(e) {
      var t = e % u;
      var n = e - t + Math.max(0, t - a);
      var s = e - t + Math.min(t + a, c);
      var r = 0;

      for (; n <= s; n++) {
        var _e373 = h[n];
        r += _e373 * _e373;
      }

      return r;
    }

    for (var _e374 = 0; _e374 < p; _e374++) {
      var _t318 = g(_e374),
          _n232 = h[_e374] * Math.pow(i + o * _t318, -l);

      f[_e374] = _n232;
    }

    return n.makeTensorInfo(r.shape, r.dtype, f);
  }
},
    wx = {
  kernelName: "LRNGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      y: a,
      dy: i
    } = t,
        {
      depthRadius: o,
      bias: l,
      alpha: u,
      beta: c
    } = s;
    Bf(i, "LRNGrad");
    var h = d(i.shape),
        p = i.shape[3],
        f = n.data.get(i.dataId).values,
        g = n.data.get(r.dataId).values,
        m = n.data.get(a.dataId).values,
        b = new Float32Array(h),
        x = h;

    for (var _e375 = 0; _e375 < x; _e375++) {
      var _t319 = _e375 % p,
          _n233 = _e375 - _t319 + Math.max(0, _t319 - o),
          _s185 = _e375 - _t319 + Math.min(p, _t319 + o + 1);

      var _r137 = 0;

      for (var _e376 = _n233; _e376 < _s185; _e376++) {
        _r137 += Math.pow(g[_e376], 2);
      }

      _r137 = u * _r137 + l;

      for (var _t320 = _n233; _t320 < _s185; _t320++) {
        var _n234 = -2 * u * c * g[_t320] * m[_e375] / _r137;

        _e375 === _t320 && (_n234 += Math.pow(_r137, -c)), _n234 *= f[_e375], b[_t320] += _n234;
      }
    }

    return n.makeTensorInfo(i.shape, r.dtype, b);
  }
};

function vx(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    reductionIndices: a,
    keepDims: i
  } = s,
      o = n;
  var l = r.shape;
  var u = l.length,
      c = y(a, l);
  var h = c;
  var p = Zr(h, u);
  var f = o.data.get(r.dataId).values;

  if (null != p) {
    var _e377 = new Array(u);

    for (var _t321 = 0; _t321 < _e377.length; _t321++) {
      _e377[_t321] = l[p[_t321]];
    }

    f = Xg(f, l, r.dtype, p, _e377), h = ea(h.length, u), l = _e377;
  }

  Bf(r, "max"), Jr("max", h, u);
  var [g, m] = Xr(l, h),
      b = Mg(f, d(m), g, r.dtype),
      x = o.write(b, g, r.dtype);
  var k = g;
  return i && (k = Yr(g, c)), {
    dataId: x,
    shape: k,
    dtype: r.dtype
  };
}

var Ix = {
  kernelName: "Max",
  backendName: "cpu",
  kernelFunc: vx
},
    $x = {
  kernelName: "MaxPool",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t;
    Bf(r, "maxPool");
    var {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: u
    } = s;
    l(Ts(i, 1), () => "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'"));
    var c = xs(r.shape, a, i, 1, o, u);
    var h;
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) h = Kf({
      inputs: {
        x: r
      },
      backend: n
    });else {
      var _e378 = n.data.get(r.dataId).values,
          _t322 = A(r.shape),
          _s186 = ib(_e378, 0, r.dtype, _t322, c, "max");

      h = n.makeTensorInfo(c.outShape, r.dtype, _s186.values);
    }
    return h;
  }
},
    Sx = {
  kernelName: "MaxPool3D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: l,
      dataFormat: u
    } = s;
    Bf(r, "maxPool3d");
    var c = ys(r.shape, a, i, 1, o, l, u),
        h = lb(n.data.get(r.dataId).values, 0, r.dtype, A(r.shape), c, "max");
    return n.makeTensorInfo(h.shape, "float32", h.values);
  }
},
    Nx = {
  kernelName: "MaxPool3DGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        {
      filterSize: i,
      strides: o,
      pad: l,
      dimRoundingMode: u
    } = s;
    Bf([r, a], "maxPool3DGrad");

    var c = ys(a.shape, i, o, 1, l, u),
        h = function (e, t) {
      var n = pn(t.outShape, "int32"),
          s = t.strideDepth,
          r = t.strideHeight,
          a = t.strideWidth,
          i = t.dilationDepth,
          o = t.dilationHeight,
          l = t.dilationWidth,
          u = t.effectiveFilterDepth,
          c = t.effectiveFilterHeight,
          h = t.effectiveFilterWidth,
          d = t.padInfo.front,
          p = t.padInfo.top,
          f = t.padInfo.left;

      for (var _g16 = 0; _g16 < t.batchSize; ++_g16) {
        for (var _m11 = 0; _m11 < t.inChannels; ++_m11) {
          for (var _b11 = 0; _b11 < t.outDepth; ++_b11) {
            var _x54 = _b11 * s - d;

            var _y9 = _x54;

            for (; _y9 < 0;) {
              _y9 += i;
            }

            var _k7 = Math.min(t.inDepth, u + _x54);

            for (var _s187 = 0; _s187 < t.outHeight; ++_s187) {
              var _u26 = _s187 * r - p;

              var _d16 = _u26;

              for (; _d16 < 0;) {
                _d16 += o;
              }

              var _w7 = Math.min(t.inHeight, c + _u26);

              for (var _r138 = 0; _r138 < t.outWidth; ++_r138) {
                var _p12 = _r138 * a - f;

                var _v5 = _p12;

                for (; _v5 < 0;) {
                  _v5 += l;
                }

                var _I4 = Math.min(t.inWidth, h + _p12);

                var _$2 = Number.NEGATIVE_INFINITY,
                    _S4 = -1;

                for (var _t323 = _y9; _t323 < _k7; _t323 += i) {
                  var _n235 = _t323 - _x54;

                  for (var _s188 = _d16; _s188 < _w7; _s188 += o) {
                    var _r139 = _s188 - _u26;

                    for (var _a106 = _v5; _a106 < _I4; _a106 += l) {
                      var _i77 = _a106 - _p12,
                          _o57 = e.get(_g16, _t323, _s188, _a106, _m11);

                      _o57 >= _$2 && (_$2 = _o57, _S4 = _n235 * c * h + _r139 * c + _i77);
                    }
                  }
                }

                n.set(_S4, _g16, _b11, _s187, _r138, _m11);
              }
            }
          }
        }
      }

      return n;
    }(n.bufferSync(a), c),
        d = c.strideDepth,
        p = c.strideHeight,
        f = c.strideWidth,
        g = c.dilationDepth,
        m = c.dilationHeight,
        b = c.dilationWidth,
        x = c.effectiveFilterDepth,
        y = c.effectiveFilterHeight,
        k = c.effectiveFilterWidth,
        w = x - 1 - c.padInfo.front,
        v = k - 1 - c.padInfo.left,
        I = y - 1 - c.padInfo.top,
        $ = pn(a.shape, "float32"),
        S = n.bufferSync(r);

    for (var _e379 = 0; _e379 < c.batchSize; ++_e379) {
      for (var _t324 = 0; _t324 < c.inChannels; ++_t324) {
        for (var _n236 = 0; _n236 < c.inDepth; ++_n236) {
          for (var _s189 = 0; _s189 < c.inHeight; ++_s189) {
            for (var _r140 = 0; _r140 < c.inWidth; ++_r140) {
              var _a107 = _n236 - w,
                  _i78 = _s189 - I,
                  _o58 = _r140 - v;

              var _l40 = 0;

              for (var _n237 = 0; _n237 < x; _n237 += g) {
                var _s190 = (_a107 + _n237) / d;

                if (!(_s190 < 0 || _s190 >= c.outDepth || Math.floor(_s190) !== _s190)) for (var _r141 = 0; _r141 < y; _r141 += m) {
                  var _a108 = (_i78 + _r141) / p;

                  if (!(_a108 < 0 || _a108 >= c.outHeight || Math.floor(_a108) !== _a108)) for (var _i79 = 0; _i79 < k; _i79 += b) {
                    var _u27 = (_o58 + _i79) / f;

                    if (_u27 < 0 || _u27 >= c.outWidth || Math.floor(_u27) !== _u27) continue;

                    var _d17 = x * y * k - 1 - h.get(_e379, _s190, _a108, _u27, _t324) === _n237 * y * k + _r141 * k + _i79 ? 1 : 0;

                    0 !== _d17 && (_l40 += S.get(_e379, _s190, _a108, _u27, _t324) * _d17);
                  }
                }
              }

              $.set(_l40, _e379, _n236, _s189, _r140, _t324);
            }
          }
        }
      }
    }

    return n.makeTensorInfo($.shape, $.dtype, $.values);
  }
},
    Cx = {
  kernelName: "MaxPoolGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a,
      output: i
    } = t,
        o = a;
    Bf([a, i], "maxPoolGrad");
    var {
      filterSize: l,
      strides: u,
      pad: c,
      dimRoundingMode: h
    } = s,
        d = xs(o.shape, l, u, 1, c, h),
        p = n.data.get(o.dataId).values,
        f = pn(d.outShape, o.dtype, ob(p, o.shape, o.dtype, d).values),
        g = d.strideHeight,
        m = d.strideWidth,
        b = d.dilationHeight,
        x = d.dilationWidth,
        y = d.effectiveFilterHeight,
        k = d.effectiveFilterWidth,
        w = k - 1 - d.padInfo.left,
        v = y - 1 - d.padInfo.top,
        I = pn(o.shape, "float32"),
        $ = n.data.get(r.dataId).values,
        S = pn(r.shape, "float32", $);

    for (var _e380 = 0; _e380 < d.batchSize; ++_e380) {
      for (var _t325 = 0; _t325 < d.inChannels; ++_t325) {
        for (var _n238 = 0; _n238 < d.inHeight; ++_n238) {
          for (var _s191 = 0; _s191 < d.inWidth; ++_s191) {
            var _r142 = _n238 - v,
                _a109 = _s191 - w;

            var _i80 = 0;

            for (var _n239 = 0; _n239 < y; _n239 += b) {
              var _s192 = (_r142 + _n239) / g;

              if (!(_s192 < 0 || _s192 >= d.outHeight || Math.floor(_s192) !== _s192)) for (var _r143 = 0; _r143 < k; _r143 += x) {
                var _o59 = (_a109 + _r143) / m;

                if (_o59 < 0 || _o59 >= d.outWidth || Math.floor(_o59) !== _o59) continue;

                var _l41 = y * k - 1 - f.get(_e380, _s192, _o59, _t325) === _n239 * k + _r143 ? 1 : 0;

                0 !== _l41 && (_i80 += S.get(_e380, _s192, _o59, _t325) * _l41);
              }
            }

            I.set(_i80, _e380, _n238, _s191, _t325);
          }
        }
      }
    }

    return n.makeTensorInfo(I.shape, I.dtype, I.values);
  }
},
    Tx = {
  kernelName: "MaxPoolWithArgmax",
  backendName: "cpu",
  kernelFunc: _ref17 => {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref17;
    var {
      x: s
    } = e,
        {
      filterSize: r,
      strides: a,
      pad: i,
      includeBatchInIndex: o
    } = t,
        l = n;
    Bf(s, "MaxPoolWithArgmax");

    var u = l.data.get(s.dataId).values,
        c = xs(s.shape, r, a, [1, 1], i),
        [h, d] = function (e, t, n, s, r) {
      var a = ib(e, 0, n, A(t), r, "max"),
          i = ob(e, t, n, r, !0, s);
      return [a.values, i.values];
    }(u, s.shape, s.dtype, o, c),
        p = l.write(h, c.outShape, s.dtype),
        f = l.write(d, c.outShape, s.dtype);

    return [{
      dataId: p,
      shape: c.outShape,
      dtype: s.dtype
    }, {
      dataId: f,
      shape: c.outShape,
      dtype: "int32"
    }];
  }
},
    Ex = {
  kernelName: "Mean",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s,
        o = y(a, r.shape),
        l = d(Xr(r.shape, o)[1]),
        u = [],
        c = n.makeTensorInfo([], "float32", new Float32Array([l]));
    u.push(c);
    var h = Zf({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        dtype: "float32"
      }
    });
    u.push(h);
    var p = Jb({
      inputs: {
        a: h,
        b: c
      },
      backend: n
    });
    u.push(p);
    var f = Gb({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        axis: a,
        keepDims: i
      }
    });
    return u.forEach(e => n.disposeIntermediateTensorInfo(e)), f;
  }
},
    Rx = {
  kernelName: "Min",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s;
    Bf(r, "min");
    var o = y(a, r.shape);
    var l = o;
    var u = Zr(l, r.shape.length);
    var c = r;
    null != u && (c = Yg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), l = ea(l.length, r.shape.length)), Jr("min", l, c.shape.length);
    var [h, p] = Xr(c.shape, l),
        f = d(p),
        g = O(d(h), c.dtype),
        m = n.data.get(c.dataId).values;

    for (var _e381 = 0; _e381 < g.length; ++_e381) {
      var _t326 = _e381 * f;

      var _n240 = m[_t326];

      for (var _e382 = 0; _e382 < f; ++_e382) {
        var _s193 = m[_t326 + _e382];
        (Number.isNaN(_s193) || _s193 < _n240) && (_n240 = _s193);
      }

      g[_e381] = _n240;
    }

    null != u && n.disposeIntermediateTensorInfo(c);
    var b = n.makeTensorInfo(h, c.dtype, g);

    if (i) {
      var _e383 = Vm({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: Yr(h, o)
        }
      });

      return n.disposeIntermediateTensorInfo(b), _e383;
    }

    return b;
  }
},
    Ax = {
  kernelName: "MirrorPad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      paddings: a,
      mode: i
    } = s;
    Bf(r, "mirrorPad");
    var o = a.map((e, t) => e[0] + r.shape[t] + e[1]),
        l = a.map(e => e[0]),
        u = a.map((e, t) => e[0] + r.shape[t]),
        c = "reflect" === i ? 0 : 1,
        h = n.data.get(r.dataId).values,
        p = r.shape.length,
        f = A(r.shape),
        g = d(o),
        m = o.length,
        b = A(o),
        x = w(r.dtype, g);

    for (var _e384 = 0; _e384 < g; _e384++) {
      var _t327 = B(_e384, m, b);

      for (var _e385 = 0; _e385 < m; _e385++) {
        _t327[_e385] < l[_e385] ? _t327[_e385] = 2 * l[_e385] - _t327[_e385] - c : _t327[_e385] >= u[_e385] && (_t327[_e385] = 2 * (u[_e385] - 1) - _t327[_e385] + c);
      }

      _t327 = _t327.map((e, t) => e - l[t]);

      var _n241 = z(_t327, p, f);

      x[_e384] = h[_n241];
    }

    return {
      dataId: n.write(x, o, r.dtype),
      shape: o,
      dtype: r.dtype
    };
  }
},
    Fx = {
  kernelName: "Mod",
  backendName: "cpu",
  kernelFunc: eg("Mod", Gf((e, t) => {
    var n = e % t;
    return e < 0 && t < 0 || e >= 0 && t >= 0 ? n : (n + t) % t;
  }))
};

function Dx(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    logits: r
  } = t,
      {
    dim: a
  } = s,
      i = r.shape.length;
  var o = a;
  if (-1 === o && (o = i - 1), o !== i - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(i, " and dim was ").concat(o));
  var l = y([o], r.shape),
      u = vx({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      reductionIndices: l,
      keepDims: !1
    }
  }),
      c = Yr(u.shape, l),
      h = Vm({
    inputs: {
      x: u
    },
    backend: n,
    attrs: {
      shape: c
    }
  }),
      d = Im({
    inputs: {
      a: r,
      b: h
    },
    backend: n
  }),
      p = bg({
    inputs: {
      x: d
    },
    backend: n
  }),
      f = Gb({
    inputs: {
      x: p
    },
    backend: n,
    attrs: {
      axis: l,
      keepDims: !1
    }
  }),
      g = Vm({
    inputs: {
      x: f
    },
    backend: n,
    attrs: {
      shape: c
    }
  }),
      m = Jb({
    inputs: {
      a: p,
      b: g
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
}

var _x = {
  kernelName: "Softmax",
  backendName: "cpu",
  kernelFunc: Dx
},
    Ox = {
  kernelName: "Multinomial",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      logits: r
    } = t,
        {
      numSamples: a,
      seed: i,
      normalized: o
    } = s;
    Bf(r, "multinomial");
    var l = o ? r : Dx({
      inputs: {
        logits: r
      },
      backend: n,
      attrs: {
        dim: -1
      }
    }),
        u = l.shape[0],
        c = l.shape[1],
        h = n.data.get(l.dataId).values,
        p = [u, a],
        f = O(d(p), "int32");

    for (var _e386 = 0; _e386 < u; ++_e386) {
      var _t328 = _e386 * c,
          _n242 = new Float32Array(c - 1);

      _n242[0] = h[_t328];

      for (var _e387 = 1; _e387 < _n242.length; ++_e387) {
        _n242[_e387] = _n242[_e387 - 1] + h[_t328 + _e387];
      }

      var _s194 = Oa.alea(i.toString()),
          _r144 = _e386 * a;

      for (var _e388 = 0; _e388 < a; ++_e388) {
        var _t329 = _s194();

        f[_r144 + _e388] = _n242.length;

        for (var _s195 = 0; _s195 < _n242.length; _s195++) {
          if (_t329 < _n242[_s195]) {
            f[_r144 + _e388] = _s195;
            break;
          }
        }
      }
    }

    return o || n.disposeIntermediateTensorInfo(l), n.makeTensorInfo(p, "int32", f);
  }
},
    Mx = Ki,
    Lx = {
  kernelName: "NonMaxSuppressionV3",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l
    } = s;
    Bf(r, "NonMaxSuppression");
    var u = n.data.get(r.dataId).values,
        c = n.data.get(a.dataId).values,
        {
      selectedIndices: h
    } = Mx(u, c, i, o, l);
    return n.makeTensorInfo([h.length], "int32", new Int32Array(h));
  }
},
    zx = Xi,
    Bx = {
  kernelName: "NonMaxSuppressionV4",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l,
      padToMaxOutputSize: u
    } = s;
    Bf(r, "NonMaxSuppressionPadded");
    var c = n.data.get(r.dataId).values,
        h = n.data.get(a.dataId).values,
        {
      selectedIndices: d,
      validOutputs: p
    } = zx(c, h, i, o, l, u);
    return [n.makeTensorInfo([d.length], "int32", new Int32Array(d)), n.makeTensorInfo([], "int32", new Int32Array([p]))];
  }
},
    Px = Yi,
    Wx = {
  kernelName: "NonMaxSuppressionV5",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l,
      softNmsSigma: u
    } = s;
    Bf(r, "NonMaxSuppressionWithScore");
    var c = n.data.get(r.dataId).values,
        h = n.data.get(a.dataId).values,
        d = i,
        p = o,
        f = l,
        g = u,
        {
      selectedIndices: m,
      selectedScores: b
    } = Px(c, h, d, p, f, g);
    return [n.makeTensorInfo([m.length], "int32", new Int32Array(m)), n.makeTensorInfo([b.length], "float32", new Float32Array(b))];
  }
},
    Ux = {
  kernelName: "OneHot",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      indices: r
    } = t,
        {
      depth: a,
      onValue: i,
      offValue: o
    } = s;
    Bf(r, "oneHot");
    var l = d(r.shape),
        u = new Float32Array(l * a);
    u.fill(o);
    var c = n.data.get(r.dataId).values;

    for (var _e389 = 0; _e389 < l; ++_e389) {
      c[_e389] >= 0 && c[_e389] < a && (u[_e389 * a + c[_e389]] = i);
    }

    return n.makeTensorInfo([...r.shape, a], "int32", u);
  }
};

function Vx(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    x: s
  } = t;
  if ("string" === s.dtype) throw new Error("zerosLike is not supported for string tensors");

  if ("complex64" === s.dtype) {
    var _e390 = Yf({
      inputs: {
        input: s
      },
      backend: n
    }),
        _t330 = Vx({
      inputs: {
        x: _e390
      },
      backend: n
    }),
        _r145 = yb({
      inputs: {
        input: s
      },
      backend: n
    }),
        _a110 = Vx({
      inputs: {
        x: _r145
      },
      backend: n
    }),
        _i81 = Hf({
      inputs: {
        real: _t330,
        imag: _a110
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_e390), n.disposeIntermediateTensorInfo(_t330), n.disposeIntermediateTensorInfo(_r145), n.disposeIntermediateTensorInfo(_a110), _i81;
  }

  return sx({
    backend: n,
    attrs: {
      shape: s.shape,
      value: 0,
      dtype: s.dtype
    }
  });
}

var Gx = {
  kernelName: "ZerosLike",
  backendName: "cpu",
  kernelFunc: Vx
},
    Hx = {
  kernelName: "OnesLike",
  backendName: "cpu",
  kernelFunc: function e(t) {
    var {
      inputs: n,
      backend: s
    } = t,
        {
      x: r
    } = n;
    if ("string" === r.dtype) throw new Error("onesLike is not supported for string tensors");

    if ("complex64" === r.dtype) {
      var _t331 = Yf({
        inputs: {
          input: r
        },
        backend: s
      }),
          _n243 = e({
        inputs: {
          x: _t331
        },
        backend: s
      }),
          _a111 = yb({
        inputs: {
          input: r
        },
        backend: s
      }),
          _i82 = Vx({
        inputs: {
          x: _a111
        },
        backend: s
      }),
          _o60 = Hf({
        inputs: {
          real: _n243,
          imag: _i82
        },
        backend: s
      });

      return s.disposeIntermediateTensorInfo(_t331), s.disposeIntermediateTensorInfo(_n243), s.disposeIntermediateTensorInfo(_a111), s.disposeIntermediateTensorInfo(_i82), _o60;
    }

    return sx({
      backend: s,
      attrs: {
        shape: r.shape,
        value: 1,
        dtype: r.dtype
      }
    });
  }
};

function qx(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    axis: r
  } = s;
  if (1 === t.length) return Xb({
    inputs: {
      input: t[0]
    },
    backend: n,
    attrs: {
      dim: r
    }
  });
  var a = t[0].shape,
      i = t[0].dtype;
  t.forEach(e => {
    u(a, e.shape, "All tensors passed to stack must have matching shapes"), l(i === e.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  var o = [],
      c = wb({
    inputs: t.map(e => {
      var t = Xb({
        inputs: {
          input: e
        },
        backend: n,
        attrs: {
          dim: r
        }
      });
      return o.push(t), t;
    }),
    backend: n,
    attrs: {
      axis: r
    }
  });
  return o.forEach(e => n.disposeIntermediateTensorInfo(e)), c;
}

var jx = {
  kernelName: "Pack",
  backendName: "cpu",
  kernelFunc: qx
},
    Kx = {
  kernelName: "PadV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      paddings: a,
      constantValue: i
    } = s;
    Bf(r, "pad");
    var o = a.map((e, t) => e[0] + r.shape[t] + e[1]),
        l = a.map(e => e[0]),
        u = n.data.get(r.dataId).values,
        c = d(r.shape),
        h = r.shape.length,
        p = A(r.shape),
        f = d(o),
        g = o.length,
        m = A(o),
        b = w(r.dtype, f);
    0 !== i && b.fill(i);

    for (var _e391 = 0; _e391 < c; _e391++) {
      b[z(B(_e391, h, p).map((e, t) => e + l[t]), g, m)] = u[_e391];
    }

    return {
      dataId: n.write(b, o, r.dtype),
      shape: o,
      dtype: r.dtype
    };
  }
},
    Xx = {
  kernelName: "Pow",
  backendName: "cpu",
  kernelFunc: eg("Pow", Gf((e, t) => Math.pow(e, t)))
},
    Yx = {
  kernelName: "Range",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      backend: t,
      attrs: n
    } = e,
        {
      start: s,
      stop: r,
      dtype: a,
      step: i
    } = n,
        o = em(s, r, i, a);
    return t.makeTensorInfo([o.length], a, o);
  }
},
    Jx = {
  kernelName: "Reciprocal",
  backendName: "cpu",
  kernelFunc: lg("Reciprocal", e => 1 / e)
},
    Zx = {
  kernelName: "ResizeBilinear",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r
    } = t,
        {
      alignCorners: a,
      halfPixelCenters: i,
      size: o
    } = s;
    Bf(r, "resizeBilinear");
    var l = A(r.shape),
        [u, c] = o,
        [h, p, f, g] = r.shape,
        m = n.data.get(r.dataId).values,
        b = new Float32Array(d([h, u, c, g])),
        x = [a && u > 1 ? p - 1 : p, a && c > 1 ? f - 1 : f],
        y = [a && u > 1 ? u - 1 : u, a && c > 1 ? c - 1 : c];
    var k = 0;
    var w = x[0] / y[0],
        v = x[1] / y[1];

    for (var _e392 = 0; _e392 < h; _e392++) {
      for (var _t332 = 0; _t332 < u; _t332++) {
        var _n244 = void 0;

        _n244 = i ? w * (_t332 + .5) - .5 : w * _t332;

        var _s196 = Math.max(0, Math.floor(_n244)),
            _r146 = _n244 - _s196,
            _a112 = Math.min(p - 1, Math.ceil(_n244)),
            _o61 = _e392 * l[0] + _s196 * l[1],
            _u28 = _e392 * l[0] + _a112 * l[1];

        for (var _e393 = 0; _e393 < c; _e393++) {
          var _t333 = void 0;

          _t333 = i ? v * (_e393 + .5) - .5 : v * _e393;

          var _n245 = Math.max(0, Math.floor(_t333)),
              _s197 = _t333 - _n245,
              _a113 = Math.min(f - 1, Math.ceil(_t333)),
              _c27 = _o61 + _n245 * l[2],
              _h15 = _u28 + _n245 * l[2],
              _d18 = _o61 + _a113 * l[2],
              _p13 = _u28 + _a113 * l[2];

          for (var _e394 = 0; _e394 < g; _e394++) {
            var _t334 = m[_c27 + _e394],
                _n246 = m[_h15 + _e394],
                _a114 = _t334 + (m[_d18 + _e394] - _t334) * _s197;

            b[k++] = _a114 + (_n246 + (m[_p13 + _e394] - _n246) * _s197 - _a114) * _r146;
          }
        }
      }
    }

    return n.makeTensorInfo([h, u, c, g], "float32", b);
  }
},
    Qx = {
  kernelName: "ResizeBilinearGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r,
      dy: a
    } = t,
        {
      alignCorners: i
    } = s;
    Bf([a, r], "resizeBilinearGrad");
    var o = A(r.shape),
        [l, u, c, h] = r.shape,
        [, d, p] = a.shape,
        f = new Float32Array(l * u * c * h),
        g = [i && d > 1 ? u - 1 : u, i && p > 1 ? c - 1 : c],
        m = [i && d > 1 ? d - 1 : d, i && p > 1 ? p - 1 : p],
        b = g[0] / m[0],
        x = g[1] / m[1],
        y = n.data.get(a.dataId).values;
    var k = 0;

    for (var _e395 = 0; _e395 < l; _e395++) {
      var _t335 = _e395 * o[0];

      for (var _e396 = 0; _e396 < d; _e396++) {
        var _n247 = _e396 * b,
            _s198 = Math.floor(_n247),
            _r147 = Math.min(Math.ceil(_n247), u - 1),
            _a115 = _t335 + _s198 * o[1],
            _i83 = _t335 + _r147 * o[1],
            _l42 = _n247 - _s198,
            _d19 = 1 - _l42;

        for (var _e397 = 0; _e397 < p; _e397++) {
          var _t336 = _e397 * x,
              _n248 = Math.floor(_t336),
              _s199 = Math.min(Math.ceil(_t336), c - 1),
              _r148 = _t336 - _n248,
              _u29 = 1 - _r148,
              _p14 = _a115 + _n248 * o[2],
              _g17 = _a115 + _s199 * o[2],
              _m12 = _i83 + _n248 * o[2],
              _b12 = _i83 + _s199 * o[2],
              _w8 = _d19 * _u29,
              _v6 = _d19 * _r148,
              _I5 = _l42 * _u29,
              _$3 = _l42 * _r148;

          for (var _e398 = 0; _e398 < h; _e398++) {
            var _t337 = y[k++];
            f[_p14 + _e398] += _t337 * _w8, f[_g17 + _e398] += _t337 * _v6, f[_m12 + _e398] += _t337 * _I5, f[_b12 + _e398] += _t337 * _$3;
          }
        }
      }
    }

    return n.makeTensorInfo([l, c, u, h], "float32", f);
  }
},
    ey = {
  kernelName: "ResizeNearestNeighbor",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r
    } = t,
        {
      alignCorners: a,
      halfPixelCenters: i,
      size: o
    } = s;
    Bf(r, "resizeNearestNeighbor");
    var l = A(r.shape),
        [u, c] = o,
        [h, d, p, f] = r.shape,
        g = n.data.get(r.dataId).values,
        m = new Float32Array(h * u * c * f),
        b = [a && u > 1 ? d - 1 : d, a && c > 1 ? p - 1 : p],
        x = [a && u > 1 ? u - 1 : u, a && c > 1 ? c - 1 : c],
        y = b[0] / x[0],
        k = b[1] / x[1];
    var w = 0;

    for (var _e399 = 0; _e399 < h; _e399++) {
      var _t338 = _e399 * l[0];

      for (var _e400 = 0; _e400 < u; _e400++) {
        var _n249 = i ? y * (_e400 + .5) : y * _e400;

        var _s200 = Math.min(d - 1, a ? Math.round(_n249) : Math.floor(_n249));

        i && (_s200 = Math.max(0, _s200));

        var _r149 = _t338 + _s200 * l[1];

        for (var _e401 = 0; _e401 < c; _e401++) {
          var _t339 = i ? k * (_e401 + .5) : k * _e401;

          var _n250 = Math.min(p - 1, a ? Math.round(_t339) : Math.floor(_t339));

          i && (_n250 = Math.max(0, _n250));

          var _s201 = _r149 + _n250 * l[2];

          for (var _e402 = 0; _e402 < f; _e402++) {
            m[w++] = g[_s201 + _e402];
          }
        }
      }
    }

    return n.makeTensorInfo([h, u, c, f], r.dtype, m);
  }
},
    ty = {
  kernelName: "ResizeNearestNeighborGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r,
      dy: a
    } = t,
        {
      alignCorners: i
    } = s;
    Bf([a, r], "resizeNearestNeighborGrad");
    var o = A(r.shape),
        l = A(a.shape),
        [u, c, h, d] = r.shape,
        [, p, f] = a.shape,
        g = new Float32Array(u * c * h * d),
        m = n.data.get(a.dataId).values,
        b = [i && p > 1 ? c - 1 : c, i && f > 1 ? h - 1 : h],
        x = [i && p > 1 ? p - 1 : p, i && f > 1 ? f - 1 : f],
        y = b[0] / x[0],
        k = b[1] / x[1],
        w = 1 / y,
        v = 1 / k,
        I = 2 * Math.ceil(w) + 2,
        $ = 2 * Math.ceil(v) + 2;

    for (var _e403 = 0; _e403 < u; _e403++) {
      var _t340 = _e403 * o[0];

      for (var _e404 = 0; _e404 < c; _e404++) {
        var _n251 = _t340 + _e404 * o[1],
            _s202 = Math.floor(_e404 * w),
            _r150 = Math.floor(_s202 - I / 2);

        for (var _s203 = 0; _s203 < h; _s203++) {
          var _a116 = _n251 + _s203 * o[2],
              _u30 = Math.floor(_s203 * v),
              _b13 = Math.floor(_u30 - $ / 2);

          for (var _n252 = 0; _n252 < d; _n252++) {
            var _o62 = 0;

            for (var _a117 = 0; _a117 < I; _a117++) {
              var _u31 = _a117 + _r150;

              if (_u31 < 0 || _u31 >= p) continue;

              var _d20 = _t340 + _u31 * l[1],
                  _g18 = _u31 * y;

              if (_e404 === Math.min(c - 1, i ? Math.round(_g18) : Math.floor(_g18))) for (var _e405 = 0; _e405 < $; _e405++) {
                var _t341 = _e405 + _b13;

                if (_t341 < 0 || _t341 >= f) continue;

                var _r151 = _d20 + _t341 * l[2],
                    _a118 = _t341 * k;

                _s203 === Math.min(h - 1, i ? Math.round(_a118) : Math.floor(_a118)) && (_o62 += m[_r151 + _n252]);
              }
            }

            g[_a116 + _n252] = _o62;
          }
        }
      }
    }

    return n.makeTensorInfo(r.shape, r.dtype, g);
  }
},
    ny = {
  kernelName: "Reverse",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      dims: a
    } = s;
    Bf(r, "reverse");
    var i = r.shape.length,
        o = y(a, r.shape);
    if (0 === i) return Kf({
      inputs: {
        x: r
      },
      backend: n
    });
    var l = new tt(r.shape, r.dtype),
        u = n.bufferSync(r);

    var _loop31 = function _loop31(_e406) {
      var t = l.indexToLoc(_e406),
          n = t.slice();
      o.forEach(e => n[e] = r.shape[e] - 1 - n[e]), l.set(u.get(...n), ...t);
    };

    for (var _e406 = 0; _e406 < l.size; _e406++) {
      _loop31(_e406);
    }

    return n.makeTensorInfo(l.shape, l.dtype, l.values);
  }
},
    sy = {
  kernelName: "RotateWithOffset",
  backendName: "cpu",
  kernelFunc: _ref18 => {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref18;
    var {
      image: s
    } = e,
        {
      radians: r,
      fillValue: a,
      center: i
    } = t,
        o = n,
        l = w(s.dtype, d(s.shape)),
        [u, c, h, p] = s.shape,
        [f, g] = Ao(i, c, h),
        m = Math.sin(r),
        b = Math.cos(r),
        x = o.data.get(s.dataId).values;

    for (var _e407 = 0; _e407 < u; _e407++) {
      var _t342 = _e407 * h * c * p;

      for (var _e408 = 0; _e408 < c; _e408++) {
        var _n253 = _e408 * (h * p);

        for (var _s204 = 0; _s204 < h; _s204++) {
          var _r152 = _s204 * p;

          for (var _i84 = 0; _i84 < p; _i84++) {
            var _o63 = [u, _e408, _s204, _i84],
                _d21 = _o63[2],
                _y10 = _o63[1];

            var _k8 = (_d21 - f) * b - (_y10 - g) * m,
                _w9 = (_d21 - f) * m + (_y10 - g) * b;

            _k8 = Math.round(_k8 + f), _w9 = Math.round(_w9 + g);
            var _v7 = a;
            "number" != typeof a && (_v7 = 3 === _i84 ? 255 : a[_i84]), _k8 >= 0 && _k8 < h && _w9 >= 0 && _w9 < c && (_v7 = x[_t342 + _w9 * (h * p) + _k8 * p + _i84]), l[_t342 + _n253 + _r152 + _i84] = _v7;
          }
        }
      }
    }

    return {
      dataId: o.write(l, s.shape, s.dtype),
      shape: s.shape,
      dtype: s.dtype
    };
  }
},
    ry = {
  kernelName: "Round",
  backendName: "cpu",
  kernelFunc: lg("Round", e => {
    var t = Math.floor(e);
    return e - t < .5 ? Math.floor(e) : e - t > .5 ? Math.ceil(e) : t % 2 == 0 ? t : t + 1;
  })
};

function ay(e, t, n, s, r, a, i, o, l, u) {
  var c = [s / r, r],
      h = e.values,
      d = t.values;
  if (0 === s) return pn(n, t.dtype);
  var p = pn(c, t.dtype);
  p.values.fill(l);

  for (var _e409 = 0; _e409 < a; _e409++) {
    var _a119 = [];
    var _l43 = 0;

    for (var _t343 = 0; _t343 < i; _t343++) {
      var _n254 = h[_e409 * i + _t343];
      _a119.push(_n254), _l43 += _n254 * o[_t343];
    }

    if (_l43 < 0 || _l43 >= s / r) throw new Error("Invalid indices: ".concat(_a119, " does not index into ").concat(n));

    for (var _n255 = 0; _n255 < r; _n255++) {
      u ? p.values[_l43 * r + _n255] += d[_e409 * r + _n255] : p.values[_l43 * r + _n255] = 0 === t.rank ? d[0] : d[_e409 * r + _n255];
    }
  }

  return p;
}

var iy = {
  kernelName: "ScatterNd",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      indices: r,
      updates: a
    } = t,
        {
      shape: i
    } = s,
        {
      sliceRank: o,
      numUpdates: l,
      sliceSize: u,
      strides: c,
      outputSize: h
    } = Tn(0, r, i),
        d = ay(n.bufferSync(r), n.bufferSync(a), i, h, u, l, o, c, 0, !0);
    return n.makeTensorInfo(i, d.dtype, d.values);
  }
},
    oy = {
  kernelName: "Select",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      condition: s,
      t: r,
      e: a
    } = t;
    Bf([s, r, a], "select");
    var i = s.shape.length,
        o = n.data.get(s.dataId).values,
        l = n.data.get(r.dataId).values,
        u = n.data.get(a.dataId).values,
        c = pt(r.dtype, a.dtype),
        h = O(d(r.shape), c);
    var p = 0;
    var f = 0 === i || i > 1 || 1 === r.shape.length ? 1 : d(r.shape.slice(1));

    for (var _e410 = 0; _e410 < o.length; _e410++) {
      for (var _t344 = 0; _t344 < f; _t344++) {
        h[p++] = 1 === o[_e410] ? l[_e410] : u[_e410];
      }
    }

    return n.makeTensorInfo(r.shape, c, h);
  }
},
    ly = {
  kernelName: "Selu",
  backendName: "cpu",
  kernelFunc: lg("Selu", e => e >= 0 ? 1.0507009873554805 * e : 1.7580993408473768 * (Math.exp(e) - 1))
},
    uy = {
  kernelName: "Sign",
  backendName: "cpu",
  kernelFunc: lg("Sign", e => e < 0 ? -1 : e > 0 ? 1 : 0)
},
    cy = {
  kernelName: "Sin",
  backendName: "cpu",
  kernelFunc: lg("Sin", e => Math.sin(e))
},
    hy = {
  kernelName: "Sinh",
  backendName: "cpu",
  kernelFunc: lg("Sinh", e => Math.sinh(e))
},
    dy = Math.log(1.1920928955078125e-7) + 2,
    py = {
  kernelName: "Softplus",
  backendName: "cpu",
  kernelFunc: lg("Softplus", e => {
    var t = e > -dy,
        n = e < dy,
        s = Math.exp(e);
    var r;
    return r = n ? s : t ? e : Math.log(1 + s), r;
  })
},
    fy = {
  kernelName: "SpaceToBatchND",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockShape: a,
      paddings: i
    } = s;
    Bf([r], "spaceToBatchND");
    var o = d(a),
        l = [[0, 0]];
    l.push(...i);

    for (var _e411 = 1 + a.length; _e411 < r.shape.length; ++_e411) {
      l.push([0, 0]);
    }

    var u = Kx.kernelFunc({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        paddings: l,
        constantValue: 0
      }
    }),
        c = Fo(u.shape, a, o, !1),
        h = Do(c.length, a.length, !1),
        p = _o(u.shape, a, o, !1),
        f = Vm({
      inputs: {
        x: u
      },
      backend: n,
      attrs: {
        shape: c
      }
    }),
        g = Yg({
      inputs: {
        x: f
      },
      backend: n,
      attrs: {
        perm: h
      }
    }),
        m = Vm({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        shape: p
      }
    });

    return n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
  }
},
    gy = {
  kernelName: "SparseFillEmptyRows",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      indices: s,
      values: r,
      denseShape: a,
      defaultValue: i
    } = t;
    if (1 !== a.shape.length) throw new Error("Dense shape must be a vector, saw:\n        ".concat(a.shape));
    if (2 !== s.shape.length) throw new Error("Indices must be a matrix, saw:\n        ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));
    if (0 !== i.shape.length) throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));
    var o = n.data.get(s.dataId).values,
        l = n.data.get(r.dataId).values,
        u = n.data.get(a.dataId).values,
        c = n.data.get(i.dataId).values[0],
        [h, d, p, f, g] = um(o, s.shape, s.dtype, l, r.dtype, u, c);
    return [n.makeTensorInfo(d, s.dtype, h), n.makeTensorInfo([d[0]], r.dtype, p), n.makeTensorInfo([f.length], "bool", new Uint8Array(f.map(e => Number(e)))), n.makeTensorInfo([g.length], s.dtype, new Int32Array(g))];
  }
},
    my = {
  kernelName: "SparseReshape",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      inputIndices: s,
      inputShape: r,
      newShape: a
    } = t;
    if (2 !== s.shape.length) throw new Error("Input indices should be a matrix but received shape\n        ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Target shape should be a vector but received shape ".concat(a.shape));
    var i = Array.from(n.data.get(r.dataId).values),
        o = n.data.get(s.dataId).values,
        l = Array.from(n.data.get(a.dataId).values),
        [u, c, h] = cm(o, s.shape, s.dtype, i, l);
    return [n.makeTensorInfo(c, s.dtype, u), n.makeTensorInfo([h.length], a.dtype, new Int32Array(h))];
  }
},
    by = {
  kernelName: "SparseSegmentMean",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      data: s,
      indices: r,
      segmentIds: a
    } = t;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n          ".concat(a.shape));
    var i = n.data.get(s.dataId).values,
        o = n.data.get(r.dataId).values,
        l = n.data.get(a.dataId).values,
        [u, c] = hm(i, s.shape, s.dtype, o, l, !0);
    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    xy = {
  kernelName: "SparseSegmentSum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      data: s,
      indices: r,
      segmentIds: a
    } = t;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n         ".concat(a.shape));
    var i = n.data.get(s.dataId).values,
        o = n.data.get(r.dataId).values,
        l = n.data.get(a.dataId).values,
        [u, c] = hm(i, s.shape, s.dtype, o, l);
    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    yy = {
  kernelName: "SparseToDense",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      sparseIndices: r,
      sparseValues: a,
      defaultValue: i
    } = t,
        {
      outputShape: o
    } = s,
        {
      sliceRank: l,
      numUpdates: u,
      sliceSize: c,
      strides: h,
      outputSize: d
    } = Tn(0, r, o),
        p = ay(n.bufferSync(r), n.bufferSync(a), o, d, c, u, l, h, n.data.get(i.dataId).values[0], !1);
    return n.makeTensorInfo(o, p.dtype, p.values);
  }
},
    ky = {
  kernelName: "SplitV",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      numOrSizeSplits: a,
      axis: i
    } = s,
        o = y(i, r.shape)[0],
        l = Zo(r, a, o),
        u = new Array(r.shape.length).fill(0),
        c = r.shape.slice();
    return l.map(e => {
      var t = [...c];
      t[o] = e;
      var s = om({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          begin: u,
          size: t
        }
      });
      return u[o] += e, s;
    });
  }
},
    wy = {
  kernelName: "Square",
  backendName: "cpu",
  kernelFunc: _ref19 => {
    var {
      inputs: e,
      backend: t
    } = _ref19;
    var {
      x: n
    } = e,
        s = t;
    Bf(n, "square");
    var r = s.data.get(n.dataId).values,
        a = new Float32Array(r.length);

    for (var _e412 = 0; _e412 < r.length; ++_e412) {
      var _t345 = r[_e412];
      a[_e412] = _t345 * _t345;
    }

    return {
      dataId: s.write(a, n.shape, n.dtype),
      shape: n.shape,
      dtype: n.dtype
    };
  }
},
    vy = {
  kernelName: "Step",
  backendName: "cpu",
  kernelFunc: lg("Step", (e, t) => {
    var n = t;
    return isNaN(e) ? NaN : e > 0 ? 1 : n.alpha;
  })
},
    Iy = {
  kernelName: "StridedSlice",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      begin: a,
      end: i,
      strides: o,
      beginMask: l,
      endMask: u,
      ellipsisMask: c,
      newAxisMask: h,
      shrinkAxisMask: d
    } = s;
    Bf(r, "stridedSlice");
    var {
      nonStrided: p,
      $begin: f,
      $strides: g,
      size: m,
      newShape: b,
      outShape: x
    } = Gn(r.shape, a, i, o, l, u, c, h, d),
        y = Vm({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: b
      }
    });
    var k;

    if (p) {
      var _e413 = om({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          begin: f,
          size: m
        }
      });

      k = Vm({
        inputs: {
          x: _e413
        },
        backend: n,
        attrs: {
          shape: x
        }
      }), n.disposeIntermediateTensorInfo(_e413);
    } else if (x.some(e => 0 === e)) k = n.makeTensorInfo(x, r.dtype, []);else {
      var _e414 = mm(x, n.bufferSync(y), g, f);

      k = n.makeTensorInfo(_e414.shape, _e414.dtype, _e414.values);
    }

    var w = Vm({
      inputs: {
        x: k
      },
      backend: n,
      attrs: {
        shape: x
      }
    });
    return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(k), w;
  }
},
    $y = {
  kernelName: "StringNGrams",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      separator: r,
      nGramWidths: a,
      leftPad: i,
      rightPad: o,
      padWidth: l,
      preserveShortSequences: u
    } = s,
        {
      data: c,
      dataSplits: h
    } = t,
        d = n.data.get(c.dataId).values,
        p = n.data.get(h.dataId).values,
        [f, g] = xm(d, p, r, a, i, o, l, u);
    return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(h.shape, "int32", g)];
  }
},
    Sy = {
  kernelName: "StringSplit",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      skipEmpty: r
    } = s,
        {
      input: a,
      delimiter: i
    } = t;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (1 !== a.shape.length) throw new Error("Input must be a vector, got shape: ".concat(a.shape));
    if (0 !== i.shape.length) throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));
    var o = n.data.get(a.dataId).values,
        l = n.data.get(i.dataId).values[0],
        [u, c, h] = km(o, l, r),
        d = c.length;
    return [n.makeTensorInfo([d, 2], "int32", u), n.makeTensorInfo([d], "string", c), n.makeTensorInfo([2], "int32", new Int32Array(h))];
  }
},
    Ny = {
  kernelName: "StringToHashBucketFast",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      numBuckets: r
    } = s,
        {
      input: a
    } = t;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (r <= 0) throw new Error("Number of buckets must be at least 1");
    var i = wm(n.data.get(a.dataId).values, r);
    return n.makeTensorInfo(a.shape, "int32", i);
  }
},
    Cy = {
  kernelName: "Tan",
  backendName: "cpu",
  kernelFunc: lg("Tan", e => Math.tan(e))
},
    Ty = lg("Tanh", e => Math.tanh(e));

function Ey(e, t, n) {
  switch (n) {
    case "reflect":
      return function (e, t) {
        var n = e;
        if (n < 0) {
          if (t <= 1) n = 0;else {
            var _e415 = 2 * t;

            n < _e415 && (n = _e415 * Math.trunc(-n / _e415) + n), n = n < -t ? n + _e415 : -n - 1;
          }
        } else if (n > t - 1) if (t <= 1) n = 0;else {
          var _e416 = 2 * t;

          n -= _e416 * Math.trunc(n / _e416), n >= t && (n = _e416 - n - 1);
        }
        return a(0, n, t - 1);
      }(e, t);

    case "wrap":
      return function (e, t) {
        var n = e;
        return n < 0 ? t <= 1 ? n = 0 : n += t * (Math.trunc(-n / (t - 1)) + 1) : n > t - 1 && (t <= 1 ? n = 0 : n -= t * Math.trunc(n / (t - 1))), a(0, n, t - 1);
      }(e, t);

    case "nearest":
      return function (e, t) {
        return a(0, e, t - 1);
      }(e, t);

    case "constant":
    default:
      return function (e, t) {
        return e;
      }(e);
  }
}

function Ry(e, t, n, s, r, a, i, o, l, u, c) {
  return 0 <= o && o < t && 0 <= l && l < n ? e[i * s + o * r + l * a + u] : c;
}

function Ay(e, t, n, s, r, a, i, o, l, u, c) {
  return Ry(e, t, n, s, r, a, i, Math.round(o), Math.round(l), u, c);
}

function Fy(e, t, n, s, r, a, i, o, l, u, c) {
  var h = Math.floor(o),
      d = Math.floor(l),
      p = h + 1,
      f = d + 1;
  return (p - o) * ((f - l) * Ry(e, t, n, s, r, a, i, h, d, u, c) + (l - d) * Ry(e, t, n, s, r, a, i, h, f, u, c)) + (o - h) * ((f - l) * Ry(e, t, n, s, r, a, i, p, d, u, c) + (l - d) * Ry(e, t, n, s, r, a, i, p, f, u, c));
}

var Dy = [jm, Vf, Km, Xm, rg, Ym, Jm, Zm, Qm, eb, tb, nb, sb, rb, ab, ub, cb, hb, db, qm, pb, fb, gb, mb, Qf, hg, bb, qf, xb, vb, Sb, Nb, $b, Tb, Eb, Cb, Rb, Ab, Fb, Db, _b, Ob, Lb, zb, Bb, Pb, Wb, Vb, Ub, Zb, qb, Fm, jb, gg, Kb, xg, Yb, kg, nx, rx, ax, vg, ix, ox, lx, ux, cx, Ng, Tg, Xf, hx, kb, dx, px, fx, _m, Rg, Fg, gx, Og, mx, bx, xx, yx, kx, wx, zg, $x, Sx, Nx, Cx, Tx, Ix, Ex, Rx, Pg, Ax, Fx, Ox, Gg, qg, Lx, Bx, Wx, Kg, Ux, Hx, jx, Kx, Xx, Lm, Qg, Yx, Jf, Jx, Bm, Wm, Gm, Zx, Qx, ey, ty, ny, sy, ry, nm, iy, oy, ly, am, uy, cy, hy, lm, _x, py, fy, gy, my, by, xy, yy, ky, pm, wy, gm, vy, Iy, $y, Sy, Ny, $m, Hb, Cy, {
  kernelName: "Tanh",
  backendName: "cpu",
  kernelFunc: Ty
}, {
  kernelName: "Tile",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      reps: a
    } = s;
    Bf(r, "tile");
    var i = Sm(n.bufferSync(r), a);
    return n.makeTensorInfo(i.shape, i.dtype, i.values);
  }
}, {
  kernelName: "TopK",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      k: a,
      sorted: i
    } = s;
    Bf(r, "topk");
    var o = n.data.get(r.dataId).values,
        [l, u] = Tm(o, r.shape, r.dtype, a, i);
    return [n.makeTensorInfo(l.shape, l.dtype, l.values), n.makeTensorInfo(u.shape, u.dtype, u.values)];
  }
}, Jg, {
  kernelName: "Transform",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      attrs: n,
      backend: s
    } = e,
        {
      image: r,
      transforms: a
    } = t,
        {
      interpolation: i,
      fillMode: o,
      fillValue: l,
      outputShape: u
    } = n,
        [c, h, p, f] = r.shape,
        [g, m] = null != u ? u : [h, p],
        b = [c, g, m, f],
        x = A(r.shape),
        y = x[0],
        k = x[1],
        v = x[2],
        I = w(r.dtype, d(b));
    I.fill(l);
    var $ = s.data.get(r.dataId).values,
        S = s.data.get(a.dataId).values;

    for (var _e417 = 0; _e417 < c; ++_e417) {
      var _t346 = 1 === a.shape[0] ? S : S.subarray(8 * _e417, 8 * _e417 + 8);

      for (var _n256 = 0; _n256 < g; ++_n256) {
        for (var _s205 = 0; _s205 < m; ++_s205) {
          for (var _r153 = 0; _r153 < f; ++_r153) {
            var _a120 = void 0;

            var _u32 = _t346[6] * _s205 + _t346[7] * _n256 + 1;

            if (0 === _u32) continue;

            var _c28 = (_t346[3] * _s205 + _t346[4] * _n256 + _t346[5]) / _u32,
                _d22 = Ey((_t346[0] * _s205 + _t346[1] * _n256 + _t346[2]) / _u32, p, o),
                _f10 = Ey(_c28, h, o);

            switch (i) {
              case "nearest":
                _a120 = Ay($, h, p, y, k, v, _e417, _f10, _d22, _r153, l);
                break;

              case "bilinear":
                _a120 = Fy($, h, p, y, k, v, _e417, _f10, _d22, _r153, l);
                break;

              default:
                throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got ".concat(i));
            }

            I[_e417 * y + _n256 * k + _s205 * v + _r153] = _a120;
          }
        }
      }

      return s.makeTensorInfo(b, r.dtype, I);
    }

    return {
      dataId: s.write(I, b, r.dtype),
      shape: r.shape,
      dtype: r.dtype
    };
  }
}, {
  kernelName: "Unique",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      attrs: n,
      backend: s
    } = e,
        {
      axis: r
    } = n,
        {
      x: a
    } = t;
    Bf(a, "unique");
    var i = s.data.get(a.dataId).values,
        {
      outputValues: o,
      outputShape: l,
      indices: u
    } = Em(i, r, a.shape, a.dtype);
    return [s.makeTensorInfo(l, a.dtype, o), s.makeTensorInfo([u.length], "int32", u)];
  }
}, {
  kernelName: "Unpack",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      value: r
    } = t;
    var {
      axis: a
    } = s;
    a < 0 && (a += r.shape.length);
    var i = r.shape.length,
        o = r.shape[a],
        l = new Array(i - 1);
    var u = 0;

    for (var _e418 = 0; _e418 < i; _e418++) {
      _e418 !== a && (l[u++] = r.shape[_e418]);
    }

    var c = new Array(i).fill(0),
        h = r.shape.slice();
    h[a] = 1;
    var d = new Array(o);

    for (var _e419 = 0; _e419 < d.length; _e419++) {
      c[a] = _e419;

      var _t347 = om({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          begin: c,
          size: h
        }
      });

      d[_e419] = Vm({
        inputs: {
          x: _t347
        },
        backend: n,
        attrs: {
          shape: l
        }
      }), n.disposeIntermediateTensorInfo(_t347);
    }

    return d;
  }
}, {
  kernelName: "UnsortedSegmentSum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      segmentIds: a
    } = t,
        {
      numSegments: i
    } = s;
    Bf(r, "unsortedSegmentSum");
    var o = [],
        l = [],
        u = r.shape.length - a.shape.length;
    var c = a;

    for (var _e420 = 0; _e420 < u; ++_e420) {
      var _t348 = Xb({
        inputs: {
          input: c
        },
        backend: n,
        attrs: {
          dim: _e420 + 1
        }
      });

      c = _t348, l.push(_t348);
    }

    for (var _e421 = 0; _e421 < i; ++_e421) {
      var _t349 = Ue(_e421, "int32"),
          _s206 = n.makeTensorInfo([], "int32", _t349),
          _a121 = fg({
        inputs: {
          a: _s206,
          b: c
        },
        backend: n
      }),
          _i85 = Zf({
        inputs: {
          x: _a121
        },
        backend: n,
        attrs: {
          dtype: "float32"
        }
      }),
          _u33 = Vg({
        inputs: {
          a: _i85,
          b: r
        },
        backend: n
      }),
          _h16 = Gb({
        inputs: {
          x: _u33
        },
        backend: n,
        attrs: {
          axis: 0,
          keepDims: !1
        }
      });

      o.push(_h16), l.push(_s206), l.push(_a121), l.push(_i85), l.push(_u33), l.push(_h16);
    }

    var h = qx({
      inputs: o,
      backend: n,
      attrs: {
        axis: 0
      }
    });
    return l.forEach(e => n.disposeIntermediateTensorInfo(e)), h;
  }
}, Gx];

for (var _e422 of Dy) {
  ee(_e422);
}

var _y = {},
    Oy = {
  alpha: !1,
  antialias: !1,
  premultipliedAlpha: !1,
  preserveDrawingBuffer: !1,
  depth: !1,
  stencil: !1,
  failIfMajorPerformanceCaveat: !0
};

function My(e) {
  if (!(e in _y)) {
    var _t350 = function (e) {
      if (1 !== e && 2 !== e) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");

      var t = function (e) {
        if ("undefined" != typeof OffscreenCanvas && 2 === e) return new OffscreenCanvas(300, 150);
        if ("undefined" != typeof document) return document.createElement("canvas");
        throw new Error("Cannot create a canvas in this context");
      }(e);

      return t.addEventListener("webglcontextlost", t => {
        t.preventDefault(), delete _y[e];
      }, !1), 1 === e ? t.getContext("webgl", Oy) || t.getContext("experimental-webgl", Oy) : t.getContext("webgl2", Oy);
    }(e);

    if (null === _t350) return console.log("Could not get context for WebGL version", e), null;
    _y[e] = _t350;
  }

  var t = _y[e];
  return t.isContextLost() ? (delete _y[e], My(e)) : (t.disable(t.DEPTH_TEST), t.disable(t.STENCIL_TEST), t.disable(t.BLEND), t.disable(t.DITHER), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SAMPLE_COVERAGE), t.enable(t.SCISSOR_TEST), t.enable(t.CULL_FACE), t.cullFace(t.BACK), _y[e]);
}

var Ly, zy, By;

function Py(e, t) {
  return [t, e];
}

function Wy(e) {
  var t = d(e);
  return g(Math.ceil(t / 4));
}

function Uy(e, t) {
  return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2))];
}

function Vy(e, t) {
  var n = e;
  var s, r, a, i, o, l, u, c, h, d;
  return 2 === G().getNumber("WEBGL_VERSION") ? (s = n.R32F, r = n.R16F, a = n.RGBA16F, i = n.RGBA32F, o = n.RED, u = 4, c = 1, h = n.HALF_FLOAT, d = n.FLOAT) : (s = e.RGBA, r = e.RGBA, a = e.RGBA, i = n.RGBA, o = e.RGBA, u = 4, c = 4, h = null != t ? t.HALF_FLOAT_OES : null, d = e.FLOAT), l = e.RGBA, {
    internalFormatFloat: s,
    internalFormatHalfFloat: r,
    internalFormatPackedHalfFloat: a,
    internalFormatPackedFloat: i,
    textureFormatFloat: o,
    downloadTextureFormat: l,
    downloadUnpackNumChannels: u,
    defaultNumChannels: c,
    textureTypeHalfFloat: h,
    textureTypeFloat: d
  };
}

function Gy(e, t) {
  var n = t();
  return G().getBool("DEBUG") && function (e) {
    var t = e.getError();
    if (t !== e.NO_ERROR) throw new Error("WebGL Error: " + function (e, t) {
      switch (t) {
        case e.NO_ERROR:
          return "NO_ERROR";

        case e.INVALID_ENUM:
          return "INVALID_ENUM";

        case e.INVALID_VALUE:
          return "INVALID_VALUE";

        case e.INVALID_OPERATION:
          return "INVALID_OPERATION";

        case e.INVALID_FRAMEBUFFER_OPERATION:
          return "INVALID_FRAMEBUFFER_OPERATION";

        case e.OUT_OF_MEMORY:
          return "OUT_OF_MEMORY";

        case e.CONTEXT_LOST_WEBGL:
          return "CONTEXT_LOST_WEBGL";

        default:
          return "Unknown error code ".concat(t);
      }
    }(e, t));
  }(e), n;
}

function Hy(e) {
  return !!(G().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === e || 5.96e-8 < Math.abs(e) && Math.abs(e) < 65504);
}

function qy(e, t) {
  return Qy(e, () => e.getExtension(t), 'Extension "' + t + '" not supported on this browser.');
}

!function (e) {
  e[e.DENSE = 0] = "DENSE", e[e.SHARED_BATCH = 1] = "SHARED_BATCH";
}(Ly || (Ly = {})), function (e) {
  e[e.RENDER = 0] = "RENDER", e[e.UPLOAD = 1] = "UPLOAD", e[e.PIXELS = 2] = "PIXELS", e[e.DOWNLOAD = 3] = "DOWNLOAD";
}(zy || (zy = {})), function (e) {
  e[e.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e[e.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e[e.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e[e.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(By || (By = {}));
var jy = /ERROR: [0-9]+:([0-9]+):/g;

function Ky(e, t) {
  if (Gy(e, () => e.validateProgram(t)), !1 === e.getProgramParameter(t, e.VALIDATE_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Shader program validation failed.");
}

function Xy(e, t, n, s, r, a, i) {
  var o = e.getAttribLocation(t, n);
  return -1 !== o && (Gy(e, () => e.bindBuffer(e.ARRAY_BUFFER, s)), Gy(e, () => e.vertexAttribPointer(o, r, e.FLOAT, !1, a, i)), Gy(e, () => e.enableVertexAttribArray(o)), !0);
}

function Yy(e, t, n) {
  Gy(e, () => e.bindFramebuffer(e.FRAMEBUFFER, n)), Gy(e, () => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0));
}

function Jy(e, t) {
  Gy(e, () => e.bindFramebuffer(e.FRAMEBUFFER, t)), Gy(e, () => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0));
}

function Zy(e) {
  var t = e.checkFramebufferStatus(e.FRAMEBUFFER);
  if (t !== e.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + function (e, t) {
    switch (t) {
      case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

      case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

      case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

      case e.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";

      default:
        return "unknown error ".concat(t);
    }
  }(e, t));
}

function Qy(e, t, n) {
  var s = Gy(e, () => t());
  if (null == s) throw new Error(n);
  return s;
}

function ek(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  return d(e.slice(0, e.length - t));
}

function tk(e) {
  if (0 === e.length) throw Error("Cannot get rows and columns of an empty shape array.");
  return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]];
}

function nk(e) {
  var t = [1, 1, 1];
  return 0 === e.length || 1 === e.length && 1 === e[0] || (t = [ek(e), ...tk(e)]), t;
}

function sk(e) {
  return e % 2 == 0;
}

function rk(e, t) {
  if (p(e = e.slice(-2), t = t.slice(-2))) return !0;
  if (!e.length || !t.length) return !0;
  if (0 === e[0] || 0 === e[1] || 0 === t[0] || 0 === t[1]) return !0;

  if (e.length !== t.length) {
    var _n257 = e.slice(-1)[0],
        _s207 = t.slice(-1)[0];
    if (_n257 === _s207) return !0;
    if (sk(_n257) && sk(_s207) && (1 === e[0] || 1 === t[0])) return !0;
  }

  return e[1] === t[1] && sk(e[0]) && sk(t[0]);
}

var ak, ik;

function ok(e, t) {
  return null != e.getExtension(t);
}

function lk(e) {
  try {
    if (null != My(e)) return !0;
  } catch (e) {
    return console.log("Error when getting WebGL context: ", e), !1;
  }

  return !1;
}

function uk(e) {
  var t = Vy(e),
      n = e.createTexture();
  e.bindTexture(e.TEXTURE_2D, n), e.texImage2D(e.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
  var s = e.createFramebuffer();
  e.bindFramebuffer(e.FRAMEBUFFER, s), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
  var r = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
  return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(n), e.deleteFramebuffer(s), r;
}

function ck(e, t) {
  Array.isArray(e) || (e = [e]), e.forEach(e => {
    null != e && l("complex64" !== e.dtype, () => "".concat(t, " does not support complex64 tensors in the WebGL backend."));
  });
}

var hk = G();

function dk() {
  var e, t, n, s, r, a, i, o, l, u;
  return 2 === G().getNumber("WEBGL_VERSION") ? (e = "#version 300 es", t = "in", n = "out", s = "in", r = "texture", a = "outputColor", i = "out vec4 outputColor;", o = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", l = "", u = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (e = "", t = "attribute", n = "varying", s = "varying", r = "texture2D", a = "gl_FragColor", i = "", o = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", l = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", u = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
    version: e,
    attribute: t,
    varyingVs: n,
    varyingFs: s,
    texture2D: r,
    output: a,
    defineOutput: i,
    defineSpecialNaN: o,
    defineSpecialInf: l,
    defineRound: u
  };
}

function pk(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "index";
  var s = A(t);
  return s.map((t, r) => "int ".concat(e[r], " = ").concat(n, " / ").concat(t, "; ").concat(r === s.length - 1 ? "int ".concat(e[r + 1], " = ").concat(n, " - ").concat(e[r], " * ").concat(t) : "index -= ".concat(e[r], " * ").concat(t), ";")).join("");
}

function fk(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "index";
  var s = A(t);
  return s.map((t, r) => "int ".concat(e[r], " = ").concat(n, " / outShapeStrides[").concat(r, "]; ").concat(r === s.length - 1 ? "int ".concat(e[r + 1], " = ").concat(n, " - ").concat(e[r], " * outShapeStrides[").concat(r, "]") : "index -= ".concat(e[r], " * outShapeStrides[").concat(r, "]"), ";")).join("");
}

function gk(e) {
  var t = A(e).map(e => e.toString());
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0], " + coords.y * ").concat(t[1], " + coords.z;\n  }\n");
}

hk.registerFlag("HAS_WEBGL", () => hk.getNumber("WEBGL_VERSION") > 0), hk.registerFlag("WEBGL_VERSION", () => lk(2) ? 2 : lk(1) ? 1 : 0), hk.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => !1), hk.registerFlag("WEBGL_BUFFER_SUPPORTED", () => 2 === hk.get("WEBGL_VERSION")), hk.registerFlag("WEBGL_CPU_FORWARD", () => !0), hk.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => !1), hk.registerFlag("WEBGL_PACK", () => hk.getBool("HAS_WEBGL")), hk.registerFlag("WEBGL_PACK_NORMALIZATION", () => hk.getBool("WEBGL_PACK")), hk.registerFlag("WEBGL_PACK_CLIP", () => hk.getBool("WEBGL_PACK")), hk.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => hk.getBool("WEBGL_PACK")), hk.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => hk.getBool("WEBGL_PACK")), hk.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => hk.getBool("WEBGL_PACK")), hk.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => hk.getBool("WEBGL_PACK")), hk.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => hk.getBool("WEBGL_PACK")), hk.registerFlag("WEBGL_PACK_REDUCE", () => hk.getBool("WEBGL_PACK")), hk.registerFlag("WEBGL_LAZILY_UNPACK", () => hk.getBool("WEBGL_PACK")), hk.registerFlag("WEBGL_CONV_IM2COL", () => hk.getBool("WEBGL_PACK")), hk.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => function (e) {
  if (null == ak) {
    var _t351 = My(e);

    ak = _t351.getParameter(_t351.MAX_TEXTURE_SIZE);
  }

  return ak;
}(hk.getNumber("WEBGL_VERSION"))), hk.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => function (e) {
  if (null == ik) {
    var _t352 = My(e);

    ik = _t352.getParameter(_t352.MAX_TEXTURE_IMAGE_UNITS);
  }

  return Math.min(16, ik);
}(hk.getNumber("WEBGL_VERSION"))), hk.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
  var e = hk.getNumber("WEBGL_VERSION");
  return 0 === e ? 0 : function (e) {
    if (0 === e) return 0;
    var t;
    var n = My(e);
    return t = ok(n, "EXT_disjoint_timer_query_webgl2") && 2 === e ? 2 : ok(n, "EXT_disjoint_timer_query") ? 1 : 0, t;
  }(e);
}), hk.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => hk.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !$t()), hk.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => function (e) {
  if (0 === e) return !1;
  var t = My(e);

  if (1 === e) {
    if (!ok(t, "OES_texture_float")) return !1;
  } else if (!ok(t, "EXT_color_buffer_float")) return !1;

  return uk(t);
}(hk.getNumber("WEBGL_VERSION"))), hk.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => !hk.getBool("WEBGL_FORCE_F16_TEXTURES") && hk.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")), hk.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => function (e) {
  if (0 === e) return !1;
  var t = My(e);

  if (1 !== e) {
    if (ok(t, "EXT_color_buffer_float")) return uk(t);
    var _e423 = "EXT_color_buffer_half_float";

    if (ok(t, _e423)) {
      var _n258 = t.getExtension(_e423);

      return function (e, t) {
        var n = Vy(e, t),
            s = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, s), e.texImage2D(e.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
        var r = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, s, 0);
        var a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
        return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(s), e.deleteFramebuffer(r), a;
      }(t, _n258);
    }

    return !1;
  }

  return !!ok(t, "OES_texture_float") && !!ok(t, "WEBGL_color_buffer_float") && uk(t);
}(hk.getNumber("WEBGL_VERSION"))), hk.registerFlag("WEBGL_FENCE_API_ENABLED", () => {
  return 2 === (e = hk.getNumber("WEBGL_VERSION")) && null != My(e).fenceSync;
  var e;
}), hk.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => hk.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0), hk.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, e => {
  if (e < 0 && -1 !== e) throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ".concat(e, "."));
}), hk.registerFlag("WEBGL_FLUSH_THRESHOLD", () => $t() && hk.getBool("IS_CHROME") ? 1 : -1, e => {
  if (e < 0 && -1 !== e) throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ".concat(e, "."));
}), hk.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128), hk.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => !1), hk.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5), hk.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
var mk = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",
    {
  getBroadcastDims: bk
} = rl;

function xk(e, t, n) {
  var s = [];

  if (e.forEach(e => {
    var t = d(e.shapeInfo.logicalShape);

    if (e.shapeInfo.isUniform ? s.push("uniform float ".concat(e.name).concat(t > 1 ? "[".concat(t, "]") : "", ";")) : (s.push("uniform sampler2D ".concat(e.name, ";")), s.push("uniform int offset".concat(e.name, ";"))), n.enableShapeUniforms) {
      var {
        uniformShape: _t353
      } = Tk(n.packedInputs, e.shapeInfo.logicalShape, e.shapeInfo.texShape);

      switch (_t353.length) {
        case 1:
          s.push("uniform int ".concat(e.name, "Shape;"));
          break;

        case 2:
          s.push("uniform ivec2 ".concat(e.name, "Shape;"));
          break;

        case 3:
          s.push("uniform ivec3 ".concat(e.name, "Shape;"));
          break;

        case 4:
          s.push("uniform ivec4 ".concat(e.name, "Shape;"));
      }

      s.push("uniform ivec2 ".concat(e.name, "TexShape;"));
    }
  }), n.enableShapeUniforms) {
    switch (t.logicalShape.length) {
      case 1:
        s.push("uniform int outShape;");
        break;

      case 2:
        s.push("uniform ivec2 outShape;"), s.push("uniform int outShapeStrides;");
        break;

      case 3:
        s.push("uniform ivec3 outShape;"), s.push("uniform ivec2 outShapeStrides;");
        break;

      case 4:
        s.push("uniform ivec4 outShape;"), s.push("uniform ivec3 outShapeStrides;");
    }

    s.push("uniform ivec2 outTexShape;");
  }

  n.customUniforms && n.customUniforms.forEach(e => {
    s.push("uniform ".concat(e.type, " ").concat(e.name).concat(e.arrayIndex ? "[".concat(e.arrayIndex, "]") : "", ";"));
  });

  var r = s.join("\n"),
      a = e.map(e => function (e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = "";
    return r += n ? kk(e, s) : yk(e, s), e.shapeInfo.logicalShape.length <= t.logicalShape.length && (r += n ? function (e, t) {
      var n = e.name,
          s = n.charAt(0).toUpperCase() + n.slice(1),
          r = "get" + s + "AtOutCoords",
          a = e.shapeInfo.logicalShape.length,
          i = t.logicalShape.length,
          o = bk(e.shapeInfo.logicalShape, t.logicalShape),
          l = Ck(i),
          u = i - a;
      var c;
      var h = ["x", "y", "z", "w", "u", "v"];
      c = 0 === a ? "" : i < 2 && o.length >= 1 ? "coords = 0;" : o.map(e => "coords.".concat(h[e + u], " = 0;")).join("\n");
      var p = "";
      p = i < 2 && a > 0 ? "coords" : e.shapeInfo.logicalShape.map((e, t) => "coords.".concat(h[t + u])).join(", ");
      var f = "return outputValue;";
      var g = 1 === d(e.shapeInfo.logicalShape),
          m = 1 === d(t.logicalShape);

      if (1 !== a || g || m) {
        if (g && !m) f = 1 === i ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";else if (o.length) {
          var _e424 = a - 2,
              _t354 = a - 1;

          o.indexOf(_e424) > -1 && o.indexOf(_t354) > -1 ? f = "return vec4(outputValue.x);" : o.indexOf(_e424) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : o.indexOf(_t354) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);");
        }
      } else f = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";

      return "\n    vec4 ".concat(r, "() {\n      ").concat(l, " coords = getOutputCoords();\n      ").concat(c, "\n      vec4 outputValue = get").concat(s, "(").concat(p, ");\n      ").concat(f, "\n    }\n  ");
    }(e, t) : function (e, t) {
      var n = e.name,
          s = n.charAt(0).toUpperCase() + n.slice(1),
          r = "get" + s + "AtOutCoords",
          a = e.shapeInfo.logicalShape.length,
          i = t.logicalShape.length;
      if (!e.shapeInfo.isUniform && a === i && null == e.shapeInfo.flatOffset && p(e.shapeInfo.texShape, t.texShape)) return "\n      float ".concat(r, "() {\n        return sampleTexture(").concat(n, ", resultUV);\n      }\n    ");
      var o = Ck(i),
          l = bk(e.shapeInfo.logicalShape, t.logicalShape),
          u = i - a;
      var c;
      var h = ["x", "y", "z", "w", "u", "v"];
      c = 0 === a ? "" : i < 2 && l.length >= 1 ? "coords = 0;" : l.map(e => "coords.".concat(h[e + u], " = 0;")).join("\n");
      var d = "";
      return d = i < 2 && a > 0 ? "coords" : e.shapeInfo.logicalShape.map((e, t) => "coords.".concat(h[t + u])).join(", "), "\n    float ".concat(r, "() {\n      ").concat(o, " coords = getOutputCoords();\n      ").concat(c, "\n      return get").concat(s, "(").concat(d, ");\n    }\n  ");
    }(e, t)), r;
  }(e, t, n.packedInputs, n.enableShapeUniforms)).join("\n"),
      i = t.texShape,
      o = dk(),
      l = function (e) {
    return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D, "(textureSampler, uv).r;\n    }\n  ");
  }(o);

  var u,
      c,
      h = function (e) {
    return "".concat(e.version, "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs, " vec2 resultUV;\n    ").concat(e.defineOutput, "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN, "\n    ").concat(e.defineSpecialInf, "\n    ").concat(e.defineRound, "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(wk, "\n    ").concat(vk, "\n    ").concat(Ik, "\n  ");
  }(o);

  return t.isPacked ? (u = function (e, t, n) {
    switch (e.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (e, t, n) {
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
          return 1 === s[0] ? n ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(s[1], ".0);\n      }\n    ") : 1 === s[1] ? n ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(s[0], ".0);\n      }\n    ") : n ? "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(s[0], ", ").concat(s[1], "));\n      return 2 * (resTexRC.x * ").concat(s[1], " + resTexRC.y);\n    }\n  ");
        }(0, t, n);

      case 2:
        return function (e, t, n) {
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
          if (p(e, t)) return n ? "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(s[0], ", ").concat(s[1], "));\n      }\n    ");
          var r = Math.ceil(e[1] / 2);
          return n ? "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(s[0], ", ").concat(s[1], "));\n\n      int index = resTexRC.x * ").concat(s[1], " + resTexRC.y;\n      int r = 2 * (index / ").concat(r, ");\n      int c = imod(index, ").concat(r, ") * 2;\n\n      return ivec2(r, c);\n    }\n  ");
        }(e, t, n);

      case 3:
        return function (e, t, n) {
          if (n) return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
              r = Math.ceil(e[2] / 2),
              a = r * Math.ceil(e[1] / 2);
          return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(s[0], ", ").concat(s[1], "));\n      int index = resTexRC.x * ").concat(s[1], " + resTexRC.y;\n\n      int b = index / ").concat(a, ";\n      index -= b * ").concat(a, ";\n\n      int r = 2 * (index / ").concat(r, ");\n      int c = imod(index, ").concat(r, ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ");
        }(e, t, n);

      default:
        return function (e, t, n) {
          if (n) return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
              r = Math.ceil(e[e.length - 1] / 2),
              a = r * Math.ceil(e[e.length - 2] / 2);
          var i = a,
              o = "",
              l = "b, r, c";

          for (var _t355 = 2; _t355 < e.length - 1; _t355++) {
            i *= e[e.length - _t355 - 1], o = "\n      int b".concat(_t355, " = index / ").concat(i, ";\n      index -= b").concat(_t355, " * ").concat(i, ";\n    ") + o, l = "b".concat(_t355, ", ") + l;
          }

          return "\n    ivec".concat(e.length, " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(s[0], ", ").concat(s[1], "));\n      int index = resTexRC.x * ").concat(s[1], " + resTexRC.y;\n\n      ").concat(o, "\n\n      int b = index / ").concat(a, ";\n      index -= b * ").concat(a, ";\n\n      int r = 2 * (index / ").concat(r, ");\n      int c = imod(index, ").concat(r, ") * 2;\n\n      return ivec").concat(e.length, "(").concat(l, ");\n    }\n  ");
        }(e, t, n);
    }
  }(t.logicalShape, i, n.enableShapeUniforms), c = function (e) {
    return "\n    void setOutput(vec4 val) {\n      ".concat(e.output, " = val;\n    }\n  ");
  }(o)) : (u = function (e, t, n) {
    switch (e.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (e, t, n) {
          return 1 === t[0] ? n ? "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1], ".0);\n      }\n    ") : 1 === t[1] ? n ? "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0], ".0);\n      }\n    ") : n ? "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      return resTexRC.x * ").concat(t[1], " + resTexRC.y;\n    }\n  ");
        }(0, t, n);

      case 2:
        return function (e, t, n) {
          return p(e, t) ? n ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0], ", ").concat(t[1], "));\n      }\n    ") : 1 === e[1] ? n ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0], ", ").concat(t[1], "));\n        int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ") : 1 === e[0] ? n ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0], ", ").concat(t[1], "));\n        int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ") : n ? "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      int r = index / ").concat(e[1], ";\n      int c = index - r * ").concat(e[1], ";\n      return ivec2(r, c);\n    }\n  ");
        }(e, t, n);

      case 3:
        return function (e, t, n) {
          if (n) return "\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(fk(["r", "c", "d"], e), "\n    return ivec3(r, c, d);\n  }\n");
          var s = pk(["r", "c", "d"], e);
          return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      ").concat(s, "\n      return ivec3(r, c, d);\n    }\n  ");
        }(e, t, n);

      case 4:
        return function (e, t, n) {
          if (n) return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(fk(["r", "c", "d", "d2"], e), "\n      return ivec4(r, c, d, d2);\n    }\n  ");
          var s = pk(["r", "c", "d", "d2"], e);
          return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      ").concat(s, "\n      return ivec4(r, c, d, d2);\n    }\n  ");
        }(e, t, n);

      case 5:
        return function (e, t) {
          var n = pk(["r", "c", "d", "d2", "d3"], e);
          return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0], ",\n                             ").concat(t[1], "));\n\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n\n      ").concat(n, "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ");
        }(e, t);

      case 6:
        return function (e, t) {
          var n = pk(["r", "c", "d", "d2", "d3", "d4"], e);
          return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n\n      ").concat(n, "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ");
        }(e, t);

      default:
        throw new Error("".concat(e.length, "-D output sampling is not yet supported"));
    }
  }(t.logicalShape, i, n.enableShapeUniforms), c = function (e) {
    return "\n    void setOutput(float val) {\n      ".concat(e.output, " = vec4(val, 0, 0, 0);\n    }\n  ");
  }(o)), n.packedInputs && (h += $k), [h, l, c, r, u, a, n.userCode].join("\n");
}

function yk(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  var n = e.shapeInfo.logicalShape;

  switch (n.length) {
    case 0:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1);
        if (e.shapeInfo.isUniform) return "float ".concat(s, "() {return ").concat(n, ";}");
        var [r, a] = e.shapeInfo.texShape;
        if (1 === r && 1 === a) return "\n      float ".concat(s, "() {\n        return sampleTexture(").concat(n, ", halfCR);\n      }\n    ");
        var i = Sk(n);
        if (t) return "\n    float ".concat(s, "() {\n      vec2 uv = uvFromFlat(").concat(n, "TexShape[0], ").concat(n, "TexShape[1], ").concat(i, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
        var [o, l] = e.shapeInfo.texShape;
        return "\n    float ".concat(s, "() {\n      vec2 uv = uvFromFlat(").concat(o, ", ").concat(l, ", ").concat(i, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e, t);

    case 1:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1);
        if (e.shapeInfo.isUniform) return "\n      float ".concat(s, "(int index) {\n        ").concat(Nk(e), "\n      }\n    ");
        var r = e.shapeInfo.texShape,
            a = r[0],
            i = r[1];
        if (1 === i && 1 === a) return "\n      float ".concat(s, "(int index) {\n        return sampleTexture(").concat(n, ", halfCR);\n      }\n    ");
        var o = Sk(n);
        return 1 === i ? t ? "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o, ") + 0.5) / float(").concat(n, "TexShape[0]));\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o, ") + 0.5) / ").concat(a, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : 1 === a ? t ? "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2((float(index + ").concat(o, ") + 0.5) / float(").concat(n, "TexShape[1]), 0.5);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2((float(index + ").concat(o, ") + 0.5) / ").concat(i, ".0, 0.5);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : t ? "\n    float ".concat(s, "(int index) {\n      vec2 uv = uvFromFlat(").concat(n, "TexShape[0], ").concat(n, "TexShape[1], index + ").concat(o, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ") : "\n    float ".concat(s, "(int index) {\n      vec2 uv = uvFromFlat(").concat(a, ", ").concat(i, ", index + ").concat(o, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e, t);

    case 2:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = e.shapeInfo.texShape;
        if (null != a && p(n, a)) return t ? "\n      float ".concat(r, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a[1], ".0, ").concat(a[0], ".0);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ");
        var {
          newShape: i,
          keptDims: o
        } = k(n);

        if (i.length < n.length) {
          var _n259 = ["row", "col"];
          return "\n      ".concat(yk(Ek(e, i), t), "\n      float ").concat(r, "(int row, int col) {\n        return ").concat(r, "(").concat(Rk(_n259, o), ");\n      }\n    ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1], ", 1)));\n        ").concat(Nk(e), "\n      }\n    ");
        var l = a[0],
            u = a[1],
            c = Sk(s);
        return 1 === u ? t ? "\n      float ".concat(r, "(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(s, "Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(s, "TexShape[0]));\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(n[1], ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l, ".0);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ") : 1 === l ? t ? "\n      float ".concat(r, "(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(s, "Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(s, "TexShape[1]), 0.5);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(n[1], ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u, ".0, 0.5);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ") : t ? "\n      float ".concat(r, "(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(s, "Shape[1] + col + ").concat(c, ";\n        vec2 uv = uvFromFlat(").concat(s, "TexShape[0], ").concat(s, "TexShape[1], index);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n  float ".concat(r, "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1], " + col + ").concat(c, ";\n    vec2 uv = uvFromFlat(").concat(l, ", ").concat(u, ", index);\n    return sampleTexture(").concat(s, ", uv);\n  }\n");
      }(e, t);

    case 3:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = n[1] * n[2],
            i = n[2],
            {
          newShape: o,
          keptDims: l
        } = k(n);

        if (o.length < n.length) {
          var _n260 = ["row", "col", "depth"];
          return "\n        ".concat(yk(Ek(e, o), t), "\n        float ").concat(r, "(int row, int col, int depth) {\n          return ").concat(r, "(").concat(Rk(_n260, l), ");\n        }\n      ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(a, ", ").concat(i, ", 1)));\n        ").concat(Nk(e), "\n      }\n    ");
        var u = e.shapeInfo.texShape,
            c = u[0],
            h = u[1],
            d = e.shapeInfo.flatOffset;
        if (h === a && null == d) return t ? "\n      float ".concat(r, "(int row, int col, int depth) {\n        int stride1 = ").concat(s, "Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n        float ".concat(r, "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(i, ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(h, ".0, ").concat(c, ".0);\n          return sampleTexture(").concat(s, ", uv);\n        }\n      ");
        if (h === i && null == d) return t ? "\n      float ".concat(r, "(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(s, "Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1], ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(h, ".0, ").concat(c, ".0);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ");
        var p = Sk(s);
        return t ? "\n    float ".concat(r, "(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(s, "Shape[1] * ").concat(s, "Shape[2];\n      int stride1 = ").concat(s, "Shape[2];\n      int index = row * ").concat(a, " + col * ").concat(i, " + depth + ").concat(p, ";\n      vec2 uv = uvFromFlat(").concat(s, "TexShape[0], ").concat(s, "TexShape[1], index);\n      return sampleTexture(").concat(s, ", uv);\n    }\n    ") : "\n      float ".concat(r, "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a, " + col * ").concat(i, " + depth + ").concat(p, ";\n        vec2 uv = uvFromFlat(").concat(c, ", ").concat(h, ", index);\n        return sampleTexture(").concat(s, ", uv);\n      }\n  ");
      }(e, t);

    case 4:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = n[3],
            i = n[2] * a,
            o = n[1] * i,
            {
          newShape: l,
          keptDims: u
        } = k(n);

        if (l.length < n.length) {
          var _n261 = ["row", "col", "depth", "depth2"];
          return "\n      ".concat(yk(Ek(e, l), t), "\n      float ").concat(r, "(int row, int col, int depth, int depth2) {\n        return ").concat(r, "(").concat(Rk(_n261, u), ");\n      }\n    ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(o, ", ").concat(i, ", ").concat(a, ", 1)));\n        ").concat(Nk(e), "\n      }\n    ");
        var c = e.shapeInfo.flatOffset,
            h = e.shapeInfo.texShape,
            d = h[0],
            p = h[1],
            f = "int stride2 = ".concat(s, "Shape[3];"),
            g = "int stride1 = ".concat(s, "Shape[2] * stride2;"),
            m = "int stride0 = ".concat(s, "Shape[1] * stride1;");
        if (p === o && null == c) return t ? "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        ").concat(f, "\n        ").concat(g, "\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(i, ", ").concat(a, ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ");
        if (p === a && null == c) return t ? "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(s, "Shape[1] * ").concat(s, "Shape[2], ").concat(s, "Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1] * n[2], ", ").concat(n[2], ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ");
        var b = Sk(s);
        return t ? "\n    float ".concat(r, "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f, "\n      ").concat(g, "\n      ").concat(m, "\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(s, "TexShape[0], ").concat(s, "TexShape[1], index + ").concat(b, ");\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ") : "\n    float ".concat(r, "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o, " + col * ").concat(i, " +\n          depth * ").concat(a, " + depth2;\n      vec2 uv = uvFromFlat(").concat(d, ", ").concat(p, ", index + ").concat(b, ");\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ");
      }(e, t);

    case 5:
      return function (e) {
        var t = e.shapeInfo.logicalShape,
            n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            r = t[4],
            a = t[3] * r,
            i = t[2] * a,
            o = t[1] * i,
            {
          newShape: l,
          keptDims: u
        } = k(t);

        if (l.length < t.length) {
          var _t356 = ["row", "col", "depth", "depth2", "depth3"];
          return "\n      ".concat(yk(Ek(e, l)), "\n      float ").concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(s, "(").concat(Rk(_t356, u), ");\n      }\n    ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(o, ", ").concat(i, ", ").concat(a, ", ").concat(r, ")) +\n          depth3;\n        ").concat(Nk(e), "\n      }\n    ");
        var c = e.shapeInfo.flatOffset,
            h = e.shapeInfo.texShape,
            d = h[0],
            p = h[1];
        return p === o && null == c ? "\n      float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(i, ", ").concat(a, ", ").concat(r, ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : p === r && null == c ? "\n      float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1] * t[2] * t[3], ",\n               ").concat(t[2] * t[3], ", ").concat(t[3], ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n    float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o, " + col * ").concat(i, " + depth * ").concat(a, " +\n          depth2 * ").concat(r, " + depth3 + ").concat(Sk(n), ";\n      vec2 uv = uvFromFlat(").concat(d, ", ").concat(p, ", index);\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e);

    case 6:
      return function (e) {
        var t = e.shapeInfo.logicalShape,
            n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            {
          newShape: r,
          keptDims: a
        } = k(t);

        if (r.length < t.length) {
          var _t357 = ["row", "col", "depth", "depth2", "depth3", "depth4"];
          return "\n      ".concat(yk(Ek(e, r)), "\n      float ").concat(s, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(s, "(").concat(Rk(_t357, a), ");\n      }\n    ");
        }

        var i = t[5],
            o = t[4] * i,
            l = t[3] * o,
            u = t[2] * l,
            c = t[1] * u;
        if (e.shapeInfo.isUniform) return "\n      float ".concat(s, "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(c, ", ").concat(u, ", ").concat(l, ", ").concat(o, ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(i, ", 1)));\n        ").concat(Nk(e), "\n      }\n    ");
        var h = e.shapeInfo.flatOffset,
            d = e.shapeInfo.texShape,
            p = d[0],
            f = d[1];
        return f === c && null == h ? "\n      float ".concat(s, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(u, ", ").concat(l, ", ").concat(o, ", ").concat(i, ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f, ".0, ").concat(p, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : f === i && null == h ? "\n      float ".concat(s, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1] * t[2] * t[3] * t[4], ",\n               ").concat(t[2] * t[3] * t[4], ",\n               ").concat(t[3] * t[4], ",\n               ").concat(t[4], ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f, ".0, ").concat(p, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n    float ".concat(s, "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(c, " + col * ").concat(u, " + depth * ").concat(l, " +\n          depth2 * ").concat(o, " + depth3 * ").concat(i, " + depth4 + ").concat(Sk(n), ";\n      vec2 uv = uvFromFlat(").concat(p, ", ").concat(f, ", index);\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e);

    default:
      throw new Error("".concat(n.length, "-D input sampling is not yet supported"));
  }
}

function kk(e, t) {
  switch (e.shapeInfo.logicalShape.length) {
    case 0:
      return function (e) {
        var t = e.name;
        return "\n    vec4 ".concat("get" + t.charAt(0).toUpperCase() + t.slice(1), "() {\n      return ").concat(dk().texture2D, "(").concat(t, ", halfCR);\n    }\n  ");
      }(e);

    case 1:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            r = e.shapeInfo.texShape,
            a = dk();
        if (t) return "\n    vec4 ".concat(s, "(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n, "TexShape[0]) / 2.0), ceil(float(").concat(n, "TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(a.texture2D, "(").concat(n, ", uv);\n    }\n  ");
        var i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)];
        return "\n    vec4 ".concat(s, "(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0], ", ").concat(i[1], ", index);\n      return ").concat(a.texture2D, "(").concat(n, ", uv);\n    }\n  ");
      }(e, t);

    case 2:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = e.shapeInfo.texShape,
            i = a[0],
            o = a[1],
            l = dk();
        if (null != a && p(n, a)) return t ? "\n      vec4 ".concat(r, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n\n        return ").concat(l.texture2D, "(").concat(s, ", uv);\n      }\n    ") : "\n      vec4 ".concat(r, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(o, ".0, ").concat(i, ".0);\n\n        return ").concat(l.texture2D, "(").concat(s, ", uv);\n      }\n    ");
        if (t) return "\n    vec4 ".concat(r, "(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(s, "TexShape[0]) / 2.0), ceil(float(").concat(s, "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(s, "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(l.texture2D, "(").concat(s, ", uv);\n    }\n  ");
        var u = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];
        return "\n    vec4 ".concat(r, "(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(Math.ceil(n[1] / 2), ", ").concat(u[0], ", ").concat(u[1], ", row, col);\n      return ").concat(l.texture2D, "(").concat(s, ", uv);\n    }\n  ");
      }(e, t);

    case 3:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = e.shapeInfo.texShape,
            i = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];

        if (1 === n[0]) {
          var _s208 = [1, 2],
              _a122 = ["b", "row", "col"];
          return "\n        ".concat(kk(Ek(e, n.slice(1)), t), "\n        vec4 ").concat(r, "(int b, int row, int col) {\n          return ").concat(r, "(").concat(Rk(_a122, _s208), ");\n        }\n      ");
        }

        var o = dk();
        if (t) return "\n    vec4 ".concat(r, "(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(s, "TexShape[0]) / 2.0), ceil(float(").concat(s, "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(s, "Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(s, "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(o.texture2D, "(").concat(s, ", uv);\n    }\n  ");
        var l = i[0],
            u = i[1],
            c = Math.ceil(n[2] / 2);
        return "\n    vec4 ".concat(r, "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(l, ", ").concat(u, ", ").concat(c * Math.ceil(n[1] / 2), ", ").concat(c, ", b, row, col);\n      return ").concat(o.texture2D, "(").concat(s, ", uv);\n    }\n  ");
      }(e, t);

    default:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            r = dk();
        if (t) return "\n    vec4 ".concat(s, "(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n, "Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n, "Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n, "Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n, "TexShape[0]) / 2.0), ceil(float(").concat(n, "TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D, "(").concat(n, ", uv);\n    }\n  ");
        var a = e.shapeInfo.logicalShape,
            i = a.length,
            o = e.shapeInfo.texShape,
            l = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)],
            u = l[0],
            c = l[1],
            h = Math.ceil(a[i - 1] / 2);
        var d = h * Math.ceil(a[i - 2] / 2),
            p = "int b, int row, int col",
            f = "b * ".concat(d, " + (row / 2) * ").concat(h, " + (col / 2)");

        for (var _e425 = 2; _e425 < i - 1; _e425++) {
          p = "int b".concat(_e425, ", ") + p, d *= a[i - _e425 - 1], f = "b".concat(_e425, " * ").concat(d, " + ") + f;
        }

        return "\n    vec4 ".concat(s, "(").concat(p, ") {\n      int index = ").concat(f, ";\n      int texR = index / ").concat(c, ";\n      int texC = index - texR * ").concat(c, ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(c, ", ").concat(u, ");\n      return ").concat(r.texture2D, "(").concat(n, ", uv);\n    }\n  ");
      }(e, t);
  }
}

var wk = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    vk = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    Ik = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    $k = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

function Sk(e) {
  return "offset".concat(e);
}

function Nk(e) {
  var t = e.name,
      n = d(e.shapeInfo.logicalShape);
  return n < 2 ? "return ".concat(t, ";") : "\n    for (int i = 0; i < ".concat(n, "; i++) {\n      if (i == index) {\n        return ").concat(t, "[i];\n      }\n    }\n  ");
}

function Ck(e) {
  if (e <= 1) return "int";
  if (2 === e) return "ivec2";
  if (3 === e) return "ivec3";
  if (4 === e) return "ivec4";
  if (5 === e) return "ivec5";
  if (6 === e) return "ivec6";
  throw Error("GPU for rank ".concat(e, " is not yet supported"));
}

function Tk(e, t, n) {
  var {
    newShape: s,
    keptDims: r
  } = k(t),
      a = t.length,
      i = e && 3 === a && 1 === t[0],
      o = i ? t.slice(1) : s,
      l = !e && a > 1 && !p(t, n) && s.length < a || i;
  return {
    useSqueezeShape: l,
    uniformShape: l ? o : t,
    keptDims: r
  };
}

function Ek(e, t) {
  var n = JSON.parse(JSON.stringify(e));
  return n.shapeInfo.logicalShape = t, n;
}

function Rk(e, t) {
  return t.map(t => e[t]).join(", ");
}

function Ak(e, t) {
  if (e.length !== t.length) throw Error("Binary was compiled with ".concat(e.length, " inputs, but was executed with ").concat(t.length, " inputs"));
  e.forEach((e, n) => {
    var s = e.logicalShape,
        r = t[n],
        a = r.shape;
    if (!p(s, a)) throw Error("Binary was compiled with different shapes than the current args. Shapes ".concat(s, " and ").concat(a, " must match"));
    if (e.isUniform && r.isUniform) return;
    var i = e.texShape,
        o = r.isUniform ? null : r.texData.texShape;
    if (!p(i, o)) throw Error("Binary was compiled with different texture shapes than the current args. Shape ".concat(i, " and ").concat(o, " must match"));
  });
}

function Fk(e) {
  return G().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e <= 4;
}

class Dk {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Ly.DENSE, this.customUniforms = [{
      name: "texShape",
      type: "ivec2"
    }];
    var t = dk();
    this.outputShape = e, this.enableShapeUniforms = Fk(this.outputShape.length), this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms ? fk(["r", "c", "d"], e) : pk(["r", "c", "d"], e), "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output, " = result;\n      }\n    ");
  }

}

class _k {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Ly.DENSE, this.customUniforms = [{
      name: "texShape",
      type: "ivec2"
    }];
    var t = dk();
    this.outputShape = e, this.enableShapeUniforms = Fk(this.outputShape.length), this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms ? fk(["r", "c", "d"], e) : pk(["r", "c", "d"], e), "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output, " = result;\n      }\n    ");
  }

}

class Ok {
  constructor(e) {
    this.variableNames = ["A"], this.outTexUsage = zy.DOWNLOAD;
    var t = dk();
    this.outputShape = e, this.userCode = "\n      ".concat(mk, "\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output, " = encode_float(x);\n      }\n    ");
  }

}

class Mk {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = zy.DOWNLOAD;
    var t = dk();
    this.outputShape = e, this.userCode = "\n      ".concat(mk, "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output, " = encode_float(x);\n      }\n    ");
  }

}

class Lk {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    this.variableNames = ["A"], this.customUniforms = [{
      name: "texShape",
      type: "ivec2"
    }];
    var n = dk();
    this.outputShape = e, this.enableShapeUniforms = Fk(this.outputShape.length);
    var s = "result";
    t && (s = "floor(result * 255. + 0.5)"), this.userCode = "\n      ".concat(this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : gk(e), "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ").concat(n.texture2D, "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ").concat(n.output, " = vec4(").concat(s, ", 0., 0., 0.);\n      }\n    ");
  }

}

class zk {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.customUniforms = [{
      name: "texShape",
      type: "ivec2"
    }];
    var n = dk();
    this.outputShape = e, this.enableShapeUniforms = Fk(this.outputShape.length);
    var s = "",
        r = "result";
    t && (r = "floor(result * 255. + 0.5)");

    for (var _t358 = 0; _t358 <= 1; _t358++) {
      for (var _r154 = 0; _r154 <= 1; _r154++) {
        var _a123 = 2 * _t358 + _r154;

        s += "\n          localCoords = coords;\n          if(localCoords[2] + ".concat(_r154, " < ").concat(this.enableShapeUniforms ? "outShape[2]" : "".concat(e[2]), ") {\n          localCoords[2] += ").concat(_r154, ";\n          if (localCoords[1] + ").concat(_t358, " < ").concat(this.enableShapeUniforms ? "outShape[1]" : "".concat(e[1]), ") {\n            localCoords[1] += ").concat(_t358, ";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D, "(A, uv);\n\n            if (offset == 0) {\n              result[").concat(_a123, "] = values[0];\n            } else if (offset == 1) {\n              result[").concat(_a123, "] = values[1];\n            } else if (offset == 2) {\n              result[").concat(_a123, "] = values[2];\n            } else {\n              result[").concat(_a123, "] = values[3];\n            }\n          }\n        }\n        ");
      }
    }

    this.userCode = "\n        ".concat(this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : gk(e), "\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(s, "\n\n          ").concat(n.output, " = ").concat(r, ";\n        }\n    ");
  }

}

function Bk(e, t, n, s, r, a) {
  !function (e, t) {
    var n = G().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (e <= 0 || t <= 0) throw new Error("Requested texture size [".concat(e, "x").concat(t, "] is invalid."));
    if (e > n || t > n) throw new Error("Requested texture size [".concat(e, "x").concat(t, "] greater than WebGL maximum on this browser / GPU [").concat(n, "x").concat(n, "]."));
  }(t, n);

  var i = function (e) {
    return Qy(e, () => e.createTexture(), "Unable to create WebGLTexture.");
  }(e),
      o = e.TEXTURE_2D;

  return Gy(e, () => e.bindTexture(o, i)), Gy(e, () => e.texParameteri(o, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE)), Gy(e, () => e.texParameteri(o, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), Gy(e, () => e.texParameteri(o, e.TEXTURE_MIN_FILTER, e.NEAREST)), Gy(e, () => e.texParameteri(o, e.TEXTURE_MAG_FILTER, e.NEAREST)), Gy(e, () => e.texImage2D(o, 0, s, t, n, 0, r, a, null)), Gy(e, () => e.bindTexture(e.TEXTURE_2D, null)), i;
}

function Pk(e) {
  return e.internalFormatFloat;
}

function Wk(e) {
  return e.internalFormatHalfFloat;
}

function Uk(e) {
  return e.downloadTextureFormat;
}

function Vk(e) {
  return e.internalFormatPackedFloat;
}

function Gk(e) {
  return e.internalFormatPackedHalfFloat;
}

class Hk {
  constructor(e) {
    this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
    var t = G().getNumber("WEBGL_VERSION");
    null != e ? (this.gl = e, function (e, t) {
      _y[e] = t;
    }(t, e)) : this.gl = My(t);
    var n = "WEBGL_color_buffer_float";
    var s = "EXT_color_buffer_half_float";

    if (1 === G().getNumber("WEBGL_VERSION")) {
      var _e426 = "OES_texture_half_float";
      if (this.textureFloatExtension = qy(this.gl, "OES_texture_float"), ok(this.gl, _e426)) this.textureHalfFloatExtension = qy(this.gl, _e426);else if (G().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(n), ok(this.gl, s)) this.colorBufferHalfFloatExtension = qy(this.gl, s);else if (G().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (n = "EXT_color_buffer_float", ok(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);else {
      if (!ok(this.gl, s)) throw new Error("GL context does not support color renderable floats");
      this.colorBufferHalfFloatExtension = this.gl.getExtension(s);
    }

    this.vertexBuffer = function (e) {
      return function (e, t) {
        var n = Qy(e, () => e.createBuffer(), "Unable to create WebGLBuffer");
        return Gy(e, () => e.bindBuffer(e.ARRAY_BUFFER, n)), Gy(e, () => e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW)), n;
      }(e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
    }(this.gl), this.indexBuffer = function (e) {
      return function (e, t) {
        var n = Qy(e, () => e.createBuffer(), "Unable to create WebGLBuffer");
        return Gy(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n)), Gy(e, () => e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW)), n;
      }(e, new Uint16Array([0, 1, 2, 2, 1, 3]));
    }(this.gl), this.framebuffer = function (e) {
      return Qy(e, () => e.createFramebuffer(), "Unable to create WebGLFramebuffer.");
    }(this.gl), this.textureConfig = Vy(this.gl, this.textureHalfFloatExtension);
  }

  get debug() {
    return G().getBool("DEBUG");
  }

  dispose() {
    if (this.disposed) return;
    null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
    var e = this.gl;
    Gy(e, () => e.finish()), Gy(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), Gy(e, () => e.deleteFramebuffer(this.framebuffer)), Gy(e, () => e.bindBuffer(e.ARRAY_BUFFER, null)), Gy(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)), Gy(e, () => e.deleteBuffer(this.indexBuffer)), this.disposed = !0;
  }

  createFloat32MatrixTexture(e, t) {
    return this.throwIfDisposed(), function (e, t, n, s) {
      var [r, a] = Py(t, n);
      return Bk(e, r, a, Pk(s), s.textureFormatFloat, e.FLOAT);
    }(this.gl, e, t, this.textureConfig);
  }

  createFloat16MatrixTexture(e, t) {
    return this.throwIfDisposed(), function (e, t, n, s) {
      var [r, a] = Py(t, n);
      return Bk(e, r, a, Wk(s), s.textureFormatFloat, s.textureTypeHalfFloat);
    }(this.gl, e, t, this.textureConfig);
  }

  createUnsignedBytesMatrixTexture(e, t) {
    return this.throwIfDisposed(), function (e, t, n, s) {
      var [r, a] = Py(t, n);
      return Bk(e, r, a, Uk(s), e.RGBA, e.UNSIGNED_BYTE);
    }(this.gl, e, t, this.textureConfig);
  }

  uploadPixelDataToTexture(e, t) {
    this.throwIfDisposed(), function (e, t, n) {
      Gy(e, () => e.bindTexture(e.TEXTURE_2D, t)), n.data instanceof Uint8Array ? Gy(e, () => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, n.width, n.height, 0, e.RGBA, e.UNSIGNED_BYTE, n.data)) : Gy(e, () => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n)), Gy(e, () => e.bindTexture(e.TEXTURE_2D, null));
    }(this.gl, e, t);
  }

  uploadDenseMatrixToTexture(e, t, n, s) {
    this.throwIfDisposed(), function (e, t, n, s, r, a) {
      var i, o, l;
      Gy(e, () => e.bindTexture(e.TEXTURE_2D, t)), r instanceof Uint8Array ? (i = new Uint8Array(n * s * 4), o = e.UNSIGNED_BYTE, l = e.RGBA) : (i = new Float32Array(n * s * 4), o = e.FLOAT, l = a.internalFormatPackedFloat), i.set(r), Gy(e, () => e.texImage2D(e.TEXTURE_2D, 0, l, n, s, 0, e.RGBA, o, i)), Gy(e, () => e.bindTexture(e.TEXTURE_2D, null));
    }(this.gl, e, t, n, s, this.textureConfig);
  }

  createFloat16PackedMatrixTexture(e, t) {
    return this.throwIfDisposed(), function (e, t, n, s) {
      var [r, a] = Uy(t, n);
      return Bk(e, r, a, Gk(s), e.RGBA, s.textureTypeHalfFloat);
    }(this.gl, e, t, this.textureConfig);
  }

  createPackedMatrixTexture(e, t) {
    return this.throwIfDisposed(), function (e, t, n, s) {
      var [r, a] = Uy(t, n);
      return Bk(e, r, a, Vk(s), e.RGBA, e.FLOAT);
    }(this.gl, e, t, this.textureConfig);
  }

  deleteMatrixTexture(e) {
    this.throwIfDisposed(), this.outputTexture === e && (Jy(this.gl, this.framebuffer), this.outputTexture = null), Gy(this.gl, () => this.gl.deleteTexture(e));
  }

  downloadByteEncodedFloatMatrixFromOutputTexture(e, t, n) {
    return this.downloadMatrixDriver(e, () => function (e, t, n, s) {
      var [r, a] = Py(t, n),
          i = new Uint8Array(t * n * 4);
      return Gy(e, () => e.readPixels(0, 0, r, a, s.downloadTextureFormat, e.UNSIGNED_BYTE, i)), new Float32Array(i.buffer);
    }(this.gl, t, n, this.textureConfig));
  }

  downloadPackedMatrixFromBuffer(e, t, n, s, r, a) {
    return function (e, t, n, s, r, a, i, o) {
      var l = e,
          u = new Float32Array(function (e, t) {
        var [n, s] = Uy(e, t);
        return n * s * 4;
      }(a, i));
      return l.bindBuffer(l.PIXEL_PACK_BUFFER, t), l.getBufferSubData(l.PIXEL_PACK_BUFFER, 0, u), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), u;
    }(this.gl, e, 0, 0, 0, r, a);
  }

  downloadFloat32MatrixFromBuffer(e, t) {
    return function (e, t, n) {
      var s = e,
          r = new Float32Array(n);
      return s.bindBuffer(s.PIXEL_PACK_BUFFER, t), s.getBufferSubData(s.PIXEL_PACK_BUFFER, 0, r), s.bindBuffer(s.PIXEL_PACK_BUFFER, null), r;
    }(this.gl, e, t);
  }

  createBufferFromTexture(e, t, n) {
    this.bindTextureToFrameBuffer(e);

    var s = function (e, t, n, s) {
      var r = e.createBuffer();
      Gy(e, () => e.bindBuffer(e.PIXEL_PACK_BUFFER, r));
      var a = 16 * t * n;
      return Gy(e, () => e.bufferData(e.PIXEL_PACK_BUFFER, a, e.STREAM_READ)), Gy(e, () => e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, 0)), Gy(e, () => e.bindBuffer(e.PIXEL_PACK_BUFFER, null)), r;
    }(this.gl, t, n);

    return this.unbindTextureToFrameBuffer(), s;
  }

  createAndWaitForFence() {
    var e = this.createFence(this.gl);
    return this.pollFence(e);
  }

  createFence(e) {
    var t, n;

    if (G().getBool("WEBGL_FENCE_API_ENABLED")) {
      var _s209 = e,
          _r155 = _s209.fenceSync(_s209.SYNC_GPU_COMMANDS_COMPLETE, 0);

      e.flush(), n = () => {
        var e = _s209.clientWaitSync(_r155, 0, 0);

        return e === _s209.ALREADY_SIGNALED || e === _s209.CONDITION_SATISFIED;
      }, t = _r155;
    } else G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), this.endQuery(), n = () => this.isQueryAvailable(t, G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : n = () => !0;

    return {
      query: t,
      isFencePassed: n
    };
  }

  downloadMatrixFromPackedTexture(e, t, n) {
    return this.downloadMatrixDriver(e, () => function (e, t, n) {
      var s = new Float32Array(t * n * 4);
      return Gy(e, () => e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, s)), s;
    }(this.gl, t, n));
  }

  createProgram(e) {
    this.throwIfDisposed();

    var t = this.gl,
        n = function (e, t) {
      var n = Qy(e, () => e.createShader(e.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
      if (Gy(e, () => e.shaderSource(n, t)), Gy(e, () => e.compileShader(n)), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw function (e, t) {
        var n = jy.exec(t);
        if (null == n) return console.log("Couldn't parse line number in error: ".concat(t)), void console.log(e);
        var s = +n[1],
            r = e.split("\n"),
            a = r.length.toString().length + 2,
            i = r.map((e, t) => m((t + 1).toString(), a) + e);
        var o = 0;

        for (var _e427 = 0; _e427 < i.length; _e427++) {
          o = Math.max(i[_e427].length, o);
        }

        var l = i.slice(0, s - 1),
            u = i.slice(s - 1, s),
            c = i.slice(s);
        console.log(l.join("\n")), console.log(t.split("\n")[0]), console.log("%c ".concat(m(u[0], o)), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(c.join("\n"));
      }(t, e.getShaderInfoLog(n)), new Error("Failed to compile fragment shader.");
      return n;
    }(t, e);

    null == this.vertexShader && (this.vertexShader = function (e) {
      var t = dk();
      return function (e, t) {
        var n = Qy(e, () => e.createShader(e.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
        if (Gy(e, () => e.shaderSource(n, t)), Gy(e, () => e.compileShader(n)), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw console.log(e.getShaderInfoLog(n)), new Error("Failed to compile vertex shader.");
        return n;
      }(e, "".concat(t.version, "\n    precision highp float;\n    ").concat(t.attribute, " vec3 clipSpacePos;\n    ").concat(t.attribute, " vec2 uv;\n    ").concat(t.varyingVs, " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"));
    }(t));

    var s = function (e) {
      return Qy(e, () => e.createProgram(), "Unable to create WebGLProgram.");
    }(t);

    return Gy(t, () => t.attachShader(s, this.vertexShader)), Gy(t, () => t.attachShader(s, n)), function (e, t) {
      if (Gy(e, () => e.linkProgram(t)), !1 === e.getProgramParameter(t, e.LINK_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.");
    }(t, s), this.debug && Ky(t, s), this.vertexAttrsAreBound || (this.setProgram(s), this.vertexAttrsAreBound = function (e, t, n) {
      return Gy(e, () => e.bindBuffer(e.ARRAY_BUFFER, n)), Xy(e, t, "clipSpacePos", n, 3, 20, 0) && Xy(e, t, "uv", n, 2, 20, 12);
    }(t, this.program, this.vertexBuffer)), s;
  }

  deleteProgram(e) {
    this.throwIfDisposed(), e === this.program && (this.program = null), null != e && Gy(this.gl, () => this.gl.deleteProgram(e));
  }

  setProgram(e) {
    this.throwIfDisposed(), this.program = e, null != this.program && this.debug && Ky(this.gl, this.program), Gy(this.gl, () => this.gl.useProgram(e));
  }

  getUniformLocation(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    return this.throwIfDisposed(), n ? function (e, t, n) {
      return Qy(e, () => e.getUniformLocation(t, n), 'uniform "' + n + '" not present in program.');
    }(this.gl, e, t) : function (e, t, n) {
      return e.getUniformLocation(t, n);
    }(this.gl, e, t);
  }

  getAttributeLocation(e, t) {
    return this.throwIfDisposed(), Gy(this.gl, () => this.gl.getAttribLocation(e, t));
  }

  getUniformLocationNoThrow(e, t) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(e, t);
  }

  setInputMatrixTexture(e, t, n) {
    this.throwIfDisposed(), this.throwIfNoProgram(), function (e, t, n, s) {
      Gy(e, () => function (e, t, n) {
        !function (e, t) {
          var n = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
              s = t + e.TEXTURE0;
          if (s < e.TEXTURE0 || s > n) throw new Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE".concat(n, "]."));
        }(e, n), Gy(e, () => e.activeTexture(e.TEXTURE0 + n)), Gy(e, () => e.bindTexture(e.TEXTURE_2D, t));
      }(e, t, s)), Gy(e, () => e.uniform1i(n, s));
    }(this.gl, e, t, n);
  }

  setOutputMatrixTexture(e, t, n) {
    this.setOutputMatrixTextureDriver(e, n, t);
  }

  setOutputPackedMatrixTexture(e, t, n) {
    this.throwIfDisposed();
    var [s, r] = Uy(t, n);
    this.setOutputMatrixTextureDriver(e, s, r);
  }

  setOutputMatrixWriteRegion(e, t, n, s) {
    this.setOutputMatrixWriteRegionDriver(n, e, s, t);
  }

  setOutputPackedMatrixWriteRegion(e, t, n, s) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }

  debugValidate() {
    null != this.program && Ky(this.gl, this.program), Zy(this.gl);
  }

  executeProgram() {
    this.throwIfDisposed(), this.throwIfNoProgram();
    var e = this.gl;
    this.debug && this.debugValidate(), Gy(e, () => e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
  }

  blockUntilAllProgramsCompleted() {
    this.throwIfDisposed(), Gy(this.gl, () => this.gl.finish());
  }

  getQueryTimerExtension() {
    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = qy(this.gl, 2 === G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }

  getQueryTimerExtensionWebGL2() {
    return this.getQueryTimerExtension();
  }

  getQueryTimerExtensionWebGL1() {
    return this.getQueryTimerExtension();
  }

  beginQuery() {
    if (2 === G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var _e428 = this.gl,
          _t359 = this.getQueryTimerExtensionWebGL2(),
          _n262 = _e428.createQuery();

      return _e428.beginQuery(_t359.TIME_ELAPSED_EXT, _n262), _n262;
    }

    var e = this.getQueryTimerExtensionWebGL1(),
        t = e.createQueryEXT();
    return e.beginQueryEXT(e.TIME_ELAPSED_EXT, t), t;
  }

  endQuery() {
    if (2 === G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var _e429 = this.gl,
          _t360 = this.getQueryTimerExtensionWebGL2();

      return void _e429.endQuery(_t360.TIME_ELAPSED_EXT);
    }

    var e = this.getQueryTimerExtensionWebGL1();
    e.endQueryEXT(e.TIME_ELAPSED_EXT);
  }

  waitForQueryAndGetTime(e) {
    var _this72 = this;

    return _asyncToGenerator(function* () {
      return yield b(() => _this72.disposed || _this72.isQueryAvailable(e, G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), _this72.getQueryTime(e, G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    })();
  }

  getQueryTime(e, t) {
    if (0 === t) return null;

    if (2 === t) {
      var _t361 = this.gl;
      return _t361.getQueryParameter(e, _t361.QUERY_RESULT) / 1e6;
    }

    {
      var _t362 = this.getQueryTimerExtensionWebGL1();

      return _t362.getQueryObjectEXT(e, _t362.QUERY_RESULT_EXT) / 1e6;
    }
  }

  isQueryAvailable(e, t) {
    if (0 === t) return !0;

    if (2 === t) {
      var _t363 = this.gl,
          _n263 = this.getQueryTimerExtensionWebGL2(),
          _s210 = _t363.getQueryParameter(e, _t363.QUERY_RESULT_AVAILABLE);

      return null == this.disjoint && (this.disjoint = this.gl.getParameter(_n263.GPU_DISJOINT_EXT)), _s210 && !this.disjoint;
    }

    {
      var _t364 = this.getQueryTimerExtensionWebGL1(),
          _n264 = _t364.getQueryObjectEXT(e, _t364.QUERY_RESULT_AVAILABLE_EXT);

      return null == this.disjoint && (this.disjoint = this.gl.getParameter(_t364.GPU_DISJOINT_EXT)), _n264 && !this.disjoint;
    }
  }

  pollFence(e) {
    return new Promise(t => {
      this.addItemToPoll(() => e.isFencePassed(), () => t());
    });
  }

  pollItems() {
    var e = function (e) {
      var t = 0;

      for (; t < e.length && e[t](); ++t) {
        ;
      }

      return t - 1;
    }(this.itemsToPoll.map(e => e.isDoneFn));

    for (var _t365 = 0; _t365 <= e; ++_t365) {
      var {
        resolveFn: _e430
      } = this.itemsToPoll[_t365];

      _e430();
    }

    this.itemsToPoll = this.itemsToPoll.slice(e + 1);
  }

  addItemToPoll(e, t) {
    this.itemsToPoll.push({
      isDoneFn: e,
      resolveFn: t
    }), this.itemsToPoll.length > 1 || b(() => (this.pollItems(), 0 === this.itemsToPoll.length));
  }

  bindTextureToFrameBuffer(e) {
    this.throwIfDisposed(), Yy(this.gl, e, this.framebuffer), this.debug && Zy(this.gl);
  }

  unbindTextureToFrameBuffer() {
    null != this.outputTexture ? (Yy(this.gl, this.outputTexture, this.framebuffer), this.debug && Zy(this.gl)) : Jy(this.gl, this.framebuffer);
  }

  downloadMatrixDriver(e, t) {
    this.bindTextureToFrameBuffer(e);
    var n = t();
    return this.unbindTextureToFrameBuffer(), n;
  }

  setOutputMatrixTextureDriver(e, t, n) {
    this.throwIfDisposed();
    var s = this.gl;
    Yy(s, e, this.framebuffer), this.debug && Zy(s), this.outputTexture = e, Gy(s, () => s.viewport(0, 0, t, n)), Gy(s, () => s.scissor(0, 0, t, n));
  }

  setOutputMatrixWriteRegionDriver(e, t, n, s) {
    this.throwIfDisposed(), Gy(this.gl, () => this.gl.scissor(e, t, n, s));
  }

  throwIfDisposed() {
    if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
  }

  throwIfNoProgram() {
    if (null == this.program) throw new Error("No GPU program is currently set.");
  }

}

var {
  addImpl: qk,
  bincountImpl: jk,
  bincountReduceImpl: Kk,
  ceilImpl: Xk,
  concatImpl: Yk,
  equalImpl: Jk,
  expImpl: Zk,
  expm1Impl: Qk,
  floorImpl: ew,
  gatherNdImpl: tw,
  gatherV2Impl: nw,
  greaterImpl: sw,
  greaterEqualImpl: rw,
  lessImpl: aw,
  lessEqualImpl: iw,
  linSpaceImpl: ow,
  logImpl: lw,
  maxImpl: uw,
  maximumImpl: cw,
  minimumImpl: hw,
  multiplyImpl: dw,
  negImpl: pw,
  notEqualImpl: fw,
  prodImpl: gw,
  rangeImpl: mw,
  rsqrtImpl: bw,
  sigmoidImpl: xw,
  simpleAbsImpl: yw,
  sliceImpl: kw,
  sparseFillEmptyRowsImpl: ww,
  sparseReshapeImpl: vw,
  sparseSegmentReductionImpl: Iw,
  sqrtImpl: $w,
  stridedSliceImpl: Sw,
  stringNGramsImpl: Nw,
  stringSplitImpl: Cw,
  stringToHashBucketFastImpl: Tw,
  subImpl: Ew,
  tileImpl: Rw,
  topKImpl: Aw,
  transposeImpl: Fw,
  uniqueImpl: Dw
} = Rm;

function _w(e, t) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, t).map(t => "".concat(e, ".").concat(t));
}

function Ow(e, t) {
  return 1 === t ? [e] : _w(e, t);
}

class Mw {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = e;
    var t = e.length;
    if (0 === t) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else {
      var _n265 = Ow("rc", t),
          _s211 = Ck(t),
          _r156 = function (e, t, n) {
        if (1 === e) return "rc > ".concat(t[0]);
        var s = "";

        for (var _r157 = e - 2; _r157 < e; _r157++) {
          s += "".concat(n[_r157], " >= ").concat(t[_r157]), _r157 < e - 1 && (s += "||");
        }

        return s;
      }(t, e, _n265),
          _a124 = function (e, t, n, s) {
        if (1 === e) return "";
        var r = s.slice(-2);
        return "\n    int r = ".concat(r[0], ";\n    int c = ").concat(r[1], ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ").concat(t, ";\n    bool rEdge = rp1 >= ").concat(n, ";\n  ");
      }(t, e[e.length - 1], e[e.length - 2], _n265),
          _i86 = function (e, t) {
        var n = e.length,
            s = function (e, t) {
          var n = [];

          for (var _s212 = 0; _s212 <= 1; _s212++) {
            for (var _r158 = 0; _r158 <= 1; _r158++) {
              var _a125 = "".concat(0 === _s212 ? "r" : "rp1", ", ").concat(0 === _r158 ? "c" : "cp1");

              for (var _n266 = 2; _n266 < e; _n266++) {
                _a125 = "".concat(t[t.length - 1 - _n266], ",") + _a125;
              }

              n.push(_a125);
            }
          }

          return n;
        }(n, t);

        return 1 === n ? "getA(rc),\n            rc + 1 >= ".concat(e[0], " ? 0. : getA(rc + 1),\n            0, 0") : "getA(".concat(s[0], "),\n          cEdge ? 0. : getA(").concat(s[1], "),\n          rEdge ? 0. : getA(").concat(s[2], "),\n          rEdge || cEdge ? 0. : getA(").concat(s[3], ")");
      }(e, _n265);

      this.userCode = "\n        void main() {\n          ".concat(_s211, " rc = getOutputCoords();\n\n          if(").concat(_r156, ") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(_a124, "\n\n            setOutput(vec4(").concat(_i86, "));\n          }\n        }\n      ");
    }
  }

}

class Lw {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
      name: "inputShape",
      type: "ivec3"
    }], this.outputShape = e, this.enableShapeUniforms = Fk(this.outputShape.length);
    var n = "";

    for (var _e431 = 0; _e431 < 4; _e431++) {
      var _t366 = "thisRC = rc;";
      _e431 % 2 == 1 && (_t366 += "thisRC.z += 1;"), _e431 > 1 && (_t366 += "thisRC.y += 1;"), n += "\n        ".concat(_t366, "\n        ").concat(_e431 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "", "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(_e431, "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(_e431 > 0 ? "}" : "", "\n      ");
    }

    var s, r;
    this.userCode = "\n      ".concat((s = t, r = this.enableShapeUniforms, "\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(r ? function (e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "index";

      var s = function (e, t) {
        var n = e.length,
            s = e.map(e => "".concat(t, "[").concat(e, "]")),
            r = new Array(n - 1);
        r[n - 2] = s[n - 1];

        for (var _e432 = n - 3; _e432 >= 0; --_e432) {
          r[_e432] = "(".concat(r[_e432 + 1], " * ").concat(s[_e432 + 1], ")");
        }

        return r;
      }(e.map((e, t) => t), t);

      return s.map((t, r) => "int ".concat(e[r], " = ").concat(n, " / ").concat(s[r], "; ").concat(r === s.length - 1 ? "int ".concat(e[r + 1], " = ").concat(n, " - ").concat(e[r], " * ").concat(s[r]) : "index -= ".concat(e[r], " * ").concat(s[r]), ";")).join("");
    }(["r", "c", "d"], "inputShape") : pk(["r", "c", "d"], s), "\n      return ivec3(r, c, d);\n    }\n  ")), "\n      ").concat(this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : gk(e), "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms ? "outShape[1]" : e[1], ";\n        int cols = ").concat(this.enableShapeUniforms ? "outShape[2]" : e[2], ";\n\n        ").concat(n, "\n\n        setOutput(result);\n      }\n    ");
  }

}

class zw {
  constructor(e) {
    this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};
  }

  acquireTexture(e, t, n) {
    var s = Pw(t, n),
        r = Ww(e, s, n);
    r in this.freeTextures || (this.freeTextures[r] = []), r in this.usedTextures || (this.usedTextures[r] = []);
    var a = Bw(e, s, this.gpgpu.gl, this.gpgpu.textureConfig, n);

    if (this.freeTextures[r].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= a, this.log();

      var _e433 = this.freeTextures[r].shift();

      return this.usedTextures[r].push(_e433), _e433;
    }

    var i;
    return s === By.PACKED_2X2_FLOAT32 ? i = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : s === By.PACKED_2X2_FLOAT16 ? i = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : s === By.UNPACKED_FLOAT32 ? i = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : s === By.UNPACKED_FLOAT16 ? i = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : s === By.PACKED_4X1_UNSIGNED_BYTE && (i = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[r].push(i), this.numUsedTextures++, this._numBytesAllocated += a, this.log(), i;
  }

  releaseTexture(e, t, n, s) {
    if (null == this.freeTextures) return;
    var r = Pw(n, s),
        a = Ww(t, r, s);
    a in this.freeTextures || (this.freeTextures[a] = []);
    var i = Bw(t, r, this.gpgpu.gl, this.gpgpu.textureConfig, s),
        o = G().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
    -1 !== o && this._numBytesAllocated > o ? (this.gpgpu.deleteMatrixTexture(e), this._numBytesAllocated -= i) : (this.freeTextures[a].push(e), this.numFreeTextures++, this._numBytesFree += i), this.numUsedTextures--;
    var l = this.usedTextures[a],
        u = l.indexOf(e);
    if (u < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
    l.splice(u, 1), this.log();
  }

  log() {
    if (!this.logEnabled) return;
    console.log("Free/Used", "".concat(this.numFreeTextures, " / ").concat(this.numUsedTextures), "(".concat(this.numFreeTextures + this.numUsedTextures, ")"));
    var e = this._numBytesFree / this._numBytesAllocated;
    console.log("Bytes allocated: ".concat(this._numBytesAllocated)), console.log("Bytes unused: ".concat(this._numBytesFree, " (").concat(Math.round(100 * e), "%)"));
  }

  get numBytesAllocated() {
    return this._numBytesAllocated;
  }

  get numBytesFree() {
    return this._numBytesFree;
  }

  getNumUsedTextures() {
    return this.numUsedTextures;
  }

  getNumFreeTextures() {
    return this.numFreeTextures;
  }

  dispose() {
    if (null != this.freeTextures) {
      for (var _e434 in this.freeTextures) {
        this.freeTextures[_e434].forEach(e => {
          this.gpgpu.deleteMatrixTexture(e);
        });
      }

      for (var _e435 in this.usedTextures) {
        this.usedTextures[_e435].forEach(e => {
          this.gpgpu.deleteMatrixTexture(e);
        });
      }

      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
    }
  }

}

function Bw(e, t, n, s, r) {
  var a = function (e, t) {
    switch (e) {
      case By.PACKED_2X2_FLOAT32:
        return Vk(t);

      case By.PACKED_2X2_FLOAT16:
        return Gk(t);

      case By.UNPACKED_FLOAT32:
        return Pk(t);

      case By.UNPACKED_FLOAT16:
        return Wk(t);

      case By.PACKED_4X1_UNSIGNED_BYTE:
        return Uk(t);

      default:
        throw new Error("Unknown physical texture type ".concat(e));
    }
  }(t, s);

  var i;

  if (r) {
    var [_t367, _n267] = Uy(e[0], e[1]);
    i = _t367 * _n267;
  } else {
    var [_t368, _n268] = Py(e[0], e[1]);
    i = _t368 * _n268;
  }

  return i * function (e, t) {
    if (t === e.R32F) return 4;
    if (t === e.R16F) return 2;
    if (t === e.RGBA32F) return 16;
    if (t === e.RGBA) return 16;
    if (t === e.RGBA16F) return 8;
    throw new Error("Unknown internal format ".concat(t));
  }(n, a);
}

function Pw(e, t) {
  if (e === zy.UPLOAD) return By.PACKED_2X2_FLOAT32;
  if (e === zy.RENDER || null == e) return function (e) {
    return G().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? e ? By.PACKED_2X2_FLOAT32 : By.UNPACKED_FLOAT32 : e ? By.PACKED_2X2_FLOAT16 : By.UNPACKED_FLOAT16;
  }(t);
  if (e === zy.DOWNLOAD || e === zy.PIXELS) return By.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type ".concat(e));
}

function Ww(e, t, n) {
  return "".concat(e[0], "_").concat(e[1], "_").concat(t, "_").concat(n);
}

class Uw {
  constructor(e, t) {
    this.variableNames = ["A"], this.outputShape = e, this.enableShapeUniforms = Fk(this.outputShape.length), this.userCode = "\n      float unaryOperation(float x) {\n        ".concat(t, "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
  }

}

var Vw = "return x;";

class Gw {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.enableShapeUniforms = Fk(this.outputShape.length), this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t, "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
  }

}

class Hw {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = e;

    var t = e.length,
        n = Ow("rc", t),
        s = Ck(t),
        r = function (e, t) {
      if (1 === e) return "rc";
      var n = "";

      for (var _s213 = 0; _s213 < e; _s213++) {
        n += t[_s213], _s213 < e - 1 && (n += ",");
      }

      return n;
    }(t, n),
        a = n.slice(-2),
        i = t <= 1 ? "rc" : "vec2(".concat(a.join(","), ")");

    this.userCode = "\n      void main() {\n        ".concat(s, " rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r, ");\n\n        setOutput(getChannel(packedInput, ").concat(i, "));\n      }\n    ");
  }

}

var qw = $i,
    jw = {},
    Kw = G().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");

class Xw extends n {
  constructor(e) {
    if (super(), this.pendingRead = new WeakMap(), this.pendingDisposal = new WeakSet(), this.dataRefCount = new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = !1, this.pendingDeletes = 0, this.disposed = !1, !G().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");

    if (null == e) {
      var _e436 = My(G().getNumber("WEBGL_VERSION"));

      this.binaryCache = ((n = G().getNumber("WEBGL_VERSION")) in jw || (jw[n] = {}), jw[n]), this.gpgpu = new Hk(_e436), this.canvas = _e436.canvas, this.gpgpuCreatedLocally = !0;
    } else this.gpgpu = e, this.binaryCache = {}, this.gpgpuCreatedLocally = !1, this.canvas = e.gl.canvas;

    var n;
    this.textureManager = new zw(this.gpgpu), this.numMBBeforeWarning = null == G().global.screen ? 1024 : G().global.screen.height * G().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024, this.texData = new t(this, Xn());
  }

  nextDataId() {
    return Xw.nextDataId++;
  }

  numDataIds() {
    return this.texData.numDataIds() - this.pendingDeletes;
  }

  write(e, t, n) {
    if ((G().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || G().getBool("DEBUG")) && this.checkNumericalProblems(e), "complex64" === n && null != e) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    var s = {
      id: this.nextDataId()
    };
    return this.texData.set(s, {
      shape: t,
      dtype: n,
      values: e,
      usage: zy.UPLOAD,
      refCount: 1
    }), s;
  }

  refCount(e) {
    return this.texData.has(e) ? this.texData.get(e).refCount : 0;
  }

  incRef(e) {
    this.texData.get(e).refCount++;
  }

  decRef(e) {
    this.texData.has(e) && this.texData.get(e).refCount--;
  }

  move(e, t, n, s, r) {
    if (G().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === s) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(e, {
      shape: n,
      dtype: s,
      values: t,
      usage: zy.UPLOAD,
      refCount: r
    });
  }

  disposeIntermediateTensorInfo(e) {
    this.disposeData(e.dataId);
  }

  readSync(e) {
    var t = this.texData.get(e),
        {
      values: n,
      dtype: s,
      complexTensorInfos: r,
      slice: a,
      shape: i,
      isPacked: o
    } = t;

    if (null != a) {
      var _t369;

      _t369 = o ? new Gw(i, Vw) : new Uw(i, Vw);

      var _n269 = this.runWebGLProgram(_t369, [{
        dataId: e,
        shape: i,
        dtype: s
      }], s),
          _r159 = this.readSync(_n269.dataId);

      return this.disposeIntermediateTensorInfo(_n269), _r159;
    }

    if (null != n) return this.convertAndCacheOnCPU(e);
    if ("string" === s) return n;
    var l = null != this.activeTimers;
    var u, c;
    return l && (u = Ge()), c = "complex64" === s ? Lo(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.getValuesFromTexture(e), l && (this.downloadWaitMs += Ge() - u), this.convertAndCacheOnCPU(e, c);
  }

  read(e) {
    var _this73 = this;

    return _asyncToGenerator(function* () {
      if (_this73.pendingRead.has(e)) {
        var _t370 = _this73.pendingRead.get(e);

        return new Promise(e => _t370.push(e));
      }

      var t = _this73.texData.get(e),
          {
        values: n,
        shape: s,
        slice: r,
        dtype: a,
        complexTensorInfos: i,
        isPacked: o
      } = t;

      if (null != r) {
        var _t371;

        _t371 = o ? new Gw(s, Vw) : new Uw(s, Vw);

        var _n270 = _this73.runWebGLProgram(_t371, [{
          dataId: e,
          shape: s,
          dtype: a
        }], a),
            _r160 = _this73.read(_n270.dataId);

        return _this73.disposeIntermediateTensorInfo(_n270), _r160;
      }

      if (null != n) return _this73.convertAndCacheOnCPU(e);
      if (!G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === G().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
      var l,
          u,
          c = null;

      if ("complex64" !== a && G().get("WEBGL_BUFFER_SUPPORTED")) {
        l = _this73.decode(e);

        var _t372 = _this73.texData.get(l.dataId);

        c = _this73.gpgpu.createBufferFromTexture(_t372.texture, ...Wy(s));
      }

      if (_this73.pendingRead.set(e, []), "complex64" !== a && (yield _this73.gpgpu.createAndWaitForFence()), "complex64" === a) {
        var _e437 = yield Promise.all([_this73.read(i.real.dataId), _this73.read(i.imag.dataId)]);

        u = Lo(_e437[0], _e437[1]);
      } else if (null == c) u = _this73.getValuesFromTexture(e);else {
        var _e438 = d(s);

        u = _this73.gpgpu.downloadFloat32MatrixFromBuffer(c, _e438);
      }

      if (null != l && _this73.disposeIntermediateTensorInfo(l), null != c) {
        var _e439 = _this73.gpgpu.gl;
        Gy(_e439, () => _e439.deleteBuffer(c));
      }

      var h = _this73.convertAndCacheOnCPU(e, u),
          p = _this73.pendingRead.get(e);

      return _this73.pendingRead.delete(e), p.forEach(e => e(h)), _this73.pendingDisposal.has(e) && (_this73.pendingDisposal.delete(e), _this73.disposeData(e) && Xn().removeDataId(e, _this73), _this73.pendingDeletes--), h;
    })();
  }

  bufferSync(e) {
    var t = this.readSync(e.dataId);
    var n = t;
    if ("string" === e.dtype) try {
      n = t.map(e => qe(e));
    } catch (e) {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return pn(e.shape, e.dtype, n);
  }

  checkNumericalProblems(e) {
    if (null != e) for (var _t373 = 0; _t373 < e.length; _t373++) {
      var _n271 = e[_t373];

      if (!Hy(_n271)) {
        if (G().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value ".concat(_n271, " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"));
        throw Error("The value ".concat(_n271, " cannot be represented on this device."));
      }
    }
  }

  getValuesFromTexture(e) {
    var {
      shape: t,
      dtype: n,
      isPacked: s
    } = this.texData.get(e),
        r = d(t);

    if (G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      var _n272 = this.decode(e),
          _s214 = this.texData.get(_n272.dataId),
          _a126 = this.gpgpu.downloadMatrixFromPackedTexture(_s214.texture, ...Wy(t)).subarray(0, r);

      return this.disposeIntermediateTensorInfo(_n272), _a126;
    }

    var a = G().getBool("WEBGL_PACK") && !0 === s,
        i = a ? nk(t) : t,
        o = a ? new Mk(i) : new Ok(i),
        l = this.runWebGLProgram(o, [{
      shape: i,
      dtype: n,
      dataId: e
    }], "float32"),
        u = this.texData.get(l.dataId),
        c = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture, u.texShape[0], u.texShape[1]).subarray(0, r);
    return this.disposeIntermediateTensorInfo(l), c;
  }

  timerAvailable() {
    return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
  }

  time(e) {
    var _this74 = this;

    return _asyncToGenerator(function* () {
      var t = _this74.activeTimers,
          n = [];
      var s = !1;
      null == _this74.programTimersStack ? (_this74.programTimersStack = n, s = !0) : _this74.activeTimers.push(n), _this74.activeTimers = n, e();
      var r = h(_this74.activeTimers.map(e => e.query)).filter(e => null != e),
          a = h(_this74.activeTimers.map(e => e.name)).filter(e => null != e);
      _this74.activeTimers = t, s && (_this74.programTimersStack = null);
      var i = {
        uploadWaitMs: _this74.uploadWaitMs,
        downloadWaitMs: _this74.downloadWaitMs,
        kernelMs: null,
        wallMs: null
      };

      if (G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        var _e440 = yield Promise.all(r);

        i.kernelMs = function (e) {
          var t = 0;

          for (var _n273 = 0; _n273 < e.length; _n273++) {
            t += e[_n273];
          }

          return t;
        }(_e440), i.getExtraProfileInfo = () => _e440.map((e, t) => ({
          name: a[t],
          ms: e
        })).map(e => "".concat(e.name, ": ").concat(e.ms)).join(", ");
      } else i.kernelMs = {
        error: "WebGL query timers are not supported in this environment."
      };

      return _this74.uploadWaitMs = 0, _this74.downloadWaitMs = 0, i;
    })();
  }

  memory() {
    return {
      unreliable: !1,
      numBytesInGPU: this.numBytesInGPU,
      numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
      numBytesInGPUFree: this.textureManager.numBytesFree
    };
  }

  startTimer() {
    return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
      startMs: Ge(),
      endMs: null
    };
  }

  endTimer(e) {
    return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = Ge(), e);
  }

  getQueryTime(e) {
    var _this75 = this;

    return _asyncToGenerator(function* () {
      return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? _this75.gpgpu.waitForQueryAndGetTime(e) : e.endMs - e.startMs;
    })();
  }

  disposeData(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    if (this.pendingDisposal.has(e)) return !1;
    if (!this.texData.has(e)) return !0;
    if (t ? this.texData.get(e).refCount = 0 : this.texData.get(e).refCount--, !t && this.texData.get(e).refCount > 0) return !1;
    if (this.pendingRead.has(e)) return this.pendingDisposal.add(e), this.pendingDeletes++, !1;
    this.releaseGPUData(e);
    var {
      complexTensorInfos: n
    } = this.texData.get(e);
    return null != n && (this.disposeData(n.real.dataId, t), this.disposeData(n.imag.dataId, t)), this.texData.delete(e), !0;
  }

  releaseGPUData(e) {
    var {
      texture: t,
      dtype: n,
      texShape: s,
      usage: r,
      isPacked: a,
      slice: i
    } = this.texData.get(e),
        o = i && i.origDataId || e,
        l = this.dataRefCount.get(o);
    l > 1 ? this.dataRefCount.set(o, l - 1) : (this.dataRefCount.delete(o), null != t && (this.numBytesInGPU -= this.computeBytes(s, n), this.textureManager.releaseTexture(t, s, r, a)));
    var u = this.texData.get(e);
    u.texture = null, u.texShape = null, u.isPacked = !1, u.slice = null;
  }

  getTexture(e) {
    return this.uploadToGPU(e), this.texData.get(e).texture;
  }

  getDataInfo(e) {
    return this.texData.get(e);
  }

  shouldExecuteOnCPU(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Kw;
    return G().getBool("WEBGL_CPU_FORWARD") && e.every(e => null == this.texData.get(e.dataId).texture && d(e.shape) < t);
  }

  getGPGPUContext() {
    return this.gpgpu;
  }

  where(e) {
    W("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    var t = e.dataSync();
    return qw(e.shape, t);
  }

  packedUnaryOp(e, t, n) {
    var s = new Gw(e.shape, t),
        r = this.compileAndRun(s, [e], n);
    return Xn().makeTensorFromDataId(r.dataId, r.shape, r.dtype);
  }

  abs(e) {
    if (this.shouldExecuteOnCPU([e]) && "complex64" !== e.dtype) {
      var _t374 = yw(this.texData.get(e.dataId).values);

      return this.makeOutput(e.shape, e.dtype, _t374);
    }

    if (G().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(e, "return abs(x);", e.dtype);
    var t = new Uw(e.shape, "return abs(x);"),
        n = this.compileAndRun(t, [e]);
    return Xn().makeTensorFromDataId(n.dataId, n.shape, n.dtype);
  }

  makeTensorInfo(e, t, n) {
    var s;

    if ("string" === t && null != n && n.length > 0 && N(n[0])) {
      var _r161 = n.map(e => He(e));

      s = this.write(_r161, e, t);
    } else s = this.write(n, e, t);

    return this.texData.get(s).usage = null, {
      dataId: s,
      shape: e,
      dtype: t
    };
  }

  makeOutput(e, t, n) {
    var {
      dataId: s
    } = this.makeTensorInfo(e, t, n);
    return Xn().makeTensorFromDataId(s, e, t, this);
  }

  unpackTensor(e) {
    var t = new Hw(e.shape);
    return this.runWebGLProgram(t, [e], e.dtype);
  }

  packTensor(e) {
    var t = new Mw(e.shape);
    return this.runWebGLProgram(t, [e], e.dtype, null, !0);
  }

  packedReshape(e, t) {
    var n = [ek(e.shape), ...tk(e.shape)],
        s = {
      dtype: e.dtype,
      shape: n,
      dataId: e.dataId
    },
        r = [ek(t), ...tk(t)],
        a = new Lw(r, n),
        i = this.runWebGLProgram(a, [s], e.dtype, [n], !0);
    return {
      dataId: i.dataId,
      shape: t,
      dtype: i.dtype
    };
  }

  decode(e) {
    var t = this.texData.get(e),
        {
      isPacked: n,
      shape: s,
      dtype: r
    } = t,
        a = nk(s);
    var i;
    var o = Wy(a);
    return i = n ? new _k(a) : new Dk(a), {
      dtype: r,
      shape: s,
      dataId: this.runWebGLProgram(i, [{
        shape: a,
        dtype: r,
        dataId: e
      }], r, [o], !0).dataId
    };
  }

  runWebGLProgram(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    var a = this.makeTensorInfo(e.outputShape, n),
        i = this.texData.get(a.dataId);

    if (e.packedOutput && (i.isPacked = !0), e.outPackingScheme === Ly.DENSE) {
      var _t375 = Wy(e.outputShape);

      i.texShape = _t375.map(e => 2 * e);
    }

    if (null != e.outTexUsage && (i.usage = e.outTexUsage), 0 === d(a.shape)) return i.values = w(a.dtype, 0), a;
    var o = [],
        l = t.map(t => {
      if ("complex64" === t.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      var n = this.texData.get(t.dataId);

      if (null == n.texture) {
        if (!e.packedInputs && d(t.shape) <= G().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
          shape: t.shape,
          texData: null,
          isUniform: !0,
          uniformValues: n.values
        };
        e.packedInputs && (n.isPacked = !0, n.shape = t.shape);
      } else if (!!n.isPacked != !!e.packedInputs) t = n.isPacked ? this.unpackTensor(t) : this.packTensor(t), o.push(t), n = this.texData.get(t.dataId);else if (n.isPacked && !rk(n.shape, t.shape)) {
        var _e441 = t,
            _s215 = t.shape;
        t.shape = n.shape, t = this.packedReshape(t, _s215), o.push(t), n = this.texData.get(t.dataId), _e441.shape = _s215;
      }

      return this.uploadToGPU(t.dataId), {
        shape: t.shape,
        texData: n,
        isUniform: !1
      };
    });
    this.uploadToGPU(a.dataId);

    var u = {
      shape: a.shape,
      texData: i,
      isUniform: !1
    },
        c = function (e, t, n) {
      var s = "";
      t.concat(n).forEach(t => {
        var r = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0;

        if (e.enableShapeUniforms && !t.isUniform) {
          var _a127 = t.texData.texShape,
              {
            useSqueezeShape: _i87,
            uniformShape: _o64,
            keptDims: _l44
          } = Tk(e.packedInputs, t.shape, _a127);
          var _u34 = "",
              _c29 = "",
              _h17 = "";

          if (1 === _o64.length && e.packedInputs) {
            var _e442 = [Math.ceil(_a127[0] / 2), Math.ceil(_a127[1] / 2)];
            _u34 = "".concat(_e442[0] > 1, "_").concat(_e442[1] > 1);
          } else if (2 !== _o64.length || e.packedInputs) {
            if (_o64.length > 2 && !e.packedInputs) {
              var _e443 = A(_o64);

              _h17 = "".concat(_e443[0] === _a127[1], "_").concat(_e443[_e443.length - 1] === _a127[1]);
            }
          } else _c29 = "".concat(_o64[0] > 1, "_").concat(_o64[1] > 1);

          var _f11 = t.shape.length,
              _g19 = 2 === _o64.length && p(t.shape, _a127),
              _m13 = 1 === d(t.shape),
              _b14 = ur(t.shape, n.shape),
              _x55 = !e.packedInputs && _f11 === n.shape.length && p(_a127, n.texData.texShape);

          s += "".concat(_f11, "_").concat(_x55, "_").concat(_i87 ? _l44 : "", "_").concat(_o64.length, "_").concat(_m13, "_").concat(_b14, "_").concat(_g19, "_").concat(_u34, "_").concat(_c29, "_").concat(_h17, "_").concat(e.packedInputs || _o64.length > 2 ? "" : "".concat(_a127[0] > 1, "_").concat(_a127[1] > 1), "_").concat(r);
        } else s += "".concat(t.shape, "_").concat(t.isUniform ? "uniform" : t.texData.texShape, "_").concat(r);
      });
      var r = e.constructor.name;
      return r += "_" + s + "_" + e.userCode + "".concat(G().getNumber("WEBGL_VERSION")), r;
    }(e, l, u),
        h = this.getAndSaveBinary(c, () => function (e, t, n, s) {
      var r = n.map((e, n) => {
        var s = {
          logicalShape: e.shape,
          texShape: e.isUniform ? null : e.texData.texShape,
          isUniform: e.isUniform,
          isPacked: !e.isUniform && e.texData.isPacked,
          flatOffset: null
        };
        return null != e.texData && null != e.texData.slice && e.texData.slice.flatOffset > 0 && (s.flatOffset = e.texData.slice.flatOffset), {
          name: t.variableNames[n],
          shapeInfo: s
        };
      }),
          a = r.map(e => e.shapeInfo),
          i = {
        logicalShape: s.shape,
        texShape: s.texData.texShape,
        isUniform: !1,
        isPacked: s.texData.isPacked,
        flatOffset: null
      },
          o = xk(r, i, t),
          l = e.createProgram(o);
      var u = null;
      var c = e.getUniformLocation(l, "NAN", !1);
      1 === G().getNumber("WEBGL_VERSION") && (u = e.getUniformLocation(l, "INFINITY", !1));
      var h = !1,
          d = {},
          p = {},
          f = {};

      for (var _n274 = 0; _n274 < t.variableNames.length; _n274++) {
        var _s216 = t.variableNames[_n274];
        d[_s216] = e.getUniformLocation(l, _s216, h), d["offset".concat(_s216)] = e.getUniformLocation(l, "offset".concat(_s216), h), t.enableShapeUniforms && (p["".concat(_s216, "Shape")] = e.getUniformLocation(l, "".concat(_s216, "Shape"), h), f["".concat(_s216, "TexShape")] = e.getUniformLocation(l, "".concat(_s216, "TexShape"), h));
      }

      var g, m, b;
      t.enableShapeUniforms && (g = e.getUniformLocation(l, "outShape", h), b = e.getUniformLocation(l, "outShapeStrides", h), m = e.getUniformLocation(l, "outTexShape", h));
      var x = [];
      return t.customUniforms && t.customUniforms.forEach((t, n) => {
        x[n] = e.getUniformLocation(l, t.name, h);
      }), {
        program: t,
        source: o,
        webGLProgram: l,
        uniformLocations: d,
        customUniformLocations: x,
        inShapeInfos: a,
        outShapeInfo: i,
        infLoc: u,
        nanLoc: c,
        inShapesLocations: p,
        inTexShapesLocations: f,
        outShapeLocation: g,
        outShapeStridesLocation: b,
        outTexShapeLocation: m
      };
    }(this.gpgpu, e, l, u)),
        f = null != this.activeTimers;

    var g;
    f && (g = this.startTimer()), function (e, t, n, s, r) {
      t.program.enableShapeUniforms || (Ak(t.inShapeInfos, n), Ak([t.outShapeInfo], [s]));
      var a = s.texData.texture,
          i = s.texData.texShape;
      s.texData.isPacked ? e.setOutputPackedMatrixTexture(a, i[0], i[1]) : e.setOutputMatrixTexture(a, i[0], i[1]), e.setProgram(t.webGLProgram), 1 === G().getNumber("WEBGL_VERSION") && null !== t.infLoc && e.gl.uniform1f(t.infLoc, Infinity), null !== t.nanLoc && e.gl.uniform1f(t.nanLoc, NaN), n.forEach((n, s) => {
        var r = t.program.variableNames[s],
            a = t.uniformLocations[r],
            i = t.uniformLocations["offset".concat(r)],
            o = t.inShapesLocations["".concat(r, "Shape")],
            l = t.inTexShapesLocations["".concat(r, "TexShape")];

        if (o) {
          var {
            uniformShape: _s217
          } = Tk(t.program.packedInputs, n.shape, n.texData.texShape);

          switch (_s217.length) {
            case 1:
              e.gl.uniform1iv(o, new Int32Array(_s217));
              break;

            case 2:
              e.gl.uniform2iv(o, new Int32Array(_s217));
              break;

            case 3:
              e.gl.uniform3iv(o, new Int32Array(_s217));
              break;

            case 4:
              e.gl.uniform4iv(o, new Int32Array(_s217));
          }
        }

        if (l && e.gl.uniform2i(l, n.texData.texShape[0], n.texData.texShape[1]), null != a) if (n.isUniform) {
          if (d(n.shape) < 2) e.gl.uniform1f(a, n.uniformValues[0]);else {
            var _t376 = n.uniformValues;
            _t376 instanceof Float32Array || (_t376 = new Float32Array(_t376)), e.gl.uniform1fv(a, _t376);
          }
        } else null != n.texData.slice && null != i && e.gl.uniform1i(i, n.texData.slice.flatOffset), e.setInputMatrixTexture(n.texData.texture, a, s);
      });
      var o = t.outShapeLocation;
      if (o) switch (s.shape.length) {
        case 1:
          e.gl.uniform1iv(o, new Int32Array(s.shape));
          break;

        case 2:
          e.gl.uniform2iv(o, new Int32Array(s.shape));
          break;

        case 3:
          e.gl.uniform3iv(o, new Int32Array(s.shape));
          break;

        case 4:
          e.gl.uniform4iv(o, new Int32Array(s.shape));
      }

      if (t.outShapeStridesLocation) {
        var _n275 = A(s.shape);

        switch (s.shape.length) {
          case 2:
            e.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(_n275));
            break;

          case 3:
            e.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(_n275));
            break;

          case 4:
            e.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(_n275));
        }
      }

      t.outTexShapeLocation && e.gl.uniform2i(t.outTexShapeLocation, s.texData.texShape[0], s.texData.texShape[1]), t.program.customUniforms && r && t.program.customUniforms.forEach((n, s) => {
        var a = t.customUniformLocations[s],
            i = r[s];
        if ("float" === n.type) e.gl.uniform1fv(a, i);else if ("vec2" === n.type) e.gl.uniform2fv(a, i);else if ("vec3" === n.type) e.gl.uniform3fv(a, i);else if ("vec4" === n.type) e.gl.uniform4fv(a, i);else if ("int" === n.type) e.gl.uniform1iv(a, i);else if ("ivec2" === n.type) e.gl.uniform2iv(a, i);else if ("ivec3" === n.type) e.gl.uniform3iv(a, i);else {
          if ("ivec4" !== n.type) throw Error("uniform type ".concat(n.type, " is not supported yet."));
          e.gl.uniform4iv(a, i);
        }
      }), e.executeProgram();
    }(this.gpgpu, h, l, u, s), o.forEach(e => this.disposeIntermediateTensorInfo(e)), f && (g = this.endTimer(g), this.activeTimers.push({
      name: e.constructor.name,
      query: this.getQueryTime(g)
    }));
    var m = G().get("WEBGL_FLUSH_THRESHOLD");

    if (m > 0) {
      var _e444 = Ge();

      _e444 - this.lastGlFlushTime > m && (this.gpgpu.gl.flush(), this.lastGlFlushTime = _e444);
    }

    if (!G().getBool("WEBGL_LAZILY_UNPACK") && i.isPacked && !1 === r) {
      var _e445 = this.unpackTensor(a);

      return this.disposeIntermediateTensorInfo(a), _e445;
    }

    return a;
  }

  compileAndRun(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    return this.runWebGLProgram(e, t, n = n || t[0].dtype, s, r);
  }

  getAndSaveBinary(e, t) {
    return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e];
  }

  getTextureManager() {
    return this.textureManager;
  }

  dispose() {
    this.disposed || (G().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach(e => {
      this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram), delete this.binaryCache[e];
    }), this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0);
  }

  floatPrecision() {
    return null == this.floatPrecisionValue && (this.floatPrecisionValue = Jn(() => {
      if (!G().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        var _e446 = G().getBool("DEBUG");

        G().set("DEBUG", !1);
        var _t377 = this.abs(Ka(1e-8)).dataSync()[0];
        if (G().set("DEBUG", _e446), _t377 > 0) return 32;
      }

      return 16;
    })), this.floatPrecisionValue;
  }

  epsilon() {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }

  uploadToGPU(e) {
    var t = this.texData.get(e),
        {
      shape: n,
      dtype: s,
      values: r,
      texture: a,
      usage: o,
      isPacked: l
    } = t;
    if (null != a) return;
    var u = null != this.activeTimers;
    var c;
    u && (c = Ge());
    var h = t.texShape;

    if (null == h && (h = function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      var n = G().getNumber("WEBGL_MAX_TEXTURE_SIZE");

      if (t && (n *= 2, 1 === (e = e.map((t, n) => n >= e.length - 2 ? i(e[n]) : e[n])).length && (e = [2, e[0]])), 2 !== e.length) {
        var _t378 = k(e);

        e = _t378.newShape;
      }

      var s = d(e);
      if (e.length <= 1 && s <= n) return [1, s];
      if (2 === e.length && e[0] <= n && e[1] <= n) return e;
      if (3 === e.length && e[0] * e[1] <= n && e[2] <= n) return [e[0] * e[1], e[2]];
      if (3 === e.length && e[0] <= n && e[1] * e[2] <= n) return [e[0], e[1] * e[2]];
      if (4 === e.length && e[0] * e[1] * e[2] <= n && e[3] <= n) return [e[0] * e[1] * e[2], e[3]];
      if (4 === e.length && e[0] <= n && e[1] * e[2] * e[3] <= n) return [e[0], e[1] * e[2] * e[3]];

      if (t) {
        var _t379 = ek(e);

        var _n276 = 2,
            _r162 = 2;
        return e.length && ([_n276, _r162] = tk(e)), s = _t379 * (_n276 / 2) * (_r162 / 2), g(s).map(e => 2 * e);
      }

      return g(s);
    }(n, l), t.texShape = h), null != r) {
      var _e447 = nk(n);

      var _a128,
          _i88 = h[1],
          _o65 = h[0];

      var _d23 = r instanceof Uint8Array;

      l ? ([_i88, _o65] = Uy(h[0], h[1]), _a128 = new zk(_e447, _d23)) : _a128 = new Lk(_e447, _d23);

      var _p15 = this.makeTensorInfo([_o65, _i88], s);

      this.texData.get(_p15.dataId).usage = _d23 ? zy.PIXELS : zy.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(_p15.dataId), _i88, _o65, r);

      var _f12 = this.runWebGLProgram(_a128, [_p15], s, [[_o65, _i88]], !0),
          _g20 = this.texData.get(_f12.dataId);

      t.texture = _g20.texture, t.texShape = _g20.texShape, t.isPacked = _g20.isPacked, t.usage = _g20.usage, this.disposeIntermediateTensorInfo(_p15), this.texData.delete(_f12.dataId), t.values = null, u && (this.uploadWaitMs += Ge() - c);
    } else {
      var _e448 = this.acquireTexture(h, o, s, l);

      t.texture = _e448;
    }
  }

  convertAndCacheOnCPU(e, t) {
    var n = this.texData.get(e),
        {
      dtype: s
    } = n;
    return this.releaseGPUData(e), null != t && (n.values = function (e, t) {
      if ("float32" === t || "complex64" === t) return e;

      if ("int32" === t || "bool" === t) {
        var _n277 = "int32" === t ? new Int32Array(e.length) : new Uint8Array(e.length);

        for (var _t380 = 0; _t380 < _n277.length; ++_t380) {
          _n277[_t380] = Math.round(e[_t380]);
        }

        return _n277;
      }

      throw new Error("Unknown dtype ".concat(t));
    }(t, s)), n.values;
  }

  acquireTexture(e, t, n, s) {
    if (this.numBytesInGPU += this.computeBytes(e, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
      var _e449 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);

      this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: ".concat(_e449, " MB, most likely due to a memory leak"));
    }

    return this.textureManager.acquireTexture(e, t, s);
  }

  computeBytes(e, t) {
    return e[0] * e[1] * S(t);
  }

}

Xw.nextDataId = 0, St() && es("webgl", () => new Xw(), 2);

class Yw {
  constructor(e, t, n) {
    this.variableNames = ["A", "B"], this.outputShape = hr(t, n), this.enableShapeUniforms = Fk(this.outputShape.length), this.userCode = "\n      float binaryOperation(float a, float b) {\n        ".concat(e, "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ");
  }

}

class Jw {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = hr(t, n);
    var r = this.outputShape.length;
    this.enableShapeUniforms = Fk(r);
    var a = "";
    if (s) if (0 === r || 1 === d(this.outputShape)) a = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if (a = "\n          ".concat(Ck(r), " coords = getOutputCoords();\n        "), 1 === r) a += this.enableShapeUniforms ? "\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          " : "\n            result.y = (coords + 1) >= ".concat(this.outputShape[0], " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else {
      var _e450 = Ow("coords", r);

      a += this.enableShapeUniforms ? "\n            bool nextRowOutOfBounds =\n              (".concat(_e450[r - 2], " + 1) >= outShape[").concat(r, " - 2];\n            bool nextColOutOfBounds =\n              (").concat(_e450[r - 1], " + 1) >= outShape[").concat(r, " - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ") : "\n            bool nextRowOutOfBounds =\n              (".concat(_e450[r - 2], " + 1) >= ").concat(this.outputShape[r - 2], ";\n            bool nextColOutOfBounds =\n              (").concat(_e450[r - 1], " + 1) >= ").concat(this.outputShape[r - 1], ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ");
    }
    this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e, "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(a, "\n\n        setOutput(result);\n      }\n    ");
  }

}

function Zw(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    x: s
  } = t;
  return n.incRef(s.dataId), {
    dataId: s.dataId,
    shape: s.shape,
    dtype: s.dtype
  };
}

var Qw = {
  kernelName: "Identity",
  backendName: "webgl",
  kernelFunc: Zw
};

function ev(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    real: s,
    imag: r
  } = t,
      a = n.makeTensorInfo(s.shape, "complex64"),
      i = n.texData.get(a.dataId),
      o = Zw({
    inputs: {
      x: s
    },
    backend: n
  }),
      l = Zw({
    inputs: {
      x: r
    },
    backend: n
  });
  return i.complexTensorInfos = {
    real: o,
    imag: l
  }, a;
}

var tv = {
  kernelName: "Complex",
  backendName: "webgl",
  kernelFunc: ev
},
    nv = "return (a < 0.) ? b * a : a;",
    sv = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
    rv = {
  kernelName: "LeakyRelu",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      alpha: a
    } = s,
        i = n.makeTensorInfo([], "float32", Ue(a, "float32")),
        o = G().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Jw(sv, r.shape, i.shape) : new Yw(nv, r.shape, i.shape),
        l = n.runWebGLProgram(o, [r, i], r.dtype);
    return n.disposeIntermediateTensorInfo(i), l;
  }
},
    av = "return (a < 0.) ? b * a : a;",
    iv = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
    ov = {
  kernelName: "Prelu",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s,
      alpha: r
    } = t,
        a = G().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Jw(iv, s.shape, r.shape) : new Yw(av, s.shape, r.shape);
    return n.runWebGLProgram(a, [s, r], s.dtype);
  }
};

function lv(_ref20) {
  var {
    opSnippet: e,
    packedOpSnippet: t,
    cpuKernelImpl: n,
    dtype: s
  } = _ref20;
  return _ref21 => {
    var {
      inputs: r,
      backend: a
    } = _ref21;
    var {
      x: i
    } = r,
        o = a,
        l = s || i.dtype;

    if (o.shouldExecuteOnCPU([i]) && null != n) {
      var _e451 = o.texData.get(i.dataId),
          _t381 = n(_e451.values, l);

      return o.makeTensorInfo(i.shape, l, _t381);
    }

    var u;
    return u = G().getBool("WEBGL_PACK_UNARY_OPERATIONS") && null != t ? new Gw(i.shape, t) : new Uw(i.shape, e), o.runWebGLProgram(u, [i], l);
  };
}

function uv(_ref22) {
  var {
    opSnippet: e,
    packedOpSnippet: t,
    checkOutOfBounds: n = !1,
    supportsComplex: s = !1,
    cpuKernelImpl: r,
    dtype: a
  } = _ref22;
  return _ref23 => {
    var {
      inputs: i,
      backend: o
    } = _ref23;
    var {
      a: l,
      b: u
    } = i,
        c = o;

    if (s && "complex64" === l.dtype) {
      var _t382 = c.texData.get(l.dataId),
          _n278 = c.texData.get(u.dataId),
          [_s218, _r163] = [[_t382.complexTensorInfos.real, _n278.complexTensorInfos.real], [_t382.complexTensorInfos.imag, _n278.complexTensorInfos.imag]].map(t => {
        var [n, s] = t,
            r = {
          dataId: n.dataId,
          dtype: n.dtype,
          shape: l.shape
        },
            a = {
          dataId: s.dataId,
          dtype: s.dtype,
          shape: u.shape
        },
            i = new Yw(e, l.shape, u.shape);
        return c.runWebGLProgram(i, [r, a], pt(n.dtype, s.dtype));
      }),
          _a129 = ev({
        inputs: {
          real: _s218,
          imag: _r163
        },
        backend: c
      });

      return c.disposeIntermediateTensorInfo(_s218), c.disposeIntermediateTensorInfo(_r163), _a129;
    }

    var h = a || pt(l.dtype, u.dtype);

    if (("string" === l.dtype || "string" === u.dtype || c.shouldExecuteOnCPU([l, u])) && null != r) {
      var _e452 = c.texData.get(l.dataId).values,
          _t383 = c.texData.get(u.dataId).values,
          _n279 = "string" === l.dtype ? nl(_e452) : _e452,
          _s219 = "string" === l.dtype ? nl(_t383) : _t383,
          [_a130, _i89] = r(l.shape, u.shape, _n279, _s219, h),
          _o66 = c.makeTensorInfo(_i89, h);

      return c.texData.get(_o66.dataId).values = _a130, _o66;
    }

    var d;
    return d = G().getBool("WEBGL_PACK_BINARY_OPERATIONS") && null != t ? new Jw(t, l.shape, u.shape, n) : new Yw(e, l.shape, u.shape), c.runWebGLProgram(d, [l, u], h);
  };
}

function cv(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  if ("linear" === e) return "return x;";
  if ("relu" === e) return t ? "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";
  if ("elu" === e) return t ? "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n" : "return (x >= 0.0) ? x : (exp(x) - 1.0);";
  if ("relu6" === e) return t ? "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
  if ("prelu" === e) return t ? iv : av;
  if ("leakyrelu" === e) return t ? sv : nv;
  if ("sigmoid" === e) return "return 1.0 / (1.0 + exp(-1.0 * x));";
  throw new Error("Activation ".concat(e, " has not been implemented for the WebGL backend."));
}

class hv {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : !1;
    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : !1;
    this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n, this.enableShapeUniforms = Fk(this.outputShape.length);
    var u = Math.ceil((s ? e[1] : e[2]) / 2),
        c = s ? "i * 2, rc.y" : "rc.y, i * 2",
        h = r ? "rc.z, i * 2" : "i * 2, rc.z",
        d = s ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
        p = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
    var f = "",
        g = "";
    i && (f = o ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(i, "\n        }") : l ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(i, "\n        }") : "vec4 activation(vec4 x) {\n          ".concat(i, "\n        }"), g = "result = activation(result);");
    var m = a ? "result += getBiasAtOutCoords();" : "";
    a && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), l && this.variableNames.push("leakyreluAlpha");
    var b = "rc.x",
        x = "rc.x";
    e[0] < t[0] ? b = "int(min(float(rc.x), ".concat(e[0] - 1, ".))") : t[0] < e[0] && (x = "int(min(float(rc.x), ".concat(t[0] - 1, ".))")), this.userCode = "\n      ".concat(f, "\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u, ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ").concat(u, "; i++) {\n          int batchA = ").concat(b, ";\n          int batchB = ").concat(x, ";\n          vec4 a = getMatrixA(batchA, ").concat(c, ");\n          vec4 b = getMatrixB(batchB, ").concat(h, ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(d[0], " * ").concat(p[0], ");\n          result += (").concat(d[1], " * ").concat(p[1], ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(m, "\n\n        ").concat(g, "\n\n        setOutput(result);\n      }\n    ");
  }

}

class dv {
  constructor(e, t, n) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = hr(t, n), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e, "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ");
  }

}

var pv = "return a * b;";

function fv(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    a: s,
    b: r
  } = t,
      a = pt(s.dtype, r.dtype);

  if ("complex64" === s.dtype) {
    var _e453 = n.texData.get(s.dataId),
        _t384 = n.texData.get(r.dataId),
        _a131 = new dv("return areal * breal - aimag * bimag;", s.shape, r.shape),
        _i90 = new dv("return areal * bimag + aimag * breal;", s.shape, r.shape),
        _o67 = [{
      dataId: _e453.complexTensorInfos.real.dataId,
      dtype: _e453.complexTensorInfos.real.dtype,
      shape: s.shape
    }, {
      dataId: _e453.complexTensorInfos.imag.dataId,
      dtype: _e453.complexTensorInfos.imag.dtype,
      shape: s.shape
    }, {
      dataId: _t384.complexTensorInfos.real.dataId,
      dtype: _t384.complexTensorInfos.real.dtype,
      shape: r.shape
    }, {
      dataId: _t384.complexTensorInfos.imag.dataId,
      dtype: _t384.complexTensorInfos.imag.dtype,
      shape: r.shape
    }],
        _l45 = n.runWebGLProgram(_a131, _o67, "float32"),
        _u35 = n.runWebGLProgram(_i90, _o67, "float32"),
        _c30 = ev({
      inputs: {
        real: _l45,
        imag: _u35
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_l45), n.disposeIntermediateTensorInfo(_u35), _c30;
  }

  if (n.shouldExecuteOnCPU([s, r])) {
    var _e454 = n.texData.get(s.dataId),
        _t385 = n.texData.get(r.dataId),
        [_i91, _o68] = dw(s.shape, r.shape, _e454.values, _t385.values, a),
        _l46 = n.makeTensorInfo(_o68, a);

    return n.texData.get(_l46.dataId).values = _i91, _l46;
  }

  var i;
  return i = G().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Jw(pv, s.shape, r.shape) : new Yw(pv, s.shape, r.shape), n.runWebGLProgram(i, [s, r], a);
}

var gv = {
  kernelName: "Multiply",
  backendName: "webgl",
  kernelFunc: fv
};

function mv(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    shape: a
  } = s,
      i = n,
      o = d(r.shape),
      u = x(a, o),
      c = d(u);
  l(o === c, () => "The new shape (".concat(u, ") has ").concat(c, " elements and the old shape (").concat(r.shape, ") has ").concat(o, " elements. The new shape and old shape must have the same number of elements."));
  var h = i.texData.get(r.dataId);
  return !h.isPacked || rk(r.shape, u) || null !== h.texture && rk(h.shape, u) ? (i.incRef(r.dataId), {
    dataId: r.dataId,
    shape: u,
    dtype: r.dtype
  }) : function (e, t, n) {
    var s = [ek(e.shape), ...tk(e.shape)],
        r = {
      dtype: e.dtype,
      shape: s,
      dataId: e.dataId
    },
        a = [ek(t), ...tk(t)],
        i = new Lw(a, s),
        o = n.runWebGLProgram(i, [r], e.dtype, [s], !0);
    return {
      dataId: o.dataId,
      shape: t,
      dtype: o.dtype
    };
  }(r, u, i);
}

var bv = {
  kernelName: "Reshape",
  backendName: "webgl",
  kernelFunc: mv
};

class xv {
  constructor(e, t) {
    this.variableNames = ["x"];
    var {
      windowSize: n,
      batchSize: s,
      inSize: r,
      outSize: a
    } = e;
    this.outputShape = [s, a];
    var i = 4 * Math.floor(n / 4),
        o = n % 4;
    var l = "sumValue += dot(values, ones);";

    if (null != t) {
      var _e455 = 1 / t;

      l = "sumValue += dot(values * ".concat(f(_e455) ? _e455.toPrecision(2) : _e455, ", ones);");
    }

    var u = "";
    r % n > 0 && (u = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return 0.0;\n        }\n      ")), this.userCode = "\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(u, "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n, ";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i, "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(l, "\n        }\n\n        int inIdx = inOffset + ").concat(i, ";\n        if (").concat(1 === o, ") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(l, "\n        } else if (").concat(2 === o, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(l, "\n        } else if (").concat(3 === o, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(l, "\n        }\n        setOutput(sumValue);\n      }\n    ");
  }

}

class yv {
  constructor(e, t) {
    this.variableNames = ["x"];
    var {
      windowSize: n,
      batchSize: s,
      inSize: r,
      outSize: a
    } = e;
    this.outputShape = [s, a];
    var i = "0.0",
        o = "";
    "prod" === t ? i = "1.0" : "min" === t ? (i = "1.0 / 1e-20", o = "min") : "max" === t && (i = "-1.0 / 1e-20", o = "max");
    var l = "".concat(t, "(").concat(t, "(").concat(t, "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");
    "sum" === t ? l = "sumValue" : "prod" === t ? l = "prodValue" : "all" === t ? l = "allValue" : "any" === t && (l = "anyValue");
    var u = 4 * Math.floor(n / 4),
        c = n % 4;
    var h = "\n      if (".concat("sum" === t, ") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod" === t, ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(o, "(values, minMaxValue);\n        if (").concat("min" === t, " || ").concat("max" === t, ") {\n          minMaxValue = ").concat(o, "(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),
        d = "vec4";
    "all" === t ? (i = "1.0", h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", d = "bvec4") : "any" === t && (i = "0.0", h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", d = "bvec4");
    var p = "";
    r % n > 0 && (p = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return initializationValue;\n        }\n      ")), this.userCode = "\n      const float initializationValue = ".concat(i, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p, "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n, ";\n\n        vec4 minMaxValue = vec4(").concat(i, ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(u, "; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h, "\n        }\n\n        int inIdx = inOffset + ").concat(u, ";\n        if (").concat(1 === c, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h, "\n        } else if (").concat(2 === c, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h, "\n        } else if (").concat(3 === c, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h, "\n        }\n        setOutput(").concat(l, ");\n      }\n    ");
  }

}

function kv(e, t, n, s) {
  var r = function (e) {
    var t = [];

    for (; 0 === t.length || 1 !== t[t.length - 1].outSize;) {
      var _n280 = t.length ? t[t.length - 1].outSize : e[1],
          _s220 = Ro(_n280);

      t.push({
        inSize: _n280,
        windowSize: _s220,
        outSize: Math.ceil(_n280 / _s220)
      });
    }

    return t;
  }(e.shape);

  var a = e;

  for (var _i92 = 0; _i92 < r.length; _i92++) {
    var {
      inSize: _o69,
      windowSize: _l47,
      outSize: _u36
    } = r[_i92];

    var _c31 = void 0,
        _h18 = void 0;

    _c31 = "mean" === n ? 0 === _i92 ? new xv({
      windowSize: _l47,
      inSize: _o69,
      batchSize: e.shape[0],
      outSize: _u36
    }, _o69) : new xv({
      windowSize: _l47,
      inSize: _o69,
      batchSize: e.shape[0],
      outSize: _u36
    }) : new yv({
      windowSize: _l47,
      inSize: _o69,
      batchSize: e.shape[0],
      outSize: _u36
    }, n), _h18 = a, a = s.runWebGLProgram(_c31, [a], t), _h18.dataId !== e.dataId && s.disposeIntermediateTensorInfo(_h18);
  }

  return a;
}

class wv {
  constructor(e, t) {
    this.variableNames = ["A"];
    var n = new Array(e.length);

    for (var _s221 = 0; _s221 < n.length; _s221++) {
      n[_s221] = e[t[_s221]];
    }

    this.outputShape = n, this.rank = n.length;

    var s = Ck(this.rank),
        r = function (e) {
      var t = e.length;
      if (t > 6) throw Error("Transpose for rank ".concat(t, " is not yet supported"));
      var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"],
          s = new Array(t);

      for (var _t386 = 0; _t386 < e.length; _t386++) {
        s[e[_t386]] = n[_t386];
      }

      return s.join();
    }(t);

    this.userCode = "\n    void main() {\n      ".concat(s, " resRC = getOutputCoords();\n      setOutput(getA(").concat(r, "));\n    }\n    ");
  }

}

class vv {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
    var n = new Array(e.length);

    for (var _s222 = 0; _s222 < n.length; _s222++) {
      n[_s222] = e[t[_s222]];
    }

    if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error("Packed transpose for rank ".concat(this.rank, " is not yet supported."));

    var s = Ck(this.rank),
        r = _w("rc", this.rank),
        a = new Array(this.rank);

    for (var _e456 = 0; _e456 < t.length; _e456++) {
      a[t[_e456]] = r[_e456];
    }

    var i = "vec2(".concat(a.slice(-2).join(), ")"),
        o = "++".concat(r[this.rank - 1], " < ").concat(n[this.rank - 1]),
        l = "getChannel(getA(".concat(a.join(), "), ").concat(i, ")");
    this.userCode = "\n    void main() {\n      ".concat(s, " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(l, ";\n      if(").concat(o, ") {\n        result[1] = ").concat(l, ";\n      }\n      --").concat(r[this.rank - 1], ";\n      if(++").concat(r[this.rank - 2], " < ").concat(n[this.rank - 2], ") {\n        result[2] = ").concat(l, ";\n        if(").concat(o, ") {\n          result[3] = ").concat(l, ";\n        }\n      }\n      setOutput(result);\n    }\n    ");
  }

}

function Iv(e, t, n) {
  var s = G().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new vv(e.shape, t) : new wv(e.shape, t);
  return n.runWebGLProgram(s, [e], e.dtype);
}

function $v(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    axis: a,
    keepDims: i
  } = s;
  return function (e, t, n, s) {
    var r = e.shape.length,
        a = y(t, e.shape);
    var i = a;
    var o = Zr(i, r),
        l = null != o;
    var u = e;
    l && (u = Iv(e, o, s), i = ea(i.length, r)), Jr("sum", i, r);
    var [c, h] = Xr(u.shape, i);
    var p = c;
    n && (p = Yr(c, a));
    var f = d(h),
        g = mv({
      inputs: {
        x: u
      },
      attrs: {
        shape: [d(e.shape) / f, f]
      },
      backend: s
    }),
        m = kv(g, ft(e.dtype), "sum", s),
        b = mv({
      inputs: {
        x: m
      },
      attrs: {
        shape: p
      },
      backend: s
    });
    return s.disposeIntermediateTensorInfo(g), s.disposeIntermediateTensorInfo(m), l && s.disposeIntermediateTensorInfo(u), b;
  }(r, a, i, n);
}

var Sv = {
  kernelName: "Sum",
  backendName: "webgl",
  kernelFunc: $v
};

function Nv(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    perm: a
  } = s,
      i = n,
      o = new Array(r.shape.length);

  for (var _e457 = 0; _e457 < o.length; _e457++) {
    o[_e457] = r.shape[a[_e457]];
  }

  var l;

  if (i.shouldExecuteOnCPU([r])) {
    var _e458 = i.texData.get(r.dataId),
        _t387 = Fw(_e458.values, r.shape, r.dtype, a, o);

    l = i.makeTensorInfo(o, r.dtype), i.texData.get(l.dataId).values = _t387;
  } else l = Iv(r, a, i);

  return l;
}

var Cv = {
  kernelName: "Transpose",
  backendName: "webgl",
  kernelFunc: Nv
};

function Tv(_ref24) {
  var {
    a: e,
    b: t,
    transposeA: n,
    transposeB: s,
    backend: r,
    bias: a = null,
    preluActivationWeights: i = null,
    leakyreluAlpha: o = 0,
    activation: u = null
  } = _ref24;
  var c = e.shape.length,
      h = t.shape.length,
      p = n ? e.shape[c - 2] : e.shape[c - 1],
      f = s ? t.shape[h - 1] : t.shape[h - 2],
      g = n ? e.shape[c - 1] : e.shape[c - 2],
      m = s ? t.shape[h - 2] : t.shape[h - 1],
      b = e.shape.slice(0, -2),
      x = t.shape.slice(0, -2),
      y = d(b),
      k = d(x);
  l(c >= 2 && h >= 2 && (y === k || 1 === y || 1 === k), () => "Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (".concat(b, ") and (").concat(x, ")."));
  var w = (y > k ? e.shape.slice(0, -2) : t.shape.slice(0, -2)).concat([g, m]);
  l(p === f, () => "Error in matMul: inner shapes (".concat(p, ") and (").concat(f, ") of Tensors with shapes ").concat(e.shape, " and ").concat(t.shape, " and transposeA=").concat(n, " and transposeB=").concat(s, " must match."));
  var v = n ? [y, p, g] : [y, g, p],
      I = s ? [k, m, f] : [k, f, m],
      $ = mv({
    inputs: {
      x: e
    },
    backend: r,
    attrs: {
      shape: v
    }
  }),
      S = mv({
    inputs: {
      x: t
    },
    backend: r,
    attrs: {
      shape: I
    }
  }),
      N = [$, S],
      C = Math.max(y, k),
      T = n ? $.shape[1] : $.shape[2],
      E = null != a,
      R = null != i,
      A = "leakyrelu" === u,
      F = null != u ? cv(u, !0) : null;
  var D;

  if ((1 === g || 1 === m) && T > 1e3 && !1 === (E || R || A || null != F)) {
    var _e459 = $,
        _t388 = S;
    n && (_e459 = Nv({
      inputs: {
        x: $
      },
      backend: r,
      attrs: {
        perm: [0, 2, 1]
      }
    }), N.push(_e459)), s && (_t388 = Nv({
      inputs: {
        x: S
      },
      backend: r,
      attrs: {
        perm: [0, 2, 1]
      }
    }), N.push(_t388));

    var _a132 = 1 === m;

    var _i93 = _e459;
    1 !== m && (_i93 = mv({
      inputs: {
        x: _e459
      },
      backend: r,
      attrs: {
        shape: [C, T, 1]
      }
    }), N.push(_i93));

    var _o70 = 1 === m ? 2 : 1;

    var _l48 = _t388;
    _a132 && (_l48 = mv({
      inputs: {
        x: _t388
      },
      backend: r,
      attrs: {
        shape: [C, 1, T]
      }
    }), N.push(_l48));

    var _u37 = fv({
      inputs: {
        a: _i93,
        b: _l48
      },
      backend: r
    });

    D = $v({
      inputs: {
        x: _u37
      },
      backend: r,
      attrs: {
        axis: _o70,
        keepDims: !0
      }
    }), N.push(_u37);
  } else {
    var _l49 = pt(e.dtype, t.dtype),
        _u38 = new hv(v, I, [C, g, m], n, s, E, F, R, A),
        _c32 = [$, S];

    if (null != a && _c32.push(a), R && _c32.push(i), A) {
      var _e460 = r.makeTensorInfo([], "float32", Ue(o, "float32"));

      _c32.push(_e460), N.push(_e460);
    }

    D = r.runWebGLProgram(_u38, _c32, _l49);
  }

  var _ = mv({
    inputs: {
      x: D
    },
    backend: r,
    attrs: {
      shape: w
    }
  });

  N.push(D);

  for (var _e461 of N) {
    r.disposeIntermediateTensorInfo(_e461);
  }

  return _;
}

var Ev = {
  kernelName: "_FusedMatMul",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      a: r,
      b: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      transposeA: l,
      transposeB: u,
      activation: c,
      leakyreluAlpha: h
    } = s;
    return Tv({
      a: r,
      b: a,
      transposeA: l,
      transposeB: u,
      backend: n,
      bias: i,
      preluActivationWeights: o,
      leakyreluAlpha: h,
      activation: c
    });
  }
},
    Rv = "return abs(x);",
    Av = {
  kernelName: "Abs",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t;

    if (n.shouldExecuteOnCPU([s]) && "complex64" !== s.dtype) {
      var _e462 = n.texData.get(s.dataId),
          _t389 = yw(_e462.values);

      return n.makeTensorInfo(s.shape, s.dtype, _t389);
    }

    var r;
    return r = G().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new Gw(s.shape, Rv) : new Uw(s.shape, Rv), n.runWebGLProgram(r, [s], s.dtype);
  }
},
    Fv = {
  kernelName: "Acos",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"
  })
},
    Dv = {
  kernelName: "Acosh",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"
  })
},
    _v = "return a + b;",
    Ov = {
  kernelName: "Add",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: _v,
    packedOpSnippet: _v,
    supportsComplex: !0,
    cpuKernelImpl: qk
  })
};

class Mv {
  constructor(e, t) {
    this.outputShape = [], this.outputShape = e, this.variableNames = t.map((e, t) => "T".concat(t));
    var n = [];
    this.variableNames.forEach(e => {
      n.push("float v".concat(e, " = get").concat(e, "AtOutCoords();"));
    });
    var s = this.variableNames.map(e => "v".concat(e)).join(" + ");
    this.userCode = "\n      void main() {\n        ".concat(n.join("\n        "), "\n\n        float result = ").concat(s, ";\n        setOutput(result);\n      }\n    ");
  }

}

class Lv {
  constructor(e, t) {
    this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.variableNames = t.map((e, t) => "T".concat(t));
    var n = [];
    this.variableNames.forEach(e => {
      n.push("vec4 v".concat(e, " = get").concat(e, "AtOutCoords();"));
    });
    var s = this.variableNames.map(e => "v".concat(e)).join(" + ");
    this.userCode = "\n      void main() {\n        ".concat(n.join("\n        "), "\n\n        vec4 result = ").concat(s, ";\n        setOutput(result);\n      }\n    ");
  }

}

var zv = {
  kernelName: "AddN",
  backendName: "webgl",
  kernelFunc: function e(t) {
    var {
      inputs: n,
      backend: s
    } = t,
        r = n;
    if (1 === r.length) return Zw({
      inputs: {
        x: r[0]
      },
      backend: s
    });

    if (r.length > G().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var _t390 = Math.floor(r.length / 2),
          _n281 = e({
        inputs: r.slice(0, _t390),
        backend: s
      }),
          _a133 = e({
        inputs: r.slice(_t390),
        backend: s
      });

      return e({
        inputs: [_n281, _a133],
        backend: s
      });
    }

    var a = r.map(e => e.dtype).reduce((e, t) => pt(e, t)),
        i = r.map(e => e.shape),
        o = G().getBool("WEBGL_PACK") ? new Lv(r[0].shape, i) : new Mv(r[0].shape, i);
    return s.runWebGLProgram(o, r, a);
  }
},
    Bv = {
  kernelName: "All",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s,
        o = r.shape.length,
        l = y(a, r.shape);
    var u = l;
    var c = Zr(u, o);
    var h = r;
    null != c && (h = Nv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), u = ea(u.length, o)), Jr("all", u, o);
    var [p, f] = Xr(h.shape, u),
        g = mv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, d(f)]
      }
    }),
        m = kv(g, g.dtype, "all", n);
    var b;
    return b = mv(i ? {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Yr(p, l)
      }
    } : {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: p
      }
    }), n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), b;
  }
},
    Pv = {
  kernelName: "Any",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s,
        o = r.shape.length,
        l = y(a, r.shape);
    var u = l;
    var c = Zr(u, o);
    var h = r;
    null != c && (h = Nv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), u = ea(u.length, o)), Jr("any", u, o);
    var [p, f] = Xr(h.shape, u),
        g = mv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, d(f)]
      }
    }),
        m = kv(g, g.dtype, "any", n);
    var b;
    return b = mv(i ? {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Yr(p, l)
      }
    } : {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: p
      }
    }), n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), b;
  }
};

class Wv {
  constructor(e, t, n) {
    this.variableNames = ["A"];
    var {
      windowSize: s,
      batchSize: r,
      outSize: a
    } = e;
    n || this.variableNames.push("bestIndicesA"), this.outputShape = [r, a], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(s, ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(s, "; i++) {\n          int inIdx = ").concat(n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));", ";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat("max" === t ? ">" : "<", " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ");
  }

}

class Uv {
  constructor(e, t, n, s) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, l(e.length > 2, () => "Packed arg".concat(n.charAt(0).toUpperCase() + n.slice(1), " supports only inputs with rank above 2."));
    var r = Math.ceil(e[e.length - 1] / t);
    this.outputShape = e.slice(0, -1), r > 1 && this.outputShape.push(r), s || this.variableNames.push("bestIndicesA");
    var a = this.outputShape,
        i = a.length,
        o = Ck(i),
        u = Ow("coords", i);
    var c, h;

    if (1 === r) {
      h = i + 1;

      var _e463 = Ck(h);

      c = "\n        ".concat(_e463, " sourceLocR = ").concat(_e463, "(").concat(u.join(), ", 0);\n        ++").concat(u[i - 1], ";\n        ").concat(_e463, " sourceLocG = ").concat(_e463, "(").concat(u.join(), ", 0);\n        ++").concat(u[i - 2], ";\n        ").concat(_e463, " sourceLocA = ").concat(_e463, "(").concat(u.join(), ", 0);\n        --").concat(u[i - 1], ";\n        ").concat(_e463, " sourceLocB = ").concat(_e463, "(").concat(u.join(), ", 0);\n        --").concat(u[i - 2], ";");
    } else h = i, c = "\n        ".concat(o, " sourceLocR = coords;\n        ++").concat(u[i - 1], ";\n        ").concat(o, " sourceLocG = coords;\n        ++").concat(u[i - 2], ";\n        ").concat(o, " sourceLocA = coords;\n        --").concat(u[i - 1], ";\n        ").concat(o, " sourceLocB = coords;\n        --").concat(u[i - 2], ";");

    var d = ["x", "y", "z", "w", "u", "v"].slice(0, h),
        p = "." + d[h - 1],
        f = d.map(e => "int " + e),
        g = Ow("sourceLocR", h - 1).concat("inIdx.r"),
        m = Ow("sourceLocG", h - 1).concat("inIdx.g"),
        b = Ow("sourceLocB", h - 1).concat("inIdx.b"),
        x = Ow("sourceLocA", h - 1).concat("inIdx.a"),
        y = "max" === n ? "greaterThan" : "lessThan",
        k = s ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(g.join(), "),\n                             getBestIndicesAChannel(").concat(m.join(), "),\n                             getBestIndicesAChannel(").concat(b.join(), "),\n                             getBestIndicesAChannel(").concat(x.join(), ")));"),
        w = "vec4(\n            getAChannel(".concat(g.join(), "),\n            hasNextCol ? getAChannel(").concat(m.join(), ") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(), ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(x.join(), ") : 0.)"),
        v = s ? "" : "\n      float getBestIndicesAChannel(".concat(f.join(), ") {\n        return getChannel(getBestIndicesA(").concat(d.join(), "),\n                                          vec2(").concat(d.slice(-2).join(), "));\n      }");
    this.userCode = "\n      float getAChannel(".concat(f.join(), ") {\n        return getChannel(getA(").concat(d.join(), "),\n                               vec2(").concat(d.slice(-2).join(), "));\n      }\n      ").concat(v, "\n      void main() {\n        ").concat(o, " coords = getOutputCoords();\n        bool hasNextCol = ").concat(u[i - 1], " < ").concat(a[i - 1] - 1, ";\n        bool hasNextRow = ").concat(u[i - 2], " < ").concat(a[i - 2] - 1, ";\n        ").concat(c, "\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p, ", sourceLocG").concat(p, ",\n          sourceLocB").concat(p, ", sourceLocA").concat(p, ") * ").concat(t, ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w, ";\n\n        for (int i = 0; i < ").concat(t, "; i++) {\n          inIdx = srcIdx;\n          ").concat(k, "\n          vec4 candidate = ").concat(w, ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(y, "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ");
  }

}

function Vv(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var r = t.shape[0],
      a = t.shape[1];
  null != s && (r = s.shape[0], a = s.shape[1]);
  var i = Ro(a),
      o = {
    windowSize: i,
    inSize: a,
    batchSize: r,
    outSize: Math.ceil(a / i)
  },
      l = new Wv(o, n, null == s),
      u = [t];
  null != s && u.push(s);
  var c = e.runWebGLProgram(l, u, "int32");
  if (1 === c.shape[1]) return c;
  var h = Vv(e, t, n, c);
  return e.disposeIntermediateTensorInfo(c), h;
}

function Gv(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var r = null != s ? s.shape : t.shape,
      a = Ro(r[r.length - 1]),
      i = new Uv(r, a, n, null == s),
      o = e.runWebGLProgram(i, null == s ? [t] : [t, s], "int32");

  if (o.shape.length === t.shape.length) {
    var _s223 = Gv(e, t, n, o);

    return e.disposeIntermediateTensorInfo(o), _s223;
  }

  return o;
}

function Hv(e, t, n, s) {
  var r = [n];

  if (Jr("arg" + s.charAt(0).toUpperCase() + s.slice(1), r, t.shape.length), !G().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
    var _n282 = [],
        _a134 = e.texData.get(t.dataId);

    var _i94 = t;
    null !== _a134 && _a134.isPacked && (_i94 = e.unpackTensor(t), _n282.push(_i94));

    var [_o71, _l50] = Xr(_i94.shape, r),
        _u39 = d(_l50),
        _c33 = mv({
      inputs: {
        x: _i94
      },
      backend: e,
      attrs: {
        shape: [-1, _u39]
      }
    });

    _n282.push(_c33);

    var _h19 = Vv(e, _c33, s);

    _n282.push(_h19);

    var _p16 = mv({
      inputs: {
        x: _h19
      },
      backend: e,
      attrs: {
        shape: _o71
      }
    });

    return _n282.forEach(t => e.disposeIntermediateTensorInfo(t)), _p16;
  }

  return Gv(e, t, s);
}

var qv = {
  kernelName: "ArgMax",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a
    } = s;
    var i = y(a, r.shape);
    var o = Zr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = Nv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = ea(i.length, l.shape.length)), Jr("argMax", [i[0]], l.shape.length);
    var c = Hv(n, l, i[0], "max");
    return u.forEach(e => n.disposeIntermediateTensorInfo(e)), c;
  }
},
    jv = {
  kernelName: "ArgMin",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a
    } = s;
    var i = y(a, r.shape);
    var o = Zr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = Nv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = ea(i.length, l.shape.length)), Jr("argMin", [i[0]], l.shape.length);
    var c = Hv(n, l, i[0], "min");
    return u.forEach(e => n.disposeIntermediateTensorInfo(e)), c;
  }
},
    Kv = {
  kernelName: "Asin",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"
  })
},
    Xv = {
  kernelName: "Asinh",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"
  })
},
    Yv = {
  kernelName: "Atan",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (isnan(x)) return x;\n  return atan(x);\n"
  })
},
    Jv = {
  kernelName: "Atan2",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",
    packedOpSnippet: "\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
  })
},
    Zv = {
  kernelName: "Atanh",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"
  })
};

class Qv {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    if (this.variableNames = ["x"], "avg" === t && n) throw new Error("Cannot compute positions for average pool.");
    var a = e.filterWidth,
        i = e.strideHeight,
        o = e.strideWidth,
        l = e.dilationHeight,
        u = e.dilationWidth,
        c = e.effectiveFilterHeight,
        h = e.effectiveFilterWidth,
        d = e.padInfo.top,
        p = e.padInfo.left;
    this.outputShape = e.outShape;
    var f = "avg" === t;
    var g = "0.0";
    if (f || (g = "-1.0 / 1e-20"), n) return void (this.userCode = "\n        const ivec2 strides = ivec2(".concat(i, ", ").concat(o, ");\n        const ivec2 pads = ivec2(").concat(d, ", ").concat(p, ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(c, ";\n              wR += ").concat(l, ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h, ";\n                wC += ").concat(u, ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(s ? r ? "((batch  * ".concat(e.inHeight, " + xR) * ").concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + d") : "(xR * ".concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + d") : "wR * ".concat(h, " + wC"), ";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "));
    var m = "".concat(t, "(").concat(t, "(").concat(t, "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");
    "avg" === t && (m = "avgValue / count");
    var b = 4 * Math.floor(a / 4),
        x = a % 4,
        y = "\n      if (".concat(f, ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ");
    this.userCode = "\n      const ivec2 strides = ivec2(".concat(i, ", ").concat(o, ");\n      const ivec2 pads = ivec2(").concat(d, ", ").concat(p, ");\n      const float initializationValue = ").concat(g, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(g, ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(c, ";\n            wR += ").concat(l, ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(b, "; wC += 4) {\n            int xC = xCCorner + wC * ").concat(u, ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u, ", d),\n              getValue(batch, xR, xC + 2 * ").concat(u, ", d),\n              getValue(batch, xR, xC + 3 * ").concat(u, ", d)\n            );\n\n            ").concat(y, "\n          }\n\n          int xC = xCCorner + ").concat(b, ";\n          if (").concat(1 === x, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(y, "\n          } else if (").concat(2 === x, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u, ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(y, "\n          } else if (").concat(3 === x, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u, ", d),\n              getValue(batch, xR, xC + 2 * ").concat(u, ", d),\n              initializationValue\n            );\n\n            ").concat(y, "\n          }\n        }\n        setOutput(").concat(m, ");\n      }\n    ");
  }

}

class eI {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    if (this.variableNames = ["x"], "avg" === t && n) throw new Error("Cannot compute positions for average pool.");
    var a = e.filterWidth,
        i = e.strideDepth,
        o = e.strideHeight,
        l = e.strideWidth,
        u = e.dilationDepth,
        c = e.dilationHeight,
        h = e.dilationWidth,
        d = e.effectiveFilterDepth,
        p = e.effectiveFilterHeight,
        f = e.effectiveFilterWidth,
        g = e.padInfo.front,
        m = e.padInfo.top,
        b = e.padInfo.left;
    this.outputShape = e.outShape;
    var x = "avg" === t;
    var y = "0.0";
    if (x || (y = "-1.0 / 1e-20"), n) return void (this.userCode = "\n        const ivec3 strides =\n            ivec3(".concat(i, ", ").concat(o, ", ").concat(l, ");\n        const ivec3 pads = ivec3(").concat(g, ", ").concat(m, ", ").concat(b, ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d, ";\n              wD += ").concat(u, ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth, ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p, ";\n                wR += ").concat(c, ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f, ";\n                  wC += ").concat(h, ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(s ? r ? "(((batch * ".concat(e.inDepth, " + xD) * ").concat(e.inHeight, " + xR) * ").concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + ch") : "((xD * ".concat(e.inHeight, " + xR) * ").concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + ch") : "wD * ".concat(p, " * ").concat(f, " +\n                      wR * ").concat(f, " + wC"), ";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "));
    var k = "".concat(t, "(").concat(t, "(").concat(t, "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");
    "avg" === t && (k = "avgValue / count");
    var w = 4 * Math.floor(a / 4),
        v = a % 4,
        I = "\n      if (".concat(x, ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ");
    this.userCode = "\n      const ivec3 strides =\n        ivec3(".concat(i, ", ").concat(o, ", ").concat(l, ");\n      const ivec3 pads = ivec3(").concat(g, ", ").concat(m, ", ").concat(b, ");\n      const float initializationValue = ").concat(y, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(y, ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d, ";\n            wD += ").concat(u, ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth, ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p, ";\n            wR += ").concat(c, ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w, "; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h, ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h, ", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h, ", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h, ", ch)\n              );\n\n              ").concat(I, "\n            }\n\n            int xC = xCCorner + ").concat(w, ";\n            if (").concat(1 === v, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I, "\n            } else if (").concat(2 === v, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h, ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I, "\n            } else if (").concat(3 === v, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h, ", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h, ", ch),\n                initializationValue\n              );\n\n              ").concat(I, "\n            }\n          }\n          setOutput(").concat(k, ");\n        }\n      }\n    ");
  }

}

var tI = {
  kernelName: "AvgPool",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t;
    ck(r, "avgPool");
    var {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: u
    } = s;
    l(Ts(i, 1), () => "Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'"));
    var c = xs(r.shape, a, i, 1, o, u);
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) return Zw({
      inputs: {
        x: r
      },
      backend: n
    });
    var h = new Qv(c, "avg", !1);
    return n.runWebGLProgram(h, [r], "float32");
  }
},
    nI = {
  kernelName: "AvgPool3D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: l,
      dataFormat: u
    } = s,
        c = ys(r.shape, a, i, [1, 1, 1], o, l, u),
        h = new eI(c, "avg", !1);
    return n.runWebGLProgram(h, [r], "float32");
  }
};

class sI {
  constructor(e) {
    this.variableNames = ["dy"], this.outputShape = e.inShape;
    var t = e.effectiveFilterHeight,
        n = e.effectiveFilterWidth;
    this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n      const float avgMultiplier = float(").concat(1 / (e.filterHeight * e.filterWidth), ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t, ";\n            wR += ").concat(e.dilationHeight, ") {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(n, ";\n            wC+= ").concat(e.dilationWidth, ") {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class rI {
  constructor(e) {
    this.variableNames = ["dy"], this.outputShape = e.inShape;
    var t = e.effectiveFilterDepth,
        n = e.effectiveFilterHeight,
        s = e.effectiveFilterWidth;
    this.userCode = "\n      const ivec3 pads = ivec3(".concat(t - 1 - e.padInfo.front, ", ").concat(n - 1 - e.padInfo.top, ", ").concat(s - 1 - e.padInfo.left, ");\n      const float avgMultiplier = float(").concat(1 / (e.filterDepth * e.filterHeight * e.filterWidth), ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(t, ";\n            wD += ").concat(e.dilationDepth, ") {\n          float dyD = float(dyDCorner + wD) / ").concat(e.strideDepth, ".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth, ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(n, ";\n              wR += ").concat(e.dilationHeight, ") {\n            float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(s, ";\n                wC += ").concat(e.dilationWidth, ") {\n              float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

var aI = {
  kernelName: "AvgPool3DGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        i = a,
        {
      filterSize: o,
      strides: l,
      pad: u,
      dimRoundingMode: c
    } = s,
        h = ys(i.shape, o, l, [1, 1, 1], u, c),
        d = new rI(h);
    return n.runWebGLProgram(d, [r], i.dtype);
  }
},
    iI = {
  kernelName: "AvgPoolGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        i = a;
    ck([r, a], "avgPoolGrad");
    var {
      filterSize: o,
      strides: l,
      pad: u
    } = s,
        c = xs(i.shape, o, l, 1, u),
        h = new sI(c);
    return n.runWebGLProgram(h, [r], i.dtype);
  }
},
    oI = {
  kernelName: "BatchMatMul",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      a: r,
      b: a
    } = t,
        {
      transposeA: i,
      transposeB: o
    } = s;
    return Tv({
      a: r,
      b: a,
      transposeA: i,
      transposeB: o,
      backend: n
    });
  }
};

class lI {
  constructor(e, t, n, s, r, a) {
    this.outputShape = [], this.variableNames = ["x", "mean", "variance"], hr(e, t), hr(e, n);
    var i = "0.0";
    null != s && (hr(e, s), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
    var o = "1.0";
    null != r && (hr(e, r), this.variableNames.push("scale"), o = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(i, ";\n        float scale = ").concat(o, ";\n        float inv = scale * inversesqrt(variance + float(").concat(a, "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ");
  }

}

class uI {
  constructor(e, t, n, s, r, a) {
    this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], hr(e, t), hr(e, n);
    var i = "vec4(0.0)";
    null != s && (hr(e, s), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
    var o = "vec4(1.0)";
    null != r && (hr(e, r), this.variableNames.push("scale"), o = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = "\n      void main() {\n        vec4 offset = ".concat(i, ";\n        vec4 scale = ").concat(o, ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(a, "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ");
  }

}

var cI = {
  kernelName: "FusedBatchNorm",
  backendName: "webgl",
  kernelFunc: _ref25 => {
    var {
      inputs: e,
      backend: t,
      attrs: n
    } = _ref25;
    var {
      x: s,
      mean: r,
      variance: a,
      offset: i,
      scale: o
    } = e;
    l(r.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), l(null == i || r.shape.length === i.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), l(null == o || r.shape.length === o.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    var {
      varianceEpsilon: u
    } = n;
    null == u && (u = .001);
    var c = [s, r, a];
    var h = null;
    null != i && (h = i.shape, c.push(i));
    var d = null;
    null != o && (d = o.shape, c.push(o));
    var p = G().getBool("WEBGL_PACK_NORMALIZATION") ? new uI(s.shape, r.shape, a.shape, h, d, u) : new lI(s.shape, r.shape, a.shape, h, d, u);
    return t.runWebGLProgram(p, c, c[0].dtype);
  }
};

class hI {
  constructor(e) {
    this.variableNames = ["source"], this.outputShape = e, this.rank = e.length;
    var t = Ck(this.rank);
    this.customUniforms = [{
      name: "start",
      arrayIndex: this.rank,
      type: "int"
    }];

    var n = function (e) {
      if (1 === e) return "sourceLoc";
      if (e <= 6) return dI.slice(0, e).map(e => "sourceLoc." + e).join(",");
      throw Error("Slicing for rank ".concat(e, " is not yet supported"));
    }(this.rank);

    var s;
    s = "\n        ".concat(t, " sourceLoc;\n        ").concat(t, " coords = getOutputCoords();\n        ").concat(e.map((e, t) => "sourceLoc.".concat(dI[t], " = start[").concat(t, "] + coords.").concat(dI[t], ";")).join("\n"), "\n      "), this.userCode = "\n      void main() {\n        ".concat(s, "\n        setOutput(getSource(").concat(n, "));\n      }\n    ");
  }

}

var dI = ["x", "y", "z", "w", "u", "v"];

class pI {
  constructor(e) {
    this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.rank = e.length, this.customUniforms = [{
      name: "start",
      arrayIndex: this.rank,
      type: "int"
    }];
    var t = Ck(this.rank),
        n = Ow("coords", this.rank),
        s = Ow("sourceLoc", this.rank),
        r = 1 === this.rank ? "sourceLoc" : "vec2(".concat(s.slice(-2).join(), ")"),
        a = "getChannel(getSource(".concat(s.join(), "), ").concat(r, ")"),
        i = "\n      result.x = ".concat(a, ";\n      if (++").concat(n[this.rank - 1], " < ").concat(e[this.rank - 1], ") {\n        ++").concat(s[this.rank - 1], ";\n        result.y = ").concat(a, ";\n        --").concat(s[this.rank - 1], ";\n      }\n    "),
        o = 1 === this.rank ? "" : "\n      --".concat(n[this.rank - 1], ";\n      if (++").concat(n[this.rank - 2], " < ").concat(e[this.rank - 2], ") {\n        ++").concat(s[this.rank - 2], ";\n        result.z = ").concat(a, ";\n        if (++").concat(n[this.rank - 1], " < ").concat(e[this.rank - 1], ") {\n          ++").concat(s[this.rank - 1], ";\n          result.w = ").concat(a, ";\n        }\n      }\n    "),
        l = this.rank <= 4 ? "sourceLoc = coords +\n            ".concat(t, "(").concat(e.map((e, t) => "start[".concat(t, "]")).join(), ");") : e.map((e, t) => "".concat(s[t], " = ").concat(n[t], " + start[").concat(t, "];")).join("\n");
    this.userCode = "\n      void main() {\n        ".concat(t, " coords = getOutputCoords();\n        ").concat(t, " sourceLoc;\n        ").concat(l, "\n        vec4 result = vec4(0.);\n        ").concat(i, "\n        ").concat(o, "\n        setOutput(result);\n      }\n    ");
  }

}

function fI(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    begin: a,
    size: i
  } = s,
      [o, l] = Vn(r, a, i);
  if (En(r, o, l), 0 === d(l)) return n.makeTensorInfo(l, r.dtype, []);

  if (n.shouldExecuteOnCPU([r]) || "string" === r.dtype) {
    var _e464 = n.texData.get(r.dataId),
        _t391 = kw(_e464.values, o, l, r.shape, r.dtype);

    return n.makeTensorInfo(l, r.dtype, _t391);
  }

  var {
    isPacked: u
  } = n.texData.get(r.dataId),
      c = Wn(r.shape, o, l);

  if (u || !c) {
    var _e465 = G().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new pI(l) : new hI(l);

    return n.runWebGLProgram(_e465, [r], r.dtype, [o]);
  }

  return n.uploadToGPU(r.dataId), function (e, t, n, s) {
    var r = s.texData.get(e.dataId),
        a = s.makeTensorInfo(n, e.dtype),
        i = s.texData.get(a.dataId);
    Object.assign(i, r), i.refCount = 1, i.shape = n, i.dtype = e.dtype;
    var o = Un(t, A(e.shape));
    r.slice && (o += r.slice.flatOffset), i.slice = {
      flatOffset: o,
      origDataId: r.slice && r.slice.origDataId || e.dataId
    };
    var l = s.dataRefCount.get(i.slice.origDataId) || 1;
    return s.dataRefCount.set(i.slice.origDataId, l + 1), a;
  }(r, o, l, n);
}

var gI = {
  kernelName: "Slice",
  backendName: "webgl",
  kernelFunc: fI
},
    mI = {
  kernelName: "BatchToSpaceND",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockShape: a,
      crops: i
    } = s;
    l(r.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");

    var o = a.reduce((e, t) => e * t),
        u = Fo(r.shape, a, o),
        c = Do(u.length, a.length),
        h = _o(r.shape, a, o),
        d = Oo(i, a.length),
        p = Mo(h, i, a.length),
        f = [],
        g = mv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: u
      }
    }),
        m = Nv({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        perm: c
      }
    }),
        b = mv({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: h
      }
    }),
        x = fI({
      inputs: {
        x: b
      },
      backend: n,
      attrs: {
        begin: d,
        size: p
      }
    });

    return f.push(g), f.push(m), f.push(b), f.forEach(e => n.disposeIntermediateTensorInfo(e)), x;
  }
},
    bI = {
  kernelName: "Bincount",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      weights: a
    } = t,
        {
      size: i
    } = s,
        o = n.readSync(r.dataId),
        l = n.readSync(a.dataId),
        u = jk(o, l, a.dtype, a.shape, i);
    return n.makeTensorInfo([i], a.dtype, u);
  }
},
    xI = uv({
  opSnippet: "return float(a != b);",
  cpuKernelImpl: fw,
  dtype: "bool"
}),
    yI = {
  kernelName: "NotEqual",
  backendName: "webgl",
  kernelFunc: xI
};

function kI(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    input: s
  } = t;
  return Zw({
    inputs: {
      x: n.texData.get(s.dataId).complexTensorInfos.real
    },
    backend: n
  });
}

var wI = {
  kernelName: "Real",
  backendName: "webgl",
  kernelFunc: kI
},
    vI = {
  kernelName: "Cast",
  backendName: "webgl",
  kernelFunc: function e(t) {
    var {
      inputs: n,
      backend: s,
      attrs: r
    } = t,
        {
      x: a
    } = n,
        {
      dtype: i
    } = r;

    if ("complex64" === i) {
      if ("complex64" === a.dtype) return Zw({
        inputs: {
          x: a
        },
        backend: s
      });

      var _t392 = ca(a.shape),
          _n283 = e({
        inputs: {
          x: a
        },
        backend: s,
        attrs: {
          dtype: "float32"
        }
      }),
          _r164 = ev({
        inputs: {
          real: _n283,
          imag: _t392
        },
        backend: s
      });

      return _t392.dispose(), s.disposeIntermediateTensorInfo(_n283), _r164;
    }

    if ("complex64" === a.dtype) {
      var _t393 = kI({
        inputs: {
          input: a
        },
        backend: s
      }),
          _n284 = e({
        inputs: {
          x: _t393
        },
        backend: s,
        attrs: {
          dtype: i
        }
      });

      return s.disposeIntermediateTensorInfo(_t393), _n284;
    }

    if (!I(a.dtype, i)) {
      var _e466 = Zw({
        inputs: {
          x: a
        },
        backend: s
      });

      return {
        dataId: _e466.dataId,
        shape: _e466.shape,
        dtype: i
      };
    }

    if ("int32" === i) return function (e, t) {
      var n = new Uw(e.shape, "return float(int(x));"),
          s = t.runWebGLProgram(n, [e], "int32");
      return {
        dataId: s.dataId,
        shape: s.shape,
        dtype: s.dtype
      };
    }(a, s);

    if ("bool" === i) {
      var _e467 = s.makeTensorInfo([], "bool", w("bool", 1)),
          _t394 = xI({
        inputs: {
          a,
          b: _e467
        },
        backend: s
      });

      return s.disposeIntermediateTensorInfo(_e467), _t394;
    }

    throw new Error("Error in Cast: failed to cast ".concat(a.dtype, " to ").concat(i));
  }
},
    II = "return ceil(x);",
    $I = {
  kernelName: "Ceil",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: II,
    packedOpSnippet: II,
    cpuKernelImpl: Xk
  })
};

class SI {
  constructor(e) {
    this.variableNames = ["A"], this.customUniforms = [{
      name: "minVal",
      type: "float"
    }, {
      name: "maxVal",
      type: "float"
    }], this.outputShape = e, this.userCode = "\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
  }

}

class NI {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
      name: "minVal",
      type: "float"
    }, {
      name: "maxVal",
      type: "float"
    }], this.outputShape = e, this.userCode = "\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
  }

}

var CI = {
  kernelName: "ClipByValue",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      clipValueMin: a,
      clipValueMax: i
    } = s;
    var o;
    return o = G().getBool("WEBGL_PACK_CLIP") ? new NI(r.shape) : new SI(r.shape), n.runWebGLProgram(o, [r], r.dtype, [[a], [i]]);
  }
};

class TI {
  constructor(e) {
    this.variableNames = ["real", "imag"], this.outputShape = e, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
  }

}

function EI(e, t) {
  return {
    dataId: t.dataId,
    dtype: t.dtype,
    shape: e.shape
  };
}

var RI = {
  kernelName: "ComplexAbs",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t,
        r = n.texData.get(s.dataId),
        a = new TI(s.shape),
        i = [EI(s, r.complexTensorInfos.real), EI(s, r.complexTensorInfos.imag)];
    return n.runWebGLProgram(a, i, i[0].dtype);
  }
};

class AI {
  constructor(e) {
    this.outputShape = [], this.outputShape = Eo(e, 1), this.variableNames = e.map((e, t) => "T".concat(t));
    var t = new Array(e.length - 1);
    t[0] = e[0][1];

    for (var _n285 = 1; _n285 < t.length; _n285++) {
      t[_n285] = t[_n285 - 1] + e[_n285][1];
    }

    var n = ["if (yC < ".concat(t[0], ") setOutput(getT0(yR, yC));")];

    for (var _e468 = 1; _e468 < t.length; _e468++) {
      n.push("else if (yC < ".concat(t[_e468], ") setOutput(getT").concat(_e468, "(yR, yC-").concat(t[_e468 - 1], "));"));
    }

    n.push("else setOutput(getT".concat(t.length, "(yR, yC-").concat(t[t.length - 1], "));")), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "), "\n      }\n    ");
  }

}

class FI {
  constructor(e, t) {
    this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = Eo(e, t);
    var n = this.outputShape,
        s = n.length,
        r = Ck(s),
        a = Ow("coords", s),
        i = ["x", "y", "z", "w", "u", "v"].slice(0, s);
    this.variableNames = e.map((e, t) => "T".concat(t));
    var o = new Array(e.length - 1);
    o[0] = e[0][t];

    for (var _n286 = 1; _n286 < o.length; _n286++) {
      o[_n286] = o[_n286 - 1] + e[_n286][t];
    }

    var l = i[t],
        u = i.slice(-2),
        c = i.join();
    var h = "if (".concat(l, " < ").concat(o[0], ") {\n        return getChannel(\n            getT0(").concat(c, "), vec2(").concat(u.join(), "));\n        }");

    for (var _e469 = 1; _e469 < o.length; _e469++) {
      var _t395 = o[_e469 - 1];
      h += "\n        if (".concat(l, " < ").concat(o[_e469], "  && ").concat(l, " >= ").concat(o[_e469 - 1], ") {\n          return getChannel(\n            getT").concat(_e469, "(").concat(DI(i, l, _t395), "),\n            vec2(").concat(DI(u, l, _t395), "));\n        }");
    }

    var d = o[o.length - 1];
    h += "\n        return getChannel(\n          getT".concat(o.length, "(").concat(DI(i, l, d), "),\n          vec2(").concat(DI(u, l, d), "));"), this.userCode = "\n      float getValue(".concat(i.map(e => "int " + e), ") {\n        ").concat(h, "\n      }\n\n      void main() {\n        ").concat(r, " coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(a, "), 0., 0., 0.);\n\n        ").concat(a[s - 1], " = ").concat(a[s - 1], " + 1;\n        if (").concat(a[s - 1], " < ").concat(n[s - 1], ") {\n          result.g = getValue(").concat(a, ");\n        }\n\n        ").concat(a[s - 2], " = ").concat(a[s - 2], " + 1;\n        if (").concat(a[s - 2], " < ").concat(n[s - 2], ") {\n          result.a = getValue(").concat(a, ");\n        }\n\n        ").concat(a[s - 1], " = ").concat(a[s - 1], " - 1;\n        if (").concat(a[s - 2], " < ").concat(n[s - 2], " &&\n            ").concat(a[s - 1], " < ").concat(n[s - 1], ") {\n          result.b = getValue(").concat(a, ");\n        }\n        setOutput(result);\n      }\n    ");
  }

}

function DI(e, t, n) {
  var s = e.indexOf(t);
  return e.map((e, t) => t === s ? "".concat(e, " - ").concat(n) : e).join();
}

function _I(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    input: s
  } = t;
  return Zw({
    inputs: {
      x: n.texData.get(s.dataId).complexTensorInfos.imag
    },
    backend: n
  });
}

var OI = {
  kernelName: "Imag",
  backendName: "webgl",
  kernelFunc: _I
};

function MI(e, t, n) {
  var s = e[0].dtype;

  if ("complex64" === s) {
    var _s224 = e.map(e => kI({
      inputs: {
        input: e
      },
      backend: n
    })),
        _r165 = e.map(e => _I({
      inputs: {
        input: e
      },
      backend: n
    })),
        _a135 = MI(_s224, t, n),
        _i95 = MI(_r165, t, n),
        _o72 = ev({
      inputs: {
        real: _a135,
        imag: _i95
      },
      backend: n
    });

    return _s224.forEach(e => n.disposeIntermediateTensorInfo(e)), _r165.forEach(e => n.disposeIntermediateTensorInfo(e)), n.disposeIntermediateTensorInfo(_a135), n.disposeIntermediateTensorInfo(_i95), _o72;
  }

  var r = n.shouldExecuteOnCPU(e);

  if ("string" === s && (r = !0), r) {
    var _r166 = e.map(e => {
      var s = d(e.shape.slice(t));
      return mv({
        inputs: {
          x: e
        },
        backend: n,
        attrs: {
          shape: [-1, s]
        }
      });
    }),
        _a136 = _r166.map(e => ({
      vals: n.readSync(e.dataId),
      shape: e.shape
    })),
        _i96 = Eo(_r166.map(e => e.shape), 1),
        _o73 = Yk(_a136, _i96, s, 1 === _r166[0].shape[0]),
        _l51 = Eo(e.map(e => e.shape), t),
        _u40 = n.makeTensorInfo(_l51, s, _o73);

    return _r166.forEach(e => n.disposeIntermediateTensorInfo(e)), _u40;
  }

  if (e.length > G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    var _s225 = Math.floor(e.length / 2),
        _r167 = MI(e.slice(0, _s225), t, n),
        _a137 = MI(e.slice(_s225), t, n),
        _i97 = MI([_r167, _a137], t, n);

    return n.disposeIntermediateTensorInfo(_r167), n.disposeIntermediateTensorInfo(_a137), _i97;
  }

  if (G().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && e[0].shape.length > 1) {
    var _r168 = new FI(e.map(e => e.shape), t);

    return n.runWebGLProgram(_r168, e, s);
  }

  var {
    tensors2D: a,
    outShape: i
  } = function (e, t, n) {
    var s = Eo(e.map(e => e.shape), t);
    return {
      tensors2D: e.map(e => mv({
        inputs: {
          x: e
        },
        attrs: {
          shape: [-1, d(e.shape.slice(t))]
        },
        backend: n
      })),
      outShape: s
    };
  }(e, t, n),
      o = new AI(a.map(e => e.shape)),
      l = n.runWebGLProgram(o, a, s);

  a.forEach(e => n.disposeIntermediateTensorInfo(e));
  var u = mv({
    inputs: {
      x: l
    },
    attrs: {
      shape: i
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(l), u;
}

function LI(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    axis: r
  } = s,
      a = y(r, t[0].shape)[0],
      i = Eo(t.map(e => e.shape), a);
  if (0 === d(i)) return n.makeTensorInfo(i, t[0].dtype, []);
  var o = t.filter(e => d(e.shape) > 0);
  return 1 === o.length ? Zw({
    inputs: {
      x: o[0]
    },
    backend: n
  }) : (To(o.map(e => e.shape), a), MI(o, a, n));
}

var zI = {
  kernelName: "Concat",
  backendName: "webgl",
  kernelFunc: LI
};

class BI {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    var a = e.padInfo.top,
        i = e.padInfo.left,
        o = e.strideHeight,
        l = e.strideWidth,
        u = e.dilationHeight,
        c = e.dilationWidth,
        h = e.filterHeight,
        d = e.filterWidth,
        p = 4 * Math.floor(e.inChannels / 4),
        f = e.inChannels % 4,
        g = "channelsLast" === e.dataFormat,
        m = g ? 1 : 2,
        b = g ? 2 : 3,
        x = g ? 3 : 1;
    var y = "",
        k = "";
    n && (y = s ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n, "\n        }") : r ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n, "\n        }") : "\n          float activation(float x) {\n            ".concat(n, "\n          }\n        "), k = "result = activation(result);");
    var w = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(y, "\n\n      const ivec2 strides = ivec2(").concat(o, ", ").concat(l, ");\n      const ivec2 pads = ivec2(").concat(a, ", ").concat(i, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(x, "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(m, "], coords[").concat(b, "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h, "; wR++) {\n          int xR = xRCorner + wR * ").concat(u, ";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d, "; wC++) {\n            int xC = xCCorner + wC * ").concat(c, ";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p, "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g, ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1 === f, ") {\n\n              if (").concat(g, ") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p, ") *\n                    getW(wR, wC, ").concat(p, ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p, ", xR, xC) *\n                    getW(wR, wC, ").concat(p, ", d2);\n              }\n\n            } else if (").concat(2 === f, ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p, ", d2),\n                getW(wR, wC, ").concat(p, " + 1, d2)\n              );\n\n              if (").concat(g, ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p, "),\n                  getX(batch, xR, xC, ").concat(p, " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p, ", xR, xC),\n                  getX(batch, ").concat(p, " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3 === f, ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p, ", d2),\n                getW(wR, wC, ").concat(p, " + 1, d2),\n                getW(wR, wC, ").concat(p, " + 2, d2)\n              );\n\n              if (").concat(g, ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p, "),\n                  getX(batch, xR, xC, ").concat(p, " + 1),\n                  getX(batch, xR, xC, ").concat(p, " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p, ", xR, xC),\n                  getX(batch, ").concat(p, " + 1, xR, xC),\n                  getX(batch, ").concat(p, " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w, "\n        ").concat(k, "\n        setOutput(result);\n      }\n    ");
  }

}

class PI {
  constructor(e) {
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    var t = e.padInfo.front,
        n = e.padInfo.top,
        s = e.padInfo.left,
        r = e.strideDepth,
        a = e.strideHeight,
        i = e.strideWidth,
        o = e.dilationDepth,
        l = e.dilationHeight,
        u = e.dilationWidth,
        c = e.filterDepth,
        h = e.filterHeight,
        d = e.filterWidth,
        p = 4 * Math.floor(e.inChannels / 4),
        f = e.inChannels % 4;
    this.userCode = "\n      const ivec3 strides = ivec3(".concat(r, ", ").concat(a, ", ").concat(i, ");\n      const ivec3 pads = ivec3(").concat(t, ", ").concat(n, ", ").concat(s, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(c, "; wF++) {\n          int xF = xFCorner + wF * ").concat(o, ";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth, ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h, "; wR++) {\n            int xR = xRCorner + wR * ").concat(l, ";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d, "; wC++) {\n              int xC = xCCorner + wC * ").concat(u, ";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p, "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1 === f, ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p, ") *\n                  getW(wF, wR, wC, ").concat(p, ", d2);\n              } else if (").concat(2 === f, ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p, "),\n                  getX(batch, xF, xR, xC, ").concat(p, " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p, ", d2),\n                  getW(wF, wR, wC, ").concat(p, " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3 === f, ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p, "),\n                  getX(batch, xF, xR, xC, ").concat(p, " + 1),\n                  getX(batch, xF, xR, xC, ").concat(p, " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p, ", d2),\n                  getW(wF, wR, wC, ").concat(p, " + 1, d2),\n                  getW(wF, wR, wC, ").concat(p, " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class WI {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
      name: "inputShape",
      type: "ivec3"
    }, {
      name: "pad",
      type: "ivec2"
    }, {
      name: "stride",
      type: "ivec2"
    }, {
      name: "dilation",
      type: "ivec2"
    }, {
      name: "inChannels",
      type: "int"
    }, {
      name: "itemsPerBlockRow",
      type: "int"
    }, {
      name: "outWidth",
      type: "int"
    }], this.outputShape = e, this.enableShapeUniforms = Fk(this.outputShape.length);
    var {
      dataFormat: n
    } = t,
        s = dk(),
        r = "channelsLast" === n,
        a = r ? 0 : 1,
        i = r ? 1 : 2,
        o = this.enableShapeUniforms ? "if(blockIndex < outShape[1] && pos < outShape[0]) {" : "if(blockIndex < ".concat(e[1], " && pos < ").concat(e[0], ") {");
    var l = "";

    for (var _e470 = 0; _e470 <= 1; _e470++) {
      for (var _t396 = 0; _t396 <= 1; _t396++) {
        l += "\n          blockIndex = rc.y + ".concat(_t396, ";\n          pos = rc.x + ").concat(_e470, ";\n\n          ").concat(o, "\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(a, "] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(i, "] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r, ") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2 * _e470 + _t396, "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2 * _e470 + _t396, "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");
      }
    }

    this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(l, "\n\n        ").concat(s.output, " = result;\n      }\n    ");
  }

}

function UI(_ref26) {
  var {
    x: e,
    filter: t,
    convInfo: n,
    backend: s,
    bias: r = null,
    preluActivationWeights: a = null,
    leakyreluAlpha: i = 0,
    activation: o = null
  } = _ref26;
  var u = e.shape,
      c = s.texData.get(e.dataId),
      h = "channelsLast" === n.dataFormat;
  var d;
  var f = [];

  if ((1 != u[0] * u[1] * u[2] && 1 !== n.outChannels || !(n.inChannels > 1e3)) && c.isPacked && h && null != c.texture && u[2] % 2 != 0 && p(c.shape.slice(-3), u.slice(-3))) {
    var _h20 = {
      dataId: e.dataId,
      shape: [1, u[0] * u[1] * (u[2] + 1), n.inChannels],
      dtype: e.dtype
    },
        _p17 = c.shape;
    c.shape = c.shape.slice(), c.shape[c.shape.length - 2]++, l(rk(c.shape, _h20.shape), () => "packed reshape ".concat(c.shape, " to ").concat(_h20.shape, " isn't free"));

    var _g21 = mv({
      inputs: {
        x: t
      },
      backend: s,
      attrs: {
        shape: [1, n.inChannels, n.outChannels]
      }
    });

    f.push(_g21);

    var _m14 = Tv({
      a: _h20,
      b: _g21,
      backend: s,
      transposeA: !1,
      transposeB: !1,
      bias: r,
      activation: o,
      preluActivationWeights: a,
      leakyreluAlpha: i
    }),
        _b15 = s.texData.get(_m14.dataId);

    l(_b15.isPacked, () => "batchMatMul result is expected to be packed"), c.shape = _p17, _b15.shape = n.outShape, d = Zw({
      inputs: {
        x: _m14
      },
      backend: s
    }), d.shape = n.outShape, f.push(_m14);
  } else {
    var _l52 = mv({
      inputs: {
        x: e
      },
      backend: s,
      attrs: {
        shape: [1, h ? u[0] * u[1] * u[2] : u[0] * u[2] * u[3], n.inChannels]
      }
    }),
        _c34 = mv({
      inputs: {
        x: t
      },
      backend: s,
      attrs: {
        shape: [1, n.inChannels, n.outChannels]
      }
    }),
        _p18 = Tv({
      a: _l52,
      b: _c34,
      transposeA: !1,
      transposeB: !1,
      backend: s,
      bias: r,
      activation: o,
      preluActivationWeights: a,
      leakyreluAlpha: i
    });

    d = mv({
      inputs: {
        x: _p18
      },
      backend: s,
      attrs: {
        shape: n.outShape
      }
    }), f.push(_l52), f.push(_c34), f.push(_p18);
  }

  for (var _e471 of f) {
    s.disposeIntermediateTensorInfo(_e471);
  }

  return d;
}

function VI(_ref27) {
  var {
    x: e,
    filter: t,
    convInfo: n,
    backend: s,
    bias: r = null,
    preluActivationWeights: a = null,
    leakyreluAlpha: i = 0,
    activation: o = null
  } = _ref27;
  var {
    filterWidth: l,
    filterHeight: u,
    inChannels: c,
    outWidth: h,
    outHeight: p,
    dataFormat: f
  } = n,
      g = "channelsLast" === f,
      m = l * u * c,
      b = p * h,
      x = [m, b],
      y = [],
      k = mv({
    inputs: {
      x: e
    },
    backend: s,
    attrs: {
      shape: e.shape.slice(1)
    }
  }),
      w = mv({
    inputs: {
      x: t
    },
    backend: s,
    attrs: {
      shape: [1, m, d(t.shape) / m]
    }
  });
  y.push(k), y.push(w);
  var v = new WI(x, n),
      I = s.runWebGLProgram(v, [k], "float32", [k.shape, [n.padInfo.top, n.padInfo.left], [n.strideHeight, n.strideWidth], [n.dilationHeight, n.dilationWidth], [n.inChannels], [n.filterWidth * n.inChannels], [n.outWidth]]),
      $ = mv({
    inputs: {
      x: I
    },
    backend: s,
    attrs: {
      shape: [1, x[0], x[1]]
    }
  });
  y.push(I), y.push($);
  var S = null != r,
      N = null != a,
      C = "leakyrelu" === o,
      T = o ? cv(o, !0) : null,
      E = new hv($.shape, w.shape, [1, b, n.outChannels], !0, !1, S, T, N, C),
      R = [$, w];

  if (r && R.push(r), N && R.push(a), C) {
    var _e472 = s.makeTensorInfo([], "float32", Ue(i, "float32"));

    R.push(_e472), y.push(_e472);
  }

  var A = s.runWebGLProgram(E, R, "float32"),
      F = mv({
    inputs: {
      x: A
    },
    backend: s,
    attrs: {
      shape: g ? [1, p, h, n.outChannels] : [1, n.outChannels, p, h]
    }
  });
  y.push(A);

  for (var _e473 of y) {
    s.disposeIntermediateTensorInfo(_e473);
  }

  return F;
}

var GI = {
  kernelName: "Conv2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a
    } = t,
        {
      strides: i,
      pad: o,
      dataFormat: l,
      dilations: u,
      dimRoundingMode: c
    } = s,
        h = Es(l),
        d = ks(r.shape, a.shape, i, u, o, c, !1, h);
    var p;
    if (1 !== d.filterHeight || 1 !== d.filterWidth || 1 !== d.dilationHeight || 1 !== d.dilationWidth || 1 !== d.strideHeight || 1 !== d.strideWidth || "SAME" !== d.padInfo.type && "VALID" !== d.padInfo.type) {
      if (G().getBool("WEBGL_CONV_IM2COL") && 1 === r.shape[0]) p = VI({
        x: r,
        filter: a,
        convInfo: d,
        backend: n
      });else {
        var _e474 = new BI(d);

        p = n.runWebGLProgram(_e474, [r, a], "float32");
      }
    } else p = UI({
      x: r,
      filter: a,
      convInfo: d,
      backend: n
    });
    var f = mv({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        shape: d.outShape
      }
    });
    return n.disposeIntermediateTensorInfo(p), f;
  }
};

class HI {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize, "; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight, "; yR++) {\n            int xR = wR + yR * ").concat(e.strideHeight, " - ").concat(e.padInfo.top, ";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth, "; yC++) {\n              int xC = wC + yC * ").concat(e.strideWidth, " - ").concat(e.padInfo.left, ";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              if (").concat("channelsLast" === e.dataFormat, ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class qI {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    var t = e.filterHeight,
        n = e.filterWidth,
        s = "channelsLast" === e.dataFormat;
    this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(s ? 3 : 1, "];\n\n        ivec2 dyCorner = ivec2(coords[").concat(s ? 1 : 2, "], coords[").concat(s ? 2 : 3, "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t, "; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n, " - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels, "; d2++) {\n\n              if (").concat(s, ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class jI {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape, this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize, "; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth, "; yF++) {\n            int xF = wF + yF * ").concat(e.strideDepth, " - ").concat(e.padInfo.front, ";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth, ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight, "; yR++) {\n              int xR = wR + yR * ").concat(e.strideHeight, " - ").concat(e.padInfo.top, ";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth, "; yC++) {\n                int xC = wC + yC * ").concat(e.strideWidth, " - ").concat(e.padInfo.left, ";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class KI {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    var t = e.filterDepth,
        n = e.filterHeight,
        s = e.filterWidth;
    this.userCode = "\n      const ivec3 pads = ivec3(".concat(t - 1 - e.padInfo.front, ", ").concat(n - 1 - e.padInfo.top, ", ").concat(s - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t, "; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(e.strideDepth, ".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth, ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t, " - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n, "; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n, " - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(s, "; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(s, " - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels, "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

var XI = {
  kernelName: "Conv2DBackpropFilter",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      pad: o,
      dataFormat: l,
      dimRoundingMode: u,
      filterShape: c
    } = s,
        h = Es(l),
        d = ks(r.shape, c, i, 1, o, u, !1, h),
        p = new HI(d);
    return n.runWebGLProgram(p, [r, a], "float32");
  }
},
    YI = {
  kernelName: "Conv2DBackpropInput",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      inputShape: i,
      strides: o,
      pad: l,
      dataFormat: u,
      dimRoundingMode: c
    } = s,
        h = Es(u),
        d = ks(i, a.shape, o, 1, l, c, !1, h),
        p = new qI(d);
    return n.runWebGLProgram(p, [r, a], "float32");
  }
},
    JI = {
  kernelName: "Conv3D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a
    } = t,
        {
      strides: i,
      pad: o,
      dilations: l
    } = s,
        u = ws(r.shape, a.shape, i, l, o),
        c = new PI(u);
    return n.runWebGLProgram(c, [r, a], "float32");
  }
},
    ZI = {
  kernelName: "Conv3DBackpropFilterV2",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      pad: o,
      filterShape: l
    } = s,
        u = ws(r.shape, l, i, 1, o),
        c = new jI(u);
    return n.runWebGLProgram(c, [r, a], "float32");
  }
},
    QI = {
  kernelName: "Conv3DBackpropInputV2",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      pad: i,
      strides: o,
      inputShape: l
    } = s,
        u = ws(l, a.shape, o, 1, i),
        c = new KI(u);
    return n.runWebGLProgram(c, [r, a], "float32");
  }
},
    e$ = {
  kernelName: "Cos",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (isnan(x)) return x;\n  return cos(x);\n"
  })
},
    t$ = {
  kernelName: "Cosh",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"
  })
};

class n$ {
  constructor(e, t, n, s, r) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
    var [a, i, o, l] = e,
        [u] = t,
        [c, h] = n;
    this.outputShape = [u, c, h, l];
    var d = "bilinear" === s ? 1 : 0,
        [p, f] = [i - 1 + ".0", o - 1 + ".0"],
        [g, m, b] = c > 1 ? ["" + (i - 1) / (c - 1), "(y2-y1) * height_ratio", "y1*".concat(p, " + float(y)*(height_scale)")] : ["0.0", "0.0", "0.5 * (y1+y2) * ".concat(p)],
        [x, y, k] = h > 1 ? ["" + (o - 1) / (h - 1), "(x2-x1) * width_ratio", "x1*".concat(f, " + float(x)*(width_scale)")] : ["0.0", "0.0", "0.5 * (x1+x2) * ".concat(f)];
    this.userCode = "\n      const float height_ratio = float(".concat(g, ");\n      const float width_ratio = float(").concat(x, ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(a, ") {\n          return;\n        }\n\n        float height_scale = ").concat(m, ";\n        float width_scale = ").concat(y, ";\n\n        float in_y = ").concat(b, ";\n        if( in_y < 0.0 || in_y > ").concat(p, " ) {\n          setOutput(float(").concat(r, "));\n          return;\n        }\n        float in_x = ").concat(k, ";\n        if( in_x < 0.0 || in_x > ").concat(f, " ) {\n          setOutput(float(").concat(r, "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d, " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ");
  }

}

var s$ = {
  kernelName: "CropAndResize",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      image: r,
      boxes: a,
      boxInd: i
    } = t,
        {
      cropSize: o,
      method: l,
      extrapolationValue: u
    } = s,
        c = new n$(r.shape, a.shape, o, l, u);
    return n.runWebGLProgram(c, [r, a, i], "float32");
  }
};

class r$ {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.customUniforms = [{
      name: "index",
      type: "float"
    }], this.outputShape = e;
    var s = e.length,
        r = t ? "0.0" : "getX(".concat(a$(s, "coords"), ")"),
        a = e[e.length - 1];
    var i = "",
        o = "";
    t ? (i = n ? "end != " + (a - 1) : "end != 0", o = n ? "end + 1" : "end - 1") : (i = n ? "end + pow2 < ".concat(a) : "end >= pow2", o = n ? "end + pow2" : "end - pow2"), this.userCode = "\n      void main() {\n        ".concat(Ck(s), " coords = getOutputCoords();\n        int end = ").concat(i$(s, "coords"), ";\n        float val = ").concat(r, ";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(i, ") {\n          int idx = ").concat(o, ";\n          ").concat(i$(s, "coords"), " = idx;\n          val += getX(").concat(a$(s, "coords"), ");\n        }\n        setOutput(val);\n      }\n    ");
  }

}

function a$(e, t) {
  if (1 === e) return "".concat(t);
  if (2 === e) return "".concat(t, ".x, ").concat(t, ".y");
  if (3 === e) return "".concat(t, ".x, ").concat(t, ".y, ").concat(t, ".z");
  if (4 === e) return "".concat(t, ".x, ").concat(t, ".y, ").concat(t, ".z, ").concat(t, ".w");
  throw Error("Cumulative sum for rank ".concat(e, " is not yet supported"));
}

function i$(e, t) {
  if (1 === e) return "".concat(t);
  if (2 === e) return "".concat(t, ".y");
  if (3 === e) return "".concat(t, ".z");
  if (4 === e) return "".concat(t, ".w");
  throw Error("Cumulative sum for rank ".concat(e, " is not yet supported"));
}

var o$ = {
  kernelName: "Cumsum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      exclusive: i,
      reverse: o
    } = s,
        l = r.shape.length,
        u = Zr([a], l);
    var c = r;
    null != u && (c = Nv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }));
    var h = ea(1, l)[0];
    if (h !== l - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=".concat(r.shape.length - 1, " but got axis=").concat(a));
    var d = c.shape[h];
    var p = Zw({
      inputs: {
        x: c
      },
      backend: n
    });

    for (var _e475 = 0; _e475 <= Math.ceil(Math.log2(d)) - 1; _e475++) {
      var _t397 = new r$(c.shape, !1, o),
          _s226 = p;

      p = n.runWebGLProgram(_t397, [p], p.dtype, [[_e475]]), n.disposeIntermediateTensorInfo(_s226);
    }

    if (i) {
      var _e476 = new r$(c.shape, i, o),
          _t398 = p;

      p = n.runWebGLProgram(_e476, [p], p.dtype), n.disposeIntermediateTensorInfo(_t398);
    }

    if (null != u) {
      var _e477 = Nv({
        inputs: {
          x: p
        },
        backend: n,
        attrs: {
          perm: Qr(u)
        }
      });

      return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(c), _e477;
    }

    return p;
  }
},
    l$ = {
  kernelName: "DenseBincount",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      weights: a
    } = t,
        {
      size: i,
      binaryOutput: o
    } = s;

    if (1 === r.shape.length) {
      var _e478 = n.readSync(r.dataId),
          _t399 = n.readSync(a.dataId),
          _s227 = jk(_e478, _t399, a.dtype, a.shape, i);

      return n.makeTensorInfo([i], a.dtype, _s227);
    }

    if (2 === r.shape.length) {
      var _e479 = n.bufferSync(r),
          _t400 = n.bufferSync(a),
          _s228 = Kk(_e479, _t400, i, o);

      return n.makeTensorInfo(_s228.shape, a.dtype, _s228.values);
    }

    throw new Error("Error in denseBincount: input must be at most rank 2, but got rank".concat(r.shape.length, "."));
  }
};

class u$ {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = e, this.blockSize = t, this.dataFormat = n, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(), ";\n      int w = ").concat(this.getWidthCoordString(), ";\n      int d = ").concat(this.getDepthCoordString(), ";\n\n      int in_h = h / ").concat(t, ";\n      int offset_h = imod(h, ").concat(t, ");\n      int in_w = w / ").concat(t, ";\n      int offset_w = imod(w, ").concat(t, ");\n      int offset_d = (offset_h * ").concat(t, " + offset_w) *\n        ").concat(this.getOutputDepthSize(), ";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(), ";\n      setOutput(result);\n    }\n  ");
  }

  getHeightCoordString() {
    return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
  }

  getWidthCoordString() {
    return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
  }

  getDepthCoordString() {
    return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
  }

  getOutputDepthSize() {
    return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
  }

  getInputSamplingString() {
    return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }

}

var c$ = {
  kernelName: "DepthToSpace",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockSize: a,
      dataFormat: i
    } = s;
    l(a > 1, () => "blockSize should be > 1 for depthToSpace, but was: ".concat(a));
    var o = r.shape[0],
        u = ("NHWC" === i ? r.shape[1] : r.shape[2]) * a,
        c = ("NHWC" === i ? r.shape[2] : r.shape[3]) * a,
        h = ("NHWC" === i ? r.shape[3] : r.shape[1]) / (a * a),
        d = new u$("NHWC" === i ? [o, u, c, h] : [o, h, u, c], a, i);
    return n.runWebGLProgram(d, [r], r.dtype);
  }
};

class h$ {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    this.variableNames = ["x", "W"], this.customUniforms = [{
      name: "pads",
      type: "ivec2"
    }, {
      name: "strides",
      type: "ivec2"
    }, {
      name: "dilations",
      type: "ivec2"
    }, {
      name: "inDims",
      type: "ivec2"
    }], this.outputShape = e.outShape, this.enableShapeUniforms = Fk(this.outputShape.length);
    var a = e.filterHeight,
        i = e.filterWidth,
        o = e.outChannels / e.inChannels;
    var l = "",
        u = "";
    n && (l = s ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n, "\n        }") : r ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n, "\n        }") : "\n          float activation(float x) {\n            ".concat(n, "\n          }\n        "), u = "result = activation(result);");
    var c = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(l, "\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o, ";\n        int q = d2 - d1 * ").concat(o, ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(a, "; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(i, "; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(c, "\n        ").concat(u, "\n        setOutput(result);\n      }\n    ");
  }

}

class d$ {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
      name: "pads",
      type: "ivec2"
    }, {
      name: "strides",
      type: "ivec2"
    }, {
      name: "dilations",
      type: "ivec2"
    }, {
      name: "inDims",
      type: "ivec2"
    }], this.outputShape = e.outShape, this.enableShapeUniforms = Fk(this.outputShape.length);
    var a = e.outChannels / e.inChannels,
        o = e.padInfo.left,
        l = e.strideWidth,
        u = e.dilationWidth,
        c = e.filterHeight,
        h = e.filterWidth,
        d = h;
    var p = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";

    for (var _e480 = 0; _e480 < h; _e480++) {
      p += "\n          vec4 xTexelC".concat(2 * _e480, ";\n          int xTexelC").concat(2 * _e480, "Ready;\n          vec4 xTexelC").concat(2 * _e480 + 1, ";\n          int xTexelC").concat(2 * _e480 + 1, "Ready;\n          vec4 xC").concat(_e480, ";");
    }

    for (var _e481 = 0; _e481 < c; _e481++) {
      for (var _e482 = 0; _e482 < h; _e482++) {
        p += "\n          xTexelC".concat(2 * _e482, " = vec4(0.0);\n          xTexelC").concat(2 * _e482, "Ready = 0;\n          xTexelC").concat(2 * _e482 + 1, " = vec4(0.0);\n          xTexelC").concat(2 * _e482 + 1, "Ready = 0;\n          xC").concat(_e482, " = vec4(0.0);");
      }

      p += "\n        xR = xRCorner + ".concat(_e481, " * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ");

      for (var _t401 = 0; _t401 < (d + 1) / 2; _t401++) {
        var _n287 = 2 * _t401;

        if (p += "\n          xC = xCCorner + ".concat(_n287 * u, ";\n          "), 1 === l) {
          if (_n287 < h && (o % 2 == 1 ? (p += "\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(_n287, "Ready == 0) {\n                  xTexelC").concat(_n287, " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(_n287, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n287, "Ready = 1;\n                }\n              "), p += 1 === u && _n287 > 0 ? "\n                xC".concat(_n287, " = vec4(xTexelC").concat(_n287 - 2, ".zw, xTexelC").concat(_n287, ".xy);\n                ") : "\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(_n287, " = vec4(previous.zw, xTexelC").concat(_n287, ".xy);\n                  } else {\n                    xC").concat(_n287, " = vec4(0.0, 0.0, xTexelC").concat(_n287, ".xy);\n                  }\n                  ")) : p += "\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(_n287, "Ready == 0) {\n                  xTexelC").concat(_n287, " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(_n287, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n287, "Ready = 1;\n                }\n\n                xC").concat(_n287, " = xTexelC").concat(_n287, ";\n                "), _n287 + 1 < h)) {
            var _e483 = o % 2 == 0 ? i(u) : u;

            u % 2 == 0 && o % 2 == 1 || u % 2 != 0 && o % 2 != 1 ? (p += "\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(_e483, ";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(_n287 + 1, "Ready == 0) {\n                    xTexelC").concat(_n287 + 1, " = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(_n287 + 1, ".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(_n287 + 1, "Ready = 1;\n                  }\n                  "), u > 1 && (p += "\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(_n287, "Ready == 0) {\n                      xTexelC").concat(_n287, " = getX(batch, xR, xCOffset, d1);\n                      xTexelC").concat(_n287, "Ready = 1;\n                    }\n                    ")), p += "\n                  xC".concat(_n287 + 1, " = vec4(xTexelC").concat(_n287, ".zw, xTexelC").concat(_n287 + 1, ".xy);\n                  ")) : p += 1 === _e483 ? "\n                    xC".concat(_n287 + 1, " = xTexelC").concat(_n287, ";\n                    ") : "\n                    xCOffset = xC + ".concat(_e483, ";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(_n287 + 1, "Ready == 0) {\n                      xTexelC").concat(_n287 + 1, " = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(_n287 + 1, ".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(_n287 + 1, "Ready = 1;\n                    }\n\n                    xC").concat(_n287 + 1, " = xTexelC").concat(_n287 + 1, ";\n                    ");
          }
        } else _n287 < h && (o % 2 == 1 ? (p += "\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(_n287, "Ready == 0) {\n                  xTexelC").concat(_n287, " = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(_n287, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n287, "Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(_n287 + 1, "Ready == 0) {\n                  xTexelC").concat(_n287 + 1, " = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(_n287 + 1, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n287 + 1, "Ready = 1;\n                }\n\n                xC").concat(_n287, " = vec4(xTexelC").concat(_n287, ".zw, xTexelC").concat(_n287 + 1, ".zw);\n              "), _n287 + 1 < h && (p += "\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(_n287 + 1, " = vec4(xTexelC").concat(_n287 + 1, ".xy, final.xy);\n                "))) : (p += "\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(_n287, "Ready == 0) {\n                  xTexelC").concat(_n287, " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(_n287, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n287, "Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(_n287 + 1, "Ready == 0) {\n                  xTexelC").concat(_n287 + 1, " = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(_n287 + 1, ".zw = vec2(0.);\n                  }\n                  xTexelC").concat(_n287 + 1, "Ready = 1;\n                }\n\n                xC").concat(_n287, " = vec4(\n                  xTexelC").concat(_n287, ".xy, xTexelC").concat(_n287 + 1, ".xy);\n              "), _n287 + 1 < h && (p += "\n                  xC".concat(_n287 + 1, " = vec4(xTexelC").concat(_n287, ".zw, xTexelC").concat(_n287 + 1, ".zw);\n                "))));

        _n287 < h && (p += "\n            wTexel = getW(".concat(_e481, ", ").concat(_n287, ", d1, q);\n            dotProd += xC").concat(_n287, " * vec4(wTexel.xz, wTexel.xz);\n          "), _n287 + 1 < h && (p += "\n              wTexel = getW(".concat(_e481, ", ").concat(_n287 + 1, ", d1, q);\n              dotProd += xC").concat(_n287 + 1, " * vec4(wTexel.xz, wTexel.xz);\n            ")));
      }

      p += "\n        }\n      ";
    }

    var f = "",
        g = "";
    n && (f = s ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n, "\n        }") : r ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n, "\n        }") : "vec4 activation(vec4 x) {\n          ".concat(n, "\n        }"), g = "result = activation(result);");
    var m = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(f, "\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(a, ";\n        int q = d2 - d1 * ").concat(a, ";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(p, "\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m, "\n        ").concat(g, "\n        setOutput(result);\n      }\n    ");
  }

}

var p$ = {
  kernelName: "DepthwiseConv2dNative",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a
    } = t,
        {
      strides: i,
      pad: o,
      dilations: u,
      dimRoundingMode: c
    } = s;
    var h = u;
    null == h && (h = [1, 1]), l(Ts(i, h), () => "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '").concat(h, "'"));
    var d = ks(r.shape, a.shape, i, h, o, c, !0);
    var p;
    return p = G().getBool("WEBGL_PACK_DEPTHWISECONV") && d.strideWidth <= 2 && d.outChannels / d.inChannels == 1 ? new d$(d) : new h$(d), n.runWebGLProgram(p, [r, a], "float32", [[d.padInfo.top, d.padInfo.left], [d.strideHeight, d.strideWidth], [d.dilationHeight, d.dilationWidth], [d.inHeight, d.inWidth]]);
  }
};

class f$ {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(e.outChannels / e.inChannels, " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize, "; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight, "; yR++) {\n            int xR = wR + yR * ").concat(e.strideHeight, " - ").concat(e.padInfo.top, ";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth, "; yC++) {\n              int xC = wC + yC * ").concat(e.strideWidth, " - ").concat(e.padInfo.left, ";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class g$ {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    var t = e.filterHeight,
        n = e.filterWidth,
        s = e.outChannels / e.inChannels;
    this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t, "; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n, " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(s, "; dm++) {\n              int d2 = d1 * ").concat(s, " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

var m$ = {
  kernelName: "DepthwiseConv2dNativeBackpropFilter",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      dilations: o,
      pad: l,
      dimRoundingMode: u,
      filterShape: c
    } = s,
        h = ks(r.shape, c, i, o, l, u, !0),
        d = new f$(h);
    return n.runWebGLProgram(d, [r, a], "float32");
  }
},
    b$ = {
  kernelName: "DepthwiseConv2dNativeBackpropInput",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      strides: i,
      dilations: o,
      pad: l,
      dimRoundingMode: u,
      inputShape: c
    } = s,
        h = ks(c, a.shape, i, o, l, u, !0),
        d = new g$(h);
    return n.runWebGLProgram(d, [r, a], "float32");
  }
};

class x$ {
  constructor(e) {
    this.variableNames = ["X"], this.outputShape = [e, e], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
  }

}

var y$ = {
  kernelName: "Diag",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t,
        r = [...s.shape, ...s.shape],
        a = d(s.shape),
        i = mv({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [a]
      }
    }),
        o = new x$(a),
        l = n.runWebGLProgram(o, [i], i.dtype),
        u = mv({
      inputs: {
        x: l
      },
      backend: n,
      attrs: {
        shape: r
      }
    });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(l), u;
  }
};

class k$ {
  constructor(e) {
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    var {
      inHeight: t,
      inWidth: n,
      padInfo: s,
      strideHeight: r,
      strideWidth: a,
      filterHeight: i,
      filterWidth: o,
      dilationHeight: l,
      dilationWidth: u
    } = e,
        {
      top: c,
      left: h
    } = s;
    this.userCode = "\n      const ivec2 strides = ivec2(".concat(r, ", ").concat(a, ");\n      const ivec2 pads = ivec2(").concat(c, ", ").concat(h, ");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(i, "; h++) {\n          int hIn = hBeg + h * ").concat(l, ";\n\n          if (hIn >= 0 && hIn < ").concat(t, ") {\n            for (int w = 0; w < ").concat(o, "; w++) {\n              int wIn = wBeg + w * ").concat(u, ";\n\n              if (wIn >= 0 && wIn < ").concat(n, ") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ");
  }

}

var w$ = {
  kernelName: "Dilation2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a
    } = t,
        {
      strides: i,
      pad: o,
      dilations: l
    } = s,
        u = bs(r.shape, a.shape, i, o, "NHWC", l);
    var c;
    var h = new k$(u);
    c = n.runWebGLProgram(h, [r, a], "float32");
    var d = mv({
      inputs: {
        x: c
      },
      backend: n,
      attrs: {
        shape: u.outShape
      }
    });
    return n.disposeIntermediateTensorInfo(c), d;
  }
},
    v$ = {
  kernelName: "Einsum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      equation: r
    } = s,
        a = t,
        {
      allDims: i,
      summedDims: o,
      idDims: l
    } = qo(r, a.length);
    Ko(i.length, l, a);
    var {
      path: u,
      steps: c
    } = Xo(o, l),
        h = c.length;
    var d = null,
        f = i.length;
    var g = [];

    for (var _e484 = 0; _e484 < h; ++_e484) {
      for (var _t402 of c[_e484]) {
        var {
          permutationIndices: _e485,
          expandDims: _s229
        } = jo(f, l[_t402]);

        var _r169 = void 0;

        Yo(_e485) ? _r169 = a[_t402] : (_r169 = Nv({
          inputs: {
            x: a[_t402]
          },
          backend: n,
          attrs: {
            perm: _e485
          }
        }), g.push(_r169));

        var _i98 = _r169.shape.slice();

        for (var _e486 = 0; _e486 < _s229.length; ++_e486) {
          _i98.splice(_s229[_e486], 0, 1);
        }

        p(_r169.shape, _i98) || (_r169 = mv({
          inputs: {
            x: _r169
          },
          backend: n,
          attrs: {
            shape: _i98
          }
        }), g.push(_r169)), null === d ? d = _r169 : (d = fv({
          inputs: {
            a: _r169,
            b: d
          },
          backend: n
        }), g.push(d));
      }

      _e484 < h - 1 && (u[_e484] >= 0 && (d = $v({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          axis: u[_e484] - (i.length - f),
          keepDims: !1
        }
      }), g.push(d)), f--);
    }

    for (var _e487 of g) {
      _e487 !== d && n.disposeIntermediateTensorInfo(_e487);
    }

    return d;
  }
},
    I$ = {
  kernelName: "Elu",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);",
    packedOpSnippet: "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"
  })
},
    $$ = {
  kernelName: "EluGrad",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      dy: s,
      y: r
    } = t,
        a = G().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Jw("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", s.shape, r.shape) : new Yw("return (b >= 1.0) ? a : a * (b + 1.0);", s.shape, r.shape);
    return n.runWebGLProgram(a, [s, r], s.dtype);
  }
},
    S$ = {
  kernelName: "Equal",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "return float(a == b);",
    packedOpSnippet: "\n  return vec4(equal(a, b));\n",
    dtype: "bool",
    cpuKernelImpl: Jk
  })
},
    N$ = {
  kernelName: "Erf",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n'
  })
},
    C$ = "return exp(x);",
    T$ = lv({
  opSnippet: C$,
  packedOpSnippet: C$,
  cpuKernelImpl: Zk
}),
    E$ = {
  kernelName: "Exp",
  backendName: "webgl",
  kernelFunc: T$
};

function R$(e) {
  var {
    inputs: t,
    attrs: n,
    backend: s
  } = e,
      {
    dim: r
  } = n,
      {
    input: a
  } = t,
      i = a.shape.length,
      o = a.shape.slice();
  var u = r;
  return r < 0 && (l(-(i + 1) <= r, () => "Axis must be in the interval [".concat(-(i + 1), ", ").concat(i, "]")), u = i + r + 1), o.splice(u, 0, 1), mv({
    inputs: {
      x: a
    },
    backend: s,
    attrs: {
      shape: o
    }
  });
}

var A$ = {
  kernelName: "ExpandDims",
  backendName: "webgl",
  kernelFunc: R$
},
    F$ = "return exp(x) - 1.0;",
    D$ = {
  kernelName: "Expm1",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: F$,
    packedOpSnippet: F$,
    cpuKernelImpl: Qk
  })
};

class _$ {
  constructor(e, t, n) {
    this.variableNames = ["real", "imag"];
    var s = t[1];
    this.outputShape = t;
    var r = n ? "2.0 * ".concat(Math.PI) : "-2.0 * ".concat(Math.PI),
        a = n ? "".concat(s, ".0") : "1.0";
    var i;
    if ("real" === e) i = "return real * expR - imag * expI;";else {
      if ("imag" !== e) throw new Error("FFT component must be either \"real\" or \"imag\", got ".concat(e, "."));
      i = "return real * expI + imag * expR;";
    }
    this.userCode = "\n      const float exponentMultiplier = ".concat(r, ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(i, "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(s, ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(s, "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(a, ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ");
  }

}

function O$(e, t, n) {
  var s = n.texData.get(e.dataId),
      r = d(e.shape),
      a = e.shape[e.shape.length - 1],
      i = mv({
    inputs: {
      x: e
    },
    backend: n,
    attrs: {
      shape: [r / a, a]
    }
  }),
      o = i.shape,
      l = new _$("real", o, t),
      u = new _$("imag", o, t),
      c = [{
    dataId: s.complexTensorInfos.real.dataId,
    dtype: s.complexTensorInfos.real.dtype,
    shape: o
  }, {
    dataId: s.complexTensorInfos.imag.dataId,
    dtype: s.complexTensorInfos.imag.dtype,
    shape: o
  }],
      h = n.runWebGLProgram(l, c, "float32"),
      p = n.runWebGLProgram(u, c, "float32"),
      f = ev({
    inputs: {
      real: h,
      imag: p
    },
    backend: n
  });
  n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p);
  var g = mv({
    inputs: {
      x: f
    },
    backend: n,
    attrs: {
      shape: e.shape
    }
  });
  return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(f), g;
}

var M$ = {
  kernelName: "FFT",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      input: s
    } = t;
    return O$(s, !1, n);
  }
};

class L$ {
  constructor(e, t) {
    this.outputShape = [], this.customUniforms = [{
      name: "value",
      type: "float"
    }], this.variableNames = ["x"], this.outputShape = e, this.userCode = "\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
  }

}

function z$(e) {
  var {
    backend: t,
    attrs: n
  } = e,
      {
    shape: s,
    value: r
  } = n;
  var {
    dtype: a
  } = n;

  if (a = a || T(r), "string" === a) {
    var _e488 = v(a, d(s));

    return _e488.fill(r), t.makeTensorInfo(s, a, _e488);
  }

  {
    var _e489 = new L$(s, r);

    return t.runWebGLProgram(_e489, [], a, [[r]]);
  }
}

var B$ = {
  kernelName: "Fill",
  backendName: "webgl",
  kernelFunc: z$
};

class P$ {
  constructor(e) {
    this.variableNames = ["Image"], this.outputShape = [];
    var t = e[2];
    this.outputShape = e, this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t, " - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t, ") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ");
  }

}

var W$ = {
  kernelName: "FlipLeftRight",
  backendName: "webgl",
  kernelFunc: _ref28 => {
    var {
      inputs: e,
      backend: t
    } = _ref28;
    var {
      image: n
    } = e,
        s = t,
        r = new P$(n.shape);
    return s.runWebGLProgram(r, [n], n.dtype);
  }
},
    U$ = "return floor(x);",
    V$ = {
  kernelName: "Floor",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: U$,
    packedOpSnippet: U$,
    cpuKernelImpl: ew
  })
},
    G$ = {
  kernelName: "FloorDiv",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",
    packedOpSnippet: "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
    dtype: "int32"
  })
};

class H$ {
  constructor(e) {
    this.variableNames = ["A"];
    var t = dk(),
        [n, s] = e;
    this.outputShape = e, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(s, ".0, ").concat(n, ".0);\n\n        vec4 values = ").concat(t.texture2D, "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ");
  }

}

class q$ {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
    var t = dk(),
        [n, s] = e;
    this.outputShape = e, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(s, ".0, ").concat(n, ".0);\n            vec4 values = ").concat(t.texture2D, "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output, " = result;\n      }\n    ");
  }

}

var j$ = {
  kernelName: "FromPixels",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e;
    var {
      pixels: r
    } = t;
    var {
      numChannels: a
    } = s,
        i = "undefined" != typeof HTMLVideoElement && r instanceof HTMLVideoElement,
        o = "undefined" != typeof HTMLImageElement && r instanceof HTMLImageElement,
        [l, u] = i ? [r.videoWidth, r.videoHeight] : [r.width, r.height],
        c = [u, l],
        h = [u, l, a];
    (o || i) && (null == K$ && (K$ = document.createElement("canvas").getContext("2d")), K$.canvas.width = l, K$.canvas.height = u, K$.drawImage(r, 0, 0, l, u), r = K$.canvas);
    var d = n.makeTensorInfo(c, "int32");
    n.texData.get(d.dataId).usage = zy.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), r);
    var p = G().getBool("WEBGL_PACK") ? new q$(h) : new H$(h),
        f = n.runWebGLProgram(p, [d], "int32");
    return n.disposeData(d.dataId), f;
  }
};
var K$;
var X$ = {
  kernelName: "FusedConv2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      strides: l,
      pad: u,
      dataFormat: c,
      dilations: h,
      dimRoundingMode: d,
      activation: p,
      leakyreluAlpha: f
    } = s,
        g = Es(c),
        m = ks(r.shape, a.shape, l, h, u, d, !1, g);
    var b;
    var x = [];
    if (1 !== m.filterHeight || 1 !== m.filterWidth || 1 !== m.dilationHeight || 1 !== m.dilationWidth || 1 !== m.strideHeight || 1 !== m.strideWidth || "SAME" !== m.padInfo.type && "VALID" !== m.padInfo.type) {
      if (G().getBool("WEBGL_CONV_IM2COL") && 1 === r.shape[0]) b = VI({
        x: r,
        filter: a,
        convInfo: m,
        backend: n,
        bias: i,
        activation: p,
        preluActivationWeights: o,
        leakyreluAlpha: f
      });else {
        var _e490 = null != i,
            _t403 = null != o,
            _s230 = "leakyrelu" === p,
            _l53 = p ? cv(p, !1) : null,
            _u41 = new BI(m, _e490, _l53, _t403, _s230),
            _c35 = [r, a];

        if (i && _c35.push(i), o && _c35.push(o), _s230) {
          var _e491 = n.makeTensorInfo([], "float32", Ue(f, "float32"));

          _c35.push(_e491), x.push(_e491);
        }

        b = n.runWebGLProgram(_u41, _c35, "float32");
      }
    } else b = UI({
      x: r,
      filter: a,
      convInfo: m,
      backend: n,
      bias: i,
      activation: p,
      preluActivationWeights: o,
      leakyreluAlpha: f
    });
    var y = mv({
      inputs: {
        x: b
      },
      backend: n,
      attrs: {
        shape: m.outShape
      }
    });
    return x.push(b), x.forEach(e => n.disposeIntermediateTensorInfo(e)), y;
  }
},
    Y$ = {
  kernelName: "FusedDepthwiseConv2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      strides: u,
      pad: c,
      dilations: h,
      dimRoundingMode: d,
      activation: p,
      leakyreluAlpha: f
    } = s,
        g = [];
    var m = h;
    null == m && (m = [1, 1]), l(Ts(u, m), () => "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(u, " and dilations '").concat(m, "'"));
    var b = ks(r.shape, a.shape, u, m, c, d, !0),
        x = G().getBool("WEBGL_PACK_DEPTHWISECONV") && b.strideWidth <= 2 && b.outChannels / b.inChannels == 1,
        y = p ? cv(p, x) : null,
        k = [r, a],
        w = null != i,
        v = null != o,
        I = "leakyrelu" === p;

    if (w && k.push(i), v && k.push(o), I) {
      var _e492 = n.makeTensorInfo([], "float32", Ue(f, "float32"));

      k.push(_e492), g.push(_e492);
    }

    var $;
    $ = x ? new d$(b, w, y, v, I) : new h$(b, w, y, v, I);
    var S = n.runWebGLProgram($, k, "float32", [[b.padInfo.top, b.padInfo.left], [b.strideHeight, b.strideWidth], [b.dilationHeight, b.dilationWidth], [b.inHeight, b.inWidth]]);
    return g.forEach(e => n.disposeIntermediateTensorInfo(e)), S;
  }
};

class J$ {
  constructor(e, t, n) {
    this.sliceDim = e, this.strides = t, this.variableNames = ["x", "indices"], this.outputShape = n;
    var s = Ck(t.length),
        r = Ck(n.length);
    this.userCode = "\n        ".concat(s, " strides = ").concat(s, "(").concat(this.strides, ");\n         void main() {\n          ").concat(r, " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ").concat(this.sliceDim, "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ").concat(this.sliceDim > 1 ? "strides[j]" : "strides", ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ");
  }

}

var Z$ = {
  kernelName: "GatherNd",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      params: s,
      indices: r
    } = t,
        a = r.shape,
        i = a[a.length - 1],
        o = d(s.shape),
        [l, u, c, h] = Nn(s, r),
        p = mv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [u, i]
      }
    }),
        f = mv({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [d(s.shape) / c, c]
      }
    });

    if (n.shouldExecuteOnCPU([s, r]) || "string" === s.dtype) {
      var _e493 = n.readSync(r.dataId),
          _t404 = n.bufferSync(s),
          _a138 = tw(_e493, _t404, s.dtype, u, i, c, h, s.shape, o);

      return n.makeTensorInfo(l, s.dtype, _a138.values);
    }

    var g = new J$(i, h, [u, c]),
        m = n.runWebGLProgram(g, [f, p], f.dtype),
        b = mv({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: l
      }
    });
    return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), b;
  }
};

class Q$ {
  constructor(e, t) {
    this.variableNames = ["A", "indices"], this.outputShape = t, this.rank = t.length;

    var n = Ck(this.rank),
        s = function (e, t) {
      var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
          s = [];

      for (var _t405 = 0; _t405 < e.length; _t405++) {
        s.push(2 === _t405 ? "int(getIndices(resRC.x, resRC.z))" : "".concat(n[_t405]));
      }

      return s.join();
    }(e);

    this.userCode = "\n      void main() {\n        ".concat(n, " resRC = getOutputCoords();\n        setOutput(getA(").concat(s, "));\n      }\n    ");
  }

}

function eS(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r,
    indices: a
  } = t,
      {
    axis: i,
    batchDims: o
  } = s,
      l = tl(r, a, y(i, r.shape)[0], o),
      u = d(a.shape),
      c = [],
      h = mv({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      shape: [l.batchSize, l.outerSize, l.dimSize, l.sliceSize]
    }
  }),
      p = mv({
    inputs: {
      x: a
    },
    backend: n,
    attrs: {
      shape: [l.batchSize, u / l.batchSize]
    }
  });
  c.push(h), c.push(p);
  var f = [l.batchSize, l.outerSize, u / l.batchSize, l.sliceSize];

  if (n.shouldExecuteOnCPU([r, a]) || "string" === r.dtype) {
    var _e494 = n.bufferSync(p),
        _t406 = n.bufferSync(h),
        _s231 = nw(_t406, _e494, f);

    return c.forEach(e => n.disposeIntermediateTensorInfo(e)), n.makeTensorInfo(l.outputShape, _s231.dtype, _s231.values);
  }

  var g = new Q$(h.shape, f),
      m = n.runWebGLProgram(g, [h, p], h.dtype);
  c.push(m);
  var b = mv({
    inputs: {
      x: m
    },
    backend: n,
    attrs: {
      shape: l.outputShape
    }
  });
  return c.forEach(e => n.disposeIntermediateTensorInfo(e)), b;
}

var tS = {
  kernelName: "GatherV2",
  backendName: "webgl",
  kernelFunc: eS
},
    nS = {
  kernelName: "Greater",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "return float(a > b);",
    packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n",
    cpuKernelImpl: sw,
    dtype: "bool"
  })
},
    sS = {
  kernelName: "GreaterEqual",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "return float(a >= b);",
    packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n",
    dtype: "bool",
    cpuKernelImpl: rw
  })
},
    rS = {
  kernelName: "IFFT",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      input: s
    } = t;
    return O$(s, !0, n);
  }
},
    aS = {
  kernelName: "IsFinite",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "return float(!isnan(x) && !isinf(x));",
    dtype: "bool"
  })
},
    iS = {
  kernelName: "IsInf",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "return float(isinf(x));",
    dtype: "bool"
  })
},
    oS = {
  kernelName: "IsNan",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "return float(isnan(x));",
    dtype: "bool"
  })
},
    lS = {
  kernelName: "Less",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "return float(a < b);",
    packedOpSnippet: "\n  return vec4(lessThan(a, b));\n",
    cpuKernelImpl: aw,
    dtype: "bool"
  })
},
    uS = {
  kernelName: "LessEqual",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "return float(a <= b);",
    packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n",
    cpuKernelImpl: iw,
    dtype: "bool"
  })
},
    cS = {
  kernelName: "LinSpace",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      backend: t,
      attrs: n
    } = e,
        {
      start: s,
      stop: r,
      num: a
    } = n,
        i = ow(s, r, a);
    return t.makeTensorInfo([i.length], "float32", i);
  }
},
    hS = {
  kernelName: "Log",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (x < 0.0) return NAN;\n  return log(x);",
    packedOpSnippet: "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: lw
  })
},
    dS = {
  kernelName: "Log1p",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "return log(1.0 + x);"
  })
},
    pS = {
  kernelName: "LogicalAnd",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "return float(a >= 1.0 && b >= 1.0);",
    packedOpSnippet: "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",
    dtype: "bool"
  })
},
    fS = {
  kernelName: "LogicalNot",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "return float(!(x >= 1.0));"
  })
},
    gS = {
  kernelName: "LogicalOr",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "return float(a >= 1.0 || b >= 1.0);",
    packedOpSnippet: "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",
    dtype: "bool"
  })
};

class mS {
  constructor(e, t, n, s, r) {
    this.variableNames = ["x"], this.outputShape = [];
    var a = t,
        i = e[3] - 1;
    var o;
    this.outputShape = e;
    var l = "float(".concat(n, ") + float(").concat(s, ") * sum");
    o = .5 === r ? "inversesqrt(".concat(l, ")") : 1 === r ? "1.0/(".concat(l, ")") : "exp(log(".concat(l, ") * float(-").concat(r, "));"), this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(a, "; j <= ").concat(a, "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(i, ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(o, ";\n        setOutput(val);\n      }\n    ");
  }

}

class bS {
  constructor(e, t, n, s, r) {
    this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
    var a = t,
        i = e[3] - 1;
    var o;
    this.outputShape = e;
    var l = "float(".concat(n, ") + float(").concat(s, ") * sum");
    o = .5 === r ? "inversesqrt(".concat(l, ")") : 1 === r ? "1.0/(".concat(l, ")") : "exp(log(".concat(l, ") * float(-").concat(r, "));"), this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3], ";\n        bool hasNextRow = c < ").concat(this.outputShape[2], ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(a, ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(a, "; j <= ").concat(a, "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(i, "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(o, ";\n        setOutput(result);\n      }\n    ");
  }

}

var xS = {
  kernelName: "LRN",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      depthRadius: a,
      bias: i,
      alpha: o,
      beta: l
    } = s,
        u = G().getBool("WEBGL_PACK_NORMALIZATION") ? new bS(r.shape, a, i, o, l) : new mS(r.shape, a, i, o, l);
    return n.runWebGLProgram(u, [r], r.dtype);
  }
};

class yS {
  constructor(e, t, n, s, r) {
    this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = t, this.bias = n, this.alpha = s, this.beta = r, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth, "; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t, ")));\n          int depthEnd = int(min(float(").concat(this.depth, "),\n              float(d + ").concat(t, " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth, ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(s, ") * norm + float(").concat(n, ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(s, ")\n                * float(").concat(r, ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r, ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ");
  }

}

var kS = {
  kernelName: "LRNGrad",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      y: a,
      dy: i
    } = t,
        {
      depthRadius: o,
      bias: l,
      alpha: u,
      beta: c
    } = s,
        h = new yS(r.shape, o, l, u, c);
    return n.runWebGLProgram(h, [r, a, i], r.dtype);
  }
};

function wS(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    reductionIndices: a,
    keepDims: i
  } = s,
      o = r.shape.length,
      l = y(a, r.shape);
  var u = l;
  var c = Zr(u, o),
      h = null != c,
      p = n.shouldExecuteOnCPU([r]);
  var f = r;

  if (h) {
    if (p) {
      var _e495 = n.texData.get(f.dataId).values,
          _t407 = new Array(o);

      for (var _e496 = 0; _e496 < _t407.length; _e496++) {
        _t407[_e496] = r.shape[c[_e496]];
      }

      var _s232 = Fw(_e495, r.shape, r.dtype, c, _t407);

      f = n.makeTensorInfo(_t407, r.dtype), n.texData.get(f.dataId).values = _s232;
    } else f = Iv(r, c, n);

    u = ea(u.length, o);
  }

  Jr("max", u, o);
  var [g, m] = Xr(f.shape, u);
  var b,
      x = g;

  if (i && (x = Yr(g, l)), p) {
    var _e497 = n.texData.get(f.dataId),
        _t408 = uw(_e497.values, d(m), x, r.dtype);

    b = n.makeTensorInfo(x, r.dtype), n.texData.get(b.dataId).values = _t408;
  } else b = function (e, t, n, s) {
    var r = d(t),
        a = mv({
      inputs: {
        x: e
      },
      attrs: {
        shape: [d(e.shape) / r, r]
      },
      backend: s
    }),
        i = kv(a, e.dtype, "max", s),
        o = mv({
      inputs: {
        x: i
      },
      attrs: {
        shape: n
      },
      backend: s
    });
    return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), o;
  }(f, m, x, n);

  return h && n.disposeIntermediateTensorInfo(f), b;
}

var vS = {
  kernelName: "Max",
  backendName: "webgl",
  kernelFunc: wS
},
    IS = {
  kernelName: "Maximum",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",
    packedOpSnippet: "\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: cw
  })
},
    $S = {
  kernelName: "MaxPool",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t;
    ck(r, "maxPool");
    var {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: u
    } = s;
    l(Ts(i, 1), () => "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'"));
    var c = xs(r.shape, a, i, 1, o, u);
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) return Zw({
      inputs: {
        x: r
      },
      backend: n
    });
    var h = new Qv(c, "max", !1);
    return n.runWebGLProgram(h, [r], r.dtype);
  }
},
    SS = {
  kernelName: "MaxPool3D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      filterSize: a,
      strides: i,
      pad: o,
      dataFormat: l,
      dimRoundingMode: u
    } = s,
        c = ys(r.shape, a, i, [1, 1, 1], o, u, l),
        h = new eI(c, "max", !1);
    return n.runWebGLProgram(h, [r], r.dtype);
  }
};

class NS {
  constructor(e) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
    var t = e.effectiveFilterHeight,
        n = e.effectiveFilterWidth;
    this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t, ";\n          wR += ").concat(e.dilationHeight, ") {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(n, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(t * n - 1, " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(n, " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class CS {
  constructor(e) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
    var t = e.effectiveFilterDepth,
        n = e.effectiveFilterHeight,
        s = e.effectiveFilterWidth;
    this.userCode = "\n      const ivec3 pads = ivec3(".concat(t - 1 - e.padInfo.front, ", ").concat(n - 1 - e.padInfo.top, ", ").concat(s - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(t, ";\n           wD += ").concat(e.dilationDepth, ") {\n          float dyD = float(dyDCorner + wD) / ").concat(e.strideDepth, ".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth, ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(n, ";\n              wR += ").concat(e.dilationHeight, ") {\n            float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(s, ";\n                wC += ").concat(e.dilationWidth, ") {\n              float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(t * n * s - 1, " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(n, " * ").concat(s, " +\n                  wR * ").concat(s, " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

var TS = {
  kernelName: "MaxPool3DGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        i = a,
        {
      filterSize: o,
      strides: l,
      pad: u,
      dimRoundingMode: c
    } = s,
        h = ys(i.shape, o, l, [1, 1, 1], u, c),
        d = new eI(h, "max", !0),
        p = n.runWebGLProgram(d, [i], i.dtype),
        f = new CS(h),
        g = n.runWebGLProgram(f, [r, p], i.dtype);
    return n.disposeIntermediateTensorInfo(p), g;
  }
},
    ES = {
  kernelName: "MaxPoolGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a,
      output: i
    } = t,
        o = a;
    ck([a, i], "maxPoolGrad");
    var {
      filterSize: l,
      strides: u,
      pad: c,
      dimRoundingMode: h
    } = s,
        d = xs(o.shape, l, u, 1, c, h),
        p = new Qv(d, "max", !0),
        f = n.runWebGLProgram(p, [o], o.dtype),
        g = new NS(d),
        m = n.runWebGLProgram(g, [r, f], o.dtype);
    return n.disposeIntermediateTensorInfo(f), m;
  }
},
    RS = {
  kernelName: "MaxPoolWithArgmax",
  backendName: "webgl",
  kernelFunc: _ref29 => {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref29;
    var {
      x: s
    } = e,
        {
      filterSize: r,
      strides: a,
      pad: i,
      includeBatchInIndex: o
    } = t,
        u = n;
    l(4 === s.shape.length, () => "Error in maxPool: input must be rank 4 but got rank ".concat(s.shape.length, "."));
    var c = [1, 1];
    l(Ts(a, c), () => "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(a, " and dilations '").concat(c, "'"));

    var h = xs(s.shape, r, a, c, i),
        [d, p] = function (e, t, n, s) {
      var r = new Qv(n, "max", !1);
      var a = s.runWebGLProgram(r, [e], "float32");
      return r = new Qv(n, "max", !0, !0, t), [a, s.runWebGLProgram(r, [e], "float32")];
    }(s, o, h, u);

    return [d, p];
  }
},
    AS = {
  kernelName: "Mean",
  backendName: "webgl",
  kernelFunc: _ref30 => {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref30;
    var {
      x: s
    } = e,
        {
      keepDims: r,
      axis: a
    } = t,
        i = n,
        o = s.shape.length,
        l = y(a, s.shape);
    var u = l;
    var c = Zr(u, o),
        h = null != c,
        p = i.shouldExecuteOnCPU([s]),
        f = [];
    var g = s;

    if (h) {
      if (p) {
        var _e498 = i.texData.get(g.dataId).values,
            _t409 = new Array(o);

        for (var _e499 = 0; _e499 < _t409.length; _e499++) {
          _t409[_e499] = s.shape[c[_e499]];
        }

        var _n288 = Fw(_e498, s.shape, s.dtype, c, _t409);

        g = i.makeTensorInfo(_t409, s.dtype), i.texData.get(g.dataId).values = _n288;
      } else g = Iv(s, c, i);

      f.push(g), u = ea(u.length, o);
    }

    Jr("sum", u, o);
    var [m, b] = Xr(g.shape, u);
    var x = m;
    r && (x = Yr(m, l));

    var k = function (e, t, n, s) {
      var r = d(t),
          a = mv({
        inputs: {
          x: e
        },
        attrs: {
          shape: [d(e.shape) / r, r]
        },
        backend: s
      }),
          i = kv(a, "float32", "mean", s),
          o = mv({
        inputs: {
          x: i
        },
        attrs: {
          shape: n
        },
        backend: s
      });
      return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), o;
    }(g, b, x, i);

    for (var _e500 of f) {
      i.disposeIntermediateTensorInfo(_e500);
    }

    return k;
  }
},
    FS = {
  kernelName: "Min",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s,
        o = r.shape.length,
        l = y(a, r.shape);
    var u = l;
    var c = Zr(u, o);
    var h = r;
    null != c && (h = Nv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), u = ea(u.length, r.shape.length)), Jr("min", u, o);
    var [p, f] = Xr(h.shape, u),
        g = mv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, d(f)]
      }
    }),
        m = kv(g, g.dtype, "min", n);
    var b;
    return b = mv(i ? {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Yr(p, l)
      }
    } : {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: p
      }
    }), n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), b;
  }
},
    DS = {
  kernelName: "Minimum",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",
    packedOpSnippet: "\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: hw
  })
};

class _S {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.outputShape = t.map((t, n) => t[0] + e[n] + t[1]);
    var s = e.length,
        r = Ck(s),
        a = t.map(e => e[0]).join(","),
        i = t.map((t, n) => t[0] + e[n]).join(","),
        o = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s),
        l = "reflect" === n ? 0 : 1;
    this.userCode = 1 !== s ? "\n      ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outC = getOutputCoords();\n        for (int i = 0; i < ").concat(s, "; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(l, ";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(l, ";\n          }\n        }\n        ").concat(r, " coords = outC - start;\n        setOutput(getX(").concat(o, "));\n      }\n    ") : "\n        int start = ".concat(a, ";\n        int end = ").concat(i, ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(l, ";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(l, ";\n          }\n          setOutput(getX(outC - start));\n        }\n      ");
  }

}

class OS {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.map((t, n) => t[0] + e[n] + t[1]);
    var s = e.length,
        r = Ck(s),
        a = t.map(e => e[0]).join(","),
        i = t.map((t, n) => t[0] + e[n]).join(","),
        o = Ow("rc", s),
        l = Ow("source", s),
        u = "".concat(o[s - 1], " < ").concat(this.outputShape[s - 1]),
        c = 1 === s ? "source" : "vec2(".concat(l.slice(-2).join(), ")"),
        h = "reflect" === n ? 0 : 1;
    var d = "";

    if (1 === s) {
      var _e501 = "\n        ".concat(r, " source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h, ";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h, ";\n        }\n        source -= start;\n      ");

      d = "\n        ".concat(r, " rc = outputLoc;\n        ").concat(_e501, "\n        result[0] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        ").concat(o[s - 1], " += 1;\n        if(").concat(u, ") {\n          ").concat(_e501, "\n          result[1] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        }\n      ");
    } else {
      var _e502 = "\n        ".concat(r, " source = rc;\n        ").concat(r, " lt = ").concat(r, "(lessThan(source, start));\n        ").concat(r, " gte = ").concat(r, "(greaterThanEqual(source, end));\n        ").concat(r, " orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h, ") +\n                gte * ((end - 1) * 2 - source + ").concat(h, ");\n        source -= start;\n      ");

      d = "\n        ".concat(r, " rc = outputLoc;\n        ").concat(_e502, "\n        result[0] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        ").concat(o[s - 1], " += 1;\n        if(").concat(u, ") {\n          ").concat(_e502, "\n          result[1] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        }\n        rc = outputLoc;\n        ").concat(o[s - 2], " += 1;\n        if(").concat(o[s - 2], " < ").concat(this.outputShape[s - 2], ") {\n          ").concat(_e502, "\n          result[2] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n          ").concat(o[s - 1], " += 1;\n          if(").concat(u, ") {\n            ").concat(_e502, "\n            result[3] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n          }\n        }\n      ");
    }

    this.userCode = "\n      const ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      const ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d, "\n        setOutput(result);\n      }\n    ");
  }

}

var MS = {
  kernelName: "MirrorPad",
  backendName: "webgl",
  kernelFunc: _ref31 => {
    var {
      inputs: e,
      backend: t,
      attrs: n
    } = _ref31;
    var {
      x: s
    } = e,
        {
      paddings: r,
      mode: a
    } = n,
        i = G().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new OS(s.shape, r, a) : new _S(s.shape, r, a);
    return t.runWebGLProgram(i, [s], s.dtype);
  }
},
    LS = {
  kernelName: "Mod",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);",
    packedOpSnippet: "\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
  })
};

class zS {
  constructor(e, t, n) {
    this.variableNames = ["probs"], this.customUniforms = [{
      name: "seed",
      type: "float"
    }], this.outputShape = [e, n], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t - 1, "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t - 1, "));\n      }\n    ");
  }

}

var BS = uv({
  opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
  packedOpSnippet: "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
  checkOutOfBounds: !0
}),
    PS = {
  kernelName: "RealDiv",
  backendName: "webgl",
  kernelFunc: BS
},
    WS = "return a - b;",
    US = uv({
  opSnippet: WS,
  packedOpSnippet: WS,
  supportsComplex: !0,
  cpuKernelImpl: Ew
}),
    VS = {
  kernelName: "Sub",
  backendName: "webgl",
  kernelFunc: US
};

function GS(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    logits: r
  } = t,
      {
    dim: a
  } = s,
      i = y([a], r.shape),
      o = wS({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      reductionIndices: i,
      keepDims: !1
    }
  }),
      l = Yr(o.shape, i),
      u = mv({
    inputs: {
      x: o
    },
    backend: n,
    attrs: {
      shape: l
    }
  }),
      c = US({
    inputs: {
      a: r,
      b: u
    },
    backend: n
  }),
      h = T$({
    inputs: {
      x: c
    },
    backend: n
  }),
      d = $v({
    inputs: {
      x: h
    },
    backend: n,
    attrs: {
      axis: i,
      keepDims: !1
    }
  }),
      p = mv({
    inputs: {
      x: d
    },
    backend: n,
    attrs: {
      shape: l
    }
  }),
      f = BS({
    inputs: {
      a: h,
      b: p
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(p), f;
}

var HS = {
  kernelName: "Softmax",
  backendName: "webgl",
  kernelFunc: GS
},
    qS = {
  kernelName: "Multinomial",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      logits: r
    } = t,
        {
      numSamples: a,
      seed: i,
      normalized: o
    } = s,
        l = o ? r : GS({
      inputs: {
        logits: r
      },
      backend: n,
      attrs: {
        dim: r.shape.length - 1
      }
    }),
        u = new zS(l.shape[0], l.shape[1], a),
        c = n.runWebGLProgram(u, [l], "int32", [[i]]);
    return o || n.disposeIntermediateTensorInfo(l), c;
  }
},
    jS = "return -x;",
    KS = {
  kernelName: "Neg",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t;

    if (n.shouldExecuteOnCPU([s])) {
      var _e503 = n.texData.get(s.dataId),
          [_t410, _r170] = pw(_e503.values, s.shape, s.dtype);

      return n.makeTensorInfo(_r170, s.dtype, _t410);
    }

    var r;
    return r = G().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new Gw(s.shape, jS) : new Uw(s.shape, jS), n.runWebGLProgram(r, [s], s.dtype);
  }
},
    XS = Ki,
    YS = {
  kernelName: "NonMaxSuppressionV3",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    W("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l
    } = s,
        u = n.readSync(r.dataId),
        c = n.readSync(a.dataId),
        {
      selectedIndices: h
    } = XS(u, c, i, o, l);
    return n.makeTensorInfo([h.length], "int32", new Int32Array(h));
  }
},
    JS = Xi,
    ZS = {
  kernelName: "NonMaxSuppressionV4",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    W("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l,
      padToMaxOutputSize: u
    } = s,
        c = n.readSync(r.dataId),
        h = n.readSync(a.dataId),
        {
      selectedIndices: d,
      validOutputs: p
    } = JS(c, h, i, o, l, u);
    return [n.makeTensorInfo([d.length], "int32", new Int32Array(d)), n.makeTensorInfo([], "int32", new Int32Array([p]))];
  }
},
    QS = Yi,
    eN = {
  kernelName: "NonMaxSuppressionV5",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    W("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l,
      softNmsSigma: u
    } = s,
        c = n.readSync(r.dataId),
        h = n.readSync(a.dataId),
        d = i,
        p = o,
        f = l,
        g = u,
        {
      selectedIndices: m,
      selectedScores: b
    } = QS(c, h, d, p, f, g);
    return [n.makeTensorInfo([m.length], "int32", new Int32Array(m)), n.makeTensorInfo([b.length], "float32", new Float32Array(b))];
  }
};

class tN {
  constructor(e, t, n, s) {
    this.variableNames = ["indices"], this.outputShape = [e, t], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(s, "), float(").concat(n, "),\n                      float(index == coords.y)));\n      }\n    ");
  }

}

var nN = {
  kernelName: "OneHot",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      indices: r
    } = t,
        {
      depth: a,
      onValue: i,
      offValue: o
    } = s,
        l = d(r.shape),
        u = new tN(l, a, i, o),
        c = mv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [l]
      }
    }),
        h = n.runWebGLProgram(u, [c], r.dtype);
    n.disposeIntermediateTensorInfo(c);
    var p = mv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [...r.shape, a]
      }
    });
    return n.disposeIntermediateTensorInfo(h), p;
  }
};

function sN(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    x: s
  } = t;

  if ("complex64" === s.dtype) {
    var _e504 = kI({
      inputs: {
        input: s
      },
      backend: n
    }),
        _t411 = sN({
      inputs: {
        x: _e504
      },
      backend: n
    }),
        _r171 = _I({
      inputs: {
        input: s
      },
      backend: n
    }),
        _a139 = sN({
      inputs: {
        x: _r171
      },
      backend: n
    }),
        _i99 = ev({
      inputs: {
        real: _t411,
        imag: _a139
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_e504), n.disposeIntermediateTensorInfo(_t411), n.disposeIntermediateTensorInfo(_r171), n.disposeIntermediateTensorInfo(_a139), _i99;
  }

  return z$({
    attrs: {
      shape: s.shape,
      dtype: s.dtype,
      value: "string" === s.dtype ? "" : 0
    },
    backend: n
  });
}

var rN = {
  kernelName: "ZerosLike",
  backendName: "webgl",
  kernelFunc: sN
},
    aN = {
  kernelName: "OnesLike",
  backendName: "webgl",
  kernelFunc: function e(t) {
    var {
      inputs: n,
      backend: s
    } = t,
        {
      x: r
    } = n;
    if ("string" === r.dtype) throw new Error("onesLike is not supported under string dtype");

    if ("complex64" === r.dtype) {
      var _t412 = kI({
        inputs: {
          input: r
        },
        backend: s
      }),
          _n289 = e({
        inputs: {
          x: _t412
        },
        backend: s
      }),
          _a140 = _I({
        inputs: {
          input: r
        },
        backend: s
      }),
          _i100 = sN({
        inputs: {
          x: _a140
        },
        backend: s
      }),
          _o74 = ev({
        inputs: {
          real: _n289,
          imag: _i100
        },
        backend: s
      });

      return s.disposeIntermediateTensorInfo(_t412), s.disposeIntermediateTensorInfo(_n289), s.disposeIntermediateTensorInfo(_a140), s.disposeIntermediateTensorInfo(_i100), _o74;
    }

    return z$({
      attrs: {
        shape: r.shape,
        dtype: r.dtype,
        value: 1
      },
      backend: s
    });
  }
},
    iN = {
  kernelName: "Pack",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      axis: r
    } = s;
    if (1 === t.length) return R$({
      inputs: {
        input: t[0]
      },
      backend: n,
      attrs: {
        dim: r
      }
    });
    var a = t[0].shape,
        i = t[0].dtype;
    t.forEach(e => {
      u(a, e.shape, "All tensors passed to stack must have matching shapes"), l(i === e.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    var o = [],
        c = LI({
      inputs: t.map(e => {
        var t = R$({
          inputs: {
            input: e
          },
          backend: n,
          attrs: {
            dim: r
          }
        });
        return o.push(t), t;
      }),
      backend: n,
      attrs: {
        axis: r
      }
    });
    return o.forEach(e => n.disposeIntermediateTensorInfo(e)), c;
  }
};

class oN {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.customUniforms = [{
      name: "value",
      type: "float"
    }], this.outputShape = t.map((t, n) => t[0] + e[n] + t[1]);
    var s = e.length,
        r = Ck(s),
        a = t.map(e => e[0]).join(","),
        i = t.map((t, n) => t[0] + e[n]).join(","),
        o = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s);
    this.userCode = 1 !== s ? "\n      ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r, " coords = outC - start;\n          setOutput(getX(").concat(o, "));\n        }\n      }\n    ") : "\n        int start = ".concat(a, ";\n        int end = ").concat(i, ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ");
  }

}

class lN {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
      name: "value",
      type: "float"
    }], this.outputShape = t.map((t, n) => t[0] + e[n] + t[1]);
    var s = e.length,
        r = Ck(s),
        a = t.map(e => e[0]).join(","),
        i = t.map((t, n) => t[0] + e[n]).join(","),
        o = Ow("rc", s),
        l = Ow("source", s),
        u = "".concat(o[s - 1], " < ").concat(this.outputShape[s - 1]),
        c = 1 === s ? "source" : "vec2(".concat(l.slice(-2).join(), ")"),
        h = ["".concat(r, " rc = outputLoc;"), "".concat(o[s - 1], " += 1;\n       if(").concat(u, ") {\n      "), 1 === s ? "" : "}\n       rc = outputLoc;\n       ".concat(o[s - 2], " += 1;\n       if(").concat(o[s - 2], " < ").concat(this.outputShape[s - 2], ") {"), 1 === s ? "" : "  ".concat(o[s - 1], " += 1;\n         if(").concat(u, ") {")],
        d = 1 === s ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
    var p = "";

    for (var _e505 = 0, _t413 = 1 === s ? 2 : 4; _e505 < _t413; _e505++) {
      p += "\n        ".concat(h[_e505], "\n        if (").concat(d, ") {\n          result[").concat(_e505, "] = float(value);\n        } else {\n          ").concat(r, " source = rc - start;\n          result[").concat(_e505, "] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        }\n      ");
    }

    p += 1 === s ? "} " : "}}", this.userCode = "\n      const ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      const ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p, "\n        setOutput(result);\n      }\n    ");
  }

}

var uN = e => {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    paddings: a,
    constantValue: i
  } = s;
  if (0 === d(r.shape)) return z$({
    backend: n,
    attrs: {
      shape: a.map((e, t) => e[0] + r.shape[t] + e[1]),
      value: i,
      dtype: r.dtype
    }
  });
  var o = G().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new lN(r.shape, a, i) : new oN(r.shape, a, i);
  return n.runWebGLProgram(o, [r], r.dtype, [[i]]);
},
    cN = {
  kernelName: "PadV2",
  backendName: "webgl",
  kernelFunc: uN
},
    hN = {
  kernelName: "Pow",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",
    packedOpSnippet: "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
  })
},
    dN = {
  kernelName: "Prod",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s,
        o = r.shape.length,
        l = [],
        u = y(a, r.shape);
    var c = u;
    var h = Zr(c, o);
    var p,
        f = r;

    if (null != h && (f = Nv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: h
      }
    }), c = ea(c.length, o), l.push(f)), Jr("prod", c, o), n.shouldExecuteOnCPU([f])) {
      var _e506 = n.texData.get(f.dataId).values,
          {
        outVals: _t414,
        outShape: _s233,
        outDtype: _r172
      } = gw(f.shape, f.dtype, _e506, c);
      p = n.makeTensorInfo(_s233, _r172, _t414);
    } else {
      var [_e507, _t415] = Xr(f.shape, c),
          _s234 = d(_t415),
          _a141 = mv({
        inputs: {
          x: f
        },
        backend: n,
        attrs: {
          shape: [-1, _s234]
        }
      }),
          _i101 = kv(_a141, ft(r.dtype), "prod", n);

      p = mv({
        inputs: {
          x: _i101
        },
        backend: n,
        attrs: {
          shape: _e507
        }
      }), l.push(_a141), l.push(_i101);
    }

    if (i) {
      l.push(p);

      var _e508 = Yr(p.shape, u);

      p = mv({
        inputs: {
          x: p
        },
        backend: n,
        attrs: {
          shape: _e508
        }
      });
    }

    return l.forEach(e => n.disposeIntermediateTensorInfo(e)), p;
  }
},
    pN = e => {
  var {
    backend: t,
    attrs: n
  } = e,
      {
    start: s,
    stop: r,
    step: a,
    dtype: i
  } = n,
      o = mw(s, r, a, i);
  return t.makeTensorInfo([o.length], i, o);
},
    fN = {
  kernelName: "Range",
  backendName: "webgl",
  kernelFunc: pN
},
    gN = {
  kernelName: "Reciprocal",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "return 1.0 / x;"
  })
},
    mN = {
  kernelName: "Relu",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",
    packedOpSnippet: "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
  })
},
    bN = {
  kernelName: "Relu6",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
    packedOpSnippet: "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
  })
};

class xN {
  constructor(e, t, n, s, r) {
    this.variableNames = ["A"], this.outputShape = [];
    var [a, i, o, l] = e;
    this.outputShape = [a, t, n, l];
    var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
        c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
    var h;
    h = r ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ");\n      const vec2 inputShapeRC = vec2(").concat(i, ".0, ").concat(o, ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ");
  }

}

class yN {
  constructor(e, t, n, s, r) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
    var [a, i, o, l] = e;
    this.outputShape = [a, t, n, l];
    var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
        c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
    var h;
    h = r ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ",\n          ").concat(u[1] / c[1], ");\n      const vec3 inputShapeRC = vec3(").concat(i, ".0, ").concat(o, ".0,\n                                     ").concat(o, ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l - 1, ";\n        bool hasNextRow = coords.z < ").concat(n - 1, ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ");
  }

}

var kN = {
  kernelName: "ResizeBilinear",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r
    } = t,
        {
      alignCorners: a,
      halfPixelCenters: i,
      size: o
    } = s,
        [l, u] = o,
        c = G().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new yN(r.shape, l, u, a, i) : new xN(r.shape, l, u, a, i);
    return n.runWebGLProgram(c, [r], "float32");
  }
};

class wN {
  constructor(e, t, n) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;
    var [, s, r] = t,
        [, a, i] = e,
        o = [n && a > 1 ? s - 1 : s, n && i > 1 ? r - 1 : r],
        l = [n && a > 1 ? a - 1 : a, n && i > 1 ? i - 1 : i],
        u = o[0] / l[0],
        c = o[1] / l[1],
        h = 1 / u,
        d = 1 / c,
        p = 2 * Math.ceil(h) + 2,
        f = 2 * Math.ceil(d) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(u, ");\n        const float widthScale = float(").concat(c, ");\n\n        const float invHeightScale = float(").concat(h, ");\n        const float invWidthScale = float(").concat(d, ");\n\n        const int winHeight = int(").concat(p, ");\n        const int winWidth = int(").concat(f, ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(a, ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i, ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(s - 1, ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r - 1, ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ");
  }

}

var vN = {
  kernelName: "ResizeBilinearGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r,
      dy: a
    } = t,
        {
      alignCorners: i
    } = s,
        o = new wN(a.shape, r.shape, i);
    return n.runWebGLProgram(o, [a], a.dtype);
  }
};

class IN {
  constructor(e, t, n, s, r) {
    this.variableNames = ["A"], this.outputShape = [];
    var [a, i, o, l] = e;
    this.outputShape = [a, t, n, l];
    var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
        c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
    var h;
    h = r ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ");\n      const vec2 inputShapeRC = vec2(").concat(i, ".0, ").concat(o, ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(s ? "0.5" : "0.0", ")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ");
  }

}

class $N {
  constructor(e, t, n, s, r) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
    var [a, i, o, l] = e;
    this.outputShape = [a, t, n, l];
    var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
        c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
    var h;
    h = r ? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ",\n          ").concat(u[1] / c[1], ");\n      const vec3 inputShapeRC = vec3(").concat(i, ".0, ").concat(o, ".0,\n                                     ").concat(o, ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(s ? "0.5" : "0.0", ")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l - 1, ";\n        bool hasNextRow = coords.z < ").concat(n - 1, ";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ");
  }

}

var SN = {
  kernelName: "ResizeNearestNeighbor",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r
    } = t,
        {
      alignCorners: a,
      halfPixelCenters: i,
      size: o
    } = s,
        [l, u] = o,
        c = G().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new $N(r.shape, l, u, a, i) : new IN(r.shape, l, u, a, i);
    return n.runWebGLProgram(c, [r], r.dtype);
  }
};

class NN {
  constructor(e, t, n) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;
    var [, s, r] = t,
        [, a, i] = e,
        o = [n && a > 1 ? s - 1 : s, n && i > 1 ? r - 1 : r],
        l = [n && a > 1 ? a - 1 : a, n && i > 1 ? i - 1 : i],
        u = o[0] / l[0],
        c = o[1] / l[1],
        h = 1 / u,
        d = 1 / c,
        p = 2 * Math.ceil(h) + 2,
        f = 2 * Math.ceil(d) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(u, ");\n        const float widthScale = float(").concat(c, ");\n\n        const float invHeightScale = float(").concat(h, ");\n        const float invWidthScale = float(").concat(d, ");\n\n        const int winHeight = int(").concat(p, ");\n        const int winWidth = int(").concat(f, ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(a, ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i, ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(o[0], ") *\n                (float(dyR) / float(").concat(l[0], "));\n\n            float sourceFracCol =\n                float(").concat(o[1], ") *\n                  (float(dyC) / float(").concat(l[1], "));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(s, ") - 1),\n                ").concat(n, " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r, ") - 1),\n                ").concat(n, " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ");
  }

}

var CN = {
  kernelName: "ResizeNearestNeighborGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r,
      dy: a
    } = t,
        {
      alignCorners: i
    } = s,
        o = new NN(a.shape, r.shape, i);
    return n.runWebGLProgram(o, [a], a.dtype);
  }
};

class TN {
  constructor(e, t) {
    this.variableNames = ["x"];
    var n = e.length;
    if (n > 4) throw new Error("WebGL backend: Reverse of rank-".concat(n, " tensor is not yet supported"));
    if (this.outputShape = e, 1 === n) return void (this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0], " - coord - 1));\n        }\n      "));
    var s = e.map((n, s) => (n => -1 !== t.indexOf(n) && 1 !== e[n] ? "".concat(e[n], " - coords[").concat(n, "] - 1") : "coords[".concat(n, "]"))(s)).join(","),
        r = Ck(n);
    this.userCode = "\n      void main() {\n        ".concat(r, " coords = getOutputCoords();\n        setOutput(getX(").concat(s, "));\n      }\n    ");
  }

}

class EN {
  constructor(e, t) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
    var n = e.length;
    if (n > 4) throw new Error("WebGL backend: Reverse of rank-".concat(n, " tensor is not yet supported"));
    this.outputShape = e;
    var s = Ow("rc", n),
        r = "".concat(s[n - 1], " + 1 < ").concat(this.outputShape[n - 1]),
        a = "".concat(s[n - 2], " + 1 < ").concat(this.outputShape[n - 2]),
        i = Ck(n);

    function o(n) {
      var s = e.map((s, r) => function (n, s) {
        return -1 !== t.indexOf(n) && 1 !== e[n] ? "".concat(e[n], " - ").concat(s[n], " - 1") : "".concat(s[n]);
      }(r, n));
      return "getChannel(getX(".concat(s.join(","), "), vec2(").concat(s.slice(-2).join(","), "))");
    }

    this.userCode = 1 === n ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0], " - rc - 1),\n            ").concat(e[0], " - rc - 1);\n          if(").concat(r, "){\n              result.g = getChannel(getX(").concat(e[0], " - (rc  + 1) - 1),\n                ").concat(e[0], " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ") : "\n        void main() {\n          ".concat(i, " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function (e) {
      return o(e);
    }(s.slice()), ";\n          if(").concat(r, "){\n            result.g = ").concat(function (e) {
      return e[n - 1] = "(" + e[n - 1] + " + 1)", o(e);
    }(s.slice()), ";\n          }\n          if(").concat(a, ") {\n            result.b = ").concat(function (e) {
      return e[n - 2] = "(" + e[n - 2] + " + 1)", o(e);
    }(s.slice()), ";\n            if(").concat(r, ") {\n              result.a = ").concat(function (e) {
      return e[n - 1] = "(" + e[n - 1] + " + 1)", e[n - 2] = "(" + e[n - 2] + " + 1)", o(e);
    }(s.slice()), ";\n            }\n          }\n          setOutput(result);\n        }\n    ");
  }

}

var RN = {
  kernelName: "Reverse",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      dims: a
    } = s,
        i = r.shape.length,
        o = y(a, r.shape);
    if (0 === i) return Zw({
      inputs: {
        x: r
      },
      backend: n
    });
    var l = G().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new EN(r.shape, o) : new TN(r.shape, o);
    return n.runWebGLProgram(l, [r], r.dtype);
  }
};

class AN {
  constructor(e, t) {
    this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{
      name: "params",
      type: "vec4"
    }];
    var n = e[1],
        s = e[2];
    this.outputShape = e;
    var r = "";
    r = "number" == typeof t ? "float outputValue = ".concat(t.toFixed(2), ";") : "\n        vec3 fill = vec3(".concat(t.join(","), ");\n        float outputValue = fill[coords[3]];"), this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r, "\n          if(coordX >= 0 && coordX < ").concat(s, " && coordY >= 0 && coordY < ").concat(n, ") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ");
  }

}

var FN = {
  kernelName: "RotateWithOffset",
  backendName: "webgl",
  kernelFunc: _ref32 => {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref32;
    var {
      image: s
    } = e,
        {
      radians: r,
      fillValue: a,
      center: i
    } = t,
        o = n,
        l = new AN(s.shape, a),
        [u, c] = Ao(i, s.shape[1], s.shape[2]),
        h = [[u, c, Math.sin(r), Math.cos(r)]];
    return o.runWebGLProgram(l, [s], s.dtype, h);
  }
},
    DN = {
  kernelName: "Round",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"
  })
},
    _N = {
  kernelName: "Rsqrt",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "return inversesqrt(x);",
    cpuKernelImpl: bw
  })
};

class ON {
  constructor(e, t, n, s, r, a) {
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
    this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a;
    var o = Ck(r.length),
        l = Ck(a.length);
    var u = "";
    1 === n ? u = "i" : 2 === n && (u = "i, j");
    var c = "";
    1 === s ? c = "i" : 2 === s && (c = "i, coords[1]"), this.userCode = "\n        ".concat(o, " strides = ").concat(o, "(").concat(r, ");\n\n        void main() {\n          ").concat(l, " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e, "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t, "; j++) {\n              int index = round(getIndices(").concat(u, "));\n              flattenedIndex += index * ").concat(t > 1 ? "strides[j]" : "strides", ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(").concat(c, ");\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ");
  }

}

var MN = {
  kernelName: "ScatterNd",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      indices: r,
      updates: a
    } = t,
        {
      shape: i
    } = s,
        {
      sliceRank: o,
      numUpdates: l,
      sliceSize: u,
      strides: c,
      outputSize: h
    } = Tn(0, r, i),
        d = [h / u, u];
    if (0 === h) return n.makeTensorInfo(i, r.dtype);
    var p = mv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [l, o]
      }
    }),
        f = mv({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: [l, u]
      }
    }),
        g = n.makeTensorInfo([], "float32", new Float32Array([0])),
        m = new ON(l, o, p.shape.length, f.shape.length, c, d),
        b = n.runWebGLProgram(m, [f, p, g], f.dtype),
        x = mv({
      inputs: {
        x: b
      },
      backend: n,
      attrs: {
        shape: i
      }
    });
    return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(b), n.disposeIntermediateTensorInfo(g), x;
  }
};

class LN {
  constructor(e, t, n) {
    var s, r;
    if (this.variableNames = ["c", "a", "b"], this.outputShape = t, n > 4) throw Error("Where for rank ".concat(n, " is not yet supported"));
    if (1 === n) r = "resRC", s = "resRC";else {
      var _n290 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
          _a142 = [],
          _i102 = [];

      for (var _s235 = 0; _s235 < t.length; _s235++) {
        _i102.push("".concat(_n290[_s235])), _s235 < e && _a142.push("".concat(_n290[_s235]));
      }

      s = _a142.join(), r = _i102.join();
    }
    var a = Ck(n);
    this.userCode = "\n      void main() {\n        ".concat(a, " resRC = getOutputCoords();\n        float cVal = getC(").concat(s, ");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r, "));\n        } else {\n          setOutput(getB(").concat(r, "));\n        }\n      }\n    ");
  }

}

var zN = {
  kernelName: "Select",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      condition: s,
      t: r,
      e: a
    } = t,
        i = new LN(s.shape.length, r.shape, r.shape.length);
    return n.runWebGLProgram(i, [s, r, a], pt(r.dtype, a.dtype));
  }
},
    BN = {
  kernelName: "Selu",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n"
  })
},
    PN = "return 1.0 / (1.0 + exp(-1.0 * x));",
    WN = {
  kernelName: "Sigmoid",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: PN,
    packedOpSnippet: PN,
    cpuKernelImpl: xw
  })
},
    UN = {
  kernelName: "Sign",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"
  })
},
    VN = {
  kernelName: "Sin",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "if (isnan(x)) return x;\n  return sin(x);\n"
  })
},
    GN = {
  kernelName: "Sinh",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"
  })
},
    HN = {
  kernelName: "Softplus",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"
  })
},
    qN = {
  kernelName: "SpaceToBatchND",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockShape: a,
      paddings: i
    } = s;
    l(r.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
    var o = a.reduce((e, t) => e * t),
        u = [[0, 0]];
    u.push(...i);

    for (var _e509 = 1 + a.length; _e509 < r.shape.length; ++_e509) {
      u.push([0, 0]);
    }

    var c = [],
        h = uN({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        paddings: u,
        constantValue: 0
      }
    }),
        d = Fo(h.shape, a, o, !1),
        p = Do(d.length, a.length, !1),
        f = _o(h.shape, a, o, !1),
        g = mv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: d
      }
    }),
        m = Nv({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        perm: p
      }
    }),
        b = mv({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: f
      }
    });

    return c.push(h), c.push(g), c.push(m), c.forEach(e => n.disposeIntermediateTensorInfo(e)), b;
  }
},
    jN = {
  kernelName: "SparseFillEmptyRows",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      indices: s,
      values: r,
      denseShape: a,
      defaultValue: i
    } = t;
    if (1 !== a.shape.length) throw new Error("Dense shape must be a vector, saw:\n         ".concat(a.shape));
    if (2 !== s.shape.length) throw new Error("Indices must be a matrix, saw:\n         ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));
    if (0 !== i.shape.length) throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));
    var o = n.readSync(s.dataId),
        l = n.readSync(r.dataId),
        u = n.readSync(a.dataId),
        c = n.readSync(i.dataId)[0],
        [h, d, p, f, g] = ww(o, s.shape, s.dtype, l, r.dtype, u, c);
    return [n.makeTensorInfo(d, s.dtype, h), n.makeTensorInfo([d[0]], r.dtype, p), n.makeTensorInfo([f.length], "bool", new Uint8Array(f.map(e => Number(e)))), n.makeTensorInfo([g.length], s.dtype, new Int32Array(g))];
  }
},
    KN = {
  kernelName: "SparseReshape",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      inputIndices: s,
      inputShape: r,
      newShape: a
    } = t;
    if (2 !== s.shape.length) throw new Error("Input indices should be a matrix but received shape ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Input shape should be a vector but received shape ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Target shape should be a vector but received shape ".concat(a.shape));
    var i = Array.from(n.readSync(r.dataId)),
        o = n.readSync(s.dataId),
        l = Array.from(n.readSync(a.dataId)),
        [u, c, h] = vw(o, s.shape, s.dtype, i, l);
    return [n.makeTensorInfo(c, s.dtype, u), n.makeTensorInfo([h.length], a.dtype, new Int32Array(h))];
  }
},
    XN = {
  kernelName: "SparseSegmentMean",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      data: s,
      indices: r,
      segmentIds: a
    } = t;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n              ".concat(a.shape));
    var i = n.readSync(s.dataId),
        o = n.readSync(r.dataId),
        l = n.readSync(a.dataId),
        [u, c] = Iw(i, s.shape, s.dtype, o, l, !0);
    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    YN = {
  kernelName: "SparseSegmentSum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      data: s,
      indices: r,
      segmentIds: a
    } = t;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n             ".concat(a.shape));
    var i = n.readSync(s.dataId),
        o = n.readSync(r.dataId),
        l = n.readSync(a.dataId),
        [u, c] = Iw(i, s.shape, s.dtype, o, l);
    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    JN = {
  kernelName: "SparseToDense",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      sparseIndices: r,
      sparseValues: a,
      defaultValue: i
    } = t,
        {
      outputShape: o
    } = s,
        {
      sliceRank: l,
      numUpdates: u,
      strides: c,
      outputSize: h
    } = Tn(0, r, o),
        d = new ON(u, l, r.shape.length, a.shape.length, c, [h, 1], !1),
        p = n.runWebGLProgram(d, [a, r, i], a.dtype),
        f = mv({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        shape: o
      }
    });
    return n.disposeIntermediateTensorInfo(p), f;
  }
},
    ZN = {
  kernelName: "SplitV",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      numOrSizeSplits: a,
      axis: i
    } = s,
        o = y(i, r.shape)[0],
        l = Zo(r, a, o),
        u = new Array(r.shape.length).fill(0),
        c = r.shape.slice();
    return l.map(e => {
      var t = [...c];
      t[o] = e;
      var s = fI({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          begin: u,
          size: t
        }
      });
      return u[o] += e, s;
    });
  }
},
    QN = "return sqrt(x);",
    eC = {
  kernelName: "Sqrt",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: QN,
    packedOpSnippet: QN,
    cpuKernelImpl: $w
  })
},
    tC = {
  kernelName: "Square",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "return x * x;"
  })
},
    nC = {
  kernelName: "SquaredDifference",
  backendName: "webgl",
  kernelFunc: uv({
    opSnippet: "return (a - b) * (a - b);",
    packedOpSnippet: "return (a - b) * (a - b);"
  })
},
    sC = {
  kernelName: "Step",
  backendName: "webgl",
  kernelFunc: function kernelFunc(_ref33) {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref33;
    var {
      x: s
    } = e,
        r = new Uw(s.shape, "if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(".concat(t.alpha, ");\n  "));
    return n.runWebGLProgram(r, [s], s.dtype);
  }
};

class rC {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.outputShape = n;
    var s = n.length,
        r = Ck(n.length),
        a = Ck(n.length);
    var i = "";
    if (1 === s) i = "coords * strides + begin";else {
      var _e510 = 0;
      i = n.map((t, s) => (_e510++, 1 === n.length ? "coords * strides[".concat(s, "] + begin[").concat(s, "]") : "coords[".concat(_e510 - 1, "] * strides[").concat(s, "] + begin[").concat(s, "]"))).join(",");
    }
    this.userCode = "\n      ".concat(r, " begin = ").concat(r, "(").concat(e, ");\n      ").concat(r, " strides = ").concat(r, "(").concat(t, ");\n\n      void main() {\n        ").concat(a, " coords = getOutputCoords();\n        setOutput(getX(").concat(i, "));\n      }\n    ");
  }

}

var aC = {
  kernelName: "StridedSlice",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      begin: a,
      end: i,
      strides: o,
      beginMask: l,
      endMask: u,
      ellipsisMask: c,
      newAxisMask: h,
      shrinkAxisMask: d
    } = s,
        {
      nonStrided: p,
      $begin: f,
      $strides: g,
      size: m,
      newShape: b,
      outShape: x
    } = Gn(r.shape, a, i, o, l, u, c, h, d),
        y = mv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: b
      }
    });
    var k;

    if (p) {
      var _e511 = fI({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          begin: f,
          size: m
        }
      });

      k = mv({
        inputs: {
          x: _e511
        },
        backend: n,
        attrs: {
          shape: x
        }
      }), n.disposeIntermediateTensorInfo(_e511);
    } else if (x.some(e => 0 === e)) k = n.makeTensorInfo(x, r.dtype, []);else if (n.shouldExecuteOnCPU([y])) {
      var _e512 = n.texData.get(y.dataId),
          _t416 = pn(y.shape, y.dtype, _e512.values),
          _s236 = Sw(x, _t416, g, f);

      k = n.makeTensorInfo(x, y.dtype, _s236.values);
    } else {
      var _e513 = new rC(f, g, x);

      k = n.runWebGLProgram(_e513, [y], y.dtype);
    }

    var w = mv({
      inputs: {
        x: k
      },
      backend: n,
      attrs: {
        shape: x
      }
    });
    return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(k), w;
  }
},
    iC = {
  kernelName: "StringNGrams",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      separator: r,
      nGramWidths: a,
      leftPad: i,
      rightPad: o,
      padWidth: l,
      preserveShortSequences: u
    } = s,
        {
      data: c,
      dataSplits: h
    } = t,
        d = n.readSync(c.dataId),
        p = n.readSync(h.dataId),
        [f, g] = Nw(d, p, r, a, i, o, l, u);
    return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(h.shape, "int32", g)];
  }
},
    oC = {
  kernelName: "StringSplit",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      skipEmpty: r
    } = s,
        {
      input: a,
      delimiter: i
    } = t;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (1 !== a.shape.length) throw new Error("Input must be a vector, got shape: ".concat(a.shape));
    if (0 !== i.shape.length) throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));
    var o = n.readSync(a.dataId),
        l = n.readSync(i.dataId)[0],
        [u, c, h] = Cw(o, l, r),
        d = c.length;
    return [n.makeTensorInfo([d, 2], "int32", u), n.makeTensorInfo([d], "string", c), n.makeTensorInfo([2], "int32", new Int32Array(h))];
  }
},
    lC = {
  kernelName: "StringToHashBucketFast",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      numBuckets: r
    } = s,
        {
      input: a
    } = t;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (r <= 0) throw new Error("Number of buckets must be at least 1");
    var i = n.readSync(a.dataId),
        o = Tw(i, r);
    return n.makeTensorInfo(a.shape, "int32", o);
  }
},
    uC = {
  kernelName: "Tan",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "return tan(x);"
  })
},
    cC = {
  kernelName: "Tanh",
  backendName: "webgl",
  kernelFunc: lv({
    opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"
  })
};

class hC {
  constructor(e, t) {
    this.variableNames = ["A"];
    var n = new Array(e.length);

    for (var _s237 = 0; _s237 < n.length; _s237++) {
      n[_s237] = e[_s237] * t[_s237];
    }

    this.outputShape = n, this.rank = n.length;

    var s = Ck(this.rank),
        r = function (e) {
      var t = e.length;
      if (t > 5) throw Error("Tile for rank ".concat(t, " is not yet supported"));
      if (1 === t) return "imod(resRC, ".concat(e[0], ")");
      var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"],
          s = [];

      for (var _t417 = 0; _t417 < e.length; _t417++) {
        s.push("imod(".concat(n[_t417], ", ").concat(e[_t417], ")"));
      }

      return s.join();
    }(e);

    this.userCode = "\n      void main() {\n        ".concat(s, " resRC = getOutputCoords();\n        setOutput(getA(").concat(r, "));\n      }\n    ");
  }

}

function dC(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    reps: a
  } = s;

  if ("string" === r.dtype || r.shape.length > 5) {
    var _e514 = n.readSync(r.dataId),
        _t418 = "string" === r.dtype ? _e514.map(e => qe(e)) : _e514,
        _s238 = pn(r.shape, r.dtype, _t418),
        _i103 = Rw(_s238, a);

    return n.makeTensorInfo(_i103.shape, _i103.dtype, _i103.values);
  }

  var i = new hC(r.shape, a);
  return n.runWebGLProgram(i, [r], r.dtype);
}

var pC = {
  kernelName: "Tile",
  backendName: "webgl",
  kernelFunc: dC
};

class fC {
  constructor(e) {
    this.variableNames = ["x", "indices"], this.customUniforms = [{
      name: "n",
      type: "int"
    }, {
      name: "firstPass",
      type: "int"
    }, {
      name: "negativeInf",
      type: "float"
    }, {
      name: "dir",
      type: "int"
    }, {
      name: "inc",
      type: "int"
    }], this.outputShape = e, this.userCode = "\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     ";
  }

}

class gC {
  constructor(e) {
    this.variableNames = ["x", "indices"], this.customUniforms = [{
      name: "n",
      type: "int"
    }, {
      name: "firstPass",
      type: "int"
    }, {
      name: "k",
      type: "int"
    }], this.outputShape = e, this.userCode = "\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     ";
  }

}

function mC(e, t) {
  null !== t && e.disposeIntermediateTensorInfo(t);
}

function bC(e) {
  var t = 1;

  for (; t < e;) {
    t *= 2;
  }

  return t;
}

var xC = {
  kernelName: "TopK",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      k: a,
      sorted: i
    } = s,
        o = G().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),
        l = G().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),
        u = r.shape,
        c = u[u.length - 1];

    if (n.shouldExecuteOnCPU([r]) || c < o || a > l) {
      var _e515 = n.readSync(r.dataId),
          [_t419, _s239] = Aw(_e515, u, r.dtype, a, i);

      return [n.makeTensorInfo(_t419.shape, _t419.dtype, _t419.values), n.makeTensorInfo(_s239.shape, _s239.dtype, _s239.values)];
    }

    if (0 === a) return u[u.length - 1] = 0, [n.makeTensorInfo(u, r.dtype, []), n.makeTensorInfo(u, "int32", [])];
    if (1 === c) return [r, z$({
      attrs: {
        shape: u,
        dtype: "int32",
        value: 0
      },
      backend: n
    })];
    var h = n.texData.get(r.dataId),
        p = null !== h && h.isPacked,
        f = p ? n.unpackTensor(r) : r,
        g = d(u) / c,
        m = mv({
      inputs: {
        x: f
      },
      attrs: {
        shape: [g, c]
      },
      backend: n
    });
    p && mC(n, f);
    var b = bC(a),
        x = bC(c);
    var y = null;

    var k = () => null === y ? [m, m] : [m, y],
        w = (e, t, s) => {
      var r = k(),
          a = new fC(s),
          i = y;
      y = n.runWebGLProgram(a, r, "int32", [[c], [null === y ? 1 : 0], [Number.NEGATIVE_INFINITY], [e], [t]]), mC(n, i);
    };

    for (var _e516 = 1; _e516 < b; _e516 *= 2) {
      var _t420 = 2 * _e516;

      for (var _n291 = _e516; _n291 >= 1; _n291 /= 2) {
        w(_t420, _n291, [g, x]);
      }
    }

    for (var _e517 = x; _e517 > b; _e517 /= 2) {
      var _t421 = k(),
          _s240 = new gC([g, _e517 / 2]),
          _r173 = y;

      y = n.runWebGLProgram(_s240, _t421, "int32", [[c], [null === y ? 1 : 0], [b]]), mC(n, _r173);

      var _a143 = b / 2,
          _i104 = 2 * _a143;

      for (var _e518 = _a143; _e518 >= 1; _e518 /= 2) {
        w(_i104, _e518, y.shape);
      }
    }

    var v = y;
    y = fI({
      inputs: {
        x: y
      },
      backend: n,
      attrs: {
        begin: 0,
        size: [g, a]
      }
    }), mC(n, v);
    var I = eS({
      inputs: {
        x: m,
        indices: y
      },
      backend: n,
      attrs: {
        axis: 1,
        batchDims: 1
      }
    });
    mC(n, m);
    var $ = u.slice(0, -1);
    $.push(a), v = y, y = mv({
      inputs: {
        x: y
      },
      attrs: {
        shape: $
      },
      backend: n
    }), mC(n, v);
    var S = I;
    return I = mv({
      inputs: {
        x: I
      },
      attrs: {
        shape: $
      },
      backend: n
    }), mC(n, S), [I, y];
  }
};

class yC {
  constructor(e, t, n, s, r, a) {
    this.variableNames = ["Image", "Transforms"], this.outputShape = a;
    var i = "nearest" === n ? 1 : 2;
    var o;

    switch (s) {
      case "constant":
        o = 1;
        break;

      case "reflect":
        o = 2;
        break;

      case "wrap":
        o = 3;
        break;

      case "nearest":
        o = 4;
        break;

      default:
        o = 1;
    }

    this.userCode = "\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(o, " == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o, " == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o, " == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e, " && 0 <= coordX && coordX < ").concat(t, ") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r, ");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r, ");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t, "));\n                float mapY = mapCoord(inY, float(").concat(e, "));\n\n                if (").concat(i, " == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ");
  }

}

var kC = {
  kernelName: "Transform",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      image: r,
      transforms: a
    } = t,
        {
      interpolation: i,
      fillMode: o,
      fillValue: l,
      outputShape: u
    } = s,
        [c, h, d, p] = r.shape,
        [f, g] = null != u ? u : [h, d],
        m = new yC(h, d, i, o, l, [c, f, g, p]);
    return n.runWebGLProgram(m, [r, a], "float32");
  }
},
    wC = {
  kernelName: "Unique",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      attrs: n,
      backend: s
    } = e,
        {
      axis: r
    } = n,
        {
      x: a
    } = t;
    ck(a, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
    var i = s.readSync(a.dataId),
        {
      outputValues: o,
      outputShape: l,
      indices: u
    } = Dw(i, r, a.shape, a.dtype);
    return [s.makeTensorInfo(l, a.dtype, o), s.makeTensorInfo([u.length], "int32", u)];
  }
},
    vC = {
  kernelName: "Unpack",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      value: r
    } = t;
    var {
      axis: a
    } = s;
    a < 0 && (a += r.shape.length);
    var i = r,
        o = i.shape.length,
        l = r.shape[a],
        u = new Array(o - 1);
    var c = 0;

    for (var _e519 = 0; _e519 < o; _e519++) {
      _e519 !== a && (u[c++] = i.shape[_e519]);
    }

    var h = [],
        d = new Array(o).fill(0),
        p = i.shape.slice();
    p[a] = 1;
    var f = new Array(l);

    for (var _e520 = 0; _e520 < f.length; _e520++) {
      d[a] = _e520;

      var _t422 = fI({
        inputs: {
          x: i
        },
        backend: n,
        attrs: {
          begin: d,
          size: p
        }
      }),
          _s241 = mv({
        inputs: {
          x: _t422
        },
        backend: n,
        attrs: {
          shape: u
        }
      });

      f[_e520] = _s241, h.push(_t422);
    }

    return h.forEach(e => n.disposeIntermediateTensorInfo(e)), f;
  }
};

class IC {
  constructor(e, t) {
    this.variableNames = ["x", "segmentIds"];
    var n = e.windowSize,
        s = e.batchSize,
        r = e.inSize,
        a = e.numSegments,
        i = a * Math.ceil(r / n);
    this.outputShape = [s, i];
    var o = 4 * Math.floor(n / 4),
        l = n % 4,
        u = "\n        sumValue += dot(values, segFilter);\n    ";
    var c = "";
    r % n > 0 && (c = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return initializationValue;\n        }\n      "));
    var h = "";
    r % n > 0 && (h = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return -1.0;\n        }\n      ")), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ".concat(c, "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h, "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(a, ")) * float(").concat(n, "));\n        int currentSeg = int(mod(float(outIdx), float(").concat(a, ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o, "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(u, "\n        }\n\n        int inIdx = inOffset + ").concat(o, ";\n        if (").concat(1 === l, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(u, "\n        } else if (").concat(2 === l, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(u, "\n        } else if (").concat(3 === l, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(u, "\n        }\n        setOutput(sumValue);\n      }\n    ");
  }

}

var $C = [xS, kS, Ev, Av, Fv, Dv, Ov, zv, Bv, Pv, qv, jv, Kv, Xv, Jv, Yv, Zv, nI, tI, aI, iI, oI, cI, mI, bI, vI, $I, CI, RI, tv, zI, XI, YI, GI, ZI, QI, JI, e$, t$, s$, o$, l$, c$, m$, b$, p$, y$, w$, v$, I$, $$, S$, N$, E$, A$, D$, M$, B$, W$, V$, G$, j$, X$, Y$, Z$, tS, nS, sS, Qw, rS, OI, aS, iS, oS, rv, lS, uS, cS, dS, hS, pS, fS, gS, vS, SS, $S, TS, ES, RS, IS, AS, FS, DS, MS, LS, qS, gv, KS, YS, ZS, eN, yI, nN, aN, iN, cN, hN, ov, dN, fN, wI, PS, gN, bN, mN, bv, kN, vN, SN, CN, RN, FN, DN, _N, MN, zN, BN, WN, UN, VN, GN, gI, HS, HN, qN, jN, KN, XN, YN, JN, ZN, eC, tC, nC, sC, aC, iC, oC, lC, VS, Sv, uC, cC, pC, xC, kC, Cv, wC, vC, {
  kernelName: "UnsortedSegmentSum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      segmentIds: a
    } = t,
        {
      numSegments: i
    } = s,
        o = r.shape.length,
        l = [];
    var u = 0;
    var c = Zr([u], o);
    var h = r;
    null != c && (h = Nv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), l.push(h), u = ea(1, o)[0]);
    var p = el(h.shape, u, i),
        f = d([h.shape[u]]),
        g = mv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, f]
      }
    });
    l.push(g);

    var m = ft(r.dtype),
        b = (e, t, s, r, a) => {
      var i = e.shape[0],
          o = e.shape[1],
          u = Qo(o, a),
          c = new IC({
        windowSize: u,
        inSize: o,
        batchSize: i,
        numSegments: a
      }, t),
          h = n.compileAndRun(c, [e, s], r);
      if (l.push(h), h.shape[1] === a) return h;
      var d = pN({
        backend: n,
        attrs: {
          start: 0,
          stop: a,
          step: 1,
          dtype: "float32"
        }
      }),
          p = dC({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          reps: [o / u]
        }
      });
      return l.push(d), l.push(p), b(h, t, p, r, a);
    },
        x = mv({
      inputs: {
        x: b(g, "unsortedSegmentSum", a, m, i)
      },
      backend: n,
      attrs: {
        shape: p
      }
    });

    var y = x;

    if (null != c) {
      l.push(x);

      var _e521 = Qr(c);

      y = Nv({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          perm: _e521
        }
      });
    }

    return l.forEach(e => n.disposeIntermediateTensorInfo(e)), y;
  }
}, rN];

for (var _e522 of $C) {
  ee(_e522);
}

var SC = ["worker"],
    NC = {
  train: function () {
    var _train = _asyncToGenerator(function* (e) {
      var {
        data: t
      } = e;
      var n = [];

      var s = function (e, t, n) {
        if (c(e), null != t && 3 !== t.length) throw new Error("tensor3d() requires shape to have three numbers");
        var s = Ct(e, n);
        if (3 !== s.length && 1 !== s.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
        if (1 === s.length && null == t) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
        return _t(e, t, s, n);
      }(t.xData, [t.xData.length, t.model.inputShape[0], t.model.inputShape[1]]),
          r = $n(bi(t.yData, "int32"), t.model.labels.length),
          {
        epochs: a,
        model: i
      } = function (e, t) {
        var n = new Rd(void 0);
        return "" == t && (n.add(Mf({
          inputShape: e.inputShape,
          kernelSize: [4],
          strides: 1,
          filters: 16,
          activation: "relu"
        })), n.add(zf({
          poolSize: [2]
        })), n.add(Lf({
          rate: .1
        })), n.add(Mf({
          kernelSize: [2],
          strides: 1,
          filters: 16,
          activation: "relu"
        })), n.add(zf({
          poolSize: [2]
        })), n.add(Lf({
          rate: .1
        })), n.add(Mf({
          kernelSize: [2],
          strides: 1,
          filters: 16,
          activation: "relu"
        })), n.add(Lf({
          rate: .1
        })), n.add(new qp(void 0)), n.add(new Hp({
          units: e.outputShape,
          activation: "softmax"
        })), n.compile({
          loss: "categoricalCrossentropy",
          optimizer: "adam",
          metrics: ["accuracy"]
        })), {
          model: n,
          epochs: 250
        };
      }(t.model, t.modelBlockJSON);

      var o;
      yield i.fit(s, r, {
        epochs: a,
        callbacks: {
          onEpochEnd: CC
        }
      }).then(e => {
        n = e.history.acc;
      }), yield i.save({
        save: e => {
          o = e;
          var t = {
            modelArtifactsInfo: {
              dateSaved: new Date(),
              modelTopologyType: "JSON"
            }
          };
          return Promise.resolve(t);
        }
      });
      var l = o.weightData;
      return o.weightData = null, {
        modelJSON: JSON.stringify(o),
        modelWeights: l,
        trainingInfo: n
      };
    });

    function train(_x56) {
      return _train.apply(this, arguments);
    }

    return train;
  }(),
  predict: function () {
    var _predict = _asyncToGenerator(function* (e) {
      var {
        data: t
      } = e,
          n = Ot(t.zData),
          s = JSON.parse(t.model.modelJSON);
      s.weightData = new Uint32Array(t.model.weights).buffer;
      var r = yield (a = {
        load: () => Promise.resolve(s)
      }, null == i && (i = {}), function () {
        var _ref34 = _asyncToGenerator(function* (e, t) {
          if (null == t && (t = {}), "string" == typeof e) {
            var _n292 = Ht.getLoadHandlers(e, t);

            if (0 === _n292.length) _n292.push(vn(e, t));else if (_n292.length > 1) throw new xu("Found more than one (".concat(_n292.length, ") load handlers for URL '").concat(e, "'"));
            e = _n292[0];
          }

          return function () {
            var _ref35 = _asyncToGenerator(function* (e, t, n) {
              if (null == n && (n = {}), null == e.load) throw new xu("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
              var s = yield e.load();
              var r = s.modelTopology;
              null != r.model_config && (r = r.model_config);
              var a = null == n.strict || n.strict,
                  i = null != s.weightData && null != s.weightSpecs && a,
                  o = Rh(nd(r), void 0, i),
                  l = s.trainingConfig;

              if (null != l && o.loadTrainingConfig(l), null != s.userDefinedMetadata && o.setUserDefinedMetadata(s.userDefinedMetadata), null != s.weightData) {
                if (null == s.weightSpecs) throw new xu("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");

                var {
                  modelWeights: _e523,
                  optimizerWeights: _t423
                } = function (e, t) {
                  var n = function (e, t) {
                    var n = {};
                    var s,
                        r = 0;

                    for (var _a144 of t) {
                      var _t424 = _a144.name,
                          _i105 = _a144.dtype,
                          _o75 = _a144.shape,
                          _l54 = d(_o75);

                      var _u42 = void 0;

                      if ("quantization" in _a144) {
                        var _n293 = _a144.quantization;

                        if ("uint8" === _n293.dtype || "uint16" === _n293.dtype) {
                          if (!("min" in _n293) || !("scale" in _n293)) throw new Error("Weight ".concat(_a144.name, " with quantization ").concat(_n293.dtype, " doesn't have corresponding metadata min and scale."));
                        } else {
                          if ("float16" !== _n293.dtype) throw new Error("Weight ".concat(_a144.name, " has unknown quantization dtype ").concat(_n293.dtype, ". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'."));
                          if ("float32" !== _i105) throw new Error("Weight ".concat(_a144.name, " is quantized with ").concat(_n293.dtype, " which only supports weights of type float32 not ").concat(_i105, "."));
                        }

                        var _o76 = Mt[_n293.dtype],
                            _c36 = e.slice(r, r + _l54 * _o76),
                            _h21 = "uint8" === _n293.dtype ? new Uint8Array(_c36) : new Uint16Array(_c36);

                        if ("float32" === _i105) {
                          if ("uint8" === _n293.dtype || "uint16" === _n293.dtype) {
                            _u42 = new Float32Array(_h21.length);

                            for (var _e524 = 0; _e524 < _h21.length; _e524++) {
                              _u42[_e524] = _h21[_e524] * _n293.scale + _n293.min;
                            }
                          } else {
                            if ("float16" !== _n293.dtype) throw new Error("Unsupported quantization type ".concat(_n293.dtype, " for weight type float32."));
                            void 0 === s && (s = Gt()), _u42 = s(_h21);
                          }
                        } else {
                          if ("int32" !== _i105) throw new Error("Unsupported dtype in weight '".concat(_t424, "': ").concat(_i105));
                          if ("uint8" !== _n293.dtype && "uint16" !== _n293.dtype) throw new Error("Unsupported quantization type ".concat(_n293.dtype, " for weight type int32."));
                          _u42 = new Int32Array(_h21.length);

                          for (var _e525 = 0; _e525 < _h21.length; _e525++) {
                            _u42[_e525] = Math.round(_h21[_e525] * _n293.scale + _n293.min);
                          }
                        }
                        r += _l54 * _o76;
                      } else if ("string" === _i105) {
                        var _t425 = d(_a144.shape);

                        _u42 = [];

                        for (var _n294 = 0; _n294 < _t425; _n294++) {
                          var _t426 = new Uint32Array(e.slice(r, r + 4))[0];
                          r += 4;

                          var _n295 = new Uint8Array(e.slice(r, r + _t426));

                          _u42.push(_n295), r += _t426;
                        }
                      } else {
                        var _s242 = Mt[_i105],
                            _a145 = e.slice(r, r + _l54 * _s242);

                        if ("float32" === _i105) _u42 = new Float32Array(_a145);else if ("int32" === _i105) _u42 = new Int32Array(_a145);else if ("bool" === _i105) _u42 = new Uint8Array(_a145);else {
                          if ("complex64" !== _i105) throw new Error("Unsupported dtype in weight '".concat(_t424, "': ").concat(_i105));
                          {
                            _u42 = new Float32Array(_a145);

                            var _e526 = new Float32Array(_u42.length / 2),
                                _s243 = new Float32Array(_u42.length / 2);

                            for (var _t427 = 0; _t427 < _e526.length; _t427++) {
                              _e526[_t427] = _u42[2 * _t427], _s243[_t427] = _u42[2 * _t427 + 1];
                            }

                            var _r174 = Ot(_e526, _o75, "float32"),
                                _i106 = Ot(_s243, _o75, "float32");

                            n[_t424] = Dt(_r174, _i106), _r174.dispose(), _i106.dispose();
                          }
                        }
                        r += _l54 * _s242;
                      }

                      "complex64" !== _i105 && (n[_t424] = Ot(_u42, _o75, _i105));
                    }

                    return n;
                  }(e, t),
                      s = {},
                      r = [];

                  return t.forEach(e => {
                    "optimizer" === e.group ? r.push({
                      name: e.name,
                      tensor: n[e.name]
                    }) : s[e.name] = n[e.name];
                  }), {
                    modelWeights: s,
                    optimizerWeights: r
                  };
                }(s.weightData, s.weightSpecs);

                o.loadWeights(_e523, a), null != o.optimizer && _t423.length > 0 && (yield o.optimizer.setWeights(_t423)), Zn(_e523), Zn(_t423.map(e => e.tensor));
              }

              return o;
            });

            return function (_x60, _x61, _x62) {
              return _ref35.apply(this, arguments);
            };
          }()(e, 0, t);
        });

        return function (_x58, _x59) {
          return _ref34.apply(this, arguments);
        };
      }()(a, i));
      var a, i;
      var o = yield r.predict(n);
      return {
        prediction: yield o.dataSync()
      };
    });

    function predict(_x57) {
      return _predict.apply(this, arguments);
    }

    return predict;
  }()
};

function CC(e, t) {
  self.postMessage({
    type: "progress",
    data: t
  });
}

self.addEventListener("message", /*#__PURE__*/function () {
  var _ref36 = _asyncToGenerator(function* (t) {
    var n = t.data,
        {
      worker: s
    } = n,
        r = function (e, t) {
      if (null == e) return {};
      var n,
          s,
          r = {},
          a = Object.keys(e);

      for (s = 0; s < a.length; s++) {
        t.indexOf(n = a[s]) >= 0 || (r[n] = e[n]);
      }

      return r;
    }(n, SC);

    if ("tf" !== s) return;
    var a = e({
      worker: s
    }, r, {
      data: yield function () {
        var _ref37 = _asyncToGenerator(function* (e) {
          try {
            var _t428 = NC[e.type];
            return yield null == _t428 ? void 0 : _t428(e);
          } catch (e) {
            return void console.error(e);
          }
        });

        return function (_x64) {
          return _ref37.apply(this, arguments);
        };
      }()(n)
    });
    self.postMessage(a);
  });

  return function (_x63) {
    return _ref36.apply(this, arguments);
  };
}()), console.debug("jacdac tf: worker registered");

/***/ })

}]);
//# sourceMappingURL=8e0cf18a-a659f84bba9bf6f8e267.js.map