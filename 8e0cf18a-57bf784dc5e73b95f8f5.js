(self["webpackChunkjacdac_docs"] = self["webpackChunkjacdac_docs"] || []).push([[1954],{

/***/ 93192:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var _asyncToGenerator = __webpack_require__(50358);

__webpack_require__(25438);

function e() {
  return (e = Object.assign || function (e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];

      for (var s in n) {
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
      }
    }

    return e;
  }).apply(this, arguments);
}

class t {
  constructor(e, t) {
    this.backend = e, this.dataMover = t, this.data = new WeakMap(), this.dataIdsCount = 0;
  }

  get(e) {
    return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e);
  }

  set(e, t) {
    this.dataIdsCount++, this.data.set(e, t);
  }

  has(e) {
    return this.data.has(e);
  }

  delete(e) {
    return this.dataIdsCount--, this.data.delete(e);
  }

  numDataIds() {
    return this.dataIdsCount;
  }

}

class n {
  refCount(e) {
    return s("refCount");
  }

  incRef(e) {
    return s("incRef");
  }

  timerAvailable() {
    return !0;
  }

  time(e) {
    return s("time");
  }

  read(e) {
    return s("read");
  }

  readSync(e) {
    return s("readSync");
  }

  numDataIds() {
    return s("numDataIds");
  }

  disposeData(e, t) {
    return s("disposeData");
  }

  write(e, t, n) {
    return s("write");
  }

  move(e, t, n, r, a) {
    return s("move");
  }

  memory() {
    return s("memory");
  }

  floatPrecision() {
    return s("floatPrecision");
  }

  epsilon() {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }

  dispose() {
    return s("dispose");
  }

}

function s(e) {
  throw new Error("'".concat(e, "' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen"));
}

function r(e) {
  var t = e.length,
      n = 0;

  for (; t > 0;) {
    n = Math.random() * t | 0, t--, o(e, t, n);
  }
}

function a(e, t, n) {
  return Math.max(e, Math.min(t, n));
}

function i(e) {
  return e % 2 == 0 ? e : e + 1;
}

function o(e, t, n) {
  var s = e[t];
  e[t] = e[n], e[n] = s;
}

function l(e, t) {
  if (!e) throw new Error("string" == typeof t ? t : t());
}

function u(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  l(p(e, t), () => n + " Shapes ".concat(e, " and ").concat(t, " must match"));
}

function c(e) {
  l(null != e, () => "The input to the tensor constructor must be a non-null value.");
}

function h(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  if (null == t && (t = []), Array.isArray(e) || $(e) && !n) for (var _s2 = 0; _s2 < e.length; ++_s2) {
    h(e[_s2], t, n);
  } else t.push(e);
  return t;
}

function d(e) {
  if (0 === e.length) return 1;
  var t = e[0];

  for (var _n2 = 1; _n2 < e.length; _n2++) {
    t *= e[_n2];
  }

  return t;
}

function p(e, t) {
  if (e === t) return !0;
  if (null == e || null == t) return !1;
  if (e.length !== t.length) return !1;

  for (var _n3 = 0; _n3 < e.length; _n3++) {
    if (e[_n3] !== t[_n3]) return !1;
  }

  return !0;
}

function f(e) {
  return e % 1 == 0;
}

function g(e) {
  var t = Math.ceil(Math.sqrt(e));
  return [t, Math.ceil(e / t)];
}

function m(e, t) {
  return t <= e.length ? e : e + " ".repeat(t - e.length);
}

function b(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e => 0;
  var n = arguments.length > 2 ? arguments[2] : undefined;
  return new Promise((s, r) => {
    var a = 0;

    var i = () => {
      if (e()) return void s();
      a++;
      var o = t(a);
      null != n && a >= n ? r() : setTimeout(i, o);
    };

    i();
  });
}

function x(e, t) {
  var n = 1,
      s = -1;

  for (var _t2 = 0; _t2 < e.length; ++_t2) {
    if (e[_t2] >= 0) n *= e[_t2];else if (-1 === e[_t2]) {
      if (-1 !== s) throw Error("Shapes can only have 1 implicit size. Found -1 at dim ".concat(s, " and dim ").concat(_t2));
      s = _t2;
    } else if (e[_t2] < 0) throw Error("Shapes can not be < 0. Found ".concat(e[_t2], " at dim ").concat(_t2));
  }

  if (-1 === s) {
    if (t > 0 && t !== n) throw Error("Size(".concat(t, ") must match the product of shape ").concat(e));
    return e;
  }

  if (0 === n) throw Error("Cannot infer the missing size in [".concat(e, "] when there are 0 elements"));
  if (t % n != 0) throw Error("The implicit shape can't be a fractional number. Got ".concat(t, " / ").concat(n));
  var r = e.slice();
  return r[s] = t / n, r;
}

function y(e, t) {
  var n = t.length;
  return l((e = null == e ? t.map((e, t) => t) : [].concat(e)).every(e => e >= -n && e < n), () => "All values in axis param must be in range [-".concat(n, ", ").concat(n, ") but got axis ").concat(e)), l(e.every(e => f(e)), () => "All values in axis param must be integers but got axis ".concat(e)), e.map(e => e < 0 ? n + e : e);
}

function k(e, t) {
  var n = [],
      s = [],
      r = null != t && Array.isArray(t) && 0 === t.length,
      a = null == t || r ? null : y(t, e).sort();
  var i = 0;

  for (var _t3 = 0; _t3 < e.length; ++_t3) {
    if (null != a) {
      if (a[i] === _t3 && 1 !== e[_t3]) throw new Error("Can't squeeze axis ".concat(_t3, " since its dim '").concat(e[_t3], "' is not 1"));
      (null == a[i] || a[i] > _t3) && 1 === e[_t3] && (n.push(e[_t3]), s.push(_t3)), a[i] <= _t3 && i++;
    }

    1 !== e[_t3] && (n.push(e[_t3]), s.push(_t3));
  }

  return {
    newShape: n,
    keptDims: s
  };
}

function w(e, t) {
  var n = null;
  if (null == e || "float32" === e) n = new Float32Array(t);else if ("int32" === e) n = new Int32Array(t);else {
    if ("bool" !== e) throw new Error("Unknown data type ".concat(e));
    n = new Uint8Array(t);
  }
  return n;
}

function v(e, t) {
  var n = null;
  if (null == e || "float32" === e) n = new Float32Array(t);else if ("int32" === e) n = new Int32Array(t);else if ("bool" === e) n = new Uint8Array(t);else {
    if ("string" !== e) throw new Error("Unknown data type ".concat(e));
    n = new Array(t);
  }
  return n;
}

function I(e, t) {
  return !("complex64" === t || "float32" === t && "complex64" !== e || "int32" === t && "float32" !== e && "complex64" !== e || "bool" === t && "bool" === e);
}

function $(e) {
  return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array;
}

function N(e) {
  if ("float32" === e || "int32" === e) return 4;
  if ("complex64" === e) return 8;
  if ("bool" === e) return 1;
  throw new Error("Unknown dtype ".concat(e));
}

function C(e) {
  return "string" == typeof e || e instanceof String;
}

function S(e) {
  return "number" == typeof e;
}

function T(e) {
  return Array.isArray(e) ? T(e[0]) : e instanceof Float32Array ? "float32" : e instanceof Int32Array || e instanceof Uint8Array ? "int32" : S(e) ? "float32" : C(e) ? "string" : "boolean" == typeof e ? "bool" : "float32";
}

function E(e) {
  return !!(e && e.constructor && e.call && e.apply);
}

function R(e, t) {
  for (var _n4 = t; _n4 < e; ++_n4) {
    if (e % _n4 == 0) return _n4;
  }

  return e;
}

function A(e) {
  var t = e.length;
  if (t < 2) return [];
  var n = new Array(t - 1);
  n[t - 2] = e[t - 1];

  for (var _s3 = t - 3; _s3 >= 0; --_s3) {
    n[_s3] = n[_s3 + 1] * e[_s3 + 1];
  }

  return n;
}

function F(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  var r = new Array();

  if (1 === t.length) {
    var _a2 = t[0] * (s ? 2 : 1);

    for (var _t4 = 0; _t4 < _a2; _t4++) {
      r[_t4] = n[e + _t4];
    }
  } else {
    var _a3 = t[0],
        _i2 = t.slice(1),
        _o2 = _i2.reduce((e, t) => e * t) * (s ? 2 : 1);

    for (var _t5 = 0; _t5 < _a3; _t5++) {
      r[_t5] = F(e + _t5 * _o2, _i2, n, s);
    }
  }

  return r;
}

function D(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  if (0 === e.length) return t[0];
  var s = e.reduce((e, t) => e * t) * (n ? 2 : 1);
  if (0 === s) return [];
  if (s !== t.length) throw new Error("[".concat(e, "] does not match the input size ").concat(t.length).concat(n ? " for a complex tensor" : "", "."));
  return F(0, e, t, n);
}

function _(e, t) {
  var n = O(e, t);

  for (var _e2 = 0; _e2 < n.length; _e2++) {
    n[_e2] = 1;
  }

  return n;
}

function O(e, t) {
  if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
  if ("int32" === t) return new Int32Array(e);
  if ("bool" === t) return new Uint8Array(e);
  throw new Error("Unknown data type ".concat(t));
}

function M(e, t) {
  var n = e.reduce((e, t) => e * t, 1);
  if (null == t || "float32" === t) return D(e, new Float32Array(n));
  if ("int32" === t) return D(e, new Int32Array(n));
  if ("bool" === t) return D(e, new Uint8Array(n));
  throw new Error("Unknown data type ".concat(t));
}

function L(e) {
  e.forEach(t => {
    l(Number.isInteger(t) && t >= 0, () => "Tensor must have a shape comprised of positive integers but got shape [".concat(e, "]."));
  });
}

function z(e, t, n) {
  if (0 === t) return 0;
  if (1 === t) return e[0];
  var s = e[e.length - 1];

  for (var _t6 = 0; _t6 < e.length - 1; ++_t6) {
    s += n[_t6] * e[_t6];
  }

  return s;
}

function B(e, t, n) {
  if (0 === t) return [];
  if (1 === t) return [e];
  var s = new Array(t);

  for (var _t7 = 0; _t7 < s.length - 1; ++_t7) {
    s[_t7] = Math.floor(e / n[_t7]), e -= s[_t7] * n[_t7];
  }

  return s[s.length - 1] = e, s;
}

function P(e) {
  return e && e.then && "function" == typeof e.then;
}

class W {
  constructor(e) {
    this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = U, this.populateURLFlags();
  }

  setPlatform(e, t) {
    null != this.platform && console.warn("Platform ".concat(this.platformName, " has already been set. Overwriting the platform with ").concat(t, ".")), this.platformName = e, this.platform = t;
  }

  registerFlag(e, t, n) {
    if (this.flagRegistry[e] = {
      evaluationFn: t,
      setHook: n
    }, null != this.urlFlags[e]) {
      var _t8 = this.urlFlags[e];
      console.warn("Setting feature override from URL ".concat(e, ": ").concat(_t8, ".")), this.set(e, _t8);
    }
  }

  getAsync(e) {
    var _this = this;

    return _asyncToGenerator(function* () {
      return e in _this.flags || (_this.flags[e] = yield _this.evaluateFlag(e)), _this.flags[e];
    })();
  }

  get(e) {
    if (e in this.flags) return this.flags[e];
    var t = this.evaluateFlag(e);
    if (P(t)) throw new Error("Flag ".concat(e, " cannot be synchronously evaluated. Please use getAsync() instead."));
    return this.flags[e] = t, this.flags[e];
  }

  getNumber(e) {
    return this.get(e);
  }

  getBool(e) {
    return this.get(e);
  }

  getFlags() {
    return this.flags;
  }

  get features() {
    return this.flags;
  }

  set(e, t) {
    if (null == this.flagRegistry[e]) throw new Error("Cannot set flag ".concat(e, " as it has not been registered."));
    this.flags[e] = t, null != this.flagRegistry[e].setHook && this.flagRegistry[e].setHook(t);
  }

  evaluateFlag(e) {
    if (null == this.flagRegistry[e]) throw new Error("Cannot evaluate flag '".concat(e, "': no evaluation function found."));
    return this.flagRegistry[e].evaluationFn();
  }

  setFlags(e) {
    this.flags = Object.assign({}, e);
  }

  reset() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }

  populateURLFlags() {
    if (void 0 === this.global || void 0 === this.global.location || void 0 === this.global.location.search) return;
    var e = this.getQueryParams(this.global.location.search);
    "tfjsflags" in e && e.tfjsflags.split(",").forEach(e => {
      var [t, n] = e.split(":");

      this.urlFlags[t] = function (e, t) {
        if ("true" === (t = t.toLowerCase()) || "false" === t) return "true" === t;
        if ("" + +t === t) return +t;
        throw new Error("Could not parse value flag value ".concat(t, " for flag ").concat(e, "."));
      }(t, n);
    });
  }

}

function U(e) {
  var t = {};
  return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (e) {
    for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      n[_key - 1] = arguments[_key];
    }

    return function (e, t, n) {
      e[decodeURIComponent(t)] = decodeURIComponent(n || "");
    }(t, n[0], n[1]), n.join("=");
  }), t;
}

function V() {
  return H;
}

var G,
    H = null;

function j() {
  if (null == G) {
    var _e3;

    if ("undefined" != typeof window) _e3 = window;else if ("undefined" != typeof __webpack_require__.g) _e3 = __webpack_require__.g;else if ("undefined" != typeof process) _e3 = process;else {
      if ("undefined" == typeof self) throw new Error("Could not find a global object");
      _e3 = self;
    }
    G = _e3;
  }

  return G;
}

function q(e, t) {
  var n = function () {
    var e = j();
    return null == e._tfGlobals && (e._tfGlobals = new Map()), e._tfGlobals;
  }();

  if (n.has(e)) return n.get(e);
  {
    var _s4 = t();

    return n.set(e, _s4), n.get(e);
  }
}

var K = q("kernelRegistry", () => new Map()),
    X = q("gradRegistry", () => new Map());

function Y(e, t) {
  var n = te(e, t);
  return K.get(n);
}

function J(e) {
  return X.get(e);
}

function Z(e) {
  var t = K.entries(),
      n = [];

  for (;;) {
    var {
      done: _s5,
      value: _r2
    } = t.next();
    if (_s5) break;

    var [_a4, _i3] = _r2,
        [_o3] = _a4.split("_");

    _o3 === e && n.push(_i3);
  }

  return n;
}

function Q(e) {
  var {
    kernelName: t,
    backendName: n
  } = e,
      s = te(t, n);
  K.has(s) && console.warn("The kernel '".concat(t, "' for backend '").concat(n, "' is already registered")), K.set(s, e);
}

function ee(e) {
  var {
    kernelName: t
  } = e;
  X.has(t) && V().getBool("DEBUG") && console.warn("Overriding the gradient for '".concat(t, "'")), X.set(t, e);
}

function te(e, t) {
  return "".concat(t, "_").concat(e);
}

var ne = re,
    se = null;

try {
  se = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch (e) {}

function re(e, t, n) {
  this.low = 0 | e, this.high = 0 | t, this.unsigned = !!n;
}

function ae(e) {
  return !0 === (e && e.__isLong__);
}

Object.defineProperty(re.prototype, "__isLong__", {
  value: !0
}), re.isLong = ae;
var ie = {},
    oe = {};

function le(e, t) {
  var n, s, r;
  return t ? (r = 0 <= (e >>>= 0) && e < 256) && (s = oe[e]) ? s : (n = ce(e, (0 | e) < 0 ? -1 : 0, !0), r && (oe[e] = n), n) : (r = -128 <= (e |= 0) && e < 128) && (s = ie[e]) ? s : (n = ce(e, e < 0 ? -1 : 0, !1), r && (ie[e] = n), n);
}

function ue(e, t) {
  if (isNaN(e)) return t ? ye : xe;

  if (t) {
    if (e < 0) return ye;
    if (e >= ge) return $e;
  } else {
    if (e <= -me) return Ne;
    if (e + 1 >= me) return Ie;
  }

  return e < 0 ? ue(-e, t).neg() : ce(e % fe | 0, e / fe | 0, t);
}

function ce(e, t, n) {
  return new re(e, t, n);
}

re.fromInt = le, re.fromNumber = ue, re.fromBits = ce;
var he = Math.pow;

function de(e, t, n) {
  if (0 === e.length) throw Error("empty string");
  if ("NaN" === e || "Infinity" === e || "+Infinity" === e || "-Infinity" === e) return xe;
  if ("number" == typeof t ? (n = t, t = !1) : t = !!t, (n = n || 10) < 2 || 36 < n) throw RangeError("radix");
  var s;
  if ((s = e.indexOf("-")) > 0) throw Error("interior hyphen");
  if (0 === s) return de(e.substring(1), t, n).neg();

  for (var r = ue(he(n, 8)), a = xe, i = 0; i < e.length; i += 8) {
    var o = Math.min(8, e.length - i),
        l = parseInt(e.substring(i, i + o), n);

    if (o < 8) {
      var u = ue(he(n, o));
      a = a.mul(u).add(ue(l));
    } else a = (a = a.mul(r)).add(ue(l));
  }

  return a.unsigned = t, a;
}

function pe(e, t) {
  return "number" == typeof e ? ue(e, t) : "string" == typeof e ? de(e, t) : ce(e.low, e.high, "boolean" == typeof t ? t : e.unsigned);
}

re.fromString = de, re.fromValue = pe;
var fe = 4294967296,
    ge = fe * fe,
    me = ge / 2,
    be = le(1 << 24),
    xe = le(0);
re.ZERO = xe;
var ye = le(0, !0);
re.UZERO = ye;
var ke = le(1);
re.ONE = ke;
var we = le(1, !0);
re.UONE = we;
var ve = le(-1);
re.NEG_ONE = ve;
var Ie = ce(-1, 2147483647, !1);
re.MAX_VALUE = Ie;
var $e = ce(-1, -1, !0);
re.MAX_UNSIGNED_VALUE = $e;
var Ne = ce(0, -2147483648, !1);
re.MIN_VALUE = Ne;
var Ce = re.prototype;
Ce.toInt = function () {
  return this.unsigned ? this.low >>> 0 : this.low;
}, Ce.toNumber = function () {
  return this.unsigned ? (this.high >>> 0) * fe + (this.low >>> 0) : this.high * fe + (this.low >>> 0);
}, Ce.toString = function (e) {
  if ((e = e || 10) < 2 || 36 < e) throw RangeError("radix");
  if (this.isZero()) return "0";

  if (this.isNegative()) {
    if (this.eq(Ne)) {
      var t = ue(e),
          n = this.div(t),
          s = n.mul(t).sub(this);
      return n.toString(e) + s.toInt().toString(e);
    }

    return "-" + this.neg().toString(e);
  }

  for (var r = ue(he(e, 6), this.unsigned), a = this, i = "";;) {
    var o = a.div(r),
        l = (a.sub(o.mul(r)).toInt() >>> 0).toString(e);
    if ((a = o).isZero()) return l + i;

    for (; l.length < 6;) {
      l = "0" + l;
    }

    i = "" + l + i;
  }
}, Ce.getHighBits = function () {
  return this.high;
}, Ce.getHighBitsUnsigned = function () {
  return this.high >>> 0;
}, Ce.getLowBits = function () {
  return this.low;
}, Ce.getLowBitsUnsigned = function () {
  return this.low >>> 0;
}, Ce.getNumBitsAbs = function () {
  if (this.isNegative()) return this.eq(Ne) ? 64 : this.neg().getNumBitsAbs();

  for (var e = 0 != this.high ? this.high : this.low, t = 31; t > 0 && 0 == (e & 1 << t); t--) {
    ;
  }

  return 0 != this.high ? t + 33 : t + 1;
}, Ce.isZero = function () {
  return 0 === this.high && 0 === this.low;
}, Ce.eqz = Ce.isZero, Ce.isNegative = function () {
  return !this.unsigned && this.high < 0;
}, Ce.isPositive = function () {
  return this.unsigned || this.high >= 0;
}, Ce.isOdd = function () {
  return 1 == (1 & this.low);
}, Ce.isEven = function () {
  return 0 == (1 & this.low);
}, Ce.equals = function (e) {
  return ae(e) || (e = pe(e)), (this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) && this.high === e.high && this.low === e.low;
}, Ce.eq = Ce.equals, Ce.notEquals = function (e) {
  return !this.eq(e);
}, Ce.neq = Ce.notEquals, Ce.ne = Ce.notEquals, Ce.lessThan = function (e) {
  return this.comp(e) < 0;
}, Ce.lt = Ce.lessThan, Ce.lessThanOrEqual = function (e) {
  return this.comp(e) <= 0;
}, Ce.lte = Ce.lessThanOrEqual, Ce.le = Ce.lessThanOrEqual, Ce.greaterThan = function (e) {
  return this.comp(e) > 0;
}, Ce.gt = Ce.greaterThan, Ce.greaterThanOrEqual = function (e) {
  return this.comp(e) >= 0;
}, Ce.gte = Ce.greaterThanOrEqual, Ce.ge = Ce.greaterThanOrEqual, Ce.compare = function (e) {
  if (ae(e) || (e = pe(e)), this.eq(e)) return 0;
  var t = this.isNegative(),
      n = e.isNegative();
  return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
}, Ce.comp = Ce.compare, Ce.negate = function () {
  return !this.unsigned && this.eq(Ne) ? Ne : this.not().add(ke);
}, Ce.neg = Ce.negate, Ce.add = function (e) {
  ae(e) || (e = pe(e));
  var t = 0,
      n = 0,
      s = 0,
      r = 0;
  return s += (r += (65535 & this.low) + (65535 & e.low)) >>> 16, n += (s += (this.low >>> 16) + (e.low >>> 16)) >>> 16, t += (n += (65535 & this.high) + (65535 & e.high)) >>> 16, t += (this.high >>> 16) + (e.high >>> 16), ce((s &= 65535) << 16 | (r &= 65535), (t &= 65535) << 16 | (n &= 65535), this.unsigned);
}, Ce.subtract = function (e) {
  return ae(e) || (e = pe(e)), this.add(e.neg());
}, Ce.sub = Ce.subtract, Ce.multiply = function (e) {
  if (this.isZero()) return xe;
  if (ae(e) || (e = pe(e)), se) return ce(se.mul(this.low, this.high, e.low, e.high), se.get_high(), this.unsigned);
  if (e.isZero()) return xe;
  if (this.eq(Ne)) return e.isOdd() ? Ne : xe;
  if (e.eq(Ne)) return this.isOdd() ? Ne : xe;
  if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative()) return this.mul(e.neg()).neg();
  if (this.lt(be) && e.lt(be)) return ue(this.toNumber() * e.toNumber(), this.unsigned);
  var t = 65535 & this.high,
      n = this.low >>> 16,
      s = 65535 & this.low,
      r = 65535 & e.high,
      a = e.low >>> 16,
      i = 65535 & e.low,
      o = 0,
      l = 0,
      u = 0,
      c = 0;
  return u += (c += s * i) >>> 16, l += (u += n * i) >>> 16, u &= 65535, l += (u += s * a) >>> 16, o += (l += t * i) >>> 16, l &= 65535, o += (l += n * a) >>> 16, l &= 65535, o += (l += s * r) >>> 16, o += (this.high >>> 16) * i + t * a + n * r + s * (e.high >>> 16), ce((u &= 65535) << 16 | (c &= 65535), (o &= 65535) << 16 | (l &= 65535), this.unsigned);
}, Ce.mul = Ce.multiply, Ce.divide = function (e) {
  if (ae(e) || (e = pe(e)), e.isZero()) throw Error("division by zero");
  var t, n, s;
  if (se) return this.unsigned || -2147483648 !== this.high || -1 !== e.low || -1 !== e.high ? ce((this.unsigned ? se.div_u : se.div_s)(this.low, this.high, e.low, e.high), se.get_high(), this.unsigned) : this;
  if (this.isZero()) return this.unsigned ? ye : xe;

  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return ye;
    if (e.gt(this.shru(1))) return we;
    s = ye;
  } else {
    if (this.eq(Ne)) return e.eq(ke) || e.eq(ve) ? Ne : e.eq(Ne) ? ke : (t = this.shr(1).div(e).shl(1)).eq(xe) ? e.isNegative() ? ke : ve : (n = this.sub(e.mul(t)), s = t.add(n.div(e)));
    if (e.eq(Ne)) return this.unsigned ? ye : xe;
    if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative()) return this.div(e.neg()).neg();
    s = xe;
  }

  for (n = this; n.gte(e);) {
    t = Math.max(1, Math.floor(n.toNumber() / e.toNumber()));

    for (var r = Math.ceil(Math.log(t) / Math.LN2), a = r <= 48 ? 1 : he(2, r - 48), i = ue(t), o = i.mul(e); o.isNegative() || o.gt(n);) {
      o = (i = ue(t -= a, this.unsigned)).mul(e);
    }

    i.isZero() && (i = ke), s = s.add(i), n = n.sub(o);
  }

  return s;
}, Ce.div = Ce.divide, Ce.modulo = function (e) {
  return ae(e) || (e = pe(e)), se ? ce((this.unsigned ? se.rem_u : se.rem_s)(this.low, this.high, e.low, e.high), se.get_high(), this.unsigned) : this.sub(this.div(e).mul(e));
}, Ce.mod = Ce.modulo, Ce.rem = Ce.modulo, Ce.not = function () {
  return ce(~this.low, ~this.high, this.unsigned);
}, Ce.and = function (e) {
  return ae(e) || (e = pe(e)), ce(this.low & e.low, this.high & e.high, this.unsigned);
}, Ce.or = function (e) {
  return ae(e) || (e = pe(e)), ce(this.low | e.low, this.high | e.high, this.unsigned);
}, Ce.xor = function (e) {
  return ae(e) || (e = pe(e)), ce(this.low ^ e.low, this.high ^ e.high, this.unsigned);
}, Ce.shiftLeft = function (e) {
  return ae(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? ce(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : ce(0, this.low << e - 32, this.unsigned);
}, Ce.shl = Ce.shiftLeft, Ce.shiftRight = function (e) {
  return ae(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? ce(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : ce(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
}, Ce.shr = Ce.shiftRight, Ce.shiftRightUnsigned = function (e) {
  if (ae(e) && (e = e.toInt()), 0 == (e &= 63)) return this;
  var t = this.high;
  return e < 32 ? ce(this.low >>> e | t << 32 - e, t >>> e, this.unsigned) : ce(32 === e ? t : t >>> e - 32, 0, this.unsigned);
}, Ce.shru = Ce.shiftRightUnsigned, Ce.shr_u = Ce.shiftRightUnsigned, Ce.toSigned = function () {
  return this.unsigned ? ce(this.low, this.high, !1) : this;
}, Ce.toUnsigned = function () {
  return this.unsigned ? this : ce(this.low, this.high, !0);
}, Ce.toBytes = function (e) {
  return e ? this.toBytesLE() : this.toBytesBE();
}, Ce.toBytesLE = function () {
  var e = this.high,
      t = this.low;
  return [255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, 255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
}, Ce.toBytesBE = function () {
  var e = this.high,
      t = this.low;
  return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, 255 & t];
}, re.fromBytes = function (e, t, n) {
  return n ? re.fromBytesLE(e, t) : re.fromBytesBE(e, t);
}, re.fromBytesLE = function (e, t) {
  return new re(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
}, re.fromBytesBE = function (e, t) {
  return new re(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
};
var Se = ne;
var Te = Se || Object.assign(Object.create(null), ne, {
  default: Se
});

function Ee(e) {
  return Te.fromString(e, !0, 16);
}

var Re = Ee("c3a5c85c97cb3127"),
    Ae = Ee("b492b66fbe98f273"),
    Fe = Ee("9ae16a3b2f90404f");

function De(e) {
  return e.xor(e.shru(47));
}

function _e(e, t, n) {
  var s = e.slice(t, t + n);
  return Te.fromBytes(Array.from(s), !0, !0);
}

function Oe(e, t) {
  return _e(e, t, 8);
}

function Me(e, t) {
  return _e(e, t, 4);
}

function Le(e, t) {
  return 0 === t ? e : e.shru(t).or(e.shl(64 - t));
}

function ze(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Ee("9ddfea08eb382d69");
  var s = e.xor(t).mul(n);
  s = s.xor(s.shru(47));
  var r = t.xor(s).mul(n);
  return r = r.xor(r.shru(47)), r = r.mul(n), r;
}

function Be(e, t, n, s) {
  return function (e, t, n, s, r, a) {
    r = r.add(e), a = Le(a.add(r).add(s), 21);
    var i = r;
    return r = (r = r.add(t)).add(n), a = a.add(Le(r, 44)), [r.add(s), a.add(i)];
  }(Oe(e, t), Oe(e, t + 8), Oe(e, t + 16), Oe(e, t + 24), n, s);
}

function Pe(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;
  var n = Te.fromNumber(81, !0);
  if (t <= 32) return t <= 16 ? function (e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;

    if (t >= 8) {
      var _n5 = Fe.add(2 * t),
          _s6 = Oe(e, 0).add(Fe),
          _r3 = Oe(e, t - 8);

      return ze(Le(_r3, 37).mul(_n5).add(_s6), Le(_s6, 25).add(_r3).mul(_n5), _n5);
    }

    if (t >= 4) {
      var _n6 = Fe.add(2 * t);

      return ze(Me(e, 0).shl(3).add(t), Me(e, t - 4), _n6);
    }

    if (t > 0) {
      var _n7 = t + (e[t - 1] << 2);

      return De(Fe.mul(e[0] + (e[t >> 1] << 8)).xor(Re.mul(_n7))).mul(Fe);
    }

    return Fe;
  }(e, t) : function (e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;
    var n = Fe.add(2 * t),
        s = Oe(e, 0).mul(Ae),
        r = Oe(e, 8),
        a = Oe(e, t - 8).mul(n),
        i = Oe(e, t - 16).mul(Fe);
    return ze(Le(s.add(r), 43).add(Le(a, 30)).add(i), s.add(Le(r.add(Fe), 18)).add(a), n);
  }(e, t);
  if (t <= 64) return function (e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;
    var n = Fe.add(2 * t),
        s = Oe(e, 0).mul(Fe),
        r = Oe(e, 8),
        a = Oe(e, t - 8).mul(n),
        i = Oe(e, t - 16).mul(Fe),
        o = Le(s.add(r), 43).add(Le(a, 30)).add(i),
        l = ze(o, s.add(Le(r.add(Fe), 18)).add(a), n),
        u = Oe(e, 16).mul(n),
        c = Oe(e, 24),
        h = o.add(Oe(e, t - 32)).mul(n),
        d = l.add(Oe(e, t - 24)).mul(n);
    return ze(Le(u.add(c), 43).add(Le(h, 30)).add(d), u.add(Le(c.add(s), 18)).add(h), n);
  }(e, t);
  var s = n,
      r = n.mul(Ae).add(113),
      a = De(r.mul(Fe).add(113)).mul(Fe),
      i = [Te.UZERO, Te.UZERO],
      o = [Te.UZERO, Te.UZERO];
  s = s.mul(Fe).add(Oe(e, 0));
  var l = 0;
  var u = 64 * (t - 1 >> 6),
      c = u + (t - 1 & 63) - 63;

  do {
    s = Le(s.add(r).add(i[0]).add(Oe(e, l + 8)), 37).mul(Ae), r = Le(r.add(i[1]).add(Oe(e, l + 48)), 42).mul(Ae), s = s.xor(o[1]), r = r.add(i[0]).add(Oe(e, l + 40)), a = Le(a.add(o[0]), 33).mul(Ae), i = Be(e, l, i[1].mul(Ae), s.add(o[0])), o = Be(e, l + 32, a.add(o[1]), r.add(Oe(e, l + 16))), [a, s] = [s, a], l += 64;
  } while (l !== u);

  var h = Ae.add(a.and(255).shl(1));
  return l = c, o[0] = o[0].add(t - 1 & 63), i[0] = i[0].add(o[0]), o[0] = o[0].add(i[0]), s = Le(s.add(r).add(i[0]).add(Oe(e, l + 8)), 37).mul(h), r = Le(r.add(i[1]).add(Oe(e, l + 48)), 42).mul(h), s = s.xor(o[1].mul(9)), r = r.add(i[0].mul(9).add(Oe(e, l + 40))), a = Le(a.add(o[0]), 33).mul(h), i = Be(e, l, i[1].mul(h), s.add(o[0])), o = Be(e, l + 32, a.add(o[1]), r.add(Oe(e, l + 16))), [a, s] = [s, a], ze(ze(i[0], o[0], h).add(De(r).mul(Re)).add(a), ze(i[1], o[1], h).add(s), h);
}

function We(e, t) {
  return "string" === t ? Ge(e) : Ue([e], t);
}

function Ue(e, t) {
  if ("string" === t) throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(e) && (e = h(e)), V().getBool("DEBUG") && function (e, t) {
    for (var _n8 = 0; _n8 < e.length; _n8++) {
      var _s7 = e[_n8];
      if (isNaN(_s7) || !isFinite(_s7)) throw Error("A tensor of type ".concat(t, " being uploaded contains ").concat(_s7, "."));
    }
  }(e, t), function (e, t) {
    return e instanceof Float32Array && "float32" === t || e instanceof Int32Array && "int32" === t || e instanceof Uint8Array && "bool" === t;
  }(e, t)) return e;
  if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
  if ("int32" === t) return new Int32Array(e);

  if ("bool" === t) {
    var _t9 = new Uint8Array(e.length);

    for (var _n9 = 0; _n9 < _t9.length; ++_n9) {
      0 !== Math.round(e[_n9]) && (_t9[_n9] = 1);
    }

    return _t9;
  }

  throw new Error("Unknown data type ".concat(t));
}

function Ve() {
  return V().platform.now();
}

function Ge(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf-8";
  return t = t || "utf-8", V().platform.encode(e, t);
}

function He(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf-8";
  return t = t || "utf-8", V().platform.decode(e, t);
}

class je {
  constructor(e, t) {
    this.backendTimer = e, this.logger = t, null == t && (this.logger = new Ke());
  }

  profileKernel(e, t, n) {
    var s;

    var r = () => {
      s = n();
    };

    var a;
    var i = Ve();
    if (this.backendTimer.timerAvailable()) a = this.backendTimer.time(r);else {
      r();

      for (var _e4 of s) {
        _e4.dataSync();
      }

      a = Promise.resolve({
        kernelMs: Ve() - i
      });
    }

    if (V().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
      var _loop = function _loop(_t10) {
        var n = s[_t10];
        n.data().then(t => {
          qe(t, n.dtype, e);
        });
      };

      for (var _t10 = 0; _t10 < s.length; _t10++) {
        _loop(_t10);
      }
    }

    return {
      kernelName: e,
      outputs: s,
      inputs: t,
      timeMs: a.then(e => e.kernelMs),
      extraInfo: a.then(e => null != e.getExtraProfileInfo ? e.getExtraProfileInfo() : "")
    };
  }

  logKernelProfile(e) {
    var {
      kernelName: t,
      outputs: n,
      timeMs: s,
      inputs: r,
      extraInfo: a
    } = e;
    n.forEach(e => {
      Promise.all([e.data(), s, a]).then(n => {
        this.logger.logKernelProfile(t, e, n[0], n[1], r, n[2]);
      });
    });
  }

}

function qe(e, t, n) {
  if ("float32" !== t) return !1;

  for (var _t11 = 0; _t11 < e.length; _t11++) {
    var _s8 = e[_t11];
    if (isNaN(_s8) || !isFinite(_s8)) return console.warn("Found ".concat(_s8, " in the result of '").concat(n, "'")), !0;
  }

  return !1;
}

class Ke {
  logKernelProfile(e, t, n, s, r, a) {
    var i = "number" == typeof s ? m("".concat(s, "ms"), 9) : s.error,
        o = m(e, 25),
        l = t.rank,
        u = t.size,
        c = m(t.shape.toString(), 14);
    var h = "";

    for (var _e5 in r) {
      var _n10 = r[_e5];

      if (null != _n10) {
        var _s9 = _n10.shape || t.shape,
            _r4 = _s9.length;

        h += "".concat(_e5, ": ").concat(_r4, "D ").concat(_r4 > 0 ? _s9 : "", " ");
      }
    }

    console.log("%c".concat(o, "\t%c").concat(i, "\t%c").concat(l, "D ").concat(c, "\t%c").concat(u, "\t%c").concat(h, "\t%c").concat(a), "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }

}

function Xe(e, t, n, s) {
  var r = A(t),
      a = function (e, t, n, s) {
    var r = d(t),
        a = s[s.length - 1],
        i = new Array(a).fill(0),
        o = t.length,
        l = "complex64" === n ? Qe(e) : e;
    if (o > 1) for (var _e6 = 0; _e6 < r / a; _e6++) {
      var _t12 = _e6 * a;

      for (var _e7 = 0; _e7 < a; _e7++) {
        i[_e7] = Math.max(i[_e7], Ye(l[_t12 + _e7], 0, n).length);
      }
    }
    return i;
  }(e, t, n, r),
      i = t.length,
      o = Ze(e, t, n, r, a),
      l = ["Tensor"];

  return s && (l.push("  dtype: ".concat(n)), l.push("  rank: ".concat(i)), l.push("  shape: [".concat(t, "]")), l.push("  values:")), l.push(o.map(e => "    " + e).join("\n")), l.join("\n");
}

function Ye(e, t, n) {
  var s;
  return s = Array.isArray(e) ? "".concat(parseFloat(e[0].toFixed(7)), " + ").concat(parseFloat(e[1].toFixed(7)), "j") : C(e) ? "'".concat(e, "'") : "bool" === n ? Je(e) : parseFloat(e.toFixed(7)).toString(), m(s, t);
}

function Je(e) {
  return 0 === e ? "false" : "true";
}

function Ze(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !0;
  var i = "complex64" === n ? 2 : 1,
      o = t[0],
      l = t.length;
  if (0 === l) return "complex64" === n ? [Ye(Qe(e)[0], 0, n)] : "bool" === n ? [Je(e[0])] : [e[0].toString()];

  if (1 === l) {
    if (o > 20) {
      var _t13 = Array.from(e.slice(0, 3 * i)),
          _s10 = Array.from(e.slice((o - 3) * i, o * i));

      return "complex64" === n && (_t13 = Qe(_t13), _s10 = Qe(_s10)), ["[" + _t13.map((e, t) => Ye(e, r[t], n)).join(", ") + ", ..., " + _s10.map((e, t) => Ye(e, r[o - 3 + t], n)).join(", ") + "]"];
    }

    return ["[" + ("complex64" === n ? Qe(e) : Array.from(e)).map((e, t) => Ye(e, r[t], n)).join(", ") + "]"];
  }

  var u = t.slice(1),
      c = s.slice(1),
      h = s[0] * i,
      d = [];

  if (o > 20) {
    for (var _t14 = 0; _t14 < 3; _t14++) {
      var _s11 = _t14 * h;

      d.push(...Ze(e.slice(_s11, _s11 + h), u, n, c, r, !1));
    }

    d.push("...");

    for (var _t15 = o - 3; _t15 < o; _t15++) {
      var _s12 = _t15 * h;

      d.push(...Ze(e.slice(_s12, _s12 + h), u, n, c, r, _t15 === o - 1));
    }
  } else for (var _t16 = 0; _t16 < o; _t16++) {
    var _s13 = _t16 * h;

    d.push(...Ze(e.slice(_s13, _s13 + h), u, n, c, r, _t16 === o - 1));
  }

  var p = 2 === l ? "," : "";
  d[0] = "[" + d[0] + p;

  for (var _e8 = 1; _e8 < d.length - 1; _e8++) {
    d[_e8] = " " + d[_e8] + p;
  }

  var f = ",\n";

  for (var _e9 = 2; _e9 < l; _e9++) {
    f += "\n";
  }

  return d[d.length - 1] = " " + d[d.length - 1] + "]" + (a ? "" : f), d;
}

function Qe(e) {
  var t = [];

  for (var _n11 = 0; _n11 < e.length; _n11 += 2) {
    t.push([e[_n11], e[_n11 + 1]]);
  }

  return t;
}

class et {
  constructor(e, t, n) {
    if (this.dtype = t, this.shape = e.slice(), this.size = d(e), null != n) {
      var _e10 = n.length;
      l(_e10 === this.size, () => "Length of values '".concat(_e10, "' does not match the size inferred by the shape '").concat(this.size, "'."));
    }

    if ("complex64" === t) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = n || v(t, this.size), this.strides = A(e);
  }

  set(e) {
    for (var _len2 = arguments.length, t = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      t[_key2 - 1] = arguments[_key2];
    }

    0 === t.length && (t = [0]), l(t.length === this.rank, () => "The number of provided coordinates (".concat(t.length, ") must match the rank (").concat(this.rank, ")"));
    var n = this.locToIndex(t);
    this.values[n] = e;
  }

  get() {
    for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      e[_key3] = arguments[_key3];
    }

    0 === e.length && (e = [0]);
    var t = 0;

    for (var _n12 of e) {
      if (_n12 < 0 || _n12 >= this.shape[t]) throw new Error("Requested out of range element at ".concat(e, ".   Buffer shape=").concat(this.shape));
      t++;
    }

    var n = e[e.length - 1];

    for (var _t17 = 0; _t17 < e.length - 1; ++_t17) {
      n += this.strides[_t17] * e[_t17];
    }

    return this.values[n];
  }

  locToIndex(e) {
    if (0 === this.rank) return 0;
    if (1 === this.rank) return e[0];
    var t = e[e.length - 1];

    for (var _n13 = 0; _n13 < e.length - 1; ++_n13) {
      t += this.strides[_n13] * e[_n13];
    }

    return t;
  }

  indexToLoc(e) {
    if (0 === this.rank) return [];
    if (1 === this.rank) return [e];
    var t = new Array(this.shape.length);

    for (var _n14 = 0; _n14 < t.length - 1; ++_n14) {
      t[_n14] = Math.floor(e / this.strides[_n14]), e -= t[_n14] * this.strides[_n14];
    }

    return t[t.length - 1] = e, t;
  }

  get rank() {
    return this.shape.length;
  }

  toTensor() {
    return tt().makeTensor(this.values, this.shape, this.dtype);
  }

}

var tt = null,
    nt = null;

class st {
  constructor(e, t, n, s) {
    this.kept = !1, this.isDisposedInternal = !1, this.shape = e.slice(), this.dtype = t || "float32", this.size = d(e), this.strides = A(e), this.dataId = n, this.id = s, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }

  get rank() {
    return this.shape.length;
  }

  buffer() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      var e = yield _this2.data();
      return nt.buffer(_this2.shape, _this2.dtype, e);
    })();
  }

  bufferSync() {
    return nt.buffer(this.shape, this.dtype, this.dataSync());
  }

  array() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      var e = yield _this3.data();
      return D(_this3.shape, e, "complex64" === _this3.dtype);
    })();
  }

  arraySync() {
    return D(this.shape, this.dataSync(), "complex64" === this.dtype);
  }

  data() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      _this4.throwIfDisposed();

      var e = tt().read(_this4.dataId);

      if ("string" === _this4.dtype) {
        var _t18 = yield e;

        try {
          return _t18.map(e => He(e));
        } catch (e) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }

      return e;
    })();
  }

  dataSync() {
    this.throwIfDisposed();
    var e = tt().readSync(this.dataId);
    if ("string" === this.dtype) try {
      return e.map(e => He(e));
    } catch (e) {
      throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
    }
    return e;
  }

  bytes() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      _this5.throwIfDisposed();

      var e = yield tt().read(_this5.dataId);
      return "string" === _this5.dtype ? e : new Uint8Array(e.buffer);
    })();
  }

  dispose() {
    this.isDisposed || (tt().disposeTensor(this), this.isDisposedInternal = !0);
  }

  get isDisposed() {
    return this.isDisposedInternal;
  }

  throwIfDisposed() {
    if (this.isDisposed) throw new Error("Tensor is disposed.");
  }

  print() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    return nt.print(this, e);
  }

  clone() {
    return this.throwIfDisposed(), nt.clone(this);
  }

  toString() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    return Xe(this.dataSync(), this.shape, this.dtype, e);
  }

  cast(e) {
    return this.throwIfDisposed(), nt.cast(this, e);
  }

  variable() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    var t = arguments.length > 1 ? arguments[1] : undefined;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    return this.throwIfDisposed(), tt().makeVariable(this, e, t, n);
  }

}

function rt() {
  return q("Tensor", () => st);
}

Object.defineProperty(st, Symbol.hasInstance, {
  value: e => !!e && null != e.data && null != e.dataSync && null != e.throwIfDisposed
}), rt();

class at extends st {
  constructor(e, t, n, s) {
    super(e.shape, e.dtype, e.dataId, s), this.trainable = t, this.name = n;
  }

  assign(e) {
    if (e.dtype !== this.dtype) throw new Error("dtype of the new value (".concat(e.dtype, ") and previous value (").concat(this.dtype, ") must match"));
    if (!p(e.shape, this.shape)) throw new Error("shape of the new value (".concat(e.shape, ") and previous value (").concat(this.shape, ") must match"));
    tt().disposeTensor(this), this.dataId = e.dataId, tt().incRef(this, null);
  }

  dispose() {
    tt().disposeVariable(this), this.isDisposedInternal = !0;
  }

}

var it, ot, lt, ut, ct;
Object.defineProperty(at, Symbol.hasInstance, {
  value: e => e instanceof st && null != e.assign && e.assign instanceof Function
}), function (e) {
  e.R0 = "R0", e.R1 = "R1", e.R2 = "R2", e.R3 = "R3", e.R4 = "R4", e.R5 = "R5", e.R6 = "R6";
}(it || (it = {})), function (e) {
  e.float32 = "float32", e.int32 = "int32", e.bool = "int32", e.complex64 = "complex64";
}(ot || (ot = {})), function (e) {
  e.float32 = "float32", e.int32 = "int32", e.bool = "bool", e.complex64 = "complex64";
}(lt || (lt = {})), function (e) {
  e.float32 = "float32", e.int32 = "float32", e.bool = "float32", e.complex64 = "complex64";
}(ut || (ut = {})), function (e) {
  e.float32 = "complex64", e.int32 = "complex64", e.bool = "complex64", e.complex64 = "complex64";
}(ct || (ct = {}));
var ht = {
  float32: ut,
  int32: ot,
  bool: lt,
  complex64: ct
};

function dt(e, t) {
  if ("string" === e || "string" === t) {
    if ("string" === e && "string" === t) return "string";
    throw new Error("Can not upcast ".concat(e, " with ").concat(t));
  }

  return ht[e][t];
}

function pt(e) {
  return dt(e, "int32");
}

function ft(e, t) {
  if (e.dtype === t.dtype) return [e, t];
  var n = dt(e.dtype, t.dtype);
  return [e.cast(n), t.cast(n)];
}

function gt(e) {
  var t = [];
  return mt(e, t, new Set()), t;
}

function mt(e, t, n) {
  if (null == e) return;
  if (e instanceof st) return void t.push(e);
  if (s = e, !Array.isArray(s) && "object" != typeof s) return;
  var s;
  var r = e;

  for (var _e11 in r) {
    var _s14 = r[_e11];
    n.has(_s14) || (n.add(_s14), mt(_s14, t, n));
  }
}

function bt(e) {
  return null != e.kernelName;
}

class xt {
  constructor() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap(), this.profiling = !1, this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null,

      get kernelNames() {
        return Array.from(new Set(this.kernels.map(e => e.name)));
      }

    };
  }

  dispose() {
    for (var _e12 in this.registeredVariables) {
      this.registeredVariables[_e12].dispose();
    }
  }

}

class yt {
  constructor(e) {
    this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new xt();
  }

  ready() {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      if (null != _this6.pendingBackendInit) return _this6.pendingBackendInit.then(() => {});
      if (null != _this6.backendInstance) return;

      var e = _this6.getSortedBackends();

      for (var _t19 = 0; _t19 < e.length; _t19++) {
        var _n15 = e[_t19];
        if (yield _this6.initializeBackend(_n15).success) return void (yield _this6.setBackend(_n15));
      }

      throw new Error("Could not initialize any backends, all backend initializations failed.");
    })();
  }

  get backend() {
    if (null != this.pendingBackendInit) throw new Error("Backend '".concat(this.backendName, "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"));

    if (null == this.backendInstance) {
      var {
        name: _e13,
        asyncInit: _t20
      } = this.initializeBackendsAndReturnBest();
      if (_t20) throw new Error("The highest priority backend '".concat(_e13, "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"));
      this.setBackend(_e13);
    }

    return this.backendInstance;
  }

  backendNames() {
    return Object.keys(this.registryFactory);
  }

  findBackend(e) {
    if (!(e in this.registry)) {
      if (!(e in this.registryFactory)) return null;
      {
        var {
          asyncInit: _t21
        } = this.initializeBackend(e);
        if (_t21) return null;
      }
    }

    return this.registry[e];
  }

  findBackendFactory(e) {
    return e in this.registryFactory ? this.registryFactory[e].factory : null;
  }

  registerBackend(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return e in this.registryFactory ? (console.warn("".concat(e, " backend was already registered. Reusing existing backend factory.")), !1) : (this.registryFactory[e] = {
      factory: t,
      priority: n
    }, !0);
  }

  setBackend(e) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      if (null == _this7.registryFactory[e]) throw new Error("Backend name '".concat(e, "' not found in registry"));

      if (_this7.backendName = e, null == _this7.registry[e]) {
        _this7.backendInstance = null;

        var {
          success: _t22,
          asyncInit: _n16
        } = _this7.initializeBackend(e);

        if (!(_n16 ? yield _t22 : _t22)) return !1;
      }

      return _this7.backendInstance = _this7.registry[e], _this7.setupRegisteredKernels(), _this7.profiler = new je(_this7.backendInstance), !0;
    })();
  }

  setupRegisteredKernels() {
    Z(this.backendName).forEach(e => {
      null != e.setupFunc && e.setupFunc(this.backendInstance);
    });
  }

  disposeRegisteredKernels(e) {
    Z(e).forEach(t => {
      null != t.disposeFunc && t.disposeFunc(this.registry[e]);
    });
  }

  initializeBackend(e) {
    var t = this.registryFactory[e];
    if (null == t) throw new Error("Cannot initialize backend ".concat(e, ", no registration found."));

    try {
      var _s15 = t.factory();

      if (!_s15 || _s15 instanceof n || "function" != typeof _s15.then) return this.registry[e] = _s15, {
        success: !0,
        asyncInit: !1
      };
      {
        var _t23 = ++this.pendingBackendInitId,
            _n17 = _s15.then(n => !(_t23 < this.pendingBackendInitId || (this.registry[e] = n, this.pendingBackendInit = null, 0))).catch(n => (_t23 < this.pendingBackendInitId || (this.pendingBackendInit = null, console.warn("Initialization of backend ".concat(e, " failed")), console.warn(n.stack || n.message)), !1));

        return this.pendingBackendInit = _n17, {
          success: _n17,
          asyncInit: !0
        };
      }
    } catch (t) {
      return console.warn("Initialization of backend ".concat(e, " failed")), console.warn(t.stack || t.message), {
        success: !1,
        asyncInit: !1
      };
    }
  }

  removeBackend(e) {
    if (!(e in this.registryFactory)) throw new Error("".concat(e, " backend not found in registry"));
    this.backendName === e && null != this.pendingBackendInit && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }

  getSortedBackends() {
    if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort((e, t) => this.registryFactory[t].priority - this.registryFactory[e].priority);
  }

  initializeBackendsAndReturnBest() {
    var e = this.getSortedBackends();

    for (var _t24 = 0; _t24 < e.length; _t24++) {
      var _n18 = e[_t24],
          {
        success: _s16,
        asyncInit: _r5
      } = this.initializeBackend(_n18);
      if (_r5 || _s16) return {
        name: _n18,
        asyncInit: _r5
      };
    }

    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }

  moveData(e, t) {
    var n = this.state.tensorInfo.get(t),
        s = n.backend,
        r = this.readSync(t),
        a = s.refCount(t);
    s.disposeData(t, !0), n.backend = e, e.move(t, r, n.shape, n.dtype, a), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }

  tidy(e, t) {
    var n,
        s = null;

    if (null == t) {
      if ("function" != typeof e) throw new Error("Please provide a function to tidy()");
      t = e;
    } else {
      if ("string" != typeof e && !(e instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if ("function" != typeof t) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      s = e;
    }

    return this.scopedRun(() => this.startScope(s), () => this.endScope(n), () => (n = t(), n instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n));
  }

  scopedRun(e, t, n) {
    e();

    try {
      var _e14 = n();

      return t(), _e14;
    } catch (e) {
      throw t(), e;
    }
  }

  nextTensorId() {
    return yt.nextTensorId++;
  }

  nextVariableId() {
    return yt.nextVariableId++;
  }

  clone(e) {
    var t = wt.runKernel("Identity", {
      x: e
    });
    return this.addTapeNode(this.state.activeScope.name, {
      x: e
    }, [t], e => ({
      x: () => wt.runKernel("Cast", {
        x: e
      }, {
        dtype: "float32"
      })
    }), [], {}), t;
  }

  runKernel(e, t, n) {
    if (null == Y(e, this.backendName)) throw new Error("Kernel '".concat(e, "' not registered for backend '").concat(this.backendName, "'"));
    return this.runKernelFunc({
      kernelName: e,
      inputs: t,
      attrs: n
    });
  }

  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }

  checkKernelForMemLeak(e, t, n) {
    var s = this.backend.numDataIds();
    var r = 0;
    n.forEach(e => {
      r += "complex64" === e.dtype ? 3 : 1;
    });
    var a = s - t - r - this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
    if (a > 0) throw new Error("Backend '".concat(this.backendName, "' has an internal memory leak (").concat(a, " data ids) after running '").concat(e, "'"));
  }

  runKernelFunc(e) {
    var t,
        n = [];
    var s = this.isTapeOn(),
        r = this.state.numBytes,
        a = this.state.numTensors;
    var i, o;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    var u = bt(e) ? e.kernelName : null != this.state.activeScope ? this.state.activeScope.name : "";

    if (bt(e)) {
      var {
        kernelName: _t25,
        inputs: _r6,
        attrs: _a5
      } = e,
          _u2 = Y(_t25, this.backendName);

      l(null != _u2, () => "Cannot find registered kernel '".concat(_t25, "' for backend '").concat(this.backendName, "'")), i = () => {
        var e = this.backend.numDataIds();
        o = _u2.kernelFunc({
          inputs: _r6,
          attrs: _a5,
          backend: this.backend
        });
        var i = Array.isArray(o) ? o : [o];
        this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(_t25, e, i);
        var l = i.map(e => {
          if (null != e.rank) return e;
          var {
            dataId: t,
            shape: n,
            dtype: s
          } = e;
          return this.makeTensorFromDataId(t, n, s);
        });

        if (s) {
          var _e15 = this.getTensorsForGradient(_t25, _r6, l);

          n = this.saveTensorsForBackwardMode(_e15);
        }

        return l;
      };
    } else {
      var {
        forwardFunc: _t26
      } = e,
          _r7 = e => {
        s && (n = e.map(e => this.keep(this.clone(e))));
      };

      i = () => {
        var e = this.backend.numDataIds();
        o = this.tidy(() => _t26(this.backend, _r7));
        var n = Array.isArray(o) ? o : [o];
        return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(u, e, n), n;
      };
    }

    var {
      inputs: c,
      attrs: h
    } = e,
        d = bt(e) ? null : e.backwardsFunc;
    var p;
    return this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
      this.ENV.getBool("DEBUG") || this.state.profiling ? (p = this.profiler.profileKernel(u, c, () => i()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(p), t = p.outputs) : t = i();
    }), s && this.addTapeNode(u, c, t, d, n, h), this.state.profiling && this.state.activeProfile.kernels.push({
      name: u,
      bytesAdded: this.state.numBytes - r,
      totalBytesSnapshot: this.state.numBytes,
      tensorsAdded: this.state.numTensors - a,
      totalTensorsSnapshot: this.state.numTensors,
      inputShapes: Object.keys(c).map(e => null != c[e] ? c[e].shape : null),
      outputShapes: t.map(e => e.shape),
      kernelTimeMs: p.timeMs,
      extraInfo: p.extraInfo
    }), Array.isArray(o) ? t : t[0];
  }

  saveTensorsForBackwardMode(e) {
    return e.map(e => this.keep(this.clone(e)));
  }

  getTensorsForGradient(e, t, n) {
    var s = J(e);

    if (null != s) {
      var _e16 = s.inputsToSave || [],
          _r8 = s.outputsToSave || [];

      var _a6;

      s.saveAllInputs ? (l(Array.isArray(t), () => "saveAllInputs is true, expected inputs to be an array."), _a6 = Object.keys(t).map(e => t[e])) : _a6 = _e16.map(e => t[e]);

      var _i4 = n.filter((e, t) => _r8[t]);

      return _a6.concat(_i4);
    }

    return [];
  }

  makeTensor(e, t, n, s) {
    if (null == e) throw new Error("Values passed to engine.makeTensor() are null");
    s = s || this.backend;
    var r = e;
    "string" === (n = n || "float32") && C(e[0]) && (r = e.map(e => Ge(e)));
    var a = s.write(r, t, n),
        i = new st(t, n, a, this.nextTensorId());

    if (this.trackTensor(i, s), "string" === n) {
      var _e17 = this.state.tensorInfo.get(a),
          _t27 = function (e) {
        if (null == e) return 0;
        var t = 0;
        return e.forEach(e => t += e.length), t;
      }(r);

      this.state.numBytes += _t27 - _e17.bytes, _e17.bytes = _t27;
    }

    return i;
  }

  makeTensorFromDataId(e, t, n, s) {
    var r = new st(t, n = n || "float32", e, this.nextTensorId());
    return this.trackTensor(r, s), r;
  }

  makeVariable(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    n = n || this.nextVariableId().toString(), null != s && s !== e.dtype && (e = e.cast(s));
    var r = new at(e, t, n, this.nextTensorId());
    if (null != this.state.registeredVariables[r.name]) throw new Error("Variable with name ".concat(r.name, " was already registered"));
    return this.state.registeredVariables[r.name] = r, this.incRef(r, this.backend), r;
  }

  trackTensor(e, t) {
    this.state.numTensors++, "string" === e.dtype && this.state.numStringTensors++;
    var n = 0;
    "complex64" !== e.dtype && "string" !== e.dtype && (n = e.size * N(e.dtype)), this.state.numBytes += n, this.state.tensorInfo.has(e.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e.dataId, {
      backend: t || this.backend,
      dtype: e.dtype,
      shape: e.shape,
      bytes: n
    })), e instanceof at || this.track(e);
  }

  incRef(e, t) {
    this.trackTensor(e, t), this.backend.incRef(e.dataId);
  }

  removeDataId(e, t) {
    this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === t && (this.state.tensorInfo.delete(e), this.state.numDataBuffers--);
  }

  disposeTensor(e) {
    if (!this.state.tensorInfo.has(e.dataId)) return;
    var t = this.state.tensorInfo.get(e.dataId);

    if (this.state.numTensors--, "string" === e.dtype && (this.state.numStringTensors--, this.state.numBytes -= t.bytes), "complex64" !== e.dtype && "string" !== e.dtype) {
      var _t28 = e.size * N(e.dtype);

      this.state.numBytes -= _t28;
    }

    t.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, t.backend);
  }

  disposeVariables() {
    for (var _e18 in this.state.registeredVariables) {
      this.disposeVariable(this.state.registeredVariables[_e18]);
    }
  }

  disposeVariable(e) {
    this.disposeTensor(e), null != this.state.registeredVariables[e.name] && delete this.state.registeredVariables[e.name];
  }

  memory() {
    var e = this.backend.memory();
    return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = !0, null == e.reasons && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e;
  }

  profile(e) {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      _this8.state.profiling = !0;
      var t = _this8.state.numBytes,
          n = _this8.state.numTensors;
      _this8.state.activeProfile.kernels = [], _this8.state.activeProfile.result = yield e(), _this8.state.profiling = !1, _this8.state.activeProfile.peakBytes = Math.max(..._this8.state.activeProfile.kernels.map(e => e.totalBytesSnapshot)), _this8.state.activeProfile.newBytes = _this8.state.numBytes - t, _this8.state.activeProfile.newTensors = _this8.state.numTensors - n;

      for (var _e19 of _this8.state.activeProfile.kernels) {
        _e19.kernelTimeMs = yield _e19.kernelTimeMs, _e19.extraInfo = yield _e19.extraInfo;
      }

      return _this8.state.activeProfile;
    })();
  }

  isTapeOn() {
    return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
  }

  addTapeNode(e, t, n, s, r, a) {
    var i = {
      id: this.state.nextTapeNodeId++,
      kernelName: e,
      inputs: t,
      outputs: n,
      saved: r
    },
        o = J(e);
    null != o && (s = o.gradFunc), null != s && (i.gradient = e => (e = e.map((e, t) => {
      if (null == e) {
        var _e20 = n[t],
            _s17 = O(_e20.size, _e20.dtype);

        return this.makeTensor(_s17, _e20.shape, _e20.dtype);
      }

      return e;
    }), s(e.length > 1 ? e : e[0], r, a))), this.state.activeTape.push(i);
  }

  keep(e) {
    return e.kept = !0, e;
  }

  startTape() {
    0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
  }

  endTape() {
    this.state.gradientDepth--;
  }

  startScope(e) {
    var t = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    e && (t.name = e), this.state.scopeStack.push(t), this.state.activeScope = t;
  }

  endScope(e) {
    var t = gt(e),
        n = new Set(t.map(e => e.id));

    for (var _e21 = 0; _e21 < this.state.activeScope.track.length; _e21++) {
      var _t29 = this.state.activeScope.track[_e21];
      _t29.kept || n.has(_t29.id) || _t29.dispose();
    }

    var s = this.state.scopeStack.pop();
    this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], t.forEach(e => {
      e.kept || e.scopeId !== s.id || this.track(e);
    });
  }

  gradients(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    if (l(t.length > 0, () => "gradients() received an empty list of xs."), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype, "'"));
    var r = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", e));
    l(r instanceof st, () => "The result y returned by f() must be a tensor.");

    var a = function (e, t, n) {
      var s = {},
          r = {};

      for (var _e22 = 0; _e22 < t.length; _e22++) {
        s[t[_e22].id] = !0;
      }

      for (var _n19 = 0; _n19 < e.length; _n19++) {
        var _a7 = e[_n19],
            _i5 = _a7.inputs;

        for (var _e23 in _i5) {
          var _n20 = _i5[_e23];

          var _o4 = !1;

          for (var _e24 = 0; _e24 < t.length; _e24++) {
            if (s[_n20.id]) {
              _a7.outputs.forEach(e => s[e.id] = !0), _o4 = !0, r[_a7.id] = !0;
              break;
            }
          }

          if (_o4) break;
        }
      }

      var a = {};
      a[n.id] = !0;
      var i = {};

      for (var _t30 = e.length - 1; _t30 >= 0; _t30--) {
        var _n21 = e[_t30],
            _s18 = _n21.inputs;

        for (var _e25 = 0; _e25 < _n21.outputs.length; _e25++) {
          if (a[_n21.outputs[_e25].id]) {
            for (var _e26 in _s18) {
              a[_s18[_e26].id] = !0, i[_n21.id] = !0;
            }

            break;
          }
        }
      }

      var o = [];

      for (var _t31 = 0; _t31 < e.length; _t31++) {
        var _n22 = e[_t31];

        if (r[_n22.id] && i[_n22.id]) {
          var _e27 = {};

          for (var _t33 in _n22.inputs) {
            var _r9 = _n22.inputs[_t33];
            s[_r9.id] && (_e27[_t33] = _r9);
          }

          var _t32 = Object.assign({}, _n22);

          _t32.inputs = _e27, _t32.outputs = _n22.outputs, o.push(_t32);
        }
      }

      return o;
    }(this.state.activeTape, t, r);

    if (!s && 0 === a.length && t.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", () => {
      var e = {};
      e[r.id] = null == n ? function (e) {
        var t = _(d(e), "float32");

        return wt.makeTensor(t, e, "float32");
      }(r.shape) : n, function (e, t, n, s) {
        var _loop2 = function _loop2(_r10) {
          var a = t[_r10],
              i = [];
          if (a.outputs.forEach(t => {
            var n = e[t.id];
            i.push(null != n ? n : null);
          }), null == a.gradient) throw new Error("Cannot compute gradient: gradient function not found for ".concat(a.kernelName, "."));
          var o = a.gradient(i);

          var _loop3 = function _loop3(_t34) {
            if (!(_t34 in o)) throw new Error("Cannot backprop through input ".concat(_t34, ". Available gradients found: ").concat(Object.keys(o), "."));
            var r = n(() => o[_t34]());
            if ("float32" !== r.dtype) throw new Error("Error in gradient for op ".concat(a.kernelName, ". The gradient of input ").concat(_t34, " must have 'float32' dtype, but has '").concat(r.dtype, "'"));
            var i = a.inputs[_t34];
            if (!p(r.shape, i.shape)) throw new Error("Error in gradient for op ".concat(a.kernelName, ". The gradient of input '").concat(_t34, "' has shape '").concat(r.shape, "', which does not match the shape of the input '").concat(i.shape, "'"));
            if (null == e[i.id]) e[i.id] = r;else {
              var _t35 = e[i.id];
              e[i.id] = s(_t35, r), _t35.dispose();
            }
          };

          for (var _t34 in a.inputs) {
            _loop3(_t34);
          }
        };

        for (var _r10 = t.length - 1; _r10 >= 0; _r10--) {
          _loop2(_r10);
        }
      }(e, a, e => this.tidy(e), vt);
      var s = t.map(t => e[t.id]);
      return 0 === this.state.gradientDepth && (this.state.activeTape.forEach(e => {
        for (var _t36 of e.saved) {
          _t36.dispose();
        }
      }), this.state.activeTape = null), {
        value: r,
        grads: s
      };
    });
  }

  customGrad(e) {
    var _this9 = this;

    return l(E(e), () => "The f passed in customGrad(f) must be a function."), function () {
      for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        t[_key4] = arguments[_key4];
      }

      var n;
      l(t.every(e => e instanceof st), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      var s = {};
      return t.forEach((e, t) => {
        s[t] = e;
      }), _this9.runKernelFunc({
        forwardFunc: (s, r) => (n = e(...t, r), l(n.value instanceof st, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), l(E(n.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), n.value),
        backwardsFunc: (e, s) => {
          var r = n.gradFunc(e, s),
              a = Array.isArray(r) ? r : [r];
          l(a.length === t.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), l(a.every(e => e instanceof st), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
          var i = {};
          return a.forEach((e, t) => {
            i[t] = () => e;
          }), i;
        },
        inputs: s
      });
    };
  }

  readSync(e) {
    return this.state.tensorInfo.get(e).backend.readSync(e);
  }

  read(e) {
    return this.state.tensorInfo.get(e).backend.read(e);
  }

  time(e) {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      var t = Ve(),
          n = yield _this10.backend.time(e);
      return n.wallMs = Ve() - t, n;
    })();
  }

  track(e) {
    return null != this.state.activeScope && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e;
  }

  get registeredVariables() {
    return this.state.registeredVariables;
  }

  reset() {
    this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new xt();

    for (var _e28 in this.registry) {
      this.disposeRegisteredKernels(_e28), this.registry[_e28].dispose(), delete this.registry[_e28];
    }

    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }

}

function kt() {
  var e = j();

  if (null == e._tfengine) {
    var _t37 = new W(e);

    e._tfengine = new yt(_t37);
  }

  return H = e._tfengine.ENV, tt = () => e._tfengine, e._tfengine;
}

yt.nextTensorId = 0, yt.nextVariableId = 0;
var wt = kt();

function vt(e, t) {
  return wt.runKernel("Add", {
    a: e,
    b: t
  });
}

function It(e) {
  if (e || "undefined" != typeof navigator && null != navigator) {
    if (e || (e = navigator), "ReactNative" === e.product) return !0;

    var _t38 = e.userAgent || e.vendor || window.opera;

    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(_t38) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(_t38.substr(0, 4));
  }

  return !1;
}

function $t() {
  return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}

var Nt = V();

function Ct(e, t) {
  var n = e;
  if ($(e)) return "string" === t ? [] : [e.length];
  if (!Array.isArray(e)) return [];
  var s = [];

  for (; Array.isArray(n) || $(n) && "string" !== t;) {
    s.push(n.length), n = n[0];
  }

  return Array.isArray(e) && V().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && St(e, s, []), s;
}

function St(e, t, n) {
  if (n = n || [], !Array.isArray(e) && !$(e)) return void l(0 === t.length, () => "Element arr[".concat(n.join("]["), "] is a primitive, but should be an array/TypedArray of ").concat(t[0], " elements"));
  l(t.length > 0, () => "Element arr[".concat(n.join("]["), "] should be a primitive, but is an array of ").concat(e.length, " elements")), l(e.length === t[0], () => "Element arr[".concat(n.join("]["), "] should have ").concat(t[0], " elements, but has ").concat(e.length, " elements"));
  var s = t.slice(1);

  for (var _t39 = 0; _t39 < e.length; ++_t39) {
    St(e[_t39], s, n.concat(_t39));
  }
}

function Tt(e, t, n, s) {
  if ("string_or_numeric" !== e) {
    if (null == e) throw new Error("Expected dtype cannot be null.");
    if ("numeric" !== e && e !== t || "numeric" === e && "string" === t) throw new Error("Argument '".concat(n, "' passed to '").concat(s, "' must be ").concat(e, " tensor, but got ").concat(t, " tensor"));
  }
}

function Et(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "numeric";
  if (e instanceof st) return Tt(s, e.dtype, t, n), e;
  var r = T(e);
  if ("string" !== r && ["bool", "int32", "float32"].indexOf(s) >= 0 && (r = s), Tt(s, r, t, n), null == e || !$(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) throw new Error("Argument '".concat(t, "' passed to '").concat(n, "' must be a Tensor or TensorLike, but got '").concat(null == e ? "null" : e.constructor.name, "'"));
  var a = Ct(e, r);
  $(e) || Array.isArray(e) || (e = [e]);
  var i = "string" !== r ? Ue(e, r) : h(e, [], !0);
  return wt.makeTensor(i, a, r);
}

function Rt(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "numeric";
  if (!Array.isArray(e)) throw new Error("Argument ".concat(t, " passed to ").concat(n, " must be a `Tensor[]` or `TensorLike[]`"));
  return e.map((e, r) => Et(e, "".concat(t, "[").concat(r, "]"), n, s));
}

function At(e) {
  var t = Object.keys(e);
  if (1 !== t.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with ".concat(t.length, " keys."));
  var n = t[0];
  var s = e[n];
  n.endsWith("_") && (n = n.substring(0, n.length - 1)), n += "__op";

  var r = function r() {
    wt.startScope(n);

    try {
      var _t40 = s(...arguments);

      return P(_t40) && console.error("Cannot return a Promise inside of tidy."), wt.endScope(_t40), _t40;
    } catch (e) {
      throw wt.endScope(null), e;
    }
  };

  return Object.defineProperty(r, "name", {
    value: n,
    configurable: !0
  }), r;
}

Nt.registerFlag("DEBUG", () => !1, e => {
  e && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Nt.registerFlag("IS_BROWSER", () => $t()), Nt.registerFlag("IS_NODE", () => "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node), Nt.registerFlag("IS_CHROME", () => "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)), Nt.registerFlag("PROD", () => !1), Nt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => Nt.getBool("DEBUG")), Nt.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => !0), Nt.registerFlag("IS_TEST", () => !1), Nt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => !0), Nt.registerFlag("WRAP_TO_IMAGEBITMAP", () => !1);
var Ft = At({
  complex_: function complex_(e, t) {
    var n = Et(e, "real", "complex"),
        s = Et(t, "imag", "complex");
    return u(n.shape, s.shape, "real and imag shapes, ".concat(n.shape, " and ").concat(s.shape, ", must match in call to tf.complex().")), wt.runKernel("Complex", {
      real: n,
      imag: s
    });
  }
});

function Dt(e, t, n, s) {
  if (null == s && (s = T(e)), "complex64" === s) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!$(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");

  if (null != t) {
    L(t);

    var _e29 = d(t),
        _s19 = d(n);

    l(_e29 === _s19, () => "Based on the provided shape, [".concat(t, "], the tensor should have ").concat(_e29, " values but has ").concat(_s19));

    for (var _e30 = 0; _e30 < n.length; ++_e30) {
      var _s20 = n[_e30],
          _r11 = _e30 !== n.length - 1 || _s20 !== d(t.slice(_e30));

      l(n[_e30] === t[_e30] || !_r11, () => "Error creating a new Tensor. Inferred shape (".concat(n, ") does not match the provided shape (").concat(t, "). "));
    }
  }

  return $(e) || Array.isArray(e) || (e = [e]), t = t || n, e = "string" !== s ? Ue(e, s) : h(e, [], !0), wt.makeTensor(e, t, s);
}

function _t(e, t, n) {
  return Dt(e, t, Ct(e, n), n);
}

var Ot = {
  float32: 4,
  float16: 2,
  int32: 4,
  uint16: 2,
  uint8: 1,
  bool: 1,
  complex64: 8
};

function Mt(_x2, _x3) {
  return _Mt.apply(this, arguments);
}

function _Mt() {
  _Mt = _asyncToGenerator(function* (e, t) {
    var n = [],
        s = [],
        r = Array.isArray(e) ? e.map(e => e.name) : Object.keys(e);

    var _loop32 = function _loop32(_a145) {
      var i = r[_a145],
          o = Array.isArray(e) ? e[_a145].tensor : e[i];
      if ("float32" !== o.dtype && "int32" !== o.dtype && "bool" !== o.dtype && "string" !== o.dtype && "complex64" !== o.dtype) throw new Error("Unsupported dtype in weight '".concat(i, "': ").concat(o.dtype));
      var l = {
        name: i,
        shape: o.shape,
        dtype: o.dtype
      };

      if ("string" === o.dtype) {
        var _e525 = new Promise( /*#__PURE__*/function () {
          var _ref38 = _asyncToGenerator(function* (e) {
            var t = yield o.bytes(),
                n = t.reduce((e, t) => e + t.length, 0) + 4 * t.length,
                s = new Uint8Array(n);
            var r = 0;

            for (var _e526 = 0; _e526 < t.length; _e526++) {
              var _n299 = t[_e526],
                  _a146 = new Uint8Array(new Uint32Array([_n299.length]).buffer);

              s.set(_a146, r), r += 4, s.set(_n299, r), r += _n299.length;
            }

            e(s);
          });

          return function (_x65) {
            return _ref38.apply(this, arguments);
          };
        }());

        s.push(_e525);
      } else s.push(o.data());

      null != t && (l.group = t), n.push(l);
    };

    for (var _a145 = 0; _a145 < r.length; ++_a145) {
      _loop32(_a145);
    }

    return {
      data: Lt(yield Promise.all(s)),
      specs: n
    };
  });
  return _Mt.apply(this, arguments);
}

function Lt(e) {
  if (null === e) throw new Error("Invalid input value: ".concat(JSON.stringify(e)));
  var t = 0;
  var n = [];
  e.forEach(e => {
    if (t += e.byteLength, n.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e)), !(e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name));
  });
  var s = new Uint8Array(t);
  var r = 0;
  return n.forEach(e => {
    s.set(new Uint8Array(e.buffer), r), r += e.byteLength;
  }), s.buffer;
}

var zt = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

function Bt(e) {
  return zt ? Buffer.byteLength(e) : new Blob([e]).size;
}

function Pt(e) {
  if (1 === e.length) return e[0];
  var t = 0;
  e.forEach(e => {
    t += e.byteLength;
  });
  var n = new Uint8Array(t);
  var s = 0;
  return e.forEach(e => {
    n.set(new Uint8Array(e), s), s += e.byteLength;
  }), n.buffer;
}

function Wt(e, t) {
  var n = {
    modelTopology: e.modelTopology,
    format: e.format,
    generatedBy: e.generatedBy,
    convertedBy: e.convertedBy,
    weightsManifest: t
  };
  return null != e.signature && (n.signature = e.signature), null != e.userDefinedMetadata && (n.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (n.modelInitializer = e.modelInitializer), null != e.trainingConfig && (n.trainingConfig = e.trainingConfig), n;
}

function Ut(e) {
  if (e.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {
    dateSaved: new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: null == e.modelTopology ? 0 : Bt(JSON.stringify(e.modelTopology)),
    weightSpecsBytes: null == e.weightSpecs ? 0 : Bt(JSON.stringify(e.weightSpecs)),
    weightDataBytes: null == e.weightData ? 0 : e.weightData.byteLength
  };
}

function Vt() {
  var e = function () {
    var e = e => {
      var t = e << 13,
          n = 0;

      for (; 0 == (8388608 & t);) {
        n -= 8388608, t <<= 1;
      }

      return t &= -8388609, n += 947912704, t | n;
    },
        t = new Uint32Array(2048);

    t[0] = 0;

    for (var _n23 = 1; _n23 < 1024; _n23++) {
      t[_n23] = e(_n23);
    }

    for (var _e31 = 1024; _e31 < 2048; _e31++) {
      t[_e31] = 939524096 + (_e31 - 1024 << 13);
    }

    return t;
  }(),
      t = function () {
    var e = new Uint32Array(64);
    e[0] = 0, e[31] = 1199570944, e[32] = 2147483648, e[63] = 3347054592;

    for (var _t41 = 1; _t41 < 31; _t41++) {
      e[_t41] = _t41 << 23;
    }

    for (var _t42 = 33; _t42 < 63; _t42++) {
      e[_t42] = 2147483648 + (_t42 - 32 << 23);
    }

    return e;
  }(),
      n = function () {
    var e = new Uint32Array(64);

    for (var _t43 = 0; _t43 < 64; _t43++) {
      e[_t43] = 1024;
    }

    return e[0] = e[32] = 0, e;
  }();

  return s => {
    var r = new ArrayBuffer(4 * s.length),
        a = new Uint32Array(r);

    for (var _r12 = 0; _r12 < s.length; _r12++) {
      var _i6 = s[_r12];
      a[_r12] = e[n[_i6 >> 10] + (1023 & _i6)] + t[_i6 >> 10];
    }

    return new Float32Array(r);
  };
}

class Gt {
  constructor() {
    this.saveRouters = [], this.loadRouters = [];
  }

  static getInstance() {
    return null == Gt.instance && (Gt.instance = new Gt()), Gt.instance;
  }

  static registerSaveRouter(e) {
    Gt.getInstance().saveRouters.push(e);
  }

  static registerLoadRouter(e) {
    Gt.getInstance().loadRouters.push(e);
  }

  static getSaveHandlers(e) {
    return Gt.getHandlers(e, "save");
  }

  static getLoadHandlers(e, t) {
    return Gt.getHandlers(e, "load", t);
  }

  static getHandlers(e, t, n) {
    var s = [];
    return ("load" === t ? Gt.getInstance().loadRouters : Gt.getInstance().saveRouters).forEach(t => {
      var r = t(e, n);
      null !== r && s.push(r);
    }), s;
  }

}

function Ht() {
  if (!V().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var e = "undefined" == typeof window ? self : window,
      t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
  if (null == t) throw new Error("The current browser does not appear to support IndexedDB.");
  return t;
}

function jt(e) {
  var t = e.result;
  t.createObjectStore("models_store", {
    keyPath: "modelPath"
  }), t.createObjectStore("model_info_store", {
    keyPath: "modelPath"
  });
}

class qt {
  constructor(e) {
    if (this.indexedDB = Ht(), null == e || !e) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = e;
  }

  save(e) {
    var _this11 = this;

    return _asyncToGenerator(function* () {
      if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      return _this11.databaseAction(_this11.modelPath, e);
    })();
  }

  load() {
    var _this12 = this;

    return _asyncToGenerator(function* () {
      return _this12.databaseAction(_this12.modelPath);
    })();
  }

  databaseAction(e, t) {
    return new Promise((e, n) => {
      var s = this.indexedDB.open("tensorflowjs", 1);
      s.onupgradeneeded = () => jt(s), s.onsuccess = () => {
        var r = s.result;

        if (null == t) {
          var _t44 = r.transaction("models_store", "readonly"),
              _s21 = _t44.objectStore("models_store").get(this.modelPath);

          _s21.onsuccess = () => {
            if (null == _s21.result) return r.close(), n(new Error("Cannot find model with path '".concat(this.modelPath, "' in IndexedDB.")));
            e(_s21.result.modelArtifacts);
          }, _s21.onerror = e => (r.close(), n(_s21.error)), _t44.oncomplete = () => r.close();
        } else {
          var _s22 = Ut(t),
              _a8 = r.transaction("model_info_store", "readwrite");

          var _i7 = _a8.objectStore("model_info_store");

          var _o5 = _i7.put({
            modelPath: this.modelPath,
            modelArtifactsInfo: _s22
          });

          var _l2;

          _o5.onsuccess = () => {
            _l2 = r.transaction("models_store", "readwrite");

            var o = _l2.objectStore("models_store").put({
              modelPath: this.modelPath,
              modelArtifacts: t,
              modelArtifactsInfo: _s22
            });

            o.onsuccess = () => e({
              modelArtifactsInfo: _s22
            }), o.onerror = e => {
              _i7 = _a8.objectStore("model_info_store");

              var t = _i7.delete(this.modelPath);

              t.onsuccess = () => (r.close(), n(o.error)), t.onerror = e => (r.close(), n(o.error));
            };
          }, _o5.onerror = e => (r.close(), n(_o5.error)), _a8.oncomplete = () => {
            null == _l2 ? r.close() : _l2.oncomplete = () => r.close();
          };
        }
      }, s.onerror = e => n(s.error);
    });
  }

}

qt.URL_SCHEME = "indexeddb://";

var Kt = e => {
  return V().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(qt.URL_SCHEME) ? (t = e.slice(qt.URL_SCHEME.length), new qt(t)) : null;
  var t;
};

Gt.registerSaveRouter(Kt), Gt.registerLoadRouter(Kt);

class Xt {
  constructor() {
    this.indexedDB = Ht();
  }

  listModels() {
    var _this13 = this;

    return _asyncToGenerator(function* () {
      return new Promise((e, t) => {
        var n = _this13.indexedDB.open("tensorflowjs", 1);

        n.onupgradeneeded = () => jt(n), n.onsuccess = () => {
          var s = n.result,
              r = s.transaction("model_info_store", "readonly"),
              a = r.objectStore("model_info_store").getAll();
          a.onsuccess = () => {
            var t = {};

            for (var _e32 of a.result) {
              t[_e32.modelPath] = _e32.modelArtifactsInfo;
            }

            e(t);
          }, a.onerror = e => (s.close(), t(a.error)), r.oncomplete = () => s.close();
        }, n.onerror = e => t(n.error);
      });
    })();
  }

  removeModel(e) {
    var _this14 = this;

    return _asyncToGenerator(function* () {
      var t;
      return e = (t = e).startsWith(qt.URL_SCHEME) ? t.slice(qt.URL_SCHEME.length) : t, new Promise((t, n) => {
        var s = _this14.indexedDB.open("tensorflowjs", 1);

        s.onupgradeneeded = () => jt(s), s.onsuccess = () => {
          var r = s.result,
              a = r.transaction("model_info_store", "readwrite"),
              i = a.objectStore("model_info_store"),
              o = i.get(e);
          var l;
          o.onsuccess = () => {
            if (null == o.result) return r.close(), n(new Error("Cannot find model with path '".concat(e, "' in IndexedDB.")));
            {
              var _s23 = i.delete(e),
                  _a9 = () => {
                l = r.transaction("models_store", "readwrite");
                var s = l.objectStore("models_store").delete(e);
                s.onsuccess = () => t(o.result.modelArtifactsInfo), s.onerror = e => n(o.error);
              };

              _s23.onsuccess = _a9, _s23.onerror = e => (_a9(), r.close(), n(o.error));
            }
          }, o.onerror = e => (r.close(), n(o.error)), a.oncomplete = () => {
            null == l ? r.close() : l.oncomplete = () => r.close();
          };
        }, s.onerror = e => n(s.error);
      });
    })();
  }

}

var Yt = "tensorflowjs_models",
    Jt = "info",
    Zt = "model_topology",
    Qt = "weight_specs",
    en = "weight_data",
    tn = "model_metadata";

function nn(e) {
  return {
    info: [Yt, e, Jt].join("/"),
    topology: [Yt, e, Zt].join("/"),
    weightSpecs: [Yt, e, Qt].join("/"),
    weightData: [Yt, e, en].join("/"),
    modelMetadata: [Yt, e, tn].join("/")
  };
}

function sn(e) {
  for (var _t45 of Object.values(e)) {
    window.localStorage.removeItem(_t45);
  }
}

function rn(e) {
  var t = e.split("/");
  if (t.length < 3) throw new Error("Invalid key format: ".concat(e));
  return t.slice(1, t.length - 1).join("/");
}

class an {
  constructor(e) {
    if (!V().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, null == e || !e) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = e, this.keys = nn(this.modelPath);
  }

  save(e) {
    var _this15 = this;

    return _asyncToGenerator(function* () {
      if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      {
        var _t46 = JSON.stringify(e.modelTopology),
            _n24 = JSON.stringify(e.weightSpecs),
            _s24 = Ut(e);

        try {
          return _this15.LS.setItem(_this15.keys.info, JSON.stringify(_s24)), _this15.LS.setItem(_this15.keys.topology, _t46), _this15.LS.setItem(_this15.keys.weightSpecs, _n24), _this15.LS.setItem(_this15.keys.weightData, function (e) {
            if (zt) return Buffer.from(e).toString("base64");
            var t = new Uint8Array(e);
            var n = "";

            for (var _e33 = 0, _s25 = t.length; _e33 < _s25; _e33++) {
              n += String.fromCharCode(t[_e33]);
            }

            return btoa(n);
          }(e.weightData)), _this15.LS.setItem(_this15.keys.modelMetadata, JSON.stringify({
            format: e.format,
            generatedBy: e.generatedBy,
            convertedBy: e.convertedBy,
            signature: null != e.signature ? e.signature : void 0,
            userDefinedMetadata: null != e.userDefinedMetadata ? e.userDefinedMetadata : void 0,
            modelInitializer: null != e.modelInitializer ? e.modelInitializer : void 0,
            trainingConfig: null != e.trainingConfig ? e.trainingConfig : void 0
          })), {
            modelArtifactsInfo: _s24
          };
        } catch (e) {
          throw sn(_this15.keys), new Error("Failed to save model '".concat(_this15.modelPath, "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=").concat(_s24.modelTopologyBytes, ", weightSpecsBytes=").concat(_s24.weightSpecsBytes, ", weightDataBytes=").concat(_s24.weightDataBytes, "."));
        }
      }
    })();
  }

  load() {
    var _this16 = this;

    return _asyncToGenerator(function* () {
      var e = JSON.parse(_this16.LS.getItem(_this16.keys.info));
      if (null == e) throw new Error("In local storage, there is no model with name '".concat(_this16.modelPath, "'"));
      if ("JSON" !== e.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
      var t = {},
          n = JSON.parse(_this16.LS.getItem(_this16.keys.topology));
      if (null == n) throw new Error("In local storage, the topology of model '".concat(_this16.modelPath, "' is missing."));
      t.modelTopology = n;
      var s = JSON.parse(_this16.LS.getItem(_this16.keys.weightSpecs));
      if (null == s) throw new Error("In local storage, the weight specs of model '".concat(_this16.modelPath, "' are missing."));
      t.weightSpecs = s;

      var r = _this16.LS.getItem(_this16.keys.modelMetadata);

      if (null != r) {
        var _e34 = JSON.parse(r);

        t.format = _e34.format, t.generatedBy = _e34.generatedBy, t.convertedBy = _e34.convertedBy, null != _e34.signature && (t.signature = _e34.signature), null != _e34.userDefinedMetadata && (t.userDefinedMetadata = _e34.userDefinedMetadata), null != _e34.modelInitializer && (t.modelInitializer = _e34.modelInitializer), null != _e34.trainingConfig && (t.trainingConfig = _e34.trainingConfig);
      }

      var a = _this16.LS.getItem(_this16.keys.weightData);

      if (null == a) throw new Error("In local storage, the binary weight values of model '".concat(_this16.modelPath, "' are missing."));
      return t.weightData = function (e) {
        if (zt) {
          var _t47 = Buffer.from(e, "base64");

          return _t47.buffer.slice(_t47.byteOffset, _t47.byteOffset + _t47.byteLength);
        }

        var t = atob(e),
            n = new Uint8Array(t.length);

        for (var _e35 = 0; _e35 < t.length; ++_e35) {
          n.set([t.charCodeAt(_e35)], _e35);
        }

        return n.buffer;
      }(a), t;
    })();
  }

}

an.URL_SCHEME = "localstorage://";

var on = e => {
  return V().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(an.URL_SCHEME) ? (t = e.slice(an.URL_SCHEME.length), new an(t)) : null;
  var t;
};

Gt.registerSaveRouter(on), Gt.registerLoadRouter(on);

class ln {
  constructor() {
    l(V().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), l("undefined" == typeof window || void 0 !== window.localStorage, () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
  }

  listModels() {
    var _this17 = this;

    return _asyncToGenerator(function* () {
      var e = {},
          t = Yt + "/",
          n = "/" + Jt;

      for (var _s26 = 0; _s26 < _this17.LS.length; ++_s26) {
        var _r13 = _this17.LS.key(_s26);

        _r13.startsWith(t) && _r13.endsWith(n) && (e[rn(_r13)] = JSON.parse(_this17.LS.getItem(_r13)));
      }

      return e;
    })();
  }

  removeModel(e) {
    var _this18 = this;

    return _asyncToGenerator(function* () {
      var t;
      var n = nn(e = (t = e).startsWith(an.URL_SCHEME) ? t.slice(an.URL_SCHEME.length) : t);
      if (null == _this18.LS.getItem(n.info)) throw new Error("Cannot find model at path '".concat(e, "'"));
      var s = JSON.parse(_this18.LS.getItem(n.info));
      return sn(n), s;
    })();
  }

}

class un {
  constructor() {
    this.managers = {};
  }

  static getInstance() {
    return null == un.instance && (un.instance = new un()), un.instance;
  }

  static registerManager(e, t) {
    l(null != e, () => "scheme must not be undefined or null."), e.endsWith("://") && (e = e.slice(0, e.indexOf("://"))), l(e.length > 0, () => "scheme must not be an empty string.");
    var n = un.getInstance();
    l(null == n.managers[e], () => "A model store manager is already registered for scheme '".concat(e, "'.")), n.managers[e] = t;
  }

  static getManager(e) {
    var t = this.getInstance().managers[e];
    if (null == t) throw new Error("Cannot find model manager for scheme '".concat(e, "'"));
    return t;
  }

  static getSchemes() {
    return Object.keys(this.getInstance().managers);
  }

}

class cn {
  fetch(e, t) {
    return fetch(e, t);
  }

  now() {
    return performance.now();
  }

  encode(e, t) {
    if ("utf-8" !== t && "utf8" !== t) throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));
    return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e);
  }

  decode(e, t) {
    return new TextDecoder(t).decode(e);
  }

}

if (V().get("IS_BROWSER")) {
  V().setPlatform("browser", new cn());

  try {
    un.registerManager(an.URL_SCHEME, new ln());
  } catch (e) {}

  try {
    un.registerManager(qt.URL_SCHEME, new Xt());
  } catch (e) {}
}

var hn;

function dn(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";
  var n = arguments.length > 2 ? arguments[2] : undefined;
  return t = t || "float32", L(e), new et(e, t, n);
}

V().get("IS_NODE") && V().setPlatform("node", new class {
  constructor() {
    this.util = __webpack_require__(15895), this.textEncoder = new this.util.TextEncoder();
  }

  fetch(e, t) {
    return null != V().global.fetch ? V().global.fetch(e, t) : (null == hn && (hn = __webpack_require__(76474)), hn(e, t));
  }

  now() {
    var e = process.hrtime();
    return 1e3 * e[0] + e[1] / 1e6;
  }

  encode(e, t) {
    if ("utf-8" !== t && "utf8" !== t) throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));
    return this.textEncoder.encode(e);
  }

  decode(e, t) {
    return 0 === e.length ? "" : new this.util.TextDecoder(t).decode(e);
  }

}());
var pn = At({
  cast_: function cast_(e, t) {
    var n = Et(e, "x", "cast");
    if (!function (e) {
      return "bool" === e || "complex64" === e || "float32" === e || "int32" === e || "string" === e;
    }(t)) throw new Error("Failed to cast to unknown dtype ".concat(t));
    if ("string" === t && "string" !== n.dtype || "string" !== t && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
    return wt.runKernel("Cast", {
      x: n
    }, {
      dtype: t
    });
  }
}),
    fn = At({
  clone_: function clone_(e) {
    var t = Et(e, "x", "clone", "string_or_numeric");
    return wt.runKernel("Identity", {
      x: t
    });
  }
});

function gn(e) {
  return new Promise(e => setTimeout(e)).then(e);
}

kt(), nt = {
  buffer: dn,
  cast: pn,
  clone: fn,
  print: function print(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    console.log(e.toString(t));
  }
};

class mn {
  constructor(e) {
    if (!V().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(mn.URL_SCHEME) && (e = e.slice(mn.URL_SCHEME.length)), null != e && 0 !== e.length || (e = "model"), this.modelJsonFileName = e + ".json", this.weightDataFileName = e + ".weights.bin";
  }

  save(e) {
    var _this19 = this;

    return _asyncToGenerator(function* () {
      if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
      var t = window.URL.createObjectURL(new Blob([e.weightData], {
        type: "application/octet-stream"
      }));
      if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
      {
        var _n25 = Wt(e, [{
          paths: ["./" + _this19.weightDataFileName],
          weights: e.weightSpecs
        }]),
            _s27 = window.URL.createObjectURL(new Blob([JSON.stringify(_n25)], {
          type: "application/json"
        })),
            _r14 = null == _this19.modelJsonAnchor ? document.createElement("a") : _this19.modelJsonAnchor;

        if (_r14.download = _this19.modelJsonFileName, _r14.href = _s27, yield gn(() => _r14.dispatchEvent(new MouseEvent("click"))), null != e.weightData) {
          var _e36 = null == _this19.weightDataAnchor ? document.createElement("a") : _this19.weightDataAnchor;

          _e36.download = _this19.weightDataFileName, _e36.href = t, yield gn(() => _e36.dispatchEvent(new MouseEvent("click")));
        }

        return {
          modelArtifactsInfo: Ut(e)
        };
      }
    })();
  }

}

function bn(e, t, n, s) {
  !function (e) {
    l(null != e && Array.isArray(e) && e.length > 0, () => "promises must be a none empty array");
  }(e), function (e, t) {
    l(e >= 0 && e <= 1, () => "Progress fraction must be in range [0, 1], but got startFraction ".concat(e)), l(t >= 0 && t <= 1, () => "Progress fraction must be in range [0, 1], but got endFraction ".concat(t)), l(t >= e, () => "startFraction must be no more than endFraction, but got startFraction ".concat(e, " and endFraction ").concat(t));
  }(n = null == n ? 0 : n, s = null == s ? 1 : s);
  var r = 0;
  return Promise.all(e.map(a => (a.then(a => {
    var i = n + ++r / e.length * (s - n);
    return t(i), a;
  }), a)));
}

mn.URL_SCHEME = "downloads://", Gt.registerSaveRouter(e => V().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(mn.URL_SCHEME) ? function () {
  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "model";
  return new mn(e);
}(e.slice(mn.URL_SCHEME.length)) : null);

class xn {
  constructor(e, t) {
    if (this.DEFAULT_METHOD = "POST", null == t && (t = {}), this.weightPathPrefix = t.weightPathPrefix, this.onProgress = t.onProgress, this.weightUrlConverter = t.weightUrlConverter, null != t.fetchFunc ? (l("function" == typeof t.fetchFunc, () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this.fetch = t.fetchFunc) : this.fetch = V().platform.fetch, l(null != e && e.length > 0, () => "URL path for http must not be null, undefined or empty."), Array.isArray(e) && l(2 === e.length, () => "URL paths for http must have a length of 2, (actual length is ".concat(e.length, ").")), this.path = e, null != t.requestInit && null != t.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = t.requestInit || {};
  }

  save(e) {
    var _this20 = this;

    return _asyncToGenerator(function* () {
      if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
      var t = Object.assign({
        method: _this20.DEFAULT_METHOD
      }, _this20.requestInit);
      t.body = new FormData();
      var n = Wt(e, [{
        paths: ["./model.weights.bin"],
        weights: e.weightSpecs
      }]);
      t.body.append("model.json", new Blob([JSON.stringify(n)], {
        type: "application/json"
      }), "model.json"), null != e.weightData && t.body.append("model.weights.bin", new Blob([e.weightData], {
        type: "application/octet-stream"
      }), "model.weights.bin");
      var s = yield _this20.fetch(_this20.path, t);
      if (s.ok) return {
        modelArtifactsInfo: Ut(e),
        responses: [s]
      };
      throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status ".concat(s.status, "."));
    })();
  }

  load() {
    var _this21 = this;

    return _asyncToGenerator(function* () {
      var e = yield _this21.fetch(_this21.path, _this21.requestInit);
      if (!e.ok) throw new Error("Request to ".concat(_this21.path, " failed with status code ").concat(e.status, ". Please verify this URL points to the model JSON of the model to load."));
      var t;

      try {
        t = yield e.json();
      } catch (e) {
        var _t48 = "Failed to parse model JSON of response from ".concat(_this21.path, ".");

        throw _this21.path.endsWith(".pb") ? _t48 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : _t48 += " Please make sure the server is serving valid JSON for this request.", new Error(_t48);
      }

      if (null == t.modelTopology && null == t.weightsManifest) throw new Error("The JSON from HTTP path ".concat(_this21.path, " contains neither model topology or manifest for weights."));
      return function () {
        var _ref = _asyncToGenerator(function* (e, t) {
          var n = {
            modelTopology: e.modelTopology,
            format: e.format,
            generatedBy: e.generatedBy,
            convertedBy: e.convertedBy
          };

          if (null != e.trainingConfig && (n.trainingConfig = e.trainingConfig), null != e.weightsManifest) {
            var [_s28, _r15] = yield t(e.weightsManifest);
            n.weightSpecs = _s28, n.weightData = _r15;
          }

          return null != e.signature && (n.signature = e.signature), null != e.userDefinedMetadata && (n.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (n.modelInitializer = e.modelInitializer), n;
        });

        return function (_x4, _x5) {
          return _ref.apply(this, arguments);
        };
      }()(t, e => _this21.loadWeights(e));
    })();
  }

  loadWeights(e) {
    var _this22 = this;

    return _asyncToGenerator(function* () {
      var t = Array.isArray(_this22.path) ? _this22.path[1] : _this22.path,
          [n, s] = function (e) {
        var t = e.lastIndexOf("/"),
            n = e.lastIndexOf("?");
        return [e.substring(0, t) + "/", n > t ? e.substring(n) : ""];
      }(t),
          r = _this22.weightPathPrefix || n,
          a = [];

      for (var _t49 of e) {
        a.push(..._t49.weights);
      }

      var i = [],
          o = [];

      for (var _t50 of e) {
        for (var _e37 of _t50.paths) {
          null != _this22.weightUrlConverter ? o.push(_this22.weightUrlConverter(_e37)) : i.push(r + _e37 + s);
        }
      }

      return _this22.weightUrlConverter && i.push(...(yield Promise.all(o))), [a, Pt(yield function () {
        var _ref2 = _asyncToGenerator(function* (e, t) {
          null == t && (t = {});
          var n = null == t.fetchFunc ? V().platform.fetch : t.fetchFunc,
              s = e.map(e => n(e, t.requestInit, {
            isBinary: !0
          })),
              r = (null == t.onProgress ? yield Promise.all(s) : yield bn(s, t.onProgress, 0, .5)).map(e => e.arrayBuffer());
          return null == t.onProgress ? yield Promise.all(r) : yield bn(r, t.onProgress, .5, 1);
        });

        return function (_x6, _x7) {
          return _ref2.apply(this, arguments);
        };
      }()(i, {
        requestInit: _this22.requestInit,
        fetchFunc: _this22.fetch,
        onProgress: _this22.onProgress
      }))];
    })();
  }

}

function yn(e) {
  return null != e.match(xn.URL_SCHEME_REGEX);
}

xn.URL_SCHEME_REGEX = /^https?:\/\//;

var kn = (e, t) => {
  if ("undefined" == typeof fetch && (null == t || null == t.fetchFunc)) return null;
  {
    var _n26 = !0;

    if (_n26 = Array.isArray(e) ? e.every(e => yn(e)) : yn(e), _n26) return wn(e, t);
  }
  return null;
};

function wn(e, t) {
  return new xn(e, t);
}

Gt.registerSaveRouter(kn), Gt.registerLoadRouter(kn);
var vn = At({
  matMul_: function matMul_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Et(e, "a", "matMul"),
        a = Et(t, "b", "matMul");
    return [r, a] = ft(r, a), wt.runKernel("BatchMatMul", {
      a: r,
      b: a
    }, {
      transposeA: n,
      transposeB: s
    });
  }
}),
    In = At({
  oneHot_: function oneHot_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    if (t < 2) throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));
    var r = Et(e, "indices", "oneHot", "int32");
    return wt.runKernel("OneHot", {
      indices: r
    }, {
      depth: t,
      onValue: n,
      offValue: s
    });
  }
}),
    $n = At({
  transpose_: function transpose_(e, t) {
    var n = Et(e, "x", "transpose");
    return null == t && (t = n.shape.map((e, t) => t).reverse()), l(n.rank === t.length, () => "Error in transpose: rank of input ".concat(n.rank, " must match length of perm ").concat(t, ".")), t.forEach(e => {
      l(e >= 0 && e < n.rank, () => "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got ".concat(t));
    }), n.rank <= 1 ? n.clone() : wt.runKernel("Transpose", {
      x: n
    }, {
      perm: t
    });
  }
});

function Nn(e, t) {
  var n = e.shape.length,
      s = t.shape.length;
  if (n < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was ".concat(n, "."));
  if (s < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ".concat(s, "."));
  if ("int32" !== t.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was ".concat(t.dtype, "."));
  if (t.shape[s - 1] > n) throw new Error("index innermost dimension length must be <= tensor rank; saw: ".concat(t.shape[s - 1], " vs. ").concat(n));
  if (0 === d(e.shape)) throw new Error("Requested more than 0 entries, but input is empty. Input shape: ".concat(e.shape, "."));
  var r = t.shape,
      a = r[r.length - 1];
  var i = 1;

  for (var _e38 = 0; _e38 < r.length - 1; ++_e38) {
    i *= r[_e38];
  }

  var o = e.shape,
      l = r.slice();
  l.pop();
  var u = 1;

  for (var _e39 = a; _e39 < n; ++_e39) {
    u *= o[_e39], l.push(o[_e39]);
  }

  var c = [...A(e.shape).map(e => e / u), 1].slice(0, a);
  return [l, i, u, c];
}

function Cn(e, t, n) {
  var s = t.rank > 1 ? t.shape[t.rank - 1] : 1,
      r = t.rank > 1 ? t.rank - 1 : 1,
      a = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ".concat(n.shape, ", indices.shape: ").concat(t.shape, ", shape: ").concat(e, ", sliceDim: ").concat(s, ", and batchDim: ").concat(r, ".");
  if (n.rank < r) throw new Error(a + " update.rank < ".concat(r, ". "));
  if (e.length < s + (n.rank - r)) throw new Error(a + " Output shape length < ".concat(s + (n.rank - r)));
  if (n.rank !== r + e.length - s) throw new Error(a + " update.rank != " + (r + e.length - s));

  for (var _e40 = 0; _e40 < r; ++_e40) {
    if (n.shape[_e40] !== t.shape[_e40]) throw new Error(a + " updates.shape[".concat(_e40, "] (").concat(n.shape[_e40], ") != indices.shape[").concat(_e40, "] (").concat(t.shape[_e40], ")."));
  }

  for (var _t51 = 0; _t51 < n.rank - r; ++_t51) {
    if (n.shape[_t51 + r] !== e[_t51 + s]) throw new Error(a + " updates.shape[".concat(_t51 + r, "] (").concat(n.shape[_t51 + r], ") != shape[").concat(_t51 + r, "] (").concat(e[_t51 + r], ")"));
  }
}

function Sn(e, t, n) {
  var s = t.shape.length,
      r = s > 1 ? t.shape[s - 1] : 1,
      a = n.length;
  var i = 1;

  for (var _e41 = r; _e41 < a; ++_e41) {
    i *= n[_e41];
  }

  var o = r < 1 ? 1 : r;
  return {
    sliceRank: r,
    numUpdates: d(t.shape) / o,
    sliceSize: i,
    strides: [...A(n.slice(0, r)), 1],
    outputSize: d(n)
  };
}

function Tn(e, t, n) {
  var s = e.shape.length;
  l(s === t.length, () => "Error in slice".concat(s, "D: Length of begin ").concat(t, " must match the rank of the array (").concat(s, ").")), l(s === n.length, () => "Error in slice".concat(s, "D: Length of size ").concat(n, " must match the rank of the array (").concat(s, ")."));

  var _loop4 = function _loop4(_r16) {
    l(t[_r16] + n[_r16] <= e.shape[_r16], () => "Error in slice".concat(s, "D: begin[").concat(_r16, "] + size[").concat(_r16, "] (").concat(t[_r16] + n[_r16], ") would overflow input.shape[").concat(_r16, "] (").concat(e.shape[_r16], ")"));
  };

  for (var _r16 = 0; _r16 < s; ++_r16) {
    _loop4(_r16);
  }
}

function En(e) {
  var t = [];
  var n = 0;

  for (; e > 0;) {
    1 & e && t.push(n), e /= 2, n++;
  }

  return t;
}

function Rn(e, t, n) {
  var s = [];

  for (var _r17 = 0; _r17 < e.length; _r17++) {
    s[_r17] = Math.ceil((t[_r17] - e[_r17]) / n[_r17]);
  }

  return s;
}

function An(e, t, n, s) {
  var r = [...e];

  for (var _e42 = r.length; _e42 < s.length; _e42++) {
    r.push(1);
  }

  for (var _e43 = 0; _e43 < n; _e43++) {
    0 === _e43 ? r[t] = 1 : (r.splice(t, 0, 1), r.pop());
  }

  return r;
}

function Fn(e, t, n) {
  return n <= e ? n : n - (t - 1);
}

function Dn(e, t) {
  var n = [];

  for (var _s29 = 0; _s29 < e; _s29++) {
    n.push(t + _s29);
  }

  return n;
}

function _n(e, t, n, s, r, a, i, o, l) {
  var u = e.length;
  var c = new Array(u),
      h = new Array(u),
      d = new Array(u);

  if (t.length && n > 0) {
    var _l3 = t[0],
        _u3 = n + 1;

    c = On(i, _l3, _u3, s, e), h = Mn(o, _l3, _u3, r, e), d = An(a, _l3, _u3, e);
  } else for (var _t52 = 0; _t52 < u; _t52++) {
    c[_t52] = zn(i, s, a, e, _t52, l), h[_t52] = Bn(o, r, a, e, _t52, l), d[_t52] = Ln(a, _t52, l);
  }

  return {
    begin: c,
    end: h,
    strides: d
  };
}

function On(e, t, n, s, r) {
  var a = [...r],
      i = Dn(n, t);

  for (var _r18 = 0; _r18 < a.length; _r18++) {
    if (i.indexOf(_r18) > -1) a[_r18] = 0;else {
      var _i8 = Fn(t, n, _r18);

      var _o6 = s[_i8];
      e & 1 << _i8 && (_o6 = 0), a[_r18] = _o6;
    }
  }

  return a;
}

function Mn(e, t, n, s, r) {
  var i = [...r],
      o = Dn(n, t);

  for (var _r19 = 0; _r19 < i.length; _r19++) {
    if (o.indexOf(_r19) > -1) i[_r19] = Number.MAX_SAFE_INTEGER;else {
      var _a10 = Fn(t, n, _r19);

      var _o7 = s[_a10];
      e & 1 << _a10 && (_o7 = Number.MAX_SAFE_INTEGER), i[_r19] = _o7;
    }
  }

  for (var _e44 = 0; _e44 < i.length; _e44++) {
    var _t53 = r[_e44];
    i[_e44] < 0 && (i[_e44] += _t53), i[_e44] = a(0, i[_e44], r[_e44]);
  }

  return i;
}

function Ln(e, t, n) {
  var s = e[t];
  return (n & 1 << t || null == s) && (s = 1), s;
}

function zn(e, t, n, s, r, i) {
  var o = t[r];
  (e & 1 << r || i & 1 << r || null == o) && (o = (n[r] || 1) > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var l = s[r];
  return o < 0 && (o += l), o = a(0, o, l - 1), o;
}

function Bn(e, t, n, s, r, i) {
  var o = t[r];
  var l = n[r] || 1;
  (e & 1 << r || i & 1 << r || null == o) && (o = l > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var u = s[r];
  return o < 0 && (o += u), o = l > 0 ? a(0, o, u) : a(-1, o, u - 1), o;
}

function Pn(e, t, n) {
  var s = n.length;

  for (var _e45 = 0; _e45 < n.length; _e45++) {
    if (n[_e45] > 1) {
      s = _e45;
      break;
    }
  }

  for (var _r20 = s + 1; _r20 < n.length; _r20++) {
    if (t[_r20] > 0 || n[_r20] !== e[_r20]) return !1;
  }

  return !0;
}

function Wn(e, t) {
  var n = e.length > 0 ? e[e.length - 1] : 1;

  for (var _s30 = 0; _s30 < e.length - 1; _s30++) {
    n += e[_s30] * t[_s30];
  }

  return n;
}

function Un(e, t, n) {
  var s;
  var r = e.shape.length;
  var a;
  return s = "number" == typeof t ? [t, ...new Array(r - 1).fill(0)] : t.length < r ? t.concat(new Array(r - t.length).fill(0)) : t.slice(), s.forEach(e => {
    l(-1 !== e, () => "slice() does not support negative begin indexing.");
  }), a = null == n ? new Array(r).fill(-1) : "number" == typeof n ? [n, ...new Array(r - 1).fill(-1)] : n.length < r ? n.concat(new Array(r - n.length).fill(-1)) : n, a = a.map((t, n) => t >= 0 ? t : (l(-1 === t, () => "Negative size values should be exactly -1 but got ".concat(t, " for the slice() size at index ").concat(n, ".")), e.shape[n] - s[n])), [s, a];
}

function Vn(e, t, n, s, r, a, i, o, l) {
  var u = t.slice(),
      c = n.slice(),
      h = s;
  null == s && (h = new Array(u.length));
  var d = En(i);
  if (d.length > 1) throw new Error("Multiple ellipses in slice is not allowed.");
  if (0 !== i && 0 !== o) throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
  if (0 !== i && 0 !== l) throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
  var p = e.length - u.length,
      f = En(o),
      g = e.slice();
  f.forEach(e => {
    u[e] = 0, c[e] = 1, g.splice(e, 0, 1);
  });

  var {
    begin: m,
    end: b,
    strides: x
  } = _n(g, d, p, u, c, h, r, a, i);

  u = m, c = b, h = x;
  var y = En(l);
  y.forEach(e => {
    c[e] = u[e] + 1, h[e] = 1;
  });
  var k = Rn(u, c, h),
      w = k.filter((e, t) => -1 === y.indexOf(t));
  return {
    nonStrided: h.every(e => 1 === e),
    $begin: u,
    $end: c,
    $strides: h,
    size: k,
    newShape: g,
    outShape: w
  };
}

var Gn = {
  __proto__: null,
  assertParamsValid: Tn,
  maskToAxes: En,
  computeOutShape: Rn,
  stridesWithElidedDims: An,
  getNormalizedAxes: _n,
  startIndicesWithElidedDims: On,
  stopIndicesWithElidedDims: Mn,
  stridesForAxis: Ln,
  startForAxis: zn,
  stopForAxis: Bn,
  isSliceContinous: Pn,
  computeFlatOffset: Wn,
  parseSliceParams: Un,
  sliceInfo: Vn
};

class Hn {
  getClassName() {
    return this.constructor.className;
  }

  static fromConfig(e, t) {
    return new e(t);
  }

}

class jn {
  constructor() {
    this.classNameMap = {};
  }

  static getMap() {
    return null == jn.instance && (jn.instance = new jn()), jn.instance;
  }

  static register(e) {
    jn.getMap().classNameMap[e.className] = [e, e.fromConfig];
  }

}

function qn(e) {
  l(null != e.className, () => "Class being registered does not have the static className property defined."), l("string" == typeof e.className, () => "className is required to be a string, but got type " + typeof e.className), l(e.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), jn.register(e);
}

function Kn() {
  return wt;
}

function Xn() {
  return wt.memory();
}

function Yn(e, t) {
  return wt.tidy(e, t);
}

function Jn(e) {
  gt(e).forEach(e => e.dispose());
}

function Zn(e) {
  return wt.keep(e);
}

function Qn(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return wt.registerBackend(e, t, n);
}

var es = At({
  add_: function add_(e, t) {
    var n = Et(e, "a", "add"),
        s = Et(t, "b", "add");
    return [n, s] = ft(n, s), wt.runKernel("Add", {
      a: n,
      b: s
    });
  }
}),
    ts = At({
  floorDiv_: function floorDiv_(e, t) {
    var n = Et(e, "a", "floorDiv"),
        s = Et(t, "b", "floorDiv");
    return [n, s] = ft(n, s), wt.runKernel("FloorDiv", {
      a: n,
      b: s
    });
  }
}),
    ns = At({
  div_: function div_(e, t) {
    var n = Et(e, "a", "div"),
        s = Et(t, "b", "div");
    return [n, s] = ft(n, s), "int32" === n.dtype && "int32" === s.dtype ? ts(n, s) : wt.runKernel("RealDiv", {
      a: n,
      b: s
    }, {});
  }
}),
    ss = At({
  mul_: function mul_(e, t) {
    var n = Et(e, "a", "mul"),
        s = Et(t, "b", "mul");
    return [n, s] = ft(n, s), wt.runKernel("Multiply", {
      a: n,
      b: s
    });
  }
}),
    rs = At({
  abs_: function abs_(e) {
    var t = Et(e, "x", "abs");
    return wt.runKernel("complex64" === t.dtype ? "ComplexAbs" : "Abs", {
      x: t
    });
  }
}),
    as = At({
  acos_: function acos_(e) {
    var t = Et(e, "x", "acos");
    return wt.runKernel("Acos", {
      x: t
    });
  }
}),
    is = At({
  acosh_: function acosh_(e) {
    var t = Et(e, "x", "acosh");
    return wt.runKernel("Acosh", {
      x: t
    });
  }
}),
    os = At({
  all_: function all_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "all", "bool");
    return wt.runKernel("All", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    ls = At({
  any_: function any_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "any", "bool");
    return wt.runKernel("Any", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    us = At({
  argMax_: function argMax_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "argMax");
    return wt.runKernel("ArgMax", {
      x: n
    }, {
      axis: t
    });
  }
}),
    cs = At({
  argMin_: function argMin_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "argMin");
    return wt.runKernel("ArgMin", {
      x: n
    }, {
      axis: t
    });
  }
}),
    hs = At({
  asin_: function asin_(e) {
    var t = Et(e, "x", "asin");
    return wt.runKernel("Asin", {
      x: t
    });
  }
}),
    ds = At({
  asinh_: function asinh_(e) {
    var t = Et(e, "x", "asinh");
    return wt.runKernel("Asinh", {
      x: t
    });
  }
}),
    ps = At({
  atan_: function atan_(e) {
    var t = Et(e, "x", "atan");
    return wt.runKernel("Atan", {
      x: t
    });
  }
}),
    fs = At({
  atan2_: function atan2_(e, t) {
    var n = Et(e, "a", "atan2"),
        s = Et(t, "b", "atan2");
    return [n, s] = ft(n, s), wt.runKernel("Atan2", {
      a: n,
      b: s
    });
  }
}),
    gs = At({
  atanh_: function atanh_(e) {
    var t = Et(e, "x", "atanh");
    return wt.runKernel("Atanh", {
      x: t
    });
  }
});

function ms(e, t, n, s) {
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NHWC";
  var a = arguments.length > 5 ? arguments[5] : undefined;
  return ys(e, [...t, e[3]], n, a, s, null, null, Ts(r));
}

function bs(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "channelsLast";
  var [o, l] = vs(t);
  var u;
  if ("channelsLast" === i) u = [o, l, e[3], e[3]];else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat ".concat(i));
    u = [o, l, e[1], e[1]];
  }
  return ys(e, u, n, s, r, a, !1, i);
}

function xs(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "NDHWC";
  var [o, l, u] = Is(t);
  var c, h;
  if ("NDHWC" === i) h = "channelsLast", c = [o, l, u, e[4], e[4]];else {
    if ("NCDHW" !== i) throw new Error("Unknown dataFormat ".concat(i));
    h = "channelsFirst", c = [o, l, u, e[1], e[1]];
  }
  return ks(e, c, n, s, r, !1, h, a);
}

function ys(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : "channelsLast";
  var [l, u, c, h] = [-1, -1, -1, -1];
  if ("channelsLast" === o) [l, u, c, h] = e;else {
    if ("channelsFirst" !== o) throw new Error("Unknown dataFormat ".concat(o));
    [l, h, u, c] = e;
  }

  var [d, p,, f] = t,
      [g, m] = vs(n),
      [b, x] = vs(s),
      y = $s(d, b),
      k = $s(p, x),
      {
    padInfo: w,
    outHeight: v,
    outWidth: I
  } = function (e, t, n, s, r, a, i, o, l) {
    var u, c, h;

    if ("number" == typeof e) {
      u = {
        top: e,
        bottom: e,
        left: e,
        right: e,
        type: 0 === e ? "VALID" : "NUMBER"
      };

      var _r21 = function (e, t, n, s, r) {
        null == s && (s = ws(e, t, n));
        var a = e[1];
        return [Ns((e[0] - t + 2 * s) / n + 1, r), Ns((a - t + 2 * s) / n + 1, r)];
      }([t, n], a, s, e, o);

      c = _r21[0], h = _r21[1];
    } else if ("same" === e) {
      c = Math.ceil(t / s), h = Math.ceil(n / r);

      var _e46 = Math.max(0, (c - 1) * s + a - t),
          _o8 = Math.max(0, (h - 1) * r + i - n),
          _l4 = Math.floor(_e46 / 2),
          _d2 = _e46 - _l4,
          _p2 = Math.floor(_o8 / 2);

      u = {
        top: _l4,
        bottom: _d2,
        left: _p2,
        right: _o8 - _p2,
        type: "SAME"
      };
    } else if ("valid" === e) u = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      type: "VALID"
    }, c = Math.ceil((t - a + 1) / s), h = Math.ceil((n - i + 1) / r);else {
      if ("object" != typeof e) throw Error("Unknown padding parameter: ".concat(e));
      {
        var _d3 = "channelsLast" === l ? e[1][0] : e[2][0],
            _p3 = "channelsLast" === l ? e[1][1] : e[2][1],
            _f2 = "channelsLast" === l ? e[2][0] : e[3][0],
            _g2 = "channelsLast" === l ? e[2][1] : e[3][1];

        u = {
          top: _d3,
          bottom: _p3,
          left: _f2,
          right: _g2,
          type: 0 === _d3 && 0 === _p3 && 0 === _f2 && 0 === _g2 ? "VALID" : "EXPLICIT"
        }, c = Ns((t - a + _d3 + _p3) / s + 1, o), h = Ns((n - i + _f2 + _g2) / r + 1, o);
      }
    }

    return {
      padInfo: u,
      outHeight: c,
      outWidth: h
    };
  }(r, u, c, g, m, y, k, a, o),
      $ = i ? f * h : f;

  var N;
  return "channelsFirst" === o ? N = [l, $, v, I] : "channelsLast" === o && (N = [l, v, I, $]), {
    batchSize: l,
    dataFormat: o,
    inHeight: u,
    inWidth: c,
    inChannels: h,
    outHeight: v,
    outWidth: I,
    outChannels: $,
    padInfo: w,
    strideHeight: g,
    strideWidth: m,
    filterHeight: d,
    filterWidth: p,
    effectiveFilterHeight: y,
    effectiveFilterWidth: k,
    dilationHeight: b,
    dilationWidth: x,
    inShape: e,
    outShape: N,
    filterShape: t
  };
}

function ks(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "channelsLast";
  var o = arguments.length > 7 ? arguments[7] : undefined;
  var [l, u, c, h, d] = [-1, -1, -1, -1, -1];
  if ("channelsLast" === i) [l, u, c, h, d] = e;else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat ".concat(i));
    [l, d, u, c, h] = e;
  }

  var [p, f, g,, m] = t,
      [b, x, y] = Is(n),
      [k, w, v] = Is(s),
      I = $s(p, k),
      $ = $s(f, w),
      N = $s(g, v),
      {
    padInfo: C,
    outDepth: S,
    outHeight: T,
    outWidth: E
  } = function (e, t, n, s, r, a, i, o, l, u, c) {
    var h, d, p, f;

    if ("number" == typeof e) {
      h = {
        top: e,
        bottom: e,
        left: e,
        right: e,
        front: e,
        back: e,
        type: 0 === e ? "VALID" : "NUMBER"
      };

      var _a11 = function (e, t, n, s, r, a) {
        null == r && (r = ws(e, t, s));
        var i = e[1],
            o = e[2];
        return [Ns((e[0] - t + 2 * r) / s + 1, a), Ns((i - t + 2 * r) / s + 1, a), Ns((o - t + 2 * r) / s + 1, a), 1];
      }([t, n, s, 1], o, 0, r, e, c);

      d = _a11[0], p = _a11[1], f = _a11[2];
    } else if ("same" === e) {
      d = Math.ceil(t / r), p = Math.ceil(n / a), f = Math.ceil(s / i);

      var _e47 = (d - 1) * r + o - t,
          _c2 = (p - 1) * a + l - n,
          _g3 = (f - 1) * i + u - s,
          _m2 = Math.floor(_e47 / 2),
          _b2 = _e47 - _m2,
          _x8 = Math.floor(_c2 / 2),
          _y2 = _c2 - _x8,
          _k2 = Math.floor(_g3 / 2);

      h = {
        top: _x8,
        bottom: _y2,
        left: _k2,
        right: _g3 - _k2,
        front: _m2,
        back: _b2,
        type: "SAME"
      };
    } else {
      if ("valid" !== e) throw Error("Unknown padding parameter: ".concat(e));
      h = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        front: 0,
        back: 0,
        type: "VALID"
      }, d = Math.ceil((t - o + 1) / r), p = Math.ceil((n - l + 1) / a), f = Math.ceil((s - u + 1) / i);
    }

    return {
      padInfo: h,
      outDepth: d,
      outHeight: p,
      outWidth: f
    };
  }(r, u, c, h, b, x, y, I, $, N, o),
      R = a ? m * d : m;

  var A;
  return "channelsFirst" === i ? A = [l, R, S, T, E] : "channelsLast" === i && (A = [l, S, T, E, R]), {
    batchSize: l,
    dataFormat: i,
    inDepth: u,
    inHeight: c,
    inWidth: h,
    inChannels: d,
    outDepth: S,
    outHeight: T,
    outWidth: E,
    outChannels: R,
    padInfo: C,
    strideDepth: b,
    strideHeight: x,
    strideWidth: y,
    filterDepth: p,
    filterHeight: f,
    filterWidth: g,
    effectiveFilterDepth: I,
    effectiveFilterHeight: $,
    effectiveFilterWidth: N,
    dilationDepth: k,
    dilationHeight: w,
    dilationWidth: v,
    inShape: e,
    outShape: A,
    filterShape: t
  };
}

function ws(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var r = $s(t, s);
  return Math.floor((e[0] * (n - 1) - n + r) / 2);
}

function vs(e) {
  return "number" == typeof e ? [e, e, e] : 2 === e.length ? [e[0], e[1], 1] : e;
}

function Is(e) {
  return "number" == typeof e ? [e, e, e] : e;
}

function $s(e, t) {
  return t <= 1 ? e : e + (e - 1) * (t - 1);
}

function Ns(e, t) {
  if (!t) return Math.trunc(e);

  switch (t) {
    case "round":
      return Math.round(e);

    case "ceil":
      return Math.ceil(e);

    case "floor":
      return Math.floor(e);

    default:
      throw new Error("Unknown roundingMode ".concat(t));
  }
}

function Cs(e) {
  var [t, n, s] = vs(e);
  return 1 === t && 1 === n && 1 === s;
}

function Ss(e, t) {
  return Cs(e) || Cs(t);
}

function Ts(e) {
  if ("NHWC" === e) return "channelsLast";
  if ("NCHW" === e) return "channelsFirst";
  throw new Error("Unknown dataFormat ".concat(e));
}

var Es = At({
  reshape_: function reshape_(e, t) {
    var n = Et(e, "x", "reshape", "string_or_numeric");
    return wt.runKernel("Reshape", {
      x: n
    }, {
      shape: t
    });
  }
}),
    Rs = At({
  avgPool_: function avgPool_(e, t, n, s, r) {
    var a = Et(e, "x", "avgPool", "float32");
    l(Ss(n, 1), () => "Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '1'"));
    var i = a,
        o = !1;
    3 === a.rank && (o = !0, i = Es(a, [1, a.shape[0], a.shape[1], a.shape[2]])), l(4 === i.rank, () => "Error in avgPool: x must be rank 4 but got rank ".concat(i.rank, ".")), null != r && l(f(s), () => "Error in avgPool: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, "."));
    var u = wt.runKernel("AvgPool", {
      x: i
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r
    });
    return u = pn(u, a.dtype), o ? Es(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    As = At({
  avgPool3d_: function avgPool3d_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NDHWC";
    var i = Et(e, "x", "avgPool3d", "float32");
    var o = i,
        u = !1;
    4 === i.rank && (u = !0, o = Es(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), l(5 === o.rank, () => "Error in avgPool3d: x must be rank 5 but got rank ".concat(o.rank, ".")), l("NDHWC" === a, () => "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ".concat(a)), null != r && l(f(s), () => "Error in avgPool3d: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, "."));
    var c = wt.runKernel("AvgPool3D", {
      x: o
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r,
      dataFormat: a
    });
    return c = pn(c, o.dtype), u ? Es(c, [c.shape[1], c.shape[2], c.shape[3], c.shape[4]]) : c;
  }
}),
    Fs = At({
  concat_: function concat_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    l(e.length >= 1, () => "Pass at least one tensor to concat");
    var n = Rt(e, "tensors", "concat", "string_or_numeric");
    return "complex64" === n[0].dtype && n.forEach(e => {
      if ("complex64" !== e.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype, ". "));
    }), 1 === n.length ? fn(n[0]) : wt.runKernel("Concat", n, {
      axis: t
    });
  }
}),
    Ds = At({
  sigmoid_: function sigmoid_(e) {
    var t = Et(e, "x", "sigmoid");
    return wt.runKernel("Sigmoid", {
      x: t
    });
  }
}),
    _s = At({
  slice_: function slice_(e, t, n) {
    var s = Et(e, "x", "slice", "string_or_numeric");
    if (0 === s.rank) throw new Error("Slicing scalar is not possible");
    return wt.runKernel("Slice", {
      x: s
    }, {
      begin: t,
      size: n
    });
  }
}),
    Os = At({
  tanh_: function tanh_(e) {
    var t = Et(e, "x", "tanh");
    return wt.runKernel("Tanh", {
      x: t
    });
  }
}),
    Ms = At({
  batchToSpaceND_: function batchToSpaceND_(e, t, n) {
    var s = Et(e, "x", "batchToSpaceND"),
        r = t.reduce((e, t) => e * t);
    return l(s.rank >= 1 + t.length, () => "input rank is ".concat(s.rank, " but should be > than blockShape.length ").concat(t.length)), l(n.length === t.length, () => "crops.length is ".concat(n.length, " but should be equal to blockShape.length  ").concat(t.length)), l(s.shape[0] % r == 0, () => "input tensor batch is ".concat(s.shape[0], " but is not divisible by the product of the elements of blockShape ").concat(t.join(" * "), " === ").concat(r)), wt.runKernel("BatchToSpaceND", {
      x: s
    }, {
      blockShape: t,
      crops: n
    });
  }
}),
    Ls = At({
  batchNorm_: function batchNorm_(e, t, n, s, r, a) {
    null == a && (a = .001);
    var i = Et(e, "x", "batchNorm"),
        o = Et(t, "mean", "batchNorm"),
        u = Et(n, "variance", "batchNorm");
    var c, h;
    null != r && (c = Et(r, "scale", "batchNorm")), null != s && (h = Et(s, "offset", "batchNorm")), l(o.rank === u.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), l(null == h || o.rank === h.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), l(null == c || o.rank === c.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");

    var d = function (e) {
      var t;
      return t = 0 === e.rank || 1 === e.rank ? Es(e, [1, 1, 1, e.size]) : 2 === e.rank ? Es(e, [1, 1, e.shape[0], e.shape[1]]) : 3 === e.rank ? Es(e, [1, e.shape[0], e.shape[1], e.shape[2]]) : e, t;
    }(i),
        p = wt.runKernel("FusedBatchNorm", {
      x: d,
      scale: c,
      offset: h,
      mean: o,
      variance: u
    }, {
      varianceEpsilon: a
    });

    return Es(p, i.shape);
  }
}),
    zs = At({
  batchNorm2d_: function batchNorm2d_(e, t, n, s, r, a) {
    var i = Et(e, "x", "batchNorm"),
        o = Et(t, "mean", "batchNorm"),
        u = Et(n, "variance", "batchNorm");
    var c, h;
    return null != r && (c = Et(r, "scale", "batchNorm")), null != s && (h = Et(s, "offset", "batchNorm")), l(2 === i.rank, () => "Error in batchNorm2D: x must be rank 2 but got rank ".concat(i.rank, ".")), l(2 === o.rank || 1 === o.rank, () => "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ".concat(o.rank, ".")), l(2 === u.rank || 1 === u.rank, () => "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ".concat(u.rank, ".")), null != c && l(2 === c.rank || 1 === c.rank, () => "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ".concat(c.rank, ".")), null != h && l(2 === h.rank || 1 === h.rank, () => "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ".concat(h.rank, ".")), Ls(i, o, u, h, c, a);
  }
}),
    Bs = At({
  batchNorm3d_: function batchNorm3d_(e, t, n, s, r, a) {
    var i = Et(e, "x", "batchNorm"),
        o = Et(t, "mean", "batchNorm"),
        u = Et(n, "variance", "batchNorm");
    var c, h;
    return null != r && (c = Et(r, "scale", "batchNorm")), null != s && (h = Et(s, "offset", "batchNorm")), l(3 === i.rank, () => "Error in batchNorm3D: x must be rank 3 but got rank ".concat(i.rank, ".")), l(3 === o.rank || 1 === o.rank, () => "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ".concat(o.rank, ".")), l(3 === u.rank || 1 === u.rank, () => "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ".concat(u.rank, ".")), null != c && l(3 === c.rank || 1 === c.rank, () => "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ".concat(c.rank, ".")), null != h && l(3 === h.rank || 1 === h.rank, () => "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ".concat(h.rank, ".")), Ls(i, o, u, h, c, a);
  }
}),
    Ps = At({
  batchNorm4d_: function batchNorm4d_(e, t, n, s, r, a) {
    var i = Et(e, "x", "batchNorm"),
        o = Et(t, "mean", "batchNorm"),
        u = Et(n, "variance", "batchNorm");
    var c, h;
    return null != r && (c = Et(r, "scale", "batchNorm")), null != s && (h = Et(s, "offset", "batchNorm")), l(4 === i.rank, () => "Error in batchNorm4D: x must be rank 4 but got rank ".concat(i.rank, ".")), l(4 === o.rank || 1 === o.rank, () => "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ".concat(o.rank, ".")), l(4 === u.rank || 1 === u.rank, () => "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ".concat(u.rank, ".")), null != c && l(4 === c.rank || 1 === c.rank, () => "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ".concat(c.rank, ".")), null != h && l(4 === h.rank || 1 === h.rank, () => "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ".concat(h.rank, ".")), Ls(i, o, u, h, c, a);
  }
}),
    Ws = At({
  bincount_: function bincount_(e, t, n) {
    var s = Et(e, "x", "bincount"),
        r = Et(t, "weights", "bincount");
    return l("int32" === s.dtype, () => "Error in bincount: input dtype must be int32, but got ".concat(s.dtype)), l(n >= 0, () => "size must be non-negative, but got ".concat(n, ".")), l(r.size === s.size || 0 === r.size, () => "Error in bincount: weights must have the same size as input or0-length, but got input shape: ".concat(s.shape, ", weights shape: ").concat(r.shape, ".")), wt.runKernel("Bincount", {
      x: s,
      weights: r
    }, {
      size: n
    });
  }
}),
    Us = At({
  broadcastTo_: function broadcastTo_(e, t) {
    var n = Et(e, "broadcastTo", "x");
    var s = n.shape;
    if (t.some(e => !(e > 0) || e % 1 != 0)) throw new Error("broadcastTo(): Invalid broadcast shape [".concat(t, "]."));
    if (t.length < n.rank) throw new Error("broadcastTo(): shape.length=".concat(t.length, " < input.rank=").concat(n.rank, "."));

    if (t.length > n.rank) {
      var _e48 = n.shape.slice();

      for (; _e48.length < t.length;) {
        _e48.unshift(1);
      }

      n = Es(n, _e48);
    }

    var r = n.shape,
        a = Array.from(t);

    for (var _e49 = t.length - 1; _e49 >= 0; _e49--) {
      if (r[_e49] === t[_e49]) a[_e49] = 1;else if (1 !== n.shape[_e49]) throw new Error("broadcastTo(): [".concat(s, "] cannot be broadcast to [").concat(t, "]."));
    }

    return 0 === a.map((e, t) => e > 1 ? t : -1).filter(e => e >= 0).length ? fn(n) : wt.runKernel("Tile", {
      x: n
    }, {
      reps: a
    });
  }
}),
    Vs = At({
  ceil_: function ceil_(e) {
    var t = Et(e, "x", "ceil");
    return wt.runKernel("Ceil", {
      x: t
    });
  }
}),
    Gs = At({
  clipByValue_: function clipByValue_(e, t, n) {
    var s = Et(e, "x", "clipByValue");
    return l(t <= n, () => "Error in clip: min (".concat(t, ") must be less than or equal to max (").concat(n, ").")), wt.runKernel("ClipByValue", {
      x: s
    }, {
      clipValueMin: t,
      clipValueMax: n
    });
  }
}),
    Hs = At({
  concat1d_: function concat1d_(e) {
    return Fs(e, 0);
  }
}),
    js = At({
  concat2d_: function concat2d_(e, t) {
    return Fs(e, t);
  }
}),
    qs = At({
  concat3d_: function concat3d_(e, t) {
    return Fs(e, t);
  }
}),
    Ks = At({
  concat4d_: function concat4d_(e, t) {
    return Fs(e, t);
  }
}),
    Xs = At({
  conv2d_: function conv2d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NHWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = Et(e, "x", "conv2d"),
        u = Et(t, "filter", "conv2d");
    var c = o,
        h = !1;
    3 === o.rank && (h = !0, c = Es(o, [1, o.shape[0], o.shape[1], o.shape[2]])), l(4 === c.rank, () => "Error in conv2d: input must be rank 4, but got rank ".concat(c.rank, ".")), l(4 === u.rank, () => "Error in conv2d: filter must be rank 4, but got rank ".concat(u.rank, ".")), null != i && l(f(s), () => "Error in conv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, "."));
    var d = "NHWC" === r ? c.shape[3] : c.shape[1];
    l(d === u.shape[2], () => "Error in conv2d: depth of input (".concat(d, ") must match input depth for filter ").concat(u.shape[2], ".")), l(Ss(n, a), () => "Error in conv2D: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '").concat(a, "'"));
    var p = wt.runKernel("Conv2D", {
      x: c,
      filter: u
    }, {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a,
      dimRoundingMode: i
    });
    return h ? Es(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
  }
}),
    Ys = At({
  conv1d_: function conv1d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = Et(e, "x", "conv1d"),
        u = Et(t, "filter", "conv1d");
    var c = o,
        h = !1;
    2 === o.rank && (h = !0, c = Es(o, [1, o.shape[0], o.shape[1]])), l(3 === c.rank, () => "Error in conv1d: input must be rank 3, but got rank ".concat(c.rank, ".")), l(3 === u.rank, () => "Error in conv1d: filter must be rank 3, but got rank ".concat(u.rank, ".")), null != i && l(f(s), () => "Error in conv1d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, ".")), l(c.shape[2] === u.shape[1], () => "Error in conv1d: depth of input (".concat(c.shape[2], ") must match input depth for filter ").concat(u.shape[1], ".")), l(Ss(n, a), () => "Error in conv1D: Either stride or dilation must be 1. Got stride ".concat(n, " and dilation '").concat(a, "'")), l("NWC" === r, () => "Error in conv1d: got dataFormat of ".concat(r, " but only NWC is currently supported."));
    var d = Es(u, [1, u.shape[0], u.shape[1], u.shape[2]]),
        p = Es(c, [c.shape[0], 1, c.shape[1], c.shape[2]]),
        g = Xs(p, d, [1, n], s, "NHWC", [1, a], i);
    return Es(g, h ? [g.shape[2], g.shape[3]] : [g.shape[0], g.shape[2], g.shape[3]]);
  }
}),
    Js = At({
  conv2DBackpropInput_: function conv2DBackpropInput_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NHWC";
    var i = arguments.length > 6 ? arguments[6] : undefined;
    l(e.length === t.rank, () => "Length of inShape (".concat(e.length, ") and rank of dy (").concat(t.rank, ") must match"));
    var o = e,
        u = t,
        c = !1;
    3 === t.rank && (c = !0, u = Es(t, [1, t.shape[0], t.shape[1], t.shape[2]]), o = [1, e[0], e[1], e[2]]), l(4 === o.length, () => "Error in conv2dDerInput: inShape must be length 4, but got length ".concat(o.length, ".")), l(4 === u.rank, () => "Error in conv2dDerInput: dy must be rank 4, but got rank ".concat(u.rank)), l(4 === n.rank, () => "Error in conv2dDerInput: filter must be rank 4, but got rank ".concat(n.rank));
    var h = "NHWC" === a ? o[3] : o[1],
        d = "NHWC" === a ? u.shape[3] : u.shape[1];
    l(h === n.shape[2], () => "Error in conv2dDerInput: depth of input (".concat(h, ") must match input depth for filter ").concat(n.shape[2], ".")), l(d === n.shape[3], () => "Error in conv2dDerInput: depth of output (".concat(d, ") must match output depth for filter ").concat(n.shape[3], ".")), null != i && l(f(r), () => "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(r, "."));
    var p = wt.runKernel("Conv2DBackpropInput", {
      dy: u,
      filter: n
    }, {
      strides: s,
      pad: r,
      dataFormat: a,
      dimRoundingMode: i,
      inputShape: o
    });
    return c ? Es(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
  }
}),
    Zs = At({
  conv2dTranspose_: function conv2dTranspose_(e, t, n, s, r, a) {
    var i = Et(e, "x", "conv2dTranspose"),
        o = Et(t, "filter", "conv2dTranspose");
    return Js(n, i, o, s, r, "NHWC", a);
  }
}),
    Qs = At({
  conv3d_: function conv3d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NDHWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1, 1];
    var i = Et(e, "x", "conv3d"),
        o = Et(t, "filter", "conv3d");
    var u = i,
        c = !1;
    4 === i.rank && (c = !0, u = Es(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), l(5 === u.rank, () => "Error in conv3d: input must be rank 5, but got rank ".concat(u.rank, ".")), l(5 === o.rank, () => "Error in conv3d: filter must be rank 5, but got rank ".concat(o.rank, ".")), l(u.shape[4] === o.shape[3], () => "Error in conv3d: depth of input (".concat(u.shape[4], ") must match input depth for filter ").concat(o.shape[3], ".")), l(Ss(n, a), () => "Error in conv3D: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '").concat(a, "'")), l("NDHWC" === r, () => "Error in conv3d: got dataFormat of ".concat(r, " but only NDHWC is currently supported."));
    var h = wt.runKernel("Conv3D", {
      x: u,
      filter: o
    }, {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a
    });
    return c ? Es(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h;
  }
}),
    er = At({
  conv3DBackpropInput_: function conv3DBackpropInput_(e, t, n, s, r) {
    l(e.length === t.rank, () => "Length of inShape (".concat(e.length, ") and rank of dy (").concat(t.rank, ") must match"));
    var a = e,
        i = t,
        o = !1;
    4 === t.rank && (o = !0, i = Es(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]), a = [1, e[0], e[1], e[2], e[3]]);
    var u = a[4],
        c = i.shape[4];
    l(5 === a.length, () => "Error in conv3dDerInput: inShape must be length 5, but got length ".concat(a.length, ".")), l(5 === i.rank, () => "Error in conv3dDerInput: dy must be rank 5, but got rank ".concat(i.rank)), l(5 === n.rank, () => "Error in conv3dDerInput: filter must be rank 5, but got rank ".concat(n.rank)), l(u === n.shape[3], () => "Error in conv3dDerInput: depth of input (".concat(u, ") must match input depth for filter ").concat(n.shape[3], ".")), l(c === n.shape[4], () => "Error in conv3dDerInput: depth of output (".concat(c, ") must match output depth for filter ").concat(n.shape[4], "."));
    var h = wt.runKernel("Conv3DBackpropInputV2", {
      dy: i,
      filter: n
    }, {
      pad: r,
      strides: s,
      inputShape: a
    });
    return o ? Es(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h;
  }
}),
    tr = At({
  conv3dTranspose_: function conv3dTranspose_(e, t, n, s, r) {
    var a = Et(e, "x", "conv3dTranspose"),
        i = Et(t, "filter", "conv3dTranspose");
    return er(n, a, i, s, r);
  }
}),
    nr = At({
  cos_: function cos_(e) {
    var t = Et(e, "x", "cos");
    return wt.runKernel("Cos", {
      x: t
    });
  }
}),
    sr = At({
  cosh_: function cosh_(e) {
    var t = Et(e, "x", "cosh");
    return wt.runKernel("Cosh", {
      x: t
    });
  }
}),
    rr = At({
  cumsum_: function cumsum_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Et(e, "x", "cumsum");
    return wt.runKernel("Cumsum", {
      x: r
    }, {
      axis: t,
      exclusive: n,
      reverse: s
    });
  }
}),
    ar = At({
  depthToSpace_: function depthToSpace_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "NHWC";
    var s = Et(e, "x", "depthToSpace"),
        r = "NHWC" === n ? s.shape[1] : s.shape[2],
        a = "NHWC" === n ? s.shape[2] : s.shape[3],
        i = "NHWC" === n ? s.shape[3] : s.shape[1];
    return l(r * t >= 0, () => "Negative dimension size caused by overflow when multiplying\n    ".concat(r, " and ").concat(t, "  for depthToSpace with input shape\n    ").concat(s.shape)), l(a * t >= 0, () => "Negative dimension size caused by overflow when multiplying\n    ".concat(a, " and ").concat(t, " for depthToSpace with input shape\n        ").concat(s.shape)), l(i % (t * t) == 0, () => "Dimension size must be evenly divisible by ".concat(t * t, " but is ").concat(i, " for depthToSpace with input shape ").concat(s.shape)), wt.runKernel("DepthToSpace", {
      x: s
    }, {
      blockSize: t,
      dataFormat: n
    });
  }
}),
    ir = At({
  depthwiseConv2d_: function depthwiseConv2d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NHWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = Et(e, "x", "depthwiseConv2d"),
        u = Et(t, "filter", "depthwiseConv2d");
    var c = o,
        h = !1;
    3 === o.rank && (h = !0, c = Es(o, [1, o.shape[0], o.shape[1], o.shape[2]])), l(4 === c.rank, () => "Error in depthwiseConv2d: input must be rank 4, but got rank ".concat(c.rank, ".")), l(4 === u.rank, () => "Error in depthwiseConv2d: filter must be rank 4, but got rank ".concat(u.rank, ".")), l(c.shape[3] === u.shape[2], () => "Error in depthwiseConv2d: number of input channels (".concat(c.shape[3], ") must match the inChannels dimension in filter ").concat(u.shape[2], ".")), null != i && l(f(s), () => "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, "."));
    var d = wt.runKernel("DepthwiseConv2dNative", {
      x: c,
      filter: u
    }, {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a,
      dimRoundingMode: i
    });
    return h ? Es(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
  }
}),
    or = At({
  dilation2d_: function dilation2d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [1, 1];
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NHWC";
    var i = Et(e, "x", "dilation2d"),
        o = Et(t, "filter", "dilation2d");
    l(3 === i.rank || 4 === i.rank, () => "Error in dilation2d: input must be rank 3 or 4, but got rank ".concat(i.rank, ".")), l(3 === o.rank, () => "Error in dilation2d: filter must be rank 3, but got rank ".concat(o.rank, ".")), l("NHWC" === a, () => "Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ".concat(a));
    var u = i,
        c = !1;
    3 === i.rank && (u = Es(i, [1, i.shape[0], i.shape[1], i.shape[2]]), c = !0);
    var h = wt.runKernel("Dilation2D", {
      x: u,
      filter: o
    }, {
      strides: n,
      pad: s,
      dilations: r
    });
    return c ? Es(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
  }
});

function lr(e, t) {
  var n = e.length,
      s = [];

  for (var _r22 = 0; _r22 < n; _r22++) {
    var _a12 = n - 1 - _r22,
        _i9 = e[_a12] || 1;

    (t[t.length - 1 - _r22] || 1) > 1 && 1 === _i9 && s.unshift(_a12);
  }

  return s;
}

function ur(e, t) {
  var n = [];

  for (var _s31 = 0; _s31 < t.length; _s31++) {
    var _r23 = e[e.length - _s31 - 1],
        _a13 = t.length - _s31 - 1,
        _i10 = t[_a13];

    (null == _r23 || 1 === _r23 && _i10 > 1) && n.unshift(_a13);
  }

  return n;
}

function cr(e, t) {
  var n = [],
      s = Math.max(e.length, t.length);

  for (var _r24 = 0; _r24 < s; _r24++) {
    var _s32 = e[e.length - _r24 - 1];
    null == _s32 && (_s32 = 1);
    var _a14 = t[t.length - _r24 - 1];
    if (null == _a14 && (_a14 = 1), 1 === _s32) n.unshift(_a14);else if (1 === _a14) n.unshift(_s32);else {
      if (_s32 !== _a14) throw Error("Operands could not be broadcast together with shapes ".concat(e, " and ").concat(t, "."));
      n.unshift(_s32);
    }
  }

  return n;
}

var hr = At({
  equal_: function equal_(e, t) {
    var n = Et(e, "a", "equal", "string_or_numeric"),
        s = Et(t, "b", "equal", "string_or_numeric");
    return [n, s] = ft(n, s), cr(n.shape, s.shape), wt.runKernel("Equal", {
      a: n,
      b: s
    });
  }
}),
    dr = At({
  where_: function where_(e, t, n) {
    var s = Et(t, "a", "where"),
        r = Et(n, "b", "where"),
        a = Et(e, "condition", "where", "bool"),
        i = cr(cr(a.shape, s.shape), r.shape),
        o = Us(a, i),
        l = Us(s, i),
        u = Us(r, i);
    return wt.runKernel("Select", {
      condition: o,
      t: l,
      e: u
    });
  }
}),
    pr = At({
  zerosLike_: function zerosLike_(e) {
    var t = Et(e, "x", "zerosLike");
    return wt.runKernel("ZerosLike", {
      x: t
    });
  }
}),
    fr = At({
  divNoNan_: function divNoNan_(e, t) {
    var n = Et(e, "a", "div"),
        s = Et(t, "b", "div");
    [n, s] = ft(n, s);
    var r = ns(n, s),
        a = pr(r),
        i = hr(s, a);
    return dr(i, a, r);
  }
}),
    gr = At({
  dot_: function dot_(e, t) {
    var n = Et(e, "t1", "dot"),
        s = Et(t, "t2", "dot");
    l(!(1 !== n.rank && 2 !== n.rank || 1 !== s.rank && 2 !== s.rank), () => "Error in dot: inputs must all be rank 1 or 2, but got ranks ".concat(n.rank, " and ").concat(s.rank, "."));
    var r = 1 === n.rank ? n.size : n.shape[1],
        a = 1 === s.rank ? s.size : s.shape[0];

    if (l(r === a, () => "Error in dot: inner dimensions of inputs must match, but got ".concat(r, " and ").concat(a, ".")), 1 === n.rank && 1 === s.rank) {
      var _e50 = Es(n, [1, -1]),
          _t54 = Es(s, [-1, 1]),
          _r25 = vn(_e50, _t54);

      return Es(_r25, []);
    }

    if (1 === n.rank && 2 === s.rank) {
      var _e51 = Es(n, [1, -1]),
          _t55 = Es(s, [s.shape[0], s.shape[1]]),
          _r26 = vn(_e51, _t55);

      return Es(_r26, [_r26.size]);
    }

    if (2 === n.rank && 1 === s.rank) {
      var _e52 = Es(s, [-1, 1]),
          _t56 = vn(n, _e52);

      return Es(_t56, [_t56.size]);
    }

    {
      var _e53 = Es(s, [s.shape[0], s.shape[1]]);

      return vn(n, _e53);
    }
  }
}),
    mr = At({
  elu_: function elu_(e) {
    var t = Et(e, "x", "elu");
    return wt.runKernel("Elu", {
      x: t
    });
  }
}),
    br = At({
  erf_: function erf_(e) {
    var t = Et(e, "x", "erf");
    return l("int32" === t.dtype || "float32" === t.dtype, () => "Input dtype must be `int32` or `float32`."), "int32" === t.dtype && (t = pn(t, "float32")), wt.runKernel("Erf", {
      x: t
    });
  }
}),
    xr = At({
  exp_: function exp_(e) {
    var t = Et(e, "x", "exp");
    return wt.runKernel("Exp", {
      x: t
    });
  }
}),
    yr = At({
  expandDims_: function expandDims_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "expandDims", "string_or_numeric");
    return l(t <= n.rank, () => "Axis must be <= rank of the tensor"), wt.runKernel("ExpandDims", {
      input: n
    }, {
      dim: t
    });
  }
}),
    kr = At({
  expm1_: function expm1_(e) {
    var t = Et(e, "x", "expm1");
    return wt.runKernel("Expm1", {
      x: t
    });
  }
}),
    wr = At({
  tile_: function tile_(e, t) {
    var n = Et(e, "x", "tile", "string_or_numeric");
    return l(n.rank === t.length, () => "Error in transpose: rank of input ".concat(n.rank, " must match length of reps ").concat(t, ".")), wt.runKernel("Tile", {
      x: n
    }, {
      reps: t
    });
  }
}),
    vr = At({
  eye_: function eye_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "float32";
    null == t && (t = e);
    var r = dn([e, t], s),
        a = e <= t ? e : t;

    for (var _e54 = 0; _e54 < a; ++_e54) {
      r.set(1, _e54, _e54);
    }

    var i = Es(r.toTensor(), [e, t]);
    if (null == n) return i;
    if (1 === n.length) return wr(yr(i, 0), [n[0], 1, 1]);
    if (2 === n.length) return wr(yr(yr(i, 0), 0), [n[0], n[1], 1, 1]);
    if (3 === n.length) return wr(yr(yr(yr(i, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
    throw new Error("eye() currently supports only 1D and 2D batchShapes, but received ".concat(n.length, "D."));
  }
});

function Ir(e, t, n) {
  return wt.runKernel("Fill", {}, {
    shape: e,
    value: t,
    dtype: n
  });
}

var $r = At({
  floor_: function floor_(e) {
    var t = Et(e, "x", "floor");
    return wt.runKernel("Floor", {
      x: t
    });
  }
}),
    Nr = At({
  gather_: function gather_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = Et(e, "x", "gather"),
        a = Et(t, "indices", "gather", "int32");
    return wt.runKernel("GatherV2", {
      x: r,
      indices: a
    }, {
      axis: n,
      batchDims: s
    });
  }
}),
    Cr = At({
  greater_: function greater_(e, t) {
    var n = Et(e, "a", "greater", "string_or_numeric"),
        s = Et(t, "b", "greater", "string_or_numeric");
    return [n, s] = ft(n, s), cr(n.shape, s.shape), wt.runKernel("Greater", {
      a: n,
      b: s
    });
  }
}),
    Sr = At({
  greaterEqual_: function greaterEqual_(e, t) {
    var n = Et(e, "a", "greaterEqual", "string_or_numeric"),
        s = Et(t, "b", "greaterEqual", "string_or_numeric");
    return [n, s] = ft(n, s), cr(n.shape, s.shape), wt.runKernel("GreaterEqual", {
      a: n,
      b: s
    });
  }
}),
    Tr = At({
  imag_: function imag_(e) {
    var t = Et(e, "input", "imag");
    return wt.runKernel("Imag", {
      input: t
    });
  }
}),
    Er = At({
  isFinite_: function isFinite_(e) {
    var t = Et(e, "x", "isFinite");
    return wt.runKernel("IsFinite", {
      x: t
    });
  }
}),
    Rr = At({
  isInf_: function isInf_(e) {
    var t = Et(e, "x", "isInf");
    return wt.runKernel("IsInf", {
      x: t
    });
  }
}),
    Ar = At({
  isNaN_: function isNaN_(e) {
    var t = Et(e, "x", "isNaN");
    return wt.runKernel("IsNan", {
      x: t
    });
  }
}),
    Fr = At({
  leakyRelu_: function leakyRelu_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .2;
    var n = Et(e, "x", "leakyRelu");
    return wt.runKernel("LeakyRelu", {
      x: n
    }, {
      alpha: t
    });
  }
}),
    Dr = At({
  less_: function less_(e, t) {
    var n = Et(e, "a", "less", "string_or_numeric"),
        s = Et(t, "b", "less", "string_or_numeric");
    return [n, s] = ft(n, s), cr(n.shape, s.shape), wt.runKernel("Less", {
      a: n,
      b: s
    });
  }
}),
    _r = At({
  lessEqual_: function lessEqual_(e, t) {
    var n = Et(e, "a", "lessEqual", "string_or_numeric"),
        s = Et(t, "b", "lessEqual", "string_or_numeric");
    return [n, s] = ft(n, s), cr(n.shape, s.shape), wt.runKernel("LessEqual", {
      a: n,
      b: s
    });
  }
}),
    Or = At({
  localResponseNormalization_: function localResponseNormalization_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .5;
    var a = Et(e, "x", "localResponseNormalization");
    l(4 === a.rank || 3 === a.rank, () => "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(a.rank, ".")), l(f(t), () => "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ".concat(t, "."));
    var i = a,
        o = !1;
    3 === a.rank && (o = !0, i = Es(a, [1, a.shape[0], a.shape[1], a.shape[2]]));
    var u = wt.runKernel("LRN", {
      x: i
    }, {
      depthRadius: t,
      bias: n,
      alpha: s,
      beta: r
    });
    return o ? Es(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    Mr = At({
  log_: function log_(e) {
    var t = Et(e, "x", "log");
    return wt.runKernel("Log", {
      x: t
    });
  }
}),
    Lr = At({
  log1p_: function log1p_(e) {
    var t = Et(e, "x", "log1p");
    return wt.runKernel("Log1p", {
      x: t
    });
  }
});

function zr(e) {
  return wt.customGrad(e);
}

var Br = At({
  neg_: function neg_(e) {
    var t = Et(e, "x", "neg");
    return wt.runKernel("Neg", {
      x: t
    });
  }
}),
    Pr = At({
  softplus_: function softplus_(e) {
    var t = Et(e, "x", "softplus");
    return wt.runKernel("Softplus", {
      x: t
    });
  }
}),
    Wr = At({
  logSigmoid_: function logSigmoid_(e) {
    var t = Et(e, "x", "logSigmoid");
    return zr(e => ({
      value: Br(Pr(Br(e))),
      gradFunc: t => ss(t, Ds(Br(e)))
    }))(t);
  }
}),
    Ur = At({
  max_: function max_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "max");
    return wt.runKernel("Max", {
      x: s
    }, {
      reductionIndices: t,
      keepDims: n
    });
  }
}),
    Vr = At({
  sub_: function sub_(e, t) {
    var n = Et(e, "a", "sub"),
        s = Et(t, "b", "sub");
    return [n, s] = ft(n, s), wt.runKernel("Sub", {
      a: n,
      b: s
    });
  }
}),
    Gr = At({
  sum_: function sum_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "sum");
    return "bool" === s.dtype && (s = pn(s, "int32")), wt.runKernel("Sum", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    Hr = At({
  logSoftmax_: function logSoftmax_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var n = Et(e, "logits", "logSoftmax");
    if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(n.rank, " and axis was ").concat(t));
    return zr((e, n) => {
      var s = Ur(e, t, !0),
          r = Vr(e, s),
          a = Vr(pn(r, "float32"), Mr(Gr(xr(r), t, !0)));
      return n([a]), {
        value: a,
        gradFunc: (e, n) => {
          var [s] = n,
              r = xr(s);
          return Vr(e, ss(Gr(e, t, !0), r));
        }
      };
    })(n);
  }
});

function jr(e, t) {
  for (var _n27 = 0; _n27 < e.length; ++_n27) {
    if (e[e.length - _n27 - 1] !== t - 1 - _n27) return !1;
  }

  return !0;
}

function qr(e, t, n) {
  var s = e.length + t.length,
      r = [];
  var a = 0,
      i = 0;

  for (var _o9 = 0; _o9 < s; _o9++) {
    -1 === n.indexOf(_o9) ? r.push(e[a++]) : r.push(t[i++]);
  }

  return r;
}

function Kr(e, t) {
  var n = [],
      s = e.length;

  for (var _r27 = 0; _r27 < s; _r27++) {
    -1 === t.indexOf(_r27) && n.push(e[_r27]);
  }

  return [n, t.map(t => e[t])];
}

function Xr(e, t) {
  return qr(e, t.map(e => 1), t);
}

function Yr(e, t, n) {
  l(jr(t, n), () => "".concat(e, " supports only inner-most axes for now. Got axes ").concat(t, " and rank-").concat(n, " input."));
}

function Jr(e, t) {
  if (jr(e, t)) return null;
  var n = [];

  for (var _s33 = 0; _s33 < t; ++_s33) {
    -1 === e.indexOf(_s33) && n.push(_s33);
  }

  return e.forEach(e => n.push(e)), n;
}

function Zr(e) {
  return e.map((e, t) => [t, e]).sort((e, t) => e[1] - t[1]).map(e => e[0]);
}

function Qr(e, t) {
  var n = [];

  for (var _s34 = t - e; _s34 < t; ++_s34) {
    n.push(_s34);
  }

  return n;
}

var ea = At({
  logSumExp_: function logSumExp_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "logSumExp"),
        r = y(t, s.shape),
        a = Ur(s, r, !0),
        i = Vr(s, a),
        o = xr(i),
        l = Gr(o, r),
        u = Mr(l),
        c = es(Es(a, u.shape), u);

    if (n) {
      var _e55 = Xr(c.shape, r);

      return Es(c, _e55);
    }

    return c;
  }
}),
    ta = At({
  logicalAnd_: function logicalAnd_(e, t) {
    var n = Et(e, "a", "logicalAnd", "bool"),
        s = Et(t, "b", "logicalAnd", "bool");
    return cr(n.shape, s.shape), wt.runKernel("LogicalAnd", {
      a: n,
      b: s
    });
  }
}),
    na = At({
  logicalNot_: function logicalNot_(e) {
    var t = Et(e, "x", "logicalNot", "bool");
    return wt.runKernel("LogicalNot", {
      x: t
    });
  }
}),
    sa = At({
  logicalOr_: function logicalOr_(e, t) {
    var n = Et(e, "a", "logicalOr", "bool"),
        s = Et(t, "b", "logicalOr", "bool");
    return cr(n.shape, s.shape), wt.runKernel("LogicalOr", {
      a: n,
      b: s
    });
  }
}),
    ra = At({
  logicalXor_: function logicalXor_(e, t) {
    var n = Et(e, "a", "logicalXor", "bool"),
        s = Et(t, "b", "logicalXor", "bool");
    return cr(n.shape, s.shape), ta(sa(e, t), na(ta(e, t)));
  }
}),
    aa = At({
  maxPool_: function maxPool_(e, t, n, s, r) {
    var a = Et(e, "x", "maxPool");
    var i = a,
        o = !1;
    3 === a.rank && (o = !0, i = Es(a, [1, a.shape[0], a.shape[1], a.shape[2]])), l(4 === i.rank, () => "Error in maxPool: input must be rank 4 but got rank ".concat(i.rank, ".")), l(Ss(n, 1), () => "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '1'")), null != r && l(f(s), () => "Error in maxPool: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, "."));
    var u = wt.runKernel("MaxPool", {
      x: i
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r
    });
    return o ? Es(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    ia = At({
  maxPool3d_: function maxPool3d_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1];
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NDHWC";
    var i = Et(e, "x", "maxPool3d");
    var o = i,
        u = !1;
    4 === i.rank && (u = !0, o = Es(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), l(5 === o.rank, () => "Error in maxPool3d: x must be rank 5 but got rank ".concat(o.rank, ".")), l("NDHWC" === a, () => "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ".concat(a)), null != r && l(f(s), () => "Error in maxPool3d: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, "."));
    var c = wt.runKernel("MaxPool3D", {
      x: o
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r,
      dataFormat: a
    });
    return u ? Es(c, [c.shape[1], c.shape[2], c.shape[3], c.shape[4]]) : c;
  }
}),
    oa = At({
  maximum_: function maximum_(e, t) {
    var n = Et(e, "a", "maximum"),
        s = Et(t, "b", "maximum");
    return [n, s] = ft(n, s), "bool" === n.dtype && (n = pn(n, "int32"), s = pn(s, "int32")), cr(n.shape, s.shape), wt.runKernel("Maximum", {
      a: n,
      b: s
    });
  }
}),
    la = At({
  mean_: function mean_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "mean");
    return wt.runKernel("Mean", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
});

function ua(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";

  if ("complex64" === t) {
    var _t57 = ua(e, "float32"),
        _n28 = ua(e, "float32");

    return Ft(_t57, _n28);
  }

  var n = O(d(e), t);
  return wt.makeTensor(n, e, t);
}

function ca(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";

  if ("complex64" === t) {
    var _t58 = ca(e, "float32"),
        _n29 = ua(e, "float32");

    return Ft(_t58, _n29);
  }

  var n = _(d(e), t);

  return wt.makeTensor(n, e, t);
}

var ha = At({
  min_: function min_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "min");
    return wt.runKernel("Min", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    da = At({
  minimum_: function minimum_(e, t) {
    var n = Et(e, "a", "minimum"),
        s = Et(t, "b", "minimum");
    return [n, s] = ft(n, s), "bool" === n.dtype && (n = pn(n, "int32"), s = pn(s, "int32")), cr(n.shape, s.shape), wt.runKernel("Minimum", {
      a: n,
      b: s
    });
  }
}),
    pa = At({
  mirrorPad_: function mirrorPad_(e, t, n) {
    l("reflect" === n || "symmetric" === n, () => "Invalid mode. Mode must be either reflect or symmetric. Got ".concat(n, "."));
    var s = Et(e, "x", "mirrorPad");
    if (0 === s.rank) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
    l(t.length === s.rank, () => "Padding doesn't match input. Must be ".concat(s.rank, ". Got ").concat(t.length, "."));
    var r = "reflect" === n ? 1 : 0;

    var _loop5 = function _loop5(_e56) {
      l(2 === t[_e56].length, () => "Invalid number of paddings. Must be length of 2 each."), l(t[_e56][0] >= 0 && t[_e56][0] <= s.shape[_e56] - r && t[_e56][1] >= 0 && t[_e56][1] <= s.shape[_e56] - r, () => "Padding in dimension ".concat(_e56, " cannot be greater than or equal to ").concat(s.shape[_e56] - r, " or less than 0 for input of shape ").concat(s.shape));
    };

    for (var _e56 = 0; _e56 < s.rank; _e56++) {
      _loop5(_e56);
    }

    return wt.runKernel("MirrorPad", {
      x: s
    }, {
      paddings: t,
      mode: n
    });
  }
}),
    fa = At({
  mod_: function mod_(e, t) {
    var n = Et(e, "a", "mod"),
        s = Et(t, "b", "mod");
    return [n, s] = ft(n, s), wt.runKernel("Mod", {
      a: n,
      b: s
    });
  }
}),
    ga = At({
  square_: function square_(e) {
    var t = Et(e, "x", "square");
    return wt.runKernel("Square", {
      x: t
    }, {});
  }
}),
    ma = At({
  moments_: function moments_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = y(t, (e = Et(e, "x", "moments")).shape),
        r = la(e, s, n);
    var a = r.shape;
    n || (a = Xr(r.shape, s));
    var i = ga(Vr(pn(e, "float32"), Es(r, a)));
    return {
      mean: r,
      variance: la(i, s, n)
    };
  }
}),
    ba = At({
  notEqual_: function notEqual_(e, t) {
    var n = Et(e, "a", "notEqual", "string_or_numeric"),
        s = Et(t, "b", "notEqual", "string_or_numeric");
    return [n, s] = ft(n, s), cr(n.shape, s.shape), wt.runKernel("NotEqual", {
      a: n,
      b: s
    });
  }
}),
    xa = At({
  onesLike_: function onesLike_(e) {
    var t = Et(e, "x", "onesLike");
    return wt.runKernel("OnesLike", {
      x: t
    });
  }
}),
    ya = At({
  pad_: function pad_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = Et(e, "x", "pad");
    if (0 === s.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    return wt.runKernel("PadV2", {
      x: s
    }, {
      paddings: t,
      constantValue: n
    });
  }
}),
    ka = At({
  spaceToBatchND_: function spaceToBatchND_(e, t, n) {
    var s = Et(e, "x", "spaceToBatchND");
    return l(s.rank >= 1 + t.length, () => "input rank ".concat(s.rank, " should be > than [blockShape] ").concat(t.length)), l(n.length === t.length, () => "paddings.shape[0] ".concat(n.length, " must be equal to [blockShape] ").concat(t.length)), l(s.shape.reduce((e, s, r) => r > 0 && r <= t.length ? e && (s + n[r - 1][0] + n[r - 1][1]) % t[r - 1] == 0 : e, !0), () => "input spatial dimensions ".concat(s.shape.slice(1), " with paddings ").concat(n.toString(), " must be divisible by blockShapes ").concat(t.toString())), wt.runKernel("SpaceToBatchND", {
      x: s
    }, {
      blockShape: t,
      paddings: n
    });
  }
}),
    wa = At({
  pool_: function pool_(e, t, n, s, r, a) {
    null == r && (r = [1, 1]), null == a && (a = 1), 0 === s && (s = "valid");
    var i = Et(e, "x", "maxPool");
    var o = i,
        u = !1;
    3 === i.rank && (u = !0, o = Es(i, [1, i.shape[0], i.shape[1], i.shape[2]])), l(Ss(a, r), () => "Error in pool: Either strides or dilations must be 1. Got strides ".concat(a, " and dilations '").concat(r, "'"));
    var c = bs(o.shape, t, a, r, s),
        h = [c.dilationHeight, c.dilationWidth];
    var d;
    d = "same" === s ? function (e, t) {
      var n = e.map((e, n) => e + (e - 1) * (t[n] - 1)).map(e => e - 1),
          s = n.map(e => Math.floor(e / 2)),
          r = n.map((e, t) => e - s[t]);
      return n.map((e, t) => [s[t], r[t]]);
    }([c.filterHeight, c.filterWidth], h) : [[0, 0], [0, 0]];

    var p = 1 === h[0] && 1 === h[1],
        [f, g] = function (e, t, n) {
      var s = n.map(e => e[0]),
          r = n.map(e => e[1]),
          a = e.concat(s, r),
          i = t.map((e, t) => (e - a[t] % e) % e),
          o = r.map((e, t) => e + i[t]);
      return [t.map((e, t) => [s[t], o[t]]), t.map((e, t) => [0, i[t]])];
    }([c.inHeight, c.inWidth], h, d),
        m = p ? s : "valid",
        b = p ? o : ka(o, h, f),
        x = ("avg" === n ? () => Rs(b, t, a, m) : () => aa(b, t, a, m))(),
        y = p ? x : Ms(x, h, g);

    return u ? Es(y, [y.shape[1], y.shape[2], y.shape[3]]) : y;
  }
}),
    va = At({
  pow_: function pow_(e, t) {
    var n = Et(e, "base", "pow"),
        s = Et(t, "exp", "pow");
    return [n, s] = ft(n, s), wt.runKernel("Pow", {
      a: n,
      b: s
    });
  }
}),
    Ia = At({
  prelu_: function prelu_(e, t) {
    var n = Et(e, "x", "prelu"),
        s = Et(t, "alpha", "prelu");
    return wt.runKernel("Prelu", {
      x: n,
      alpha: s
    });
  }
}),
    $a = At({
  prod_: function prod_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "prod");
    return "bool" === s.dtype && (s = pn(s, "int32")), wt.runKernel("Prod", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
});

function Na(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports), t.exports;
}

"undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self && self;
var Ca = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t,
          n = this,
          s = (t = 4022871197, function (e) {
        e = e.toString();

        for (var n = 0; n < e.length; n++) {
          var s = .02519603282416938 * (t += e.charCodeAt(n));
          s -= t = s >>> 0, t = (s *= t) >>> 0, t += 4294967296 * (s -= t);
        }

        return 2.3283064365386963e-10 * (t >>> 0);
      });
      n.next = function () {
        var e = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
        return n.s0 = n.s1, n.s1 = n.s2, n.s2 = e - (n.c = 0 | e);
      }, n.c = 1, n.s0 = s(" "), n.s1 = s(" "), n.s2 = s(" "), n.s0 -= s(e), n.s0 < 0 && (n.s0 += 1), n.s1 -= s(e), n.s1 < 0 && (n.s1 += 1), n.s2 -= s(e), n.s2 < 0 && (n.s2 += 1), s = null;
    }

    function r(e, t) {
      return t.c = e.c, t.s0 = e.s0, t.s1 = e.s1, t.s2 = e.s2, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = n.next;
      return i.int32 = function () {
        return 4294967296 * n.next() | 0;
      }, i.double = function () {
        return i() + 11102230246251565e-32 * (2097152 * i() | 0);
      }, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.alea = a;
  }(0, e);
}),
    Sa = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this,
          n = "";
      t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.next = function () {
        var e = t.x ^ t.x << 11;
        return t.x = t.y, t.y = t.z, t.z = t.w, t.w ^= t.w >>> 19 ^ e ^ e >>> 8;
      }, e === (0 | e) ? t.x = e : n += e;

      for (var s = 0; s < n.length + 64; s++) {
        t.x ^= 0 | n.charCodeAt(s), t.next();
      }
    }

    function r(e, t) {
      return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xor128 = a;
  }(0, e);
}),
    Ta = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this,
          n = "";
      t.next = function () {
        var e = t.x ^ t.x >>> 2;
        return t.x = t.y, t.y = t.z, t.z = t.w, t.w = t.v, (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0;
      }, t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.v = 0, e === (0 | e) ? t.x = e : n += e;

      for (var s = 0; s < n.length + 64; s++) {
        t.x ^= 0 | n.charCodeAt(s), s == n.length && (t.d = t.x << 10 ^ t.x >>> 4), t.next();
      }
    }

    function r(e, t) {
      return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t.v = e.v, t.d = e.d, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xorwow = a;
  }(0, e);
}),
    Ea = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this;
      t.next = function () {
        var e,
            n,
            s = t.x,
            r = t.i;
        return e = s[r], n = (e ^= e >>> 7) ^ e << 24, n ^= (e = s[r + 1 & 7]) ^ e >>> 10, n ^= (e = s[r + 3 & 7]) ^ e >>> 3, n ^= (e = s[r + 4 & 7]) ^ e << 7, e = s[r + 7 & 7], s[r] = n ^= (e ^= e << 13) ^ e << 9, t.i = r + 1 & 7, n;
      }, function (e, t) {
        var n,
            s = [];
        if (t === (0 | t)) s[0] = t;else for (t = "" + t, n = 0; n < t.length; ++n) {
          s[7 & n] = s[7 & n] << 15 ^ t.charCodeAt(n) + s[n + 1 & 7] << 13;
        }

        for (; s.length < 8;) {
          s.push(0);
        }

        for (n = 0; n < 8 && 0 === s[n]; ++n) {
          ;
        }

        for (8 == n && (s[7] = -1), e.x = s, e.i = 0, n = 256; n > 0; --n) {
          e.next();
        }
      }(t, e);
    }

    function r(e, t) {
      return t.x = e.x.slice(), t.i = e.i, t;
    }

    function a(e, t) {
      null == e && (e = +new Date());

      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && (a.x && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xorshift7 = a;
  }(0, e);
}),
    Ra = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this;
      t.next = function () {
        var e,
            n,
            s = t.w,
            r = t.X,
            a = t.i;
        return t.w = s = s + 1640531527 | 0, n = r[a + 34 & 127], e = r[a = a + 1 & 127], n ^= n << 13, e ^= e << 17, n = r[a] = (n ^= n >>> 15) ^ (e ^= e >>> 12), t.i = a, n + (s ^ s >>> 16) | 0;
      }, function (e, t) {
        var n,
            s,
            r,
            a,
            i,
            o = [],
            l = 128;

        for (t === (0 | t) ? (s = t, t = null) : (t += "\0", s = 0, l = Math.max(l, t.length)), r = 0, a = -32; a < l; ++a) {
          t && (s ^= t.charCodeAt((a + 32) % t.length)), 0 === a && (i = s), s ^= s << 10, s ^= s >>> 15, s ^= s << 4, s ^= s >>> 13, a >= 0 && (r = 0 == (n = o[127 & a] ^= s + (i = i + 1640531527 | 0)) ? r + 1 : 0);
        }

        for (r >= 128 && (o[127 & (t && t.length || 0)] = -1), r = 127, a = 512; a > 0; --a) {
          s = o[r + 34 & 127], n = o[r = r + 1 & 127], s ^= s << 13, n ^= n << 17, o[r] = (s ^= s >>> 15) ^ (n ^= n >>> 12);
        }

        e.w = i, e.X = o, e.i = r;
      }(t, e);
    }

    function r(e, t) {
      return t.i = e.i, t.w = e.w, t.X = e.X.slice(), t;
    }

    function a(e, t) {
      null == e && (e = +new Date());

      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && (a.X && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xor4096 = a;
  }(0, e);
}),
    Aa = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this,
          n = "";
      t.next = function () {
        var e = t.b,
            n = t.c,
            s = t.d,
            r = t.a;
        return e = e << 25 ^ e >>> 7 ^ n, n = n - s | 0, s = s << 24 ^ s >>> 8 ^ r, r = r - e | 0, t.b = e = e << 20 ^ e >>> 12 ^ n, t.c = n = n - s | 0, t.d = s << 16 ^ n >>> 16 ^ r, t.a = r - e | 0;
      }, t.a = 0, t.b = 0, t.c = -1640531527, t.d = 1367130551, e === Math.floor(e) ? (t.a = e / 4294967296 | 0, t.b = 0 | e) : n += e;

      for (var s = 0; s < n.length + 20; s++) {
        t.b ^= 0 | n.charCodeAt(s), t.next();
      }
    }

    function r(e, t) {
      return t.a = e.a, t.b = e.b, t.c = e.c, t.d = e.d, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.tychei = a;
  }(0, e);
}),
    Fa = {
  __proto__: null,
  default: {}
},
    Da = Na(function (e) {
  !function (t, n) {
    var s,
        r = this,
        a = 256,
        i = n.pow(a, 6),
        o = n.pow(2, 52),
        l = 2 * o,
        u = 255;

    function c(e, u, c) {
      var m = [],
          b = f(p((u = 1 == u ? {
        entropy: !0
      } : u || {}).entropy ? [e, g(t)] : null == e ? function () {
        try {
          var e;
          return s && (e = s.randomBytes) ? e = e(a) : (e = new Uint8Array(a), (r.crypto || r.msCrypto).getRandomValues(e)), g(e);
        } catch (e) {
          var n = r.navigator,
              i = n && n.plugins;
          return [+new Date(), r, i, r.screen, g(t)];
        }
      }() : e, 3), m),
          x = new h(m),
          y = function y() {
        for (var e = x.g(6), t = i, n = 0; e < o;) {
          e = (e + n) * a, t *= a, n = x.g(1);
        }

        for (; e >= l;) {
          e /= 2, t /= 2, n >>>= 1;
        }

        return (e + n) / t;
      };

      return y.int32 = function () {
        return 0 | x.g(4);
      }, y.quick = function () {
        return x.g(4) / 4294967296;
      }, y.double = y, f(g(x.S), t), (u.pass || c || function (e, t, s, r) {
        return r && (r.S && d(r, x), e.state = function () {
          return d(x, {});
        }), s ? (n.random = e, t) : e;
      })(y, b, "global" in u ? u.global : this == n, u.state);
    }

    function h(e) {
      var t,
          n = e.length,
          s = this,
          r = 0,
          i = s.i = s.j = 0,
          o = s.S = [];

      for (n || (e = [n++]); r < a;) {
        o[r] = r++;
      }

      for (r = 0; r < a; r++) {
        o[r] = o[i = u & i + e[r % n] + (t = o[r])], o[i] = t;
      }

      (s.g = function (e) {
        for (var t, n = 0, r = s.i, i = s.j, o = s.S; e--;) {
          t = o[r = u & r + 1], n = n * a + o[u & (o[r] = o[i = u & i + t]) + (o[i] = t)];
        }

        return s.i = r, s.j = i, n;
      })(a);
    }

    function d(e, t) {
      return t.i = e.i, t.j = e.j, t.S = e.S.slice(), t;
    }

    function p(e, t) {
      var n,
          s = [],
          r = typeof e;
      if (t && "object" == r) for (n in e) {
        try {
          s.push(p(e[n], t - 1));
        } catch (e) {}
      }
      return s.length ? s : "string" == r ? e : e + "\0";
    }

    function f(e, t) {
      for (var n, s = e + "", r = 0; r < s.length;) {
        t[u & r] = u & (n ^= 19 * t[u & r]) + s.charCodeAt(r++);
      }

      return g(t);
    }

    function g(e) {
      return String.fromCharCode.apply(0, e);
    }

    if (n.seedrandom = c, f(n.random(), t), e.exports) {
      e.exports = c;

      try {
        s = Fa;
      } catch (e) {}
    }
  }([], Math);
});
Da.alea = Ca, Da.xor128 = Sa, Da.xorwow = Ta, Da.xorshift7 = Ea, Da.xor4096 = Ra, Da.tychei = Aa;
var _a = Da;

class Oa {
  constructor(e, t, n, s, r) {
    this.mean = e, this.stdDev = t, this.dtype = n, this.nextVal = NaN, this.truncated = s, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    var a = r || Math.random();
    this.random = _a.alea(a.toString());
  }

  nextValue() {
    if (!isNaN(this.nextVal)) {
      var _e57 = this.nextVal;
      return this.nextVal = NaN, _e57;
    }

    var e,
        t,
        n = !1;

    for (; !n;) {
      var _s35 = void 0,
          _r28 = void 0,
          _a15 = void 0;

      do {
        _s35 = 2 * this.random() - 1, _r28 = 2 * this.random() - 1, _a15 = _s35 * _s35 + _r28 * _r28;
      } while (_a15 >= 1 || 0 === _a15);

      var _i11 = Math.sqrt(-2 * Math.log(_a15) / _a15);

      e = this.mean + this.stdDev * _s35 * _i11, t = this.mean + this.stdDev * _r28 * _i11, this.truncated && !this.isValidTruncated(e) || (n = !0);
    }

    return this.truncated && !this.isValidTruncated(t) || (this.nextVal = this.convertValue(t)), this.convertValue(e);
  }

  convertValue(e) {
    return null == this.dtype || "float32" === this.dtype ? e : Math.round(e);
  }

  isValidTruncated(e) {
    return e <= this.upper && e >= this.lower;
  }

}

class Ma {
  constructor() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    if (this.canReturnFloat = () => null == this.dtype || "float32" === this.dtype, this.min = e, this.range = t - e, this.dtype = n, null == s && (s = Math.random()), "number" == typeof s && (s = s.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between ".concat(e, " - ").concat(t, " <= 1 and dtype is not float"));
    this.random = _a.alea(s);
  }

  convertValue(e) {
    return this.canReturnFloat() ? e : Math.round(e);
  }

  nextValue() {
    return this.convertValue(this.min + this.range * this.random());
  }

}

var La = At({
  randomNormal_: function randomNormal_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    if (null != s && "bool" === s) throw new Error("Unsupported data type ".concat(s));
    var a = new Oa(t, n, s, !1, r),
        i = dn(e, s);

    for (var _e58 = 0; _e58 < i.values.length; _e58++) {
      i.values[_e58] = a.nextValue();
    }

    return i.toTensor();
  }
}),
    za = At({
  randomUniform_: function randomUniform_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "float32";
    var r = arguments.length > 4 ? arguments[4] : undefined;
    var a = dn(e, s),
        i = new Ma(t, n, null, r);

    for (var _e59 = 0; _e59 < a.values.length; _e59++) {
      a.values[_e59] = i.nextValue();
    }

    return a.toTensor();
  }
});

function Ba(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "float32";
  if (0 === n) throw new Error("Cannot have a step of zero");
  return wt.runKernel("Range", {}, {
    start: e,
    stop: t,
    step: n,
    dtype: s
  });
}

var Pa = At({
  real_: function real_(e) {
    var t = Et(e, "input", "real");
    return wt.runKernel("Real", {
      input: t
    });
  }
}),
    Wa = At({
  reciprocal_: function reciprocal_(e) {
    var t = Et(e, "x", "reciprocal");
    return wt.runKernel("Reciprocal", {
      x: t
    });
  }
}),
    Ua = At({
  relu_: function relu_(e) {
    var t = Et(e, "x", "relu");
    return wt.runKernel("Relu", {
      x: t
    });
  }
}),
    Va = At({
  relu6_: function relu6_(e) {
    var t = Et(e, "x", "relu6");
    return wt.runKernel("Relu6", {
      x: t
    });
  }
}),
    Ga = At({
  reverse_: function reverse_(e, t) {
    var n = Et(e, "x", "reverse");
    return wt.runKernel("Reverse", {
      x: n
    }, {
      dims: t
    });
  }
}),
    Ha = At({
  round_: function round_(e) {
    var t = Et(e, "x", "round");
    return wt.runKernel("Round", {
      x: t
    });
  }
}),
    ja = At({
  rsqrt_: function rsqrt_(e) {
    var t = Et(e, "x", "rsqrt");
    return wt.runKernel("Rsqrt", {
      x: t
    });
  }
});

function qa(e, t) {
  if (($(e) && "string" !== t || Array.isArray(e)) && "complex64" !== t) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if ("string" === t && $(e) && !(e instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return Dt(e, [], [], t);
}

var Ka = At({
  selu_: function selu_(e) {
    var t = Et(e, "x", "selu");
    return wt.runKernel("Selu", {
      x: t
    });
  }
}),
    Xa = At({
  separableConv2d_: function separableConv2d_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "NHWC";
    var o = Et(e, "x", "separableConv2d"),
        u = Et(t, "depthwiseFilter", "separableConv2d"),
        c = Et(n, "pointwiseFilter", "separableConv2d");
    var h = o,
        d = !1;
    if (3 === o.rank && (d = !0, h = Es(o, [1, o.shape[0], o.shape[1], o.shape[2]])), "NCHW" === i) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    l(4 === h.rank, () => "Error in separableConv2d: input must be rank 4, but got rank ".concat(h.rank, ".")), l(4 === u.rank, () => "Error in separableConv2d: depthwise filter must be rank 4, but got rank ".concat(u.rank, ".")), l(4 === c.rank, () => "Error in separableConv2d: pointwise filter must be rank 4, but got rank ".concat(u.rank, ".")), l(1 === c.shape[0], () => "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ".concat(c.shape[0], ".")), l(1 === c.shape[1], () => "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ".concat(c.shape[1], "."));
    var p = u.shape[2],
        f = u.shape[3];
    l(c.shape[2] === p * f, () => "Error in separableConv2d: the third dimension of pointwise filter must be ".concat(p * f, ", but got ").concat(c.shape[2], "."));
    var g = ir(h, u, s, r, i, a),
        m = Xs(g, c, 1, "valid", i);
    return d ? Es(m, [m.shape[1], m.shape[2], m.shape[3]]) : m;
  }
}),
    Ya = At({
  sign_: function sign_(e) {
    var t = Et(e, "x", "sign");
    return wt.runKernel("Sign", {
      x: t
    });
  }
}),
    Ja = At({
  sin_: function sin_(e) {
    var t = Et(e, "x", "sin");
    return wt.runKernel("Sin", {
      x: t
    });
  }
}),
    Za = At({
  sinh_: function sinh_(e) {
    var t = Et(e, "x", "sinh");
    return wt.runKernel("Sinh", {
      x: t
    });
  }
}),
    Qa = At({
  slice1d_: function slice1d_(e, t, n) {
    var s = Et(e, "x", "slice1d");
    return l(1 === s.rank, () => "slice1d expects a rank-1 tensor, but got a rank-".concat(s.rank, " tensor")), _s(s, [t], [n]);
  }
}),
    ei = At({
  slice2d_: function slice2d_(e, t, n) {
    var s = Et(e, "x", "slice2d");
    return l(2 === s.rank, () => "slice2d expects a rank-2 tensor, but got a rank-".concat(s.rank, " tensor")), _s(s, t, n);
  }
}),
    ti = At({
  slice3d_: function slice3d_(e, t, n) {
    var s = Et(e, "x", "slice3d");
    return l(3 === s.rank, () => "slice3d expects a rank-3 tensor, but got a rank-".concat(s.rank, " tensor")), _s(s, t, n);
  }
}),
    ni = At({
  slice4d_: function slice4d_(e, t, n) {
    var s = Et(e, "x", "slice4d");
    return l(4 === s.rank, () => "slice4d expects a rank-4 tensor, but got a rank-".concat(s.rank, " tensor")), _s(s, t, n);
  }
}),
    si = At({
  softmax_: function softmax_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var n = Et(e, "logits", "softmax", "float32");
    if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(n.rank, " and dim was ").concat(t));
    return wt.runKernel("Softmax", {
      logits: n
    }, {
      dim: t
    });
  }
}),
    ri = At({
  fft_: function fft_(e) {
    return l("complex64" === e.dtype, () => "The dtype for tf.spectral.fft() must be complex64 but got ".concat(e.dtype, ".")), wt.runKernel("FFT", {
      input: e
    });
  }
}),
    ai = At({
  ifft_: function ifft_(e) {
    return l("complex64" === e.dtype, () => "The dtype for tf.spectral.ifft() must be complex64 but got ".concat(e.dtype, ".")), wt.runKernel("IFFT", {
      input: e
    });
  }
}),
    ii = At({
  irfft_: function irfft_(e) {
    var t = e.shape[e.shape.length - 1],
        n = e.size / t;
    var s;

    if (t <= 2) {
      var _r29 = Es(e, [n, t]);

      s = ai(_r29);
    } else {
      var _r30 = [n, 2 * (t - 1)],
          _a16 = Es(Pa(e), [n, t]),
          _i12 = Es(Tr(e), [n, t]),
          _o10 = Ga(_s(_a16, [0, 1], [n, t - 2]), 1),
          _l5 = ss(Ga(_s(_i12, [0, 1], [n, t - 2]), 1), qa(-1)),
          _u4 = Fs([_a16, _o10], 1),
          _c3 = Fs([_i12, _l5], 1),
          _h2 = Es(Ft(_u4, _c3), [_r30[0], _r30[1]]);

      s = ai(_h2);
    }

    if (s = Pa(s), 3 === e.rank && 0 !== e.shape[0]) {
      var _t59 = s,
          _n30 = e.shape[0];
      s = Es(s, [_n30, s.shape[0] / _n30, s.shape[1]]), _t59.dispose();
    }

    return s;
  }
}),
    oi = At({
  split_: function split_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = Et(e, "x", "split");
    return wt.runKernel("SplitV", {
      x: s
    }, {
      numOrSizeSplits: t,
      axis: n
    });
  }
}),
    li = At({
  rfft_: function rfft_(e, t) {
    l("float32" === e.dtype, () => "The dtype for rfft() must be real value but got ".concat(e.dtype));
    var n = e.shape[e.shape.length - 1];
    var s = e.size / n;
    var r;

    if (null != t && t < n) {
      var _s36 = e.shape.map(e => 0),
          _a17 = e.shape.map(e => e);

      _a17[e.shape.length - 1] = t, r = _s(e, _s36, _a17), n = t;
    } else if (null != t && t > n) {
      var _s37 = e.shape.map(e => e);

      _s37[e.shape.length - 1] = t - n, r = Fs([e, ua(_s37)], e.shape.length - 1), n = t;
    } else r = e;

    var a = pr(r),
        i = Es(Ft(r, a), [s, n]),
        o = ri(i),
        u = Math.floor(n / 2) + 1,
        c = Pa(o),
        h = Tr(o),
        d = oi(c, [u, n - u], c.shape.length - 1),
        p = oi(h, [u, n - u], h.shape.length - 1),
        f = r.shape.slice();
    return f[r.shape.length - 1] = u, Es(Ft(d[0], p[0]), f);
  }
}),
    ui = At({
  sqrt_: function sqrt_(e) {
    var t = Et(e, "x", "sqrt");
    return wt.runKernel("Sqrt", {
      x: t
    });
  }
}),
    ci = At({
  squaredDifference_: function squaredDifference_(e, t) {
    var n = Et(e, "a", "squaredDifference"),
        s = Et(t, "b", "squaredDifference");
    return [n, s] = ft(n, s), cr(n.shape, s.shape), wt.runKernel("SquaredDifference", {
      a: n,
      b: s
    }, {});
  }
}),
    hi = At({
  squeeze_: function squeeze_(e, t) {
    var n = Et(e, "x", "squeeze");
    return Es(n, k(n.shape, t).newShape);
  }
}),
    di = At({
  stack_: function stack_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Rt(e, "tensors", "stack", "string_or_numeric");
    return l(n.length >= 1, () => "Pass at least one tensor to tf.stack"), n.length > 0 && l(t <= n[0].rank, () => "Axis must be <= rank of the tensor"), wt.runKernel("Pack", n, {
      axis: t
    });
  }
}),
    pi = At({
  step_: function step_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "step");
    return wt.runKernel("Step", {
      x: n
    }, {
      alpha: t
    });
  }
}),
    fi = At({
  stridedSlice_: function stridedSlice_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    var u = Et(e, "x", "stridedSlice", "string_or_numeric");
    return wt.runKernel("StridedSlice", {
      x: u
    }, {
      begin: t,
      end: n,
      strides: s,
      beginMask: r,
      endMask: a,
      ellipsisMask: i,
      newAxisMask: o,
      shrinkAxisMask: l
    });
  }
}),
    gi = At({
  tan_: function tan_(e) {
    var t = Et(e, "x", "tan");
    return wt.runKernel("Tan", {
      x: t
    });
  }
});

function mi(e, t) {
  c(e);
  var n = Ct(e, t);
  if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return Dt(e, null, n, t);
}

function bi(e, t, n) {
  if (c(e), null != t && 2 !== t.length) throw new Error("tensor2d() requires shape to have two numbers");
  var s = Ct(e, n);
  if (2 !== s.length && 1 !== s.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (1 === s.length && null == t) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return Dt(e, t, s, n);
}

var xi = At({
  topk_: function topk_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    var s = Et(e, "x", "topk");
    if (0 === s.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
    var r = s.shape[s.shape.length - 1];
    if (t < 0) throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));
    if (t > r) throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r, ") but got ").concat(t));
    var a = {
      x: s
    },
        i = {
      k: t,
      sorted: n
    },
        [o, l] = wt.runKernel("TopK", a, i);
    return {
      values: o,
      indices: l
    };
  }
}),
    yi = At({
  truncatedNormal_: function truncatedNormal_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    if (null != s && "bool" === s) throw new Error("Unsupported data type $ { dtype }");
    var a = new Oa(t, n, s, !0, r),
        i = dn(e, s);

    for (var _e60 = 0; _e60 < i.values.length; _e60++) {
      i.values[_e60] = a.nextValue();
    }

    return i.toTensor();
  }
}),
    ki = At({
  unique_: function unique_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "unique", "string_or_numeric");
    l(n.rank > 0, () => "The input tensor must be at least 1D");
    var s = {
      x: n
    },
        r = {
      axis: t
    },
        [a, i] = wt.runKernel("Unique", s, r);
    return {
      values: a,
      indices: i
    };
  }
}),
    wi = At({
  unsortedSegmentSum_: function unsortedSegmentSum_(e, t, n) {
    var s = Et(e, "x", "unsortedSegmentSum"),
        r = Et(t, "segmentIds", "unsortedSegmentSum", "int32");
    return l(f(n), () => "numSegments must be of dtype int"), wt.runKernel("UnsortedSegmentSum", {
      x: s,
      segmentIds: r
    }, {
      numSegments: n
    });
  }
}),
    vi = At({
  unstack_: function unstack_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "unstack", "string_or_numeric");
    return l(t >= -n.shape.length && t < n.shape.length, () => "Axis = ".concat(t, " is not in [-").concat(n.shape.length, ", ").concat(n.shape.length, ")")), wt.runKernel("Unpack", {
      value: n
    }, {
      axis: t
    });
  }
});

function Ii(e, t) {
  var n = [];

  for (var _e61 = 0; _e61 < t.length; _e61++) {
    t[_e61] && n.push(_e61);
  }

  var s = dn(e, "int32"),
      r = dn([n.length, e.length], "int32");

  for (var _t60 = 0; _t60 < n.length; _t60++) {
    var _a18 = s.indexToLoc(n[_t60]);

    r.values.set(_a18, _t60 * e.length);
  }

  return r.toTensor();
}

function $i(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (0 === e.rank) return rs(e);
  if (1 !== e.rank && null === n) return $i(Es(e, [-1]), t, n);

  if (1 === e.rank || "number" == typeof n || Array.isArray(n) && 1 === n.length) {
    if (1 === t) return Gr(rs(e), n);
    if (Infinity === t) return Ur(rs(e), n);
    if (-Infinity === t) return ha(rs(e), n);
    if ("euclidean" === t || 2 === t) return ui(Gr(va(rs(e), qa(2, "int32")), n));
    throw new Error("Error in norm: invalid ord value: ".concat(t));
  }

  if (Array.isArray(n) && 2 === n.length) {
    if (1 === t) return Ur(Gr(rs(e), n[0]), n[1] - 1);
    if (Infinity === t) return Ur(Gr(rs(e), n[1]), n[0]);
    if (-Infinity === t) return ha(Gr(rs(e), n[1]), n[0]);
    if ("fro" === t || "euclidean" === t) return ui(Gr(ga(e), n));
    throw new Error("Error in norm: invalid ord value: ".concat(t));
  }

  throw new Error("Error in norm: invalid axis: ".concat(n));
}

var Ni = At({
  norm_: function norm_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "euclidean";
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = $i(e = Et(e, "x", "norm"), t, n);
    var a = r.shape;

    if (s) {
      var _t61 = y(n, e.shape);

      a = Xr(r.shape, _t61);
    }

    return Es(r, a);
  }
}),
    Ci = At({
  dropout_: function dropout_(e, t, n, s) {
    var r = Et(e, "x", "dropout");
    if (l("float32" === r.dtype, () => "x has to be a floating point tensor since it's going to be scaled, but got a ".concat(r.dtype, " tensor instead.")), l(t >= 0 && t < 1, () => "rate must be a float in the range [0, 1), but got ".concat(t, ".")), 0 === t) return e instanceof st ? r.clone() : r;

    var a = function (e, t) {
      if (null == t) return e.shape.slice();
      if (p(e.shape, t)) return t;

      if (e.shape.length === t.length) {
        var _n31 = [];

        for (var _s38 = 0; _s38 < e.shape.length; _s38++) {
          _n31.push(null == t[_s38] && null != e.shape[_s38] ? e.shape[_s38] : t[_s38]);
        }

        return _n31;
      }

      return t;
    }(r, n),
        i = 1 - t,
        o = ns($r(es(za(a, 0, 1, "float32", s), i)), i);

    return ss(r, o);
  }
});

function Si(e, t, n) {
  var s = 1 - e % 2,
      r = new Float32Array(e);

  for (var _a19 = 0; _a19 < e; ++_a19) {
    var _i13 = 2 * Math.PI * _a19 / (e + s - 1);

    r[_a19] = t - n * Math.cos(_i13);
  }

  return mi(r, "float32");
}

var Ti = At({
  conv2DBackpropFilter_: function conv2DBackpropFilter_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NHWC";
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = e;
    3 === e.rank && (o = Es(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
    var u = t;
    3 === u.rank && (u = Es(t, [1, t.shape[0], t.shape[1], t.shape[2]])), l(4 === o.rank, () => "Error in conv2dDerFilter: input must be rank 4, but got shape ".concat(o.shape, ".")), l(4 === u.rank, () => "Error in conv2dDerFilter: dy must be rank 4, but got shape ".concat(u.shape, ".")), l(4 === n.length, () => "Error in conv2dDerFilter: filterShape must be length 4, but got ".concat(n, "."));
    var c = "NHWC" === a ? o.shape[3] : o.shape[1],
        h = "NHWC" === a ? u.shape[3] : u.shape[1];
    return l(c === n[2], () => "Error in conv2dDerFilter: depth of input ".concat(c, ") must match input depth in filter (").concat(n[2], ".")), l(h === n[3], () => "Error in conv2dDerFilter: depth of dy (".concat(h, ") must match output depth for filter (").concat(n[3], ").")), null != i && l(f(r), () => "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(r, ".")), wt.runKernel("Conv2DBackpropFilter", {
      x: o,
      dy: u
    }, {
      strides: s,
      pad: r,
      dataFormat: a,
      dimRoundingMode: i,
      filterShape: n
    });
  }
});

function Ei(e, t, n) {
  if (null == n || "linear" === n) return e;
  if ("relu" === n) return ss(e, pi(t));
  throw new Error("Cannot compute gradient for fused activation ".concat(n, "."));
}

function Ri(e, t) {
  var n = t;
  var s = ur(e.shape, t.shape);
  return s.length > 0 && (n = Gr(n, s)), Es(n, e.shape);
}

function Ai(e, t, n, s) {
  if ("linear" === t) return e;
  if ("relu" === t) return Ua(e);
  if ("elu" === t) return mr(e);
  if ("relu6" === t) return Va(e);
  if ("prelu" === t) return Ia(e, n);
  if ("leakyrelu" === t) return Fr(e, s);
  if ("sigmoid" === t) return Ds(e);
  throw new Error("Unknown fused activation ".concat(t, "."));
}

var Fi = (e, t) => !(e > 0) || "linear" === t,
    Di = At({
  fusedConv2d_: function fusedConv2d_(_ref3) {
    var {
      x: e,
      filter: t,
      strides: n,
      pad: s,
      dataFormat: r = "NHWC",
      dilations: a = [1, 1],
      dimRoundingMode: i,
      bias: o,
      activation: u = "linear",
      preluActivationWeights: c,
      leakyreluAlpha: h
    } = _ref3;

    if (!1 === Fi(wt.state.gradientDepth, u = u || "linear")) {
      var _l6 = Xs(e, t, n, s, r, a, i);

      return null != o && (_l6 = es(_l6, o)), Ai(_l6, u, c, h);
    }

    var d = Et(e, "x", "conv2d"),
        p = Et(t, "filter", "conv2d");
    var g = d,
        m = !1;
    3 === d.rank && (m = !0, g = Es(d, [1, d.shape[0], d.shape[1], d.shape[2]])), l(4 === g.rank, () => "Error in fused conv2d: input must be rank 4, but got rank ".concat(g.rank, ".")), l(4 === p.rank, () => "Error in fused conv2d: filter must be rank 4, but got rank ".concat(p.rank, ".")), null != i && l(f(s), () => "Error in fused conv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, ".")), l(g.shape[3] === p.shape[2], () => "Error in conv2d: depth of input (".concat(g.shape[3], ") must match input depth for filter ").concat(p.shape[2], ".")), l(Ss(n, a), () => "Error in conv2D: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '").concat(a, "'")), l("NHWC" === r, () => "Error in conv2d: got dataFormat of ".concat(r, " but only NHWC is currently supported."));
    var b = ys(g.shape, p.shape, n, a, s, i);
    var x, y;
    null != o && (x = Et(o, "bias", "fused conv2d"), [x] = ft(x, d), cr(b.outShape, x.shape)), null != c && (y = Et(c, "prelu weights", "fused conv2d"));

    var k = (e, t) => {
      var [r, i, o, c] = t,
          h = Ei(e, o, u);
      l(Cs(a), () => "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(a, "'"));
      var d = [Js(i.shape, h, r, n, s), Ti(i, h, r.shape, n, s)];

      if (null != c) {
        var _e62 = Ri(c, h);

        d.push(_e62);
      }

      return d;
    },
        w = {
      x: g,
      filter: p,
      bias: x,
      preluActivationWeights: y
    },
        v = {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a,
      dimRoundingMode: i,
      activation: u,
      leakyreluAlpha: h
    };

    return null == o ? zr((e, t, n) => {
      var s = wt.runKernel("FusedConv2D", w, v);
      return n([t, e, s]), m && (s = Es(s, [s.shape[1], s.shape[2], s.shape[3]])), {
        value: s,
        gradFunc: k
      };
    })(g, p) : zr((e, t, n, s) => {
      var r = wt.runKernel("FusedConv2D", w, v);
      return s([t, e, r, n]), m && (r = Es(r, [r.shape[1], r.shape[2], r.shape[3]])), {
        value: r,
        gradFunc: k
      };
    })(g, p, x);
  }
}),
    _i = At({
  depthwiseConv2dNativeBackpropFilter_: function depthwiseConv2dNativeBackpropFilter_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = e;
    3 === e.rank && (o = Es(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
    var l = t;
    return 3 === l.rank && (l = Es(t, [1, t.shape[0], t.shape[1], t.shape[2]])), wt.runKernel("DepthwiseConv2dNativeBackpropFilter", {
      x: o,
      dy: l
    }, {
      strides: s,
      pad: r,
      dimRoundingMode: i,
      dilations: a,
      filterShape: n
    });
  }
}),
    Oi = At({
  depthwiseConv2dNativeBackpropInput_: function depthwiseConv2dNativeBackpropInput_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = t,
        l = !1;
    3 === t.rank && (l = !0, o = Es(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
    var u = wt.runKernel("DepthwiseConv2dNativeBackpropInput", {
      dy: o,
      filter: n
    }, {
      strides: s,
      pad: r,
      dimRoundingMode: i,
      dilations: a,
      inputShape: e
    });
    return l ? Es(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    Mi = At({
  fusedMatMul_: function fusedMatMul_(_ref4) {
    var {
      a: e,
      b: t,
      transposeA: n = !1,
      transposeB: s = !1,
      bias: r,
      activation: a = "linear",
      preluActivationWeights: i,
      leakyreluAlpha: o
    } = _ref4;

    if (!1 === Fi(wt.state.gradientDepth, a)) {
      var _l7 = vn(e, t, n, s);

      return null != r && (_l7 = es(_l7, r)), Ai(_l7, a, i, o);
    }

    var u = Et(e, "a", "fused matMul"),
        c = Et(t, "b", "fused matMul");
    [u, c] = ft(u, c);
    var h = n ? u.shape[u.rank - 2] : u.shape[u.rank - 1],
        f = s ? c.shape[c.rank - 1] : c.shape[c.rank - 2],
        g = n ? u.shape[u.rank - 1] : u.shape[u.rank - 2],
        m = s ? c.shape[c.rank - 2] : c.shape[c.rank - 1],
        b = u.shape.slice(0, -2),
        x = c.shape.slice(0, -2),
        y = d(b),
        k = d(x);
    l(u.rank >= 2 && c.rank >= 2 && u.rank === c.rank, () => "Error in fused matMul: inputs must have the same rank of at least 2, got ranks ".concat(u.rank, " and ").concat(c.rank, ".")), l(p(b, x), () => "Error in fused matMul: outer dimensions (".concat(b, ") and (").concat(x, ") of Tensors with shapes ").concat(u.shape, " and ").concat(c.shape, " must match.")), l(h === f, () => "Error in fused matMul: inner shapes (".concat(h, ") and (").concat(f, ") of Tensors with shapes ").concat(u.shape, " and ").concat(c.shape, " and transposeA=").concat(n, " and transposeB=").concat(s, " must match."));
    var w = u.shape.slice(0, -2).concat([g, m]),
        v = Es(u, n ? [y, h, g] : [y, g, h]),
        I = Es(c, s ? [k, m, f] : [k, f, m]);
    var $, N;
    null != r && ($ = Et(r, "bias", "fused matMul"), [$] = ft($, u), cr(w, $.shape)), null != i && (N = Et(i, "prelu weights", "fused matMul"));

    var C = (e, t) => {
      var [i, o, l, u] = t,
          c = Ei(Es(e, l.shape), l, a);
      var h, d;
      return n || s ? !n && s ? (h = vn(c, o, !1, !1), d = vn(c, i, !0, !1)) : n && !s ? (h = vn(o, c, !1, !0), d = vn(i, c, !1, !1)) : (h = vn(o, c, !0, !0), d = vn(c, i, !0, !0)) : (h = vn(c, o, !1, !0), d = vn(i, c, !0, !1)), null != r ? [h, d, Ri(u, c)] : [h, d];
    },
        S = {
      a: v,
      b: I,
      bias: $,
      preluActivationWeights: N
    },
        T = {
      transposeA: n,
      transposeB: s,
      activation: a,
      leakyreluAlpha: o
    };

    return null == r ? zr((e, t, n) => {
      var s = wt.runKernel("_FusedMatMul", S, T);
      return n([e, t, s]), {
        value: Es(s, w),
        gradFunc: C
      };
    })(v, I) : zr((e, t, n, s) => {
      var r = wt.runKernel("_FusedMatMul", S, T);
      return s([e, t, r, n]), {
        value: Es(r, w),
        gradFunc: C
      };
    })(v, I, $);
  }
});

At({
  hammingWindow_: function hammingWindow_(e) {
    return Si(e, .54, .46);
  }
});
var Li = At({
  hannWindow_: function hannWindow_(e) {
    return Si(e, .5, .5);
  }
}),
    zi = At({
  frame_: function frame_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var a = 0;
    var i = [];

    for (; a + t <= e.size;) {
      i.push(_s(e, a, t)), a += n;
    }

    if (s) for (; a < e.size;) {
      var _s39 = a + t - e.size,
          _o11 = Fs([_s(e, a, t - _s39), Ir([_s39], r)]);

      i.push(_o11), a += n;
    }
    return 0 === i.length ? bi([], [0, t]) : Es(Fs(i), [i.length, t]);
  }
});
At({
  stft_: function stft_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Li;
    null == s && (s = Math.floor(Math.pow(2, Math.ceil(Math.log(t) / Math.log(2)))));
    var a = zi(e, t, n),
        i = ss(a, r(t));
    return li(i, s);
  }
});
var Bi = At({
  cropAndResize_: function cropAndResize_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "bilinear";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var i = Et(e, "image", "cropAndResize"),
        o = Et(t, "boxes", "cropAndResize", "float32"),
        u = Et(n, "boxInd", "cropAndResize", "int32"),
        c = o.shape[0];
    return l(4 === i.rank, () => "Error in cropAndResize: image must be rank 4,but got rank ".concat(i.rank, ".")), l(2 === o.rank && 4 === o.shape[1], () => "Error in cropAndResize: boxes must be have size [".concat(c, ",4] but had shape ").concat(o.shape, ".")), l(1 === u.rank && u.shape[0] === c, () => "Error in cropAndResize: boxInd must be have size [".concat(c, "] but had shape ").concat(o.shape, ".")), l(2 === s.length, () => "Error in cropAndResize: cropSize must be of length 2, but got length ".concat(s.length, ".")), l(s[0] >= 1 && s[1] >= 1, () => "cropSize must be atleast [1,1], but was ".concat(s)), l("bilinear" === r || "nearest" === r, () => "method must be bilinear or nearest, but was ".concat(r)), wt.runKernel("CropAndResize", {
      image: i,
      boxes: o,
      boxInd: u
    }, {
      method: r,
      extrapolationValue: a,
      cropSize: s
    });
  }
}),
    Pi = At({
  flipLeftRight_: function flipLeftRight_(e) {
    var t = Et(e, "image", "flipLeftRight", "float32");
    return l(4 === t.rank, () => "Error in flipLeftRight: image must be rank 4,but got rank ".concat(t.rank, ".")), wt.runKernel("FlipLeftRight", {
      image: t
    }, {});
  }
}),
    Wi = At({
  rotateWithOffset_: function rotateWithOffset_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = Et(e, "image", "rotateWithOffset", "float32");
    return l(4 === r.rank, () => "Error in rotateWithOffset: image must be rank 4,but got rank ".concat(r.rank, ".")), wt.runKernel("RotateWithOffset", {
      image: r
    }, {
      radians: t,
      fillValue: n,
      center: s
    });
  }
});

function Ui(e, t, n, s, r, a) {
  null == s && (s = .5), null == r && (r = Number.NEGATIVE_INFINITY), null == a && (a = 0);
  var i = e.shape[0];
  return n = Math.min(n, i), l(0 <= s && s <= 1, () => "iouThreshold must be in [0, 1], but was '".concat(s, "'")), l(2 === e.rank, () => "boxes must be a 2D tensor, but was of rank '".concat(e.rank, "'")), l(4 === e.shape[1], () => "boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1])), l(1 === t.rank, () => "scores must be a 1D tensor"), l(t.shape[0] === i, () => "scores has incompatible shape with boxes. Expected ".concat(i, ", but was ").concat(t.shape[0])), l(0 <= a && a <= 1, () => "softNmsSigma must be in [0, 1], but was '".concat(a, "'")), {
    maxOutputSize: n,
    iouThreshold: s,
    scoreThreshold: r,
    softNmsSigma: a
  };
}

var Vi = At({
  nonMaxSuppression_: function nonMaxSuppression_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
    var a = Et(e, "boxes", "nonMaxSuppression"),
        i = Et(t, "scores", "nonMaxSuppression"),
        o = Ui(a, i, n, s, r);
    return wt.runKernel("NonMaxSuppressionV3", {
      boxes: a,
      scores: i
    }, {
      maxOutputSize: n = o.maxOutputSize,
      iouThreshold: s = o.iouThreshold,
      scoreThreshold: r = o.scoreThreshold
    });
  }
});

function Gi(e, t, n) {
  var s = function (e, t, n) {
    return function (e, t, n) {
      var s = 0,
          r = e.length,
          a = 0,
          i = !1;

      for (; s < r;) {
        a = s + (r - s >>> 1);

        var _o12 = n(t, e[a]);

        _o12 > 0 ? s = a + 1 : (r = a, i = !_o12);
      }

      return i ? s : -s - 1;
    }(e, t, n || Hi);
  }(e, t, n);

  e.splice(s < 0 ? -(s + 1) : s, 0, t);
}

function Hi(e, t) {
  return e > t ? 1 : e < t ? -1 : 0;
}

function ji(e, t, n, s, r) {
  return Xi(e, t, n, s, r, 0);
}

function qi(e, t, n, s, r, a) {
  return Xi(e, t, n, s, r, 0, !1, a, !0);
}

function Ki(e, t, n, s, r, a) {
  return Xi(e, t, n, s, r, a, !0);
}

function Xi(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : !1;
  var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : !1;
  var u = [];

  for (var _e63 = 0; _e63 < t.length; _e63++) {
    t[_e63] > r && u.push({
      score: t[_e63],
      boxIndex: _e63,
      suppressBeginIndex: 0
    });
  }

  u.sort(Zi);
  var c = a > 0 ? -.5 / a : 0,
      h = [],
      d = [];

  for (; h.length < n && u.length > 0;) {
    var _t62 = u.pop(),
        {
      score: _n32,
      boxIndex: _a20,
      suppressBeginIndex: _i14
    } = _t62;

    if (_n32 < r) break;

    var _o13 = !1;

    for (var _n33 = h.length - 1; _n33 >= _i14; --_n33) {
      var _i15 = Yi(e, _a20, h[_n33]);

      if (_i15 >= s) {
        _o13 = !0;
        break;
      }

      if (_t62.score = _t62.score * Ji(s, c, _i15), _t62.score <= r) break;
    }

    _t62.suppressBeginIndex = h.length, _o13 || (_t62.score === _n32 ? (h.push(_a20), d.push(_t62.score)) : _t62.score > r && Gi(u, _t62, Zi));
  }

  var p = h.length,
      f = n - p;
  o && f > 0 && (h.push(...new Array(f).fill(0)), d.push(...new Array(f).fill(0)));
  var g = {
    selectedIndices: h
  };
  return i && (g.selectedScores = d), l && (g.validOutputs = p), g;
}

function Yi(e, t, n) {
  var s = e.subarray(4 * t, 4 * t + 4),
      r = e.subarray(4 * n, 4 * n + 4),
      a = Math.min(s[0], s[2]),
      i = Math.min(s[1], s[3]),
      o = Math.max(s[0], s[2]),
      l = Math.max(s[1], s[3]),
      u = Math.min(r[0], r[2]),
      c = Math.min(r[1], r[3]),
      h = Math.max(r[0], r[2]),
      d = Math.max(r[1], r[3]),
      p = (o - a) * (l - i),
      f = (h - u) * (d - c);
  if (p <= 0 || f <= 0) return 0;
  var g = Math.max(a, u),
      m = Math.max(i, c),
      b = Math.min(o, h),
      x = Math.min(l, d),
      y = Math.max(b - g, 0) * Math.max(x - m, 0);
  return y / (p + f - y);
}

function Ji(e, t, n) {
  var s = Math.exp(t * n * n);
  return n <= e ? s : 0;
}

function Zi(e, t) {
  return e.score - t.score || e.score === t.score && t.boxIndex - e.boxIndex;
}

var Qi = At({
  nonMaxSuppressionWithScore_: function nonMaxSuppressionWithScore_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var i = Et(e, "boxes", "nonMaxSuppression"),
        o = Et(t, "scores", "nonMaxSuppression"),
        l = Ui(i, o, n, s, r, a),
        u = wt.runKernel("NonMaxSuppressionV5", {
      boxes: i,
      scores: o
    }, {
      maxOutputSize: n = l.maxOutputSize,
      iouThreshold: s = l.iouThreshold,
      scoreThreshold: r = l.scoreThreshold,
      softNmsSigma: a = l.softNmsSigma
    });
    return {
      selectedIndices: u[0],
      selectedScores: u[1]
    };
  }
}),
    eo = At({
  nonMaxSuppressionPadded_: function nonMaxSuppressionPadded_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
    var i = Et(e, "boxes", "nonMaxSuppression"),
        o = Et(t, "scores", "nonMaxSuppression"),
        l = Ui(i, o, n, s, r, null),
        u = wt.runKernel("NonMaxSuppressionV4", {
      boxes: i,
      scores: o
    }, {
      maxOutputSize: l.maxOutputSize,
      iouThreshold: l.iouThreshold,
      scoreThreshold: l.scoreThreshold,
      padToMaxOutputSize: a
    });
    return {
      selectedIndices: u[0],
      validOutputs: u[1]
    };
  }
}),
    to = At({
  resizeBilinear_: function resizeBilinear_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Et(e, "images", "resizeBilinear");
    l(3 === r.rank || 4 === r.rank, () => "Error in resizeBilinear: x must be rank 3 or 4, but got rank ".concat(r.rank, ".")), l(2 === t.length, () => "Error in resizeBilinear: new shape must 2D, but got shape ".concat(t, ".")), l(!1 === s || !1 === n, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
    var a = r,
        i = !1;
    3 === r.rank && (i = !0, a = Es(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
    var o = wt.runKernel("ResizeBilinear", {
      images: a
    }, {
      alignCorners: n,
      halfPixelCenters: s,
      size: t
    });
    return i ? Es(o, [o.shape[1], o.shape[2], o.shape[3]]) : o;
  }
}),
    no = At({
  resizeNearestNeighbor_: function resizeNearestNeighbor_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Et(e, "images", "resizeNearestNeighbor");
    l(3 === r.rank || 4 === r.rank, () => "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ".concat(r.rank, ".")), l(2 === t.length, () => "Error in resizeNearestNeighbor: new shape must 2D, but got shape ".concat(t, ".")), l("float32" === r.dtype || "int32" === r.dtype, () => "`images` must have `int32` or `float32` as dtype"), l(!1 === s || !1 === n, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
    var a = r,
        i = !1;
    3 === r.rank && (i = !0, a = Es(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
    var o = wt.runKernel("ResizeNearestNeighbor", {
      images: a
    }, {
      alignCorners: n,
      halfPixelCenters: s,
      size: t
    });
    return i ? Es(o, [o.shape[1], o.shape[2], o.shape[3]]) : o;
  }
}),
    so = At({
  threshold_: function threshold_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "binary";
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = Et(e, "image", "threshold"),
        a = r.shape[0] * r.shape[1];
    var i,
        o,
        u,
        c,
        h = ss(mi([s]), 255);

    if (l(3 === r.rank, () => "Error in threshold: image must be rank 3,but got rank ".concat(r.rank, ".")), l(3 === r.shape[2] || 1 === r.shape[2], () => "Error in threshold: image color channel must be equal to 3 or 1but got ".concat(r.shape[2], ".")), l("int32" === r.dtype || "float32" === r.dtype, () => "Error in dtype: image dtype must be int32 or float32,but got dtype ".concat(r.dtype, ".")), l("otsu" === t || "binary" === t, () => "Method must be binary or otsu, but was ".concat(t)), 3 === r.shape[2]) {
      [i, o, u] = oi(r, [1, 1, 1], -1);

      var _e64 = ss(i, .2989),
          _t63 = ss(o, .587),
          _n34 = ss(u, .114);

      c = es(es(_e64, _t63), _n34);
    } else c = e;

    "otsu" === t && (h = function (e, t) {
      var n,
          s,
          r,
          a,
          i,
          o,
          l = mi([-1]),
          u = mi([0]),
          c = mi([0]);

      for (var _h3 = 0; _h3 < e.size - 1; _h3++) {
        n = _s(e, 0, _h3 + 1), s = _s(e, _h3 + 1), i = ns(Gr(n), t), o = ns(Gr(s), t);

        var _d4 = Gr(ss(n, Ba(0, n.size)));

        r = ns(_d4, Gr(n));

        var _p4 = Ir(s.shape, n.size),
            _f3 = es(Ba(0, s.size), _p4),
            _g4 = ss(s, _f3);

        a = ns(Gr(_g4), Gr(s));

        var _m3 = Vr(r, a),
            _b3 = Vr(r, a),
            _x9 = ss(i, o);

        c = ss(ss(_x9, _m3), _b3);

        var _y3 = Cr(c, u);

        u = dr(_y3, c, u), l = dr(_y3, mi([_h3]), l);
      }

      return l;
    }(Ws(pn(Ha(c), "int32"), _t([]), 256), a));
    var d = n ? _r(c, h) : Cr(c, h);
    return pn(ss(d, 255), "int32");
  }
}),
    ro = At({
  transform_: function transform_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "nearest";
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "constant";
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var a = arguments.length > 5 ? arguments[5] : undefined;
    var i = Et(e, "image", "transform", "float32"),
        o = Et(t, "transforms", "transform", "float32");
    return l(4 === i.rank, () => "Error in transform: image must be rank 4,but got rank ".concat(i.rank, ".")), l(2 === o.rank && (o.shape[0] === i.shape[0] || 1 === o.shape[0]) && 8 === o.shape[1], () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), l(null == a || 2 === a.length, () => "Error in transform: outputShape must be [height, width] or null, but got ".concat(a, ".")), wt.runKernel("Transform", {
      image: i,
      transforms: o
    }, {
      interpolation: n,
      fillMode: s,
      fillValue: r,
      outputShape: a
    });
  }
}),
    ao = At({
  bandPart_: function bandPart_(e, t, n) {
    l(t % 1 == 0, () => "bandPart(): numLower must be an integer, got ".concat(t, ".")), l(n % 1 == 0, () => "bandPart(): numUpper must be an integer, got ".concat(n, "."));
    var s = Et(e, "a", "bandPart");
    l(s.rank >= 2, () => "bandPart(): Rank must be at least 2, got ".concat(s.rank, "."));
    var r = s.shape,
        [a, i] = s.shape.slice(-2);
    if (!(t <= a)) throw new Error("bandPart(): numLower (".concat(t, ") must not be greater than the number of rows (").concat(a, ")."));
    if (!(n <= i)) throw new Error("bandPart(): numUpper (".concat(n, ") must not be greater than the number of columns (").concat(i, ")."));
    t < 0 && (t = a), n < 0 && (n = i);
    var o = Es(Ba(0, a, 1, "int32"), [-1, 1]),
        u = Ba(0, i, 1, "int32"),
        c = Vr(o, u),
        h = ta(_r(c, qa(+t, "int32")), Sr(c, qa(-n, "int32"))),
        d = ua([a, i], s.dtype);
    return Es(di(vi(Es(s, [-1, a, i])).map(e => dr(h, e, d))), r);
  }
}),
    io = At({
  gramSchmidt_: function gramSchmidt_(e) {
    var t;

    if (Array.isArray(e)) {
      (function () {
        t = !1, l(null != e && e.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
        var n = e[0].shape[0];

        var _loop6 = function _loop6(_t64) {
          l(e[_t64].shape[0] === n, () => "Gram-Schmidt: Non-unique lengths found in the input vectors: (".concat(e[_t64].shape[0], " vs. ").concat(n, ")"));
        };

        for (var _t64 = 1; _t64 < e.length; ++_t64) {
          _loop6(_t64);
        }
      })();
    } else t = !0, e = oi(e, e.shape[0], 0).map(e => hi(e, [0]));

    l(e.length <= e[0].shape[0], () => "Gram-Schmidt: Number of vectors (".concat(e.length, ") exceeds number of dimensions (").concat(e[0].shape[0], ")."));
    var n = [],
        s = e;

    var _loop7 = function _loop7(_t65) {
      n.push(wt.tidy(() => {
        var e = s[_t65];
        if (_t65 > 0) for (var _s40 = 0; _s40 < _t65; ++_s40) {
          var _t66 = ss(Gr(ss(n[_s40], e)), n[_s40]);

          e = Vr(e, _t66);
        }
        return ns(e, Ni(e, "euclidean"));
      }));
    };

    for (var _t65 = 0; _t65 < e.length; ++_t65) {
      _loop7(_t65);
    }

    return t ? di(n, 0) : n;
  }
});

function oo(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  return wt.tidy(() => {
    l(2 === e.shape.length, () => "qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length, "D Tensor."));
    var n = e.shape[0],
        s = e.shape[1];
    var r = vr(n),
        a = fn(e);
    var i = bi([[1]], [1, 1]);
    var o = fn(i);
    var u = n >= s ? s : n;

    var _loop8 = function _loop8(_e65) {
      var t = a,
          l = o,
          u = r;
      [o, a, r] = wt.tidy(() => {
        var t = _s(a, [_e65, _e65], [n - _e65, 1]),
            l = Ni(t),
            u = _s(a, [_e65, _e65], [1, 1]),
            c = dr(Cr(u, 0), bi([[-1]]), bi([[1]])),
            h = Vr(u, ss(c, l)),
            d = ns(t, h);

        o = 1 === d.shape[0] ? fn(i) : Fs([i, _s(d, [1, 0], [d.shape[0] - 1, d.shape[1]])], 0);

        var p = Br(ns(vn(c, h), l)),
            f = _s(a, [_e65, 0], [n - _e65, s]),
            g = ss(p, o),
            m = $n(o);

        if (0 === _e65) a = Vr(f, vn(g, vn(m, f)));else {
          var _t67 = Vr(f, vn(g, vn(m, f)));

          a = Fs([_s(a, [0, 0], [_e65, s]), _t67], 0);
        }

        var b = $n(g),
            x = _s(r, [0, _e65], [n, r.shape[1] - _e65]);

        if (0 === _e65) r = Vr(x, vn(vn(x, o), b));else {
          var _t68 = Vr(x, vn(vn(x, o), b));

          r = Fs([_s(r, [0, 0], [n, _e65]), _t68], 1);
        }
        return [o, a, r];
      }), Jn([t, l, u]);
    };

    for (var _e65 = 0; _e65 < u; ++_e65) {
      _loop8(_e65);
    }

    return !t && n > s && (r = _s(r, [0, 0], [n, s]), a = _s(a, [0, 0], [s, s])), [r, a];
  });
}

var lo = At({
  qr_: function qr_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    if (l(e.rank >= 2, () => "qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank)), 2 === e.rank) return oo(e, t);
    {
      var _n35 = e.shape.slice(0, e.shape.length - 2).reduce((e, t) => e * t),
          _s41 = vi(Es(e, [_n35, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0),
          _r31 = [],
          _a21 = [];

      return _s41.forEach(e => {
        var [n, s] = oo(e, t);
        _r31.push(n), _a21.push(s);
      }), [Es(di(_r31, 0), e.shape), Es(di(_a21, 0), e.shape)];
    }
  }
});
var uo;
!function (e) {
  e[e.NONE = 0] = "NONE", e[e.MEAN = 1] = "MEAN", e[e.SUM = 2] = "SUM", e[e.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
}(uo || (uo = {}));
var co = At({
  computeWeightedLoss_: function computeWeightedLoss_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uo.SUM_BY_NONZERO_WEIGHTS;
    var s = Et(e, "losses", "computeWeightedLoss");
    var r = null;
    null != t && (r = Et(t, "weights", "computeWeightedLoss"));
    var a = null == r ? s : ss(s, r);
    if (n === uo.NONE) return a;
    if (n === uo.SUM) return Gr(a);

    if (n === uo.MEAN) {
      if (null == r) return la(a);
      {
        var _e66 = s.size / r.size,
            _t69 = ns(Gr(a), Gr(r));

        return _e66 > 1 ? ns(_t69, qa(_e66)) : _t69;
      }
    }

    if (n === uo.SUM_BY_NONZERO_WEIGHTS) {
      if (null == r) return ns(Gr(a), qa(s.size));
      {
        var _e67 = ss(r, ca(s.shape)),
            _t70 = pn(Gr(ba(_e67, qa(0))), "float32");

        return ns(Gr(a), _t70);
      }
    }

    throw Error("Unknown reduction: ".concat(n));
  }
});
At({
  absoluteDifference_: function absoluteDifference_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uo.SUM_BY_NONZERO_WEIGHTS;
    var r = Et(e, "labels", "absoluteDifference"),
        a = Et(t, "predictions", "absoluteDifference");
    var i = null;
    null != n && (i = Et(n, "weights", "absoluteDifference")), u(r.shape, a.shape, "Error in absoluteDifference: ");
    var o = rs(Vr(r, a));
    return co(o, i, s);
  }
}), At({
  cosineDistance_: function cosineDistance_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : uo.SUM_BY_NONZERO_WEIGHTS;
    var a = Et(e, "labels", "cosineDistance"),
        i = Et(t, "predictions", "cosineDistance");
    var o = null;
    null != s && (o = Et(s, "weights", "cosineDistance")), u(a.shape, i.shape, "Error in cosineDistance: ");
    var l = qa(1),
        c = Vr(l, Gr(ss(a, i), n, !0));
    return co(c, o, r);
  }
}), At({
  hingeLoss_: function hingeLoss_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uo.SUM_BY_NONZERO_WEIGHTS;
    var r = Et(e, "labels", "hingeLoss");
    var a = Et(t, "predictions", "hingeLoss");
    var i = null;
    null != n && (i = Et(n, "weights", "hingeLoss")), u(r.shape, a.shape, "Error in hingeLoss: ");
    var o = qa(1);
    r = Vr(ss(qa(2), r), o);
    var l = Ua(Vr(o, ss(r, a)));
    return co(l, i, s);
  }
}), At({
  huberLoss_: function huberLoss_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : uo.SUM_BY_NONZERO_WEIGHTS;
    var a = Et(e, "labels", "huberLoss"),
        i = Et(t, "predictions", "huberLoss");
    var o = null;
    null != n && (o = Et(n, "weights", "huberLoss")), u(a.shape, i.shape, "Error in huberLoss: ");
    var l = qa(s),
        c = rs(Vr(i, a)),
        h = da(c, l),
        d = Vr(c, h),
        p = es(ss(qa(.5), ga(h)), ss(l, d));
    return co(p, o, r);
  }
}), At({
  logLoss_: function logLoss_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-7;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : uo.SUM_BY_NONZERO_WEIGHTS;
    var a = Et(e, "labels", "logLoss"),
        i = Et(t, "predictions", "logLoss");
    var o = null;
    null != n && (o = Et(n, "weights", "logLoss")), u(a.shape, i.shape, "Error in logLoss: ");
    var l = qa(1),
        c = qa(s),
        h = Br(ss(a, Mr(es(i, c)))),
        d = ss(Vr(l, a), Mr(es(Vr(l, i), c))),
        p = Vr(h, d);
    return co(p, o, r);
  }
}), At({
  meanSquaredError_: function meanSquaredError_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uo.SUM_BY_NONZERO_WEIGHTS;
    var r = Et(e, "labels", "meanSquaredError"),
        a = Et(t, "predictions", "meanSquaredError");
    var i = null;
    null != n && (i = Et(n, "weights", "meanSquaredError")), u(r.shape, a.shape, "Error in meanSquaredError: ");
    var o = ci(r, a);
    return co(o, i, s);
  }
}), At({
  sigmoidCrossEntropy_: function sigmoidCrossEntropy_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : uo.SUM_BY_NONZERO_WEIGHTS;
    var a = Et(e, "multiClassLabels", "sigmoidCrossEntropy");
    var i = Et(t, "logits", "sigmoidCrossEntropy");
    var o = null;

    if (null != n && (o = Et(n, "weights", "sigmoidCrossEntropy")), u(a.shape, i.shape, "Error in sigmoidCrossEntropy: "), s > 0) {
      var _e68 = qa(s),
          _t71 = qa(1),
          _n36 = qa(.5);

      a = es(ss(a, Vr(_t71, _e68)), ss(_n36, _e68));
    }

    var l = function (e, t) {
      var n = Et(e, "labels", "sigmoidCrossEntropyWithLogits"),
          s = Et(t, "logits", "sigmoidCrossEntropyWithLogits");
      u(n.shape, s.shape, "Error in sigmoidCrossEntropyWithLogits: ");
      var r = Ua(s),
          a = ss(s, n),
          i = Lr(xr(Br(rs(s))));
      return es(Vr(r, a), i);
    }(a, i);

    return co(l, o, r);
  }
}), At({
  softmaxCrossEntropy_: function softmaxCrossEntropy_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : uo.SUM_BY_NONZERO_WEIGHTS;
    var a = Et(e, "onehotLabels", "softmaxCrossEntropy");
    var i = Et(t, "logits", "softmaxCrossEntropy");
    var o = null;

    if (null != n && (o = Et(n, "weights", "softmaxCrossEntropy")), u(a.shape, i.shape, "Error in softmaxCrossEntropy: "), s > 0) {
      var _e69 = qa(s),
          _t72 = qa(1),
          _n37 = qa(a.shape[1]);

      a = es(ss(a, Vr(_t72, _e69)), ns(_e69, _n37));
    }

    var l = function (e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      if (-1 === n && (n = t.rank - 1), n !== t.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ".concat(t.rank, " and dim was ").concat(n));
      return zr((e, t, s) => {
        var r = ea(t, [n], !0),
            a = Vr(pn(t, "float32"), r);
        s([e, a]);
        var i = Br(ss(a, e));
        return {
          value: Gr(i, [n]),
          gradFunc: (e, t) => {
            var [s, r] = t,
                a = Xr(e.shape, [n]);
            return [ss(Es(e, a), Vr(pn(s, "float32"), xr(r))), ss(Es(e, a), Vr(xr(r), pn(s, "float32")))];
          }
        };
      })(e, t);
    }(a, i);

    return co(l, o, r);
  }
}), At({
  sparseFillEmptyRows_: function sparseFillEmptyRows_(e, t, n, s) {
    var r = Et(e, "indices", "sparseFillEmptyRows"),
        a = Et(t, "values", "sparseFillEmptyRows"),
        i = Et(n, "denseShape", "sparseFillEmptyRows"),
        o = Et(s, "defaultValue", "sparseFillEmptyRows", a.dtype);
    if (2 !== r.rank) throw new Error("Indices should be Tensor2D but received shape\n        ".concat(r.shape));
    if (1 !== a.rank) throw new Error("Values should be Tensor1D but received shape ".concat(a.shape));
    if (1 !== i.rank) throw new Error("Dense shape should be Tensor1D but received shape ".concat(i.shape));
    if (0 !== o.rank) throw new Error("Default value should be a scalar but received shape ".concat(o.shape));
    var l = wt.runKernel("SparseFillEmptyRows", {
      indices: r,
      values: a,
      denseShape: i,
      defaultValue: o
    });
    return {
      outputIndices: l[0],
      outputValues: l[1],
      emptyRowIndicator: l[2],
      reverseIndexMap: l[3]
    };
  }
}), At({
  sparseReshape_: function sparseReshape_(e, t, n) {
    var s = Et(e, "inputIndices", "sparseReshape"),
        r = Et(t, "inputShape", "sparseReshape"),
        a = Et(n, "newShape", "sparseReshape");
    if (2 !== s.rank) throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(s.shape));
    if (1 !== r.rank) throw new Error("Input shape should be Tensor1D but received shape ".concat(r.shape));
    if (1 !== a.rank) throw new Error("New shape should be Tensor1D but received shape ".concat(a.shape));
    var i = wt.runKernel("SparseReshape", {
      inputIndices: s,
      inputShape: r,
      newShape: a
    });
    return {
      outputIndices: i[0],
      outputShape: i[1]
    };
  }
}), At({
  sparseSegmentMean_: function sparseSegmentMean_(e, t, n) {
    var s = Et(e, "data", "sparseSegmentMean"),
        r = Et(t, "indices", "sparseSegmentMean"),
        a = Et(n, "segmentIds", "sparseSegmentMean");
    if (s.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.rank) throw new Error("Indices should be Tensor1D but received shape\n          ".concat(r.shape));
    if (1 !== a.rank) throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(a.shape));
    return wt.runKernel("SparseSegmentMean", {
      data: s,
      indices: r,
      segmentIds: a
    });
  }
}), At({
  sparseSegmentSum_: function sparseSegmentSum_(e, t, n) {
    var s = Et(e, "data", "sparseSegmentSum"),
        r = Et(t, "indices", "sparseSegmentSum"),
        a = Et(n, "segmentIds", "sparseSegmentSum");
    if (s.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.rank) throw new Error("Indices should be Tensor1D but received shape\n         ".concat(r.shape));
    if (1 !== a.rank) throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(a.shape));
    return wt.runKernel("SparseSegmentSum", {
      data: s,
      indices: r,
      segmentIds: a
    });
  }
}), At({
  stringNGrams_: function stringNGrams_(e, t, n, s, r, a, i, o) {
    var l = Et(e, "data", "stringNGrams", "string");
    if ("string" !== l.dtype) throw new Error("Data must be of datatype string");
    if (1 !== l.shape.length) throw new Error("Data must be a vector, saw: ".concat(l.shape));
    var u = Et(t, "dataSplits", "stringNGrams");
    if ("int32" !== u.dtype) throw new Error("Data splits must be of datatype int32");
    var c = wt.runKernel("StringNGrams", {
      data: l,
      dataSplits: u
    }, {
      separator: n,
      nGramWidths: s,
      leftPad: r,
      rightPad: a,
      padWidth: i,
      preserveShortSequences: o
    });
    return {
      nGrams: c[0],
      nGramsSplits: c[1]
    };
  }
}), At({
  stringSplit_: function stringSplit_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    var s = Et(e, "input", "stringSplit", "string"),
        r = Et(t, "delimiter", "stringSplit", "string");
    if (1 !== s.rank) throw new Error("Input should be Tensor1D but received shape ".concat(s.shape));
    if (0 !== r.rank) throw new Error("Delimiter should be a scalar but received shape ".concat(r.shape));
    var a = wt.runKernel("StringSplit", {
      input: s,
      delimiter: r
    }, {
      skipEmpty: n
    });
    return {
      indices: a[0],
      values: a[1],
      shape: a[2]
    };
  }
}), At({
  stringToHashBucketFast_: function stringToHashBucketFast_(e, t) {
    var n = Et(e, "input", "stringToHashBucketFast", "string"),
        s = {
      numBuckets: t
    };
    if (t <= 0) throw new Error("Number of buckets must be at least 1");
    return wt.runKernel("StringToHashBucketFast", {
      input: n
    }, s);
  }
});
var ho = {
  flipLeftRight: Pi,
  resizeNearestNeighbor: no,
  resizeBilinear: to,
  rotateWithOffset: Wi,
  cropAndResize: Bi,
  nonMaxSuppression: Vi,
  nonMaxSuppressionAsync: function () {
    var _nonMaxSuppressionAsync = _asyncToGenerator(function* (e, t, n) {
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
      var a = Et(e, "boxes", "nonMaxSuppressionAsync"),
          i = Et(t, "scores", "nonMaxSuppressionAsync"),
          o = Ui(a, i, n, s, r);
      n = o.maxOutputSize, s = o.iouThreshold, r = o.scoreThreshold;
      var l = yield Promise.all([a.data(), i.data()]),
          u = l[0],
          c = l[1],
          {
        selectedIndices: h
      } = ji(u, c, n, s, r);
      return a !== e && a.dispose(), i !== t && i.dispose(), mi(h, "int32");
    });

    function nonMaxSuppressionAsync(_x10, _x11, _x12) {
      return _nonMaxSuppressionAsync.apply(this, arguments);
    }

    return nonMaxSuppressionAsync;
  }(),
  nonMaxSuppressionWithScore: Qi,
  nonMaxSuppressionWithScoreAsync: function () {
    var _nonMaxSuppressionWithScoreAsync = _asyncToGenerator(function* (e, t, n) {
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
      var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var i = Et(e, "boxes", "nonMaxSuppressionAsync"),
          o = Et(t, "scores", "nonMaxSuppressionAsync"),
          l = Ui(i, o, n, s, r, a);
      n = l.maxOutputSize, s = l.iouThreshold, r = l.scoreThreshold, a = l.softNmsSigma;
      var u = yield Promise.all([i.data(), o.data()]),
          c = u[0],
          h = u[1],
          {
        selectedIndices: d,
        selectedScores: p
      } = Ki(c, h, n, s, r, a);
      return i !== e && i.dispose(), o !== t && o.dispose(), {
        selectedIndices: mi(d, "int32"),
        selectedScores: mi(p)
      };
    });

    function nonMaxSuppressionWithScoreAsync(_x13, _x14, _x15) {
      return _nonMaxSuppressionWithScoreAsync.apply(this, arguments);
    }

    return nonMaxSuppressionWithScoreAsync;
  }(),
  nonMaxSuppressionPadded: eo,
  nonMaxSuppressionPaddedAsync: function () {
    var _nonMaxSuppressionPaddedAsync = _asyncToGenerator(function* (e, t, n) {
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
      var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
      var i = Et(e, "boxes", "nonMaxSuppressionAsync"),
          o = Et(t, "scores", "nonMaxSuppressionAsync"),
          l = Ui(i, o, n, s, r, null),
          u = l.maxOutputSize,
          c = l.iouThreshold,
          h = l.scoreThreshold,
          [d, p] = yield Promise.all([i.data(), o.data()]),
          {
        selectedIndices: f,
        validOutputs: g
      } = qi(d, p, u, c, h, a);
      return i !== e && i.dispose(), o !== t && o.dispose(), {
        selectedIndices: mi(f, "int32"),
        validOutputs: qa(g, "int32")
      };
    });

    function nonMaxSuppressionPaddedAsync(_x16, _x17, _x18) {
      return _nonMaxSuppressionPaddedAsync.apply(this, arguments);
    }

    return nonMaxSuppressionPaddedAsync;
  }(),
  threshold: so,
  transform: ro
},
    po = {
  bandPart: ao,
  gramSchmidt: io,
  qr: lo
};

class fo extends Hn {
  minimize(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var {
      value: s,
      grads: r
    } = this.computeGradients(e, n);

    if (null != n) {
      var _e70 = n.map(e => ({
        name: e.name,
        tensor: r[e.name]
      }));

      this.applyGradients(_e70);
    } else this.applyGradients(r);

    return Jn(r), t ? s : (s.dispose(), null);
  }

  get iterations() {
    return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
  }

  incrementIterations() {
    this.iterations_ = this.iterations + 1;
  }

  computeGradients(e, t) {
    return function (e, t) {
      l(E(e), () => "The f passed in variableGrads(f) must be a function"), l(null == t || Array.isArray(t) && t.every(e => e instanceof at), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
      var n = null != t;

      if (!n) {
        t = [];

        for (var _e71 in wt.registeredVariables) {
          t.push(wt.registeredVariables[_e71]);
        }
      }

      var s = n ? t.filter(e => !e.trainable) : null,
          r = t.length;
      l((t = t.filter(e => e.trainable)).length > 0, () => "variableGrads() expects at least one of the input variables to be trainable, but none of the ".concat(r, " variables is trainable."));
      var {
        value: a,
        grads: i
      } = wt.gradients(e, t, null, !0);
      l(i.some(e => null != e), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), l(0 === a.rank, () => "The f passed in variableGrads(f) must return a scalar, but it returned a rank-".concat(a.rank, " tensor"));
      var o = {};
      return t.forEach((e, t) => {
        null != i[t] && (o[e.name] = i[t]);
      }), null != s && s.forEach(e => o[e.name] = null), {
        value: a,
        grads: o
      };
    }(e, t);
  }

  dispose() {
    null != this.iterations_ && Jn(this.iterations_);
  }

  saveIterations() {
    var _this23 = this;

    return _asyncToGenerator(function* () {
      return null == _this23.iterations_ && (_this23.iterations_ = 0), {
        name: "iter",
        tensor: qa(_this23.iterations_, "int32")
      };
    })();
  }

  getWeights() {
    return _asyncToGenerator(function* () {
      throw new Error("getWeights() is not implemented for this optimizer yet.");
    })();
  }

  setWeights(e) {
    var _this24 = this;

    return _asyncToGenerator(function* () {
      throw new Error("setWeights() is not implemented for this optimizer class ".concat(_this24.getClassName()));
    })();
  }

  extractIterations(e) {
    var _this25 = this;

    return _asyncToGenerator(function* () {
      return _this25.iterations_ = (yield e[0].tensor.data())[0], e.slice(1);
    })();
  }

}

Object.defineProperty(fo, Symbol.hasInstance, {
  value: e => null != e.minimize && null != e.computeGradients && null != e.applyGradients
});

class go extends fo {
  constructor(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    super(), this.learningRate = e, this.rho = t, this.epsilon = n, this.accumulatedGrads = [], this.accumulatedUpdates = [], null == n && (this.epsilon = wt.backend.epsilon());
  }

  applyGradients(e) {
    (Array.isArray(e) ? e.map(e => e.name) : Object.keys(e)).forEach((t, n) => {
      var s = wt.registeredVariables[t];
      null == this.accumulatedGrads[n] && (this.accumulatedGrads[n] = {
        originalName: "".concat(t, "/accum_grad"),
        variable: Yn(() => pr(s).variable(!1))
      }), null == this.accumulatedUpdates[n] && (this.accumulatedUpdates[n] = {
        originalName: "".concat(t, "/accum_var"),
        variable: Yn(() => pr(s).variable(!1))
      });
      var r = Array.isArray(e) ? e[n].tensor : e[t];
      if (null == r) return;
      var a = this.accumulatedGrads[n].variable,
          i = this.accumulatedUpdates[n].variable;
      Yn(() => {
        var e = es(ss(a, this.rho), ss(ga(r), 1 - this.rho)),
            t = ss(ns(ui(es(i, this.epsilon)), ui(es(a, this.epsilon))), r),
            n = es(ss(i, this.rho), ss(ga(t), 1 - this.rho));
        a.assign(e), i.assign(n);
        var o = es(ss(t, -this.learningRate), s);
        s.assign(o);
      });
    }), this.incrementIterations();
  }

  dispose() {
    null != this.accumulatedUpdates && (Jn(this.accumulatedGrads.map(e => e.variable)), Jn(this.accumulatedUpdates.map(e => e.variable)));
  }

  getWeights() {
    var _this26 = this;

    return _asyncToGenerator(function* () {
      var e = [..._this26.accumulatedGrads, ..._this26.accumulatedUpdates];
      return [yield _this26.saveIterations()].concat(e.map(e => ({
        name: e.originalName,
        tensor: e.variable
      })));
    })();
  }

  setWeights(e) {
    var _this27 = this;

    return _asyncToGenerator(function* () {
      var t = (e = yield _this27.extractIterations(e)).length / 2;
      _this27.accumulatedGrads = e.slice(0, t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      })), _this27.accumulatedUpdates = e.slice(t, 2 * t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      }));
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      rho: this.rho,
      epsilon: this.epsilon
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.rho, t.epsilon);
  }

}

go.className = "Adadelta", qn(go);

class mo extends fo {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .1;
    super(), this.learningRate = e, this.initialAccumulatorValue = t, this.accumulatedGrads = [];
  }

  applyGradients(e) {
    (Array.isArray(e) ? e.map(e => e.name) : Object.keys(e)).forEach((t, n) => {
      var s = wt.registeredVariables[t];

      if (null == this.accumulatedGrads[n]) {
        var _e72 = !1;

        this.accumulatedGrads[n] = {
          originalName: "".concat(t, "/accumulator"),
          variable: Yn(() => Ir(s.shape, this.initialAccumulatorValue).variable(_e72))
        };
      }

      var r = Array.isArray(e) ? e[n].tensor : e[t];
      if (null == r) return;
      var a = this.accumulatedGrads[n].variable;
      Yn(() => {
        var e = es(a, ga(r));
        a.assign(e);
        var t = es(ss(ns(r, ui(es(e, wt.backend.epsilon()))), -this.learningRate), s);
        s.assign(t);
      });
    }), this.incrementIterations();
  }

  dispose() {
    null != this.accumulatedGrads && Jn(this.accumulatedGrads.map(e => e.variable));
  }

  getWeights() {
    var _this28 = this;

    return _asyncToGenerator(function* () {
      return [yield _this28.saveIterations()].concat(_this28.accumulatedGrads.map(e => ({
        name: e.originalName,
        tensor: e.variable
      })));
    })();
  }

  setWeights(e) {
    var _this29 = this;

    return _asyncToGenerator(function* () {
      e = yield _this29.extractIterations(e), _this29.accumulatedGrads = e.map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      }));
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      initialAccumulatorValue: this.initialAccumulatorValue
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.initialAccumulatorValue);
  }

}

mo.className = "Adagrad", qn(mo);

class bo extends fo {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    super(), this.learningRate = e, this.beta1 = t, this.beta2 = n, this.epsilon = s, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], Yn(() => {
      this.accBeta1 = qa(t).variable(), this.accBeta2 = qa(n).variable();
    }), null == s && (this.epsilon = wt.backend.epsilon());
  }

  applyGradients(e) {
    var t = Array.isArray(e) ? e.map(e => e.name) : Object.keys(e);
    Yn(() => {
      var n = Vr(1, this.accBeta1),
          s = Vr(1, this.accBeta2);
      t.forEach((t, r) => {
        var a = wt.registeredVariables[t];
        null == this.accumulatedFirstMoment[r] && (this.accumulatedFirstMoment[r] = {
          originalName: "".concat(t, "/m"),
          variable: Yn(() => pr(a).variable(!1))
        }), null == this.accumulatedSecondMoment[r] && (this.accumulatedSecondMoment[r] = {
          originalName: "".concat(t, "/v"),
          variable: Yn(() => pr(a).variable(!1))
        });
        var i = Array.isArray(e) ? e[r].tensor : e[t];
        if (null == i) return;
        var o = this.accumulatedFirstMoment[r].variable,
            l = this.accumulatedSecondMoment[r].variable,
            u = es(ss(o, this.beta1), ss(i, 1 - this.beta1)),
            c = es(ss(l, this.beta2), ss(ga(i), 1 - this.beta2)),
            h = ns(u, n),
            d = ns(c, s);
        o.assign(u), l.assign(c);
        var p = es(ss(ns(h, es(ui(d), this.epsilon)), -this.learningRate), a);
        a.assign(p);
      }), this.accBeta1.assign(ss(this.accBeta1, this.beta1)), this.accBeta2.assign(ss(this.accBeta2, this.beta2));
    }), this.incrementIterations();
  }

  dispose() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Jn(this.accumulatedFirstMoment.map(e => e.variable)), null != this.accumulatedSecondMoment && Jn(this.accumulatedSecondMoment.map(e => e.variable));
  }

  getWeights() {
    var _this30 = this;

    return _asyncToGenerator(function* () {
      var e = [..._this30.accumulatedFirstMoment, ..._this30.accumulatedSecondMoment];
      return [yield _this30.saveIterations()].concat(e.map(e => ({
        name: e.originalName,
        tensor: e.variable
      })));
    })();
  }

  setWeights(e) {
    var _this31 = this;

    return _asyncToGenerator(function* () {
      e = yield _this31.extractIterations(e), Yn(() => {
        _this31.accBeta1.assign(va(_this31.beta1, _this31.iterations_ + 1)), _this31.accBeta2.assign(va(_this31.beta2, _this31.iterations_ + 1));
      });
      var t = e.length / 2;
      _this31.accumulatedFirstMoment = e.slice(0, t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      })), _this31.accumulatedSecondMoment = e.slice(t, 2 * t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      }));
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon);
  }

}

bo.className = "Adam", qn(bo);

class xo extends fo {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    super(), this.learningRate = e, this.beta1 = t, this.beta2 = n, this.epsilon = s, this.decay = r, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], Yn(() => {
      this.iteration = qa(0).variable(), this.accBeta1 = qa(t).variable();
    }), null == s && (this.epsilon = wt.backend.epsilon());
  }

  applyGradients(e) {
    var t = Array.isArray(e) ? e.map(e => e.name) : Object.keys(e);
    Yn(() => {
      var n = Vr(1, this.accBeta1),
          s = ns(-this.learningRate, es(ss(this.iteration, this.decay), 1));
      t.forEach((t, r) => {
        var a = wt.registeredVariables[t];
        null == this.accumulatedFirstMoment[r] && (this.accumulatedFirstMoment[r] = {
          originalName: "".concat(t, "/m"),
          variable: pr(a).variable(!1)
        }), null == this.accumulatedWeightedInfNorm[r] && (this.accumulatedWeightedInfNorm[r] = {
          originalName: "".concat(t, "/v"),
          variable: pr(a).variable(!1)
        });
        var i = Array.isArray(e) ? e[r].tensor : e[t];
        if (null == i) return;
        var o = this.accumulatedFirstMoment[r].variable,
            l = this.accumulatedWeightedInfNorm[r].variable,
            u = es(ss(o, this.beta1), ss(i, 1 - this.beta1)),
            c = ss(l, this.beta2),
            h = rs(i),
            d = oa(c, h);
        o.assign(u), l.assign(d);
        var p = es(ss(ns(s, n), ns(u, es(d, this.epsilon))), a);
        a.assign(p);
      }), this.iteration.assign(es(this.iteration, 1)), this.accBeta1.assign(ss(this.accBeta1, this.beta1));
    }), this.incrementIterations();
  }

  dispose() {
    this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Jn(this.accumulatedFirstMoment.map(e => e.variable)), null != this.accumulatedWeightedInfNorm && Jn(this.accumulatedWeightedInfNorm.map(e => e.variable));
  }

  getWeights() {
    return _asyncToGenerator(function* () {
      throw new Error("getWeights() is not implemented for Adamax yet.");
    })();
  }

  setWeights(e) {
    return _asyncToGenerator(function* () {
      throw new Error("setWeights() is not implemented for Adamax yet.");
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon,
      decay: this.decay
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay);
  }

}

xo.className = "Adamax", qn(xo);

class yo extends fo {
  constructor(e) {
    super(), this.learningRate = e, this.setLearningRate(e);
  }

  applyGradients(e) {
    (Array.isArray(e) ? e.map(e => e.name) : Object.keys(e)).forEach((t, n) => {
      var s = Array.isArray(e) ? e[n].tensor : e[t];
      if (null == s) return;
      var r = wt.registeredVariables[t];
      Yn(() => {
        var e = es(ss(this.c, s), r);
        r.assign(e);
      });
    }), this.incrementIterations();
  }

  setLearningRate(e) {
    this.learningRate = e, null != this.c && this.c.dispose(), this.c = Zn(qa(-e));
  }

  dispose() {
    this.c.dispose();
  }

  getWeights() {
    var _this32 = this;

    return _asyncToGenerator(function* () {
      return [yield _this32.saveIterations()];
    })();
  }

  setWeights(e) {
    var _this33 = this;

    return _asyncToGenerator(function* () {
      if (0 !== (e = yield _this33.extractIterations(e)).length) throw new Error("SGD optimizer does not have settable weights.");
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate);
  }

}

yo.className = "SGD", qn(yo);

class ko extends yo {
  constructor(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    super(e), this.learningRate = e, this.momentum = t, this.useNesterov = n, this.accumulations = [], this.m = qa(this.momentum);
  }

  applyGradients(e) {
    (Array.isArray(e) ? e.map(e => e.name) : Object.keys(e)).forEach((t, n) => {
      var s = wt.registeredVariables[t];

      if (null == this.accumulations[n]) {
        var _e73 = !1;

        this.accumulations[n] = {
          originalName: "".concat(t, "/momentum"),
          variable: Yn(() => pr(s).variable(_e73))
        };
      }

      var r = this.accumulations[n].variable,
          a = Array.isArray(e) ? e[n].tensor : e[t];
      null != a && Yn(() => {
        var e;
        var t = es(ss(this.m, r), a);
        e = es(ss(this.c, this.useNesterov ? es(a, ss(t, this.m)) : t), s), r.assign(t), s.assign(e);
      });
    }), this.incrementIterations();
  }

  dispose() {
    this.m.dispose(), null != this.accumulations && Jn(this.accumulations.map(e => e.variable));
  }

  setMomentum(e) {
    this.momentum = e;
  }

  getWeights() {
    var _this34 = this;

    return _asyncToGenerator(function* () {
      return [yield _this34.saveIterations()].concat(_this34.accumulations.map(e => ({
        name: e.originalName,
        tensor: e.variable
      })));
    })();
  }

  setWeights(e) {
    var _this35 = this;

    return _asyncToGenerator(function* () {
      e = yield _this35.extractIterations(e), _this35.accumulations = e.map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(!1)
      }));
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      momentum: this.momentum,
      useNesterov: this.useNesterov
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.momentum, t.useNesterov);
  }

}

ko.className = "Momentum", qn(ko);

class wo extends fo {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    if (super(), this.learningRate = e, this.decay = t, this.momentum = n, this.epsilon = s, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = r, null == s && (this.epsilon = wt.backend.epsilon()), null == e) throw new Error("learningRate for RMSPropOptimizer must be defined.");
  }

  applyGradients(e) {
    (Array.isArray(e) ? e.map(e => e.name) : Object.keys(e)).forEach((t, n) => {
      var s = wt.registeredVariables[t],
          r = !1;
      null == this.accumulatedMeanSquares[n] && (this.accumulatedMeanSquares[n] = {
        originalName: "".concat(t, "/rms"),
        variable: Yn(() => pr(s).variable(r))
      }), null == this.accumulatedMoments[n] && (this.accumulatedMoments[n] = {
        originalName: "".concat(t, "/momentum"),
        variable: Yn(() => pr(s).variable(r))
      }), null == this.accumulatedMeanGrads[n] && this.centered && (this.accumulatedMeanGrads[n] = {
        originalName: "".concat(t, "/mg"),
        variable: Yn(() => pr(s).variable(r))
      });
      var a = Array.isArray(e) ? e[n].tensor : e[t];
      if (null == a) return;
      var i = this.accumulatedMeanSquares[n].variable,
          o = this.accumulatedMoments[n].variable;
      Yn(() => {
        var e = es(ss(i, this.decay), ss(ga(a), 1 - this.decay));

        if (this.centered) {
          var _t73 = this.accumulatedMeanGrads[n].variable,
              _r32 = es(ss(_t73, this.decay), ss(a, 1 - this.decay)),
              _l8 = ns(ss(a, this.learningRate), ui(Vr(e, es(ga(_r32), this.epsilon)))),
              _u5 = es(ss(o, this.momentum), _l8);

          i.assign(e), _t73.assign(_r32), o.assign(_u5);

          var _c4 = Vr(s, _u5);

          s.assign(_c4);
        } else {
          var _e74 = es(ss(i, this.decay), ss(ga(a), 1 - this.decay)),
              _t74 = es(ss(o, this.momentum), ns(ss(a, this.learningRate), ui(es(_e74, this.epsilon))));

          i.assign(_e74), o.assign(_t74);

          var _n38 = Vr(s, _t74);

          s.assign(_n38);
        }
      });
    }), this.incrementIterations();
  }

  dispose() {
    null != this.accumulatedMeanSquares && Jn(this.accumulatedMeanSquares.map(e => e.variable)), null != this.accumulatedMeanGrads && this.centered && Jn(this.accumulatedMeanGrads.map(e => e.variable)), null != this.accumulatedMoments && Jn(this.accumulatedMoments.map(e => e.variable));
  }

  getWeights() {
    var _this36 = this;

    return _asyncToGenerator(function* () {
      var e = [..._this36.accumulatedMeanSquares, ..._this36.accumulatedMoments];
      return _this36.centered && e.push(..._this36.accumulatedMeanGrads), [yield _this36.saveIterations()].concat(e.map(e => ({
        name: e.originalName,
        tensor: e.variable
      })));
    })();
  }

  setWeights(e) {
    var _this37 = this;

    return _asyncToGenerator(function* () {
      e = yield _this37.extractIterations(e);
      var t = _this37.centered ? e.length / 3 : e.length / 2,
          n = !1;
      _this37.accumulatedMeanSquares = e.slice(0, t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(n)
      })), _this37.accumulatedMoments = e.slice(t, 2 * t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(n)
      })), _this37.centered && (_this37.accumulatedMeanGrads = e.slice(2 * t, 3 * t).map(e => ({
        originalName: e.name,
        variable: e.tensor.variable(n)
      })));
    })();
  }

  getConfig() {
    return {
      learningRate: this.learningRate,
      decay: this.decay,
      momentum: this.momentum,
      epsilon: this.epsilon,
      centered: this.centered
    };
  }

  static fromConfig(e, t) {
    return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered);
  }

}

wo.className = "RMSProp", qn(wo);

class vo {
  static sgd(e) {
    return new yo(e);
  }

  static momentum(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    return new ko(e, t, n);
  }

  static rmsprop(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    return new wo(e, t, n, s, r);
  }

  static adam() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .001;
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .999;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    return new bo(e, t, n, s);
  }

  static adadelta() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .001;
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .95;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return new go(e, t, n);
  }

  static adamax() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .002;
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .999;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    return new xo(e, t, n, s, r);
  }

  static adagrad(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .1;
    return new mo(e, t);
  }

}

var Io = {
  sgd: vo.sgd,
  momentum: vo.momentum,
  adadelta: vo.adadelta,
  adagrad: vo.adagrad,
  rmsprop: vo.rmsprop,
  adamax: vo.adamax,
  adam: vo.adam
},
    $o = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : e => e();

function No() {
  return new Promise(e => $o(() => e()));
}

function Co(e, t) {
  var n = e[0].length;
  e.forEach((e, t) => {
    l(e.length === n, () => "Error in concat".concat(n, "D: rank of tensors[").concat(t, "] must be the same as the rank of the rest (").concat(n, ")"));
  }), l(t >= 0 && t < n, () => "Error in concat".concat(n, "D: axis must be between 0 and ").concat(n - 1, "."));
  var s = e[0];
  e.forEach((e, r) => {
    for (var _a22 = 0; _a22 < n; _a22++) {
      l(_a22 === t || e[_a22] === s[_a22], () => "Error in concat".concat(n, "D: Shape of tensors[").concat(r, "] (").concat(e, ") does not match the shape of the rest (").concat(s, ") along the non-concatenated axis ").concat(r, "."));
    }
  });
}

function So(e, t) {
  var n = e[0].slice();

  for (var _s42 = 1; _s42 < e.length; _s42++) {
    n[t] += e[_s42][t];
  }

  return n;
}

function To(e) {
  return e <= 30 ? e : R(e, Math.floor(Math.sqrt(e)));
}

function Eo(e, t, n) {
  return [n * ("number" == typeof e ? e : e[0]), t * ("number" == typeof e ? e : e[1])];
}

function Ro(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = [];
  if (s) r = r.concat(t.slice(0)), r.push(e[0] / n), r = r.concat(e.slice(1));else {
    r = r.concat(e[0]);
    var _n39 = t.length;

    for (var _s43 = 0; _s43 < _n39; ++_s43) {
      r = r.concat([e[_s43 + 1] / t[_s43], t[_s43]]);
    }

    r = r.concat(e.slice(_n39 + 1));
  }
  return r;
}

function Ao(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
  var s = [];

  if (n) {
    s.push(t);

    for (var _n40 = t + 1; _n40 < e; ++_n40) {
      _n40 <= 2 * t ? (s.push(_n40), s.push(_n40 - (t + 1))) : s.push(_n40);
    }
  } else {
    var _n41 = [],
        _r33 = [];

    for (var _s44 = 1; _s44 < e; ++_s44) {
      _s44 >= 2 * t + 1 || _s44 % 2 == 1 ? _r33.push(_s44) : _n41.push(_s44);
    }

    s.push(..._n41), s.push(0), s.push(..._r33);
  }

  return s;
}

function Fo(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = [];
  r.push(s ? e[0] / n : e[0] * n);

  for (var _n42 = 1; _n42 < e.length; ++_n42) {
    r.push(_n42 <= t.length ? s ? t[_n42 - 1] * e[_n42] : e[_n42] / t[_n42 - 1] : e[_n42]);
  }

  return r;
}

function Do(e, t) {
  var n = [0];

  for (var _s45 = 0; _s45 < t; ++_s45) {
    n.push(e[_s45][0]);
  }

  return n;
}

function _o(e, t, n) {
  var s = e.slice(0, 1);

  for (var _r34 = 0; _r34 < n; ++_r34) {
    s.push(e[_r34 + 1] - t[_r34][0] - t[_r34][1]);
  }

  return s;
}

function Oo() {
  V().getBool("IS_TEST") || console.warn(...arguments);
}

function Mo(e, t) {
  if (e.length !== t.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:".concat(e.length, ", imag: ").concat(t.length, "."));
  var n = new Float32Array(2 * e.length);

  for (var _s46 = 0; _s46 < n.length; _s46 += 2) {
    n[_s46] = e[_s46 / 2], n[_s46 + 1] = t[_s46 / 2];
  }

  return n;
}

function Lo(e) {
  var t = new Float32Array(e.length / 2),
      n = new Float32Array(e.length / 2);

  for (var _s47 = 0; _s47 < e.length; _s47 += 2) {
    t[_s47 / 2] = e[_s47], n[_s47 / 2] = e[_s47 + 1];
  }

  return {
    real: t,
    imag: n
  };
}

function zo(e) {
  var t = Math.ceil(e.length / 4),
      n = new Float32Array(t),
      s = new Float32Array(t);

  for (var _t75 = 0; _t75 < e.length; _t75 += 4) {
    n[Math.floor(_t75 / 4)] = e[_t75], s[Math.floor(_t75 / 4)] = e[_t75 + 1];
  }

  return {
    real: n,
    imag: s
  };
}

function Bo(e) {
  var t = Math.floor(e.length / 4),
      n = new Float32Array(t),
      s = new Float32Array(t);

  for (var _t76 = 2; _t76 < e.length; _t76 += 4) {
    n[Math.floor(_t76 / 4)] = e[_t76], s[Math.floor(_t76 / 4)] = e[_t76 + 1];
  }

  return {
    real: n,
    imag: s
  };
}

function Po(e, t) {
  return {
    real: e[2 * t],
    imag: e[2 * t + 1]
  };
}

function Wo(e, t, n, s) {
  e[2 * s] = t, e[2 * s + 1] = n;
}

function Uo(e, t) {
  var n = new Float32Array(e / 2),
      s = new Float32Array(e / 2);

  for (var _r35 = 0; _r35 < Math.ceil(e / 2); _r35++) {
    var _a23 = (t ? 2 : -2) * Math.PI * (_r35 / e);

    n[_r35] = Math.cos(_a23), s[_r35] = Math.sin(_a23);
  }

  return {
    real: n,
    imag: s
  };
}

function Vo(e, t, n) {
  var s = (n ? 2 : -2) * Math.PI * (e / t);
  return {
    real: Math.cos(s),
    imag: Math.sin(s)
  };
}

var Go = /->/g;

function Ho(e, t) {
  var n = ((e = e.replace(/\s/g, "")).length - e.replace(Go, "").length) / "->".length;
  if (n < 1) throw new Error("Equations without an arrow are not supported.");
  if (n > 1) throw new Error('Equation must contain exactly one arrow ("->").');
  var [s, r] = e.split("->");
  l(-1 === s.indexOf("..."), () => 'The ellipsis notation ("...") is not supported yet.');
  var a = s.split(","),
      i = a.length;
  if (t !== i) throw new Error("Expected ".concat(i, " input tensors, received ").concat(t));
  if (i > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
  var o = [];

  var _loop9 = function _loop9(_e75) {
    var t = r[_e75];
    if (!a.some(e => -1 !== e.indexOf(t))) throw new Error("Output subscripts contain the label ".concat(t, " not present in the input subscripts."));
    -1 === o.indexOf(t) && o.push(t);
  };

  for (var _e75 = 0; _e75 < r.length; ++_e75) {
    _loop9(_e75);
  }

  for (var _e76 = 0; _e76 < s.length; ++_e76) {
    var _t77 = s[_e76];
    -1 === o.indexOf(_t77) && "," !== _t77 && o.push(_t77);
  }

  var u = new Array(a.length);

  for (var _e77 = 0; _e77 < i; ++_e77) {
    if (new Set(a[_e77].split("")).size !== a[_e77].length) throw new Error("Found duplicate axes in input component ".concat(a[_e77], ". Support for duplicate axes in input is not implemented yet."));
    u[_e77] = [];

    for (var _t78 = 0; _t78 < a[_e77].length; ++_t78) {
      u[_e77].push(o.indexOf(a[_e77][_t78]));
    }
  }

  var c = o.length,
      h = [];

  for (var _e78 = r.length; _e78 < c; ++_e78) {
    h.push(_e78);
  }

  return {
    allDims: o,
    summedDims: h,
    idDims: u
  };
}

function jo(e, t) {
  var n = new Array(e);
  n.fill(-1);

  for (var _e79 = 0; _e79 < t.length; ++_e79) {
    n[t[_e79]] = _e79;
  }

  var s = [];

  for (var _t79 = 0; _t79 < e; ++_t79) {
    -1 === n[_t79] && s.push(_t79);
  }

  return n = n.filter(e => -1 !== e), {
    permutationIndices: n,
    expandDims: s
  };
}

function qo(e, t, n) {
  var s = new Array(e);

  var _loop10 = function _loop10(_e80) {
    var r = n[_e80].shape;

    var _loop11 = function _loop11(_n43) {
      void 0 === s[t[_e80][_n43]] ? s[t[_e80][_n43]] = r[_n43] : l(s[t[_e80][_n43]] === r[_n43], () => "Expected dimension ".concat(s[t[_e80][_n43]], " at axis ").concat(_n43, " of input shaped ").concat(JSON.stringify(r), ", but got dimension ").concat(r[_n43]));
    };

    for (var _n43 = 0; _n43 < t[_e80].length; ++_n43) {
      _loop11(_n43);
    }
  };

  for (var _e80 = 0; _e80 < n.length; ++_e80) {
    _loop10(_e80);
  }
}

function Ko(e, t) {
  var n = e,
      s = [];
  var r = 0;
  0 === e.length && n.push(-1), r = e.length + 1;

  for (var _e81 = 0; _e81 < r; ++_e81) {
    s.push([]);
  }

  var a = [];

  for (var _e82 = 0; _e82 < n.length; ++_e82) {
    var _r36 = Yo(t, n[_e82]);

    for (var _t80 of _r36) {
      -1 === a.indexOf(_t80) && (s[_e82].push(_t80), a.push(_t80));
    }
  }

  return {
    path: n,
    steps: s
  };
}

function Xo(e) {
  return e.every((e, t) => e === t);
}

function Yo(e, t) {
  var n = [];

  for (var _s48 = 0; _s48 < e.length; ++_s48) {
    0 !== e[_s48].length && -1 === e[_s48].indexOf(t) && -1 !== t || n.push(_s48);
  }

  return n;
}

function Jo(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var s = [];
  if ("number" == typeof t) l(e.shape[n] % t == 0, () => "Number of splits must evenly divide the axis."), s = new Array(t).fill(e.shape[n] / t);else {
    l(t.reduce((e, t) => (-1 === t && (e += 1), e), 0) <= 1, () => "There should be only one negative value in split array.");

    var _r37 = t.indexOf(-1);

    if (-1 !== _r37) {
      var _s49 = t.reduce((e, t) => t > 0 ? e + t : e);

      t[_r37] = e.shape[n] - _s49;
    }

    l(e.shape[n] === t.reduce((e, t) => e + t), () => "The sum of sizes must match the size of the axis dimension."), s = t;
  }
  return s;
}

function Zo(e, t) {
  var n,
      s = !1;

  for (e <= 30 ? (n = e, s = !0) : n = R(e, Math.floor(Math.sqrt(e))); !s;) {
    n > t || n === e ? s = !0 : n = R(e, n + 1);
  }

  return n;
}

function Qo(e, t, n) {
  var s = [],
      r = e.length;

  for (var _a24 = 0; _a24 < r; _a24++) {
    s.push(_a24 !== t ? e[_a24] : n);
  }

  return s;
}

function el(e, t, n, s) {
  var r = t.shape.length,
      a = e.shape.length;
  if (0 !== s && (s < -r || s > r)) throw new Error("Expect batchDims in the range of [-".concat(r, ", ").concat(r, "], but got ").concat(s));
  if (s < 0 && (s += r), s > a) throw new Error("batchDims (".concat(s, ") must be less than rank(x) (\n    ").concat(a, ")."));
  if (n < s) throw new Error("batchDims (".concat(s, ") must be less than or equal to axis (").concat(n, ")."));

  for (var _n44 = 0; _n44 < s; ++_n44) {
    if (e.shape[_n44] !== t.shape[_n44]) throw new Error("x.shape[".concat(_n44, "]: ").concat(e.shape[_n44], " should be equal to indices.shape[").concat(_n44, "]: ").concat(t.shape[_n44], "."));
  }

  var i = e.shape[n],
      o = [];
  var l = 1,
      u = 1,
      c = 1;

  for (var _t81 = 0; _t81 < s; ++_t81) {
    o.push(e.shape[_t81]), l *= e.shape[_t81];
  }

  for (var _t82 = s; _t82 < n; _t82++) {
    o.push(e.shape[_t82]), u *= e.shape[_t82];
  }

  for (var _e83 = s; _e83 < r; _e83++) {
    o.push(t.shape[_e83]);
  }

  for (var _t83 = n + 1; _t83 < a; _t83++) {
    o.push(e.shape[_t83]), c *= e.shape[_t83];
  }

  return {
    batchSize: l,
    sliceSize: c,
    outerSize: u,
    dimSize: i,
    outputShape: o
  };
}

function tl(e) {
  try {
    return e.map(e => He(e));
  } catch (e) {
    throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(e));
  }
}

function nl(e) {
  return e.map(e => Ge(e));
}

var sl = {
  __proto__: null,
  slice_util: Gn,
  segment_util: {
    __proto__: null,
    segOpComputeOptimalWindowSize: Zo,
    computeOutShape: Qo,
    collectGatherOpShapeInfo: el
  },
  fromUint8ToStringArray: tl,
  fromStringArrayToUint8: nl,
  upcastType: dt,
  axesAreInnerMostDims: jr,
  combineLocations: qr,
  computeOutAndReduceShapes: Kr,
  expandShapeToKeepDim: Xr,
  assertAxesAreInnerMostDims: Yr,
  getAxesPermutation: Jr,
  getUndoAxesPermutation: Zr,
  getInnerMostAxes: Qr,
  getBroadcastDims: lr,
  getReductionAxes: ur,
  assertAndGetBroadcastShape: cr,
  assertParamsConsistent: Co,
  computeOutShape: So,
  computeDilation2DInfo: ms,
  computePool2DInfo: bs,
  computePool3DInfo: xs,
  computeConv2DInfo: ys,
  computeConv3DInfo: ks,
  computeDefaultPad: ws,
  tupleValuesAreOne: Cs,
  eitherStridesOrDilationsAreOne: Ss,
  convertConv2DDataFormat: Ts,
  getFusedDyActivation: Ei,
  getFusedBiasGradient: Ri,
  applyActivation: Ai,
  shouldFuse: Fi,
  PARALLELIZE_THRESHOLD: 30,
  computeOptimalWindowSize: To,
  getImageCenter: Eo,
  getReshaped: Ro,
  getPermuted: Ao,
  getReshapedPermuted: Fo,
  getSliceBeginCoords: Do,
  getSliceSize: _o,
  prepareAndValidate: Nn,
  validateUpdateShape: Cn,
  validateInput: function validateInput(e, t, n) {
    if (t.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ".concat(t.rank, "."));
    if (e.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ".concat(e.rank, "."));
    if ("int32" !== t.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));
    if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));

    if (0 === n.length) {
      if (0 === t.size) throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));
      if (0 === e.size) throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape));
    }

    Cn(n, t, e);
  },
  calculateShapes: Sn,
  SELU_SCALEALPHA: 1.7580993408473768,
  SELU_SCALE: 1.0507009873554805,
  ERF_P: .3275911,
  ERF_A1: .254829592,
  ERF_A2: -.284496736,
  ERF_A3: 1.421413741,
  ERF_A4: -1.453152027,
  ERF_A5: 1.061405429,
  warn: Oo,
  log: function log() {
    V().getBool("IS_TEST") || console.log(...arguments);
  },
  mergeRealAndImagArrays: Mo,
  splitRealAndImagArrays: Lo,
  complexWithEvenIndex: zo,
  complexWithOddIndex: Bo,
  getComplexWithIndex: Po,
  assignToTypedArray: Wo,
  exponents: Uo,
  exponent: Vo,
  decodeEinsumEquation: Ho,
  getEinsumPermutation: jo,
  checkEinsumDimSizes: qo,
  getEinsumComputePath: Ko,
  isIdentityPermutation: Xo,
  prepareSplitSize: Jo
};
var rl = {
  kernelName: "Abs",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, pi(pn(n, "float32"), -1))
    };
  }
},
    al = {
  kernelName: "Acos",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => {
        var t = ga(pn(n, "float32")),
            s = ui(Vr(qa(1), t));
        return Br(ns(e, s));
      }
    };
  }
},
    il = {
  kernelName: "Acosh",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => {
        var t = ui(Vr(ga(pn(n, "float32")), 1));
        return ns(e, t);
      }
    };
  }
},
    ol = {
  kernelName: "Add",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = cr(n.shape, s.shape);
    return {
      a: () => {
        var t = e;
        var s = ur(n.shape, r);
        return s.length > 0 && (t = Gr(t, s)), Es(t, n.shape);
      },
      b: () => {
        var t = e;
        var n = ur(s.shape, r);
        return n.length > 0 && (t = Gr(t, n)), Es(t, s.shape);
      }
    };
  }
},
    ll = {
  kernelName: "ArgMax",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => pr(n)
    };
  }
},
    ul = {
  kernelName: "ArgMin",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => pr(n)
    };
  }
},
    cl = {
  kernelName: "Asin",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ns(e, ui(Vr(qa(1), ga(pn(n, "float32")))))
    };
  }
},
    hl = {
  kernelName: "Asinh",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => {
        var t = ui(es(qa(1), ga(pn(n, "float32"))));
        return ns(e, t);
      }
    };
  }
},
    dl = {
  kernelName: "Atan2",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = cr(n.shape, s.shape);
    return {
      a: () => {
        var t = es(ga(n), ga(s));
        var a = ss(e, ns(s, t));
        var i = ur(n.shape, r);
        return i.length > 0 && (a = Gr(a, i)), Es(a, n.shape);
      },
      b: () => {
        var t = es(ga(n), ga(s));
        var a = Br(ss(e, ns(n, t)));
        var i = ur(s.shape, r);
        return i.length > 0 && (a = Gr(a, i)), Es(a, s.shape);
      }
    };
  }
},
    pl = {
  kernelName: "Atan",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ns(e, es(ga(pn(n, "float32")), 1))
    };
  }
},
    fl = {
  kernelName: "Atanh",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ns(e, Vr(qa(1), ga(pn(n, "float32"))))
    };
  }
},
    gl = At({
  avgPool3dGrad_: function avgPool3dGrad_(e, t, n, s, r, a) {
    var i = Et(e, "dy", "avgPool3dGrad"),
        o = Et(t, "input", "avgPool3dGrad");
    var u = i,
        c = o,
        h = !1;
    4 === o.rank && (h = !0, u = Es(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]]), c = Es(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), l(5 === u.rank, () => "Error in avgPool3dGrad: dy must be rank 5 but got rank ".concat(u.rank, ".")), l(5 === c.rank, () => "Error in avgPool3dGrad: input must be rank 5 but got rank ".concat(c.rank, ".")), null != a && l(f(r), () => "Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ".concat(a, " but got pad ").concat(r, "."));
    var d = wt.runKernel("AvgPool3DGrad", {
      dy: u,
      input: c
    }, {
      filterSize: n,
      strides: s,
      pad: r,
      dimRoundingMode: a
    });
    return h ? Es(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d;
  }
}),
    ml = {
  kernelName: "AvgPool3D",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      filterSize: r,
      strides: a,
      pad: i,
      dimRoundingMode: o
    } = n;
    return {
      x: () => gl(e, s, r, a, i, o)
    };
  }
},
    bl = At({
  avgPoolGrad_: function avgPoolGrad_(e, t, n, s, r) {
    var a = Et(e, "dy", "avgPoolGrad"),
        i = Et(t, "input", "avgPoolGrad");
    l(i.rank === a.rank, () => "Rank of input (".concat(i.rank, ") does not match rank of dy (").concat(a.rank, ")"));
    var o = i,
        u = a,
        c = !1;
    3 === i.rank && (c = !0, o = Es(i, [1, i.shape[0], i.shape[1], i.shape[2]]), u = Es(a, [1, a.shape[0], a.shape[1], a.shape[2]])), l(4 === u.rank, () => "Error in avgPoolGrad: dy must be rank 4 but got rank ".concat(u.rank, ".")), l(4 === o.rank, () => "Error in avgPoolGrad: input must be rank 4 but got rank ".concat(o.rank, "."));
    var h = wt.runKernel("AvgPoolGrad", {
      dy: u,
      input: o
    }, {
      filterSize: n,
      strides: s,
      pad: r
    });
    return c ? Es(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
  }
}),
    xl = {
  kernelName: "AvgPool",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      filterSize: r,
      strides: a,
      pad: i
    } = n;
    return {
      x: () => bl(e, s, r, a, i)
    };
  }
},
    yl = {
  kernelName: "BatchMatMul",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      transposeA: a,
      transposeB: i
    } = n;
    return a || i ? !a && i ? {
      a: () => vn(e, r, !1, !1),
      b: () => vn(e, s, !0, !1)
    } : a && !i ? {
      a: () => vn(r, e, !1, !0),
      b: () => vn(s, e, !1, !1)
    } : {
      a: () => vn(r, e, !0, !0),
      b: () => vn(e, s, !0, !0)
    } : {
      a: () => vn(e, r, !1, !0),
      b: () => vn(s, e, !0, !1)
    };
  }
},
    kl = {
  kernelName: "BatchToSpaceND",
  gradFunc: (e, t, n) => {
    var {
      blockShape: s,
      crops: r
    } = n;
    return {
      x: () => ka(e, s, r)
    };
  }
},
    wl = {
  kernelName: "BroadcastTo",
  gradFunc: (e, t, n) => {
    var s = n.inputShape,
        r = n.shape,
        a = Array.from(r);

    for (var _e84 = s.length - 1; _e84 >= 0; _e84--) {
      if (s[_e84] === r[_e84]) a[_e84] = 1;else if (1 !== s[_e84]) throw new Error("broadcastTo(): [".concat(s, "] cannot be broadcast to [").concat(r, "]."));
    }

    var i = [];

    for (var _e85 = 0; _e85 < a.length; _e85++) {
      a[_e85] > 1 && i.push(_e85);
    }

    return {
      x: () => Gr(e, i, !0)
    };
  }
},
    vl = {
  kernelName: "Ceil",
  gradFunc: e => ({
    x: () => pr(e)
  })
},
    Il = {
  kernelName: "ClipByValue",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      clipValueMin: r,
      clipValueMax: a
    } = n;
    return {
      x: () => dr(ta(Sr(s, r), _r(s, a)), e, pr(e))
    };
  }
},
    $l = {
  kernelName: "ComplexAbs",
  inputsToSave: ["x"],
  gradFunc: rl.gradFunc
},
    Nl = {
  kernelName: "Concat",
  saveAllInputs: !0,
  gradFunc: (e, t, n) => {
    var s = t.map(e => e.shape),
        {
      axis: r
    } = n,
        a = y(r, t[0].shape)[0],
        i = s.map(e => e[a]);
    return oi(e, i, a).map(e => () => e);
  }
},
    Cl = {
  kernelName: "Conv2D",
  inputsToSave: ["x", "filter"],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      dilations: a,
      strides: i,
      pad: o,
      dataFormat: u
    } = n;
    return l(Cs(a), () => "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(a, "'")), {
      x: () => Js(s.shape, e, r, i, o, u),
      filter: () => Ti(s, e, r.shape, i, o, u)
    };
  }
},
    Sl = {
  kernelName: "Conv2DBackpropInput",
  inputsToSave: ["dy", "filter"],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      strides: a,
      pad: i,
      dataFormat: o,
      dimRoundingMode: l
    } = n;
    return {
      dy: () => Xs(e, r, a, i, o, 1, l),
      filter: () => Ti(e, s, r.shape, a, i, o, l)
    };
  }
},
    Tl = At({
  conv3DBackpropFilter_: function conv3DBackpropFilter_(e, t, n, s, r) {
    var a = e;
    4 === e.rank && (a = Es(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]));
    var i = t;
    return 4 === i.rank && (i = Es(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])), l(5 === a.rank, () => "Error in conv3dDerFilter: input must be rank 5, but got shape ".concat(a.shape, ".")), l(5 === i.rank, () => "Error in conv3dDerFilter: dy must be rank 5, but got shape ".concat(i.shape, ".")), l(5 === n.length, () => "Error in conv3dDerFilter: filterShape must be length 5, but got ".concat(n, ".")), l(a.shape[4] === n[3], () => "Error in conv3dDerFilter: depth of input ".concat(a.shape[4], ") must match input depth in filter (").concat(n[3], ".")), l(i.shape[4] === n[4], () => "Error in conv3dDerFilter: depth of dy (".concat(i.shape[4], ") must match output depth for filter (").concat(n[4], ").")), wt.runKernel("Conv3DBackpropFilterV2", {
      x: a,
      dy: i
    }, {
      strides: s,
      pad: r,
      filterShape: n
    });
  }
}),
    El = {
  kernelName: "Conv3D",
  inputsToSave: ["x", "filter"],
  gradFunc: (e, t, n) => {
    var {
      dilations: s,
      strides: r,
      pad: a
    } = n;
    l(Cs(s), () => "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(s, "'"));
    var [i, o] = t;
    return {
      x: () => er(i.shape, e, o, r, a),
      filter: () => Tl(i, e, o.shape, r, a)
    };
  }
},
    Rl = {
  kernelName: "Cos",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(Br(Ja(pn(n, "float32"))), e)
    };
  }
},
    Al = {
  kernelName: "Cosh",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(Za(pn(n, "float32")), e)
    };
  }
},
    Fl = {
  kernelName: "Cumsum",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      axis: r,
      exclusive: a,
      reverse: i
    } = n;
    return {
      x: () => {
        var t = Jr([r], s.rank);
        var n = rr(e, r, a, !i);
        return null != t && (n = $n(n, t)), n;
      }
    };
  }
},
    Dl = {
  kernelName: "DepthwiseConv2dNative",
  inputsToSave: ["x", "filter"],
  gradFunc: (e, t, n) => {
    var {
      dilations: s,
      strides: r,
      pad: a,
      dimRoundingMode: i
    } = n,
        o = null == s ? [1, 1] : s;
    l(Cs(o), () => "Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '".concat(o, "'"));
    var [u, c] = t;
    return l(4 === u.rank, () => "Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ".concat(u.rank, ".")), l(4 === c.rank, () => "Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ".concat(c.rank, ".")), l(u.shape[3] === c.shape[2], () => "Error in gradient of depthwiseConv2d: number of input channels (".concat(u.shape[3], ") must match the inChannels dimension in filter ").concat(c.shape[2], ".")), l(Ss(r, o), () => "Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ".concat(r, " and dilations '").concat(o, "'.")), null != i && l(f(a), () => "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(a, ".")), {
      x: () => Oi(u.shape, e, c, r, a, s, i),
      filter: () => _i(u, e, c.shape, r, a, s, i)
    };
  }
},
    _l = {
  kernelName: "Dilation2D",
  inputsToSave: ["x", "filter"],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        a = {
      x: s,
      filter: r,
      dy: e
    },
        i = {
      x: s,
      filter: r,
      dy: e
    };
    return {
      x: () => wt.runKernel("Dilation2DBackpropInput", a, n),
      filter: () => wt.runKernel("Dilation2DBackpropFilter", i, n)
    };
  }
},
    Ol = {
  kernelName: "Elu",
  outputsToSave: [!0],
  gradFunc: (e, t) => {
    var [n] = t,
        s = {
      dy: e,
      y: n
    };
    return {
      x: () => wt.runKernel("EluGrad", s)
    };
  }
},
    Ml = {
  kernelName: "Erf",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t,
        s = ss(xr(Br(ga(n))), 2 / Math.sqrt(Math.PI));
    return {
      x: () => ss(e, s)
    };
  }
},
    Ll = {
  kernelName: "Exp",
  outputsToSave: [!0],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, n)
    };
  }
},
    zl = {
  kernelName: "ExpandDims",
  inputsToSave: ["input"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      input: () => Es(e, n.shape)
    };
  }
},
    Bl = {
  kernelName: "Expm1",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, xr(n))
    };
  }
},
    Pl = {
  kernelName: "Floor",
  gradFunc: e => ({
    x: () => pr(e)
  })
},
    Wl = {
  kernelName: "FloorDiv",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = cr(n.shape, s.shape);
    return {
      a: () => {
        var t = ns(e, pn(s, "float32")),
            a = ur(n.shape, r);
        return a.length > 0 ? Es(Gr(t, a), n.shape) : t;
      },
      b: () => {
        var t = ss(e, pn(n, "float32"));
        var a = ur(s.shape, r);
        a.length > 0 && (t = Es(Gr(t, a), s.shape));
        var i = ga(s);
        return Br(ns(t, pn(i, "float32")));
      }
    };
  }
},
    Ul = {
  kernelName: "FusedBatchNorm",
  inputsToSave: ["x", "mean", "variance", "scale"],
  gradFunc: (e, t, n) => {
    var {
      varianceEpsilon: s
    } = n,
        [r, a, i, o] = t,
        l = null == o ? qa(1) : o,
        u = ur(a.shape, r.shape),
        c = [];

    if (1 === a.rank) {
      for (var _e86 = 0; _e86 < r.shape.length - 1; ++_e86) {
        c.push(r.shape[_e86]);
      }

      c.push(1);
    }

    var h = Vr(r, a),
        d = ss(e, l),
        p = ja(es(i, qa(s))),
        f = ss(ss(ss(p, p), p), qa(-.5));
    return {
      x: () => Es(ss(ss(e, 1 === a.rank ? wr(Es(p, [1, 1, 1, a.shape[0]]), c) : p), l), r.shape),
      mean: () => {
        var e = ss(ss(p, qa(-1)), d);
        return 1 === a.rank && (e = Gr(e, u)), Es(e, a.shape);
      },
      variance: () => {
        var e = ss(ss(f, h), d);
        return 1 === a.rank && (e = Gr(e, u)), Es(e, a.shape);
      },
      scale: () => {
        var t = ss(h, p);
        var n = ss(e, t);
        return 1 === a.rank && (n = Gr(n, u)), Es(n, a.shape);
      },
      offset: () => {
        var t = e;
        return 1 === a.rank && (t = Gr(t, u)), Es(t, a.shape);
      }
    };
  }
},
    Vl = {
  kernelName: "GatherV2",
  inputsToSave: ["x", "indices"],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      axis: a
    } = n,
        i = y(a, s.shape)[0];
    return {
      x: () => {
        var t = s.shape,
            n = r.size,
            o = t.slice(0, i),
            l = o.length,
            u = t.slice(a, t.length).slice(1),
            c = u.length,
            h = Gl(0, l),
            d = Gl(l + 1, l + 1 + c),
            p = Hl([o, [n], u]),
            f = Es(e, p),
            g = Es(r, [n]),
            m = Hl([[l], h, d]),
            b = $n(f, m);
        var x = wi(b, g, s.shape[i]);
        var y = Zr(m);
        return x = $n(x, y), x;
      },
      indices: () => r
    };
  }
};

function Gl(e, t) {
  var n = [];

  for (var _s50 = e; _s50 < t; ++_s50) {
    n.push(_s50);
  }

  return n;
}

function Hl(e) {
  var t = [];

  for (var _n45 = 0; _n45 < e.length; ++_n45) {
    for (var _s51 = 0; _s51 < e[_n45].length; ++_s51) {
      t.push(e[_n45][_s51]);
    }
  }

  return t;
}

var jl = {
  kernelName: "GreaterEqual",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t;
    return {
      a: () => pr(n),
      b: () => pr(s)
    };
  }
},
    ql = {
  kernelName: "Identity",
  gradFunc: e => ({
    x: () => pn(e, "float32")
  })
},
    Kl = {
  kernelName: "IsFinite",
  gradFunc: e => ({
    x: () => pr(e)
  })
},
    Xl = {
  kernelName: "IsInf",
  gradFunc: e => ({
    x: () => pr(e)
  })
},
    Yl = {
  kernelName: "IsNan",
  gradFunc: e => ({
    x: () => pr(e)
  })
},
    Jl = {
  kernelName: "LeakyRelu",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      alpha: r
    } = n,
        a = Cr(s, 0);
    return {
      x: () => dr(a, e, ss(e, r))
    };
  }
},
    Zl = {
  kernelName: "Log1p",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ns(e, es(n, 1))
    };
  }
},
    Ql = {
  kernelName: "Log",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ns(e, pn(n, "float32"))
    };
  }
},
    eu = {
  kernelName: "LogSoftmax",
  inputsToSave: [],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      axis: r
    } = n;
    return {
      logits: () => {
        var t = xr(s);
        return Vr(e, ss(Gr(e, r, !0), t));
      }
    };
  }
},
    tu = At({
  localResponseNormalizationBackprop_: function localResponseNormalizationBackprop_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : .5;
    return wt.runKernel("LRNGrad", {
      x: e,
      y: t,
      dy: n
    }, {
      depthRadius: s,
      bias: r,
      alpha: a,
      beta: i
    });
  }
}),
    nu = {
  kernelName: "LRN",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      depthRadius: a,
      bias: i,
      alpha: o,
      beta: l
    } = n;
    return {
      x: () => tu(s, r, e, a, i, o, l)
    };
  }
};

function su(e, t, n, s) {
  return t.rank < n.rank && (t = Es(t, Xr(t.shape, s))), e.rank < n.rank && (e = Es(e, Xr(e.shape, s))), {
    x: () => ss(e, pn(hr(n, t), e.dtype))
  };
}

var ru = {
  kernelName: "Max",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var s = n,
        {
      reductionIndices: r
    } = s,
        a = t[0],
        i = su(e, t[1], a, y(r, a.shape));
    return {
      x: () => i.x()
    };
  }
},
    au = {
  kernelName: "Maximum",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t;
    return {
      a: () => ss(e, pn(Sr(n, s), "float32")),
      b: () => ss(e, pn(Dr(n, s), "float32"))
    };
  }
},
    iu = At({
  maxPool3dGrad_: function maxPool3dGrad_(e, t, n, s, r, a, i) {
    var o = Et(e, "dy", "maxPool3dGrad"),
        u = Et(t, "input", "maxPool3dGrad"),
        c = Et(n, "output", "maxPool3dGrad");
    var h = o,
        d = u,
        p = c,
        g = !1;
    4 === u.rank && (g = !0, h = Es(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]), d = Es(u, [1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]]), p = Es(c, [1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]])), l(5 === h.rank, () => "Error in maxPool3dGrad: dy must be rank 5 but got rank ".concat(h.rank, ".")), l(5 === d.rank, () => "Error in maxPool3dGrad: input must be rank 5 but got rank ".concat(d.rank, ".")), l(5 === p.rank, () => "Error in maxPool3dGrad: output must be rank 5 but got rank ".concat(p.rank, ".")), null != i && l(f(a), () => "Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(a, "."));
    var m = wt.runKernel("MaxPool3DGrad", {
      dy: h,
      input: d,
      output: p
    }, {
      filterSize: s,
      strides: r,
      pad: a,
      dimRoundingMode: i
    });
    return g ? Es(m, [m.shape[1], m.shape[2], m.shape[3], m.shape[4]]) : m;
  }
}),
    ou = {
  kernelName: "MaxPool3D",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: l
    } = n;
    return {
      x: () => iu(e, s, r, a, i, o, l)
    };
  }
},
    lu = At({
  maxPoolGrad_: function maxPoolGrad_(e, t, n, s, r, a, i) {
    var o = Et(e, "dy", "maxPoolGrad"),
        u = Et(t, "input", "maxPoolGrad"),
        c = Et(n, "output", "maxPoolGrad");
    return l(u.rank === o.rank, () => "Rank of input (".concat(u.rank, ") does not match rank of dy (").concat(o.rank, ")")), l(4 === o.rank, () => "Error in maxPoolGrad: dy must be rank 4 but got rank ".concat(o.rank, ".")), l(4 === u.rank, () => "Error in maxPoolGrad: input must be rank 4 but got rank ".concat(u.rank, ".")), null != i && l(f(a), () => "Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(a, ".")), wt.runKernel("MaxPoolGrad", {
      dy: o,
      input: u,
      output: c
    }, {
      filterSize: s,
      strides: r,
      pad: a,
      dimRoundingMode: i
    });
  }
}),
    uu = {
  kernelName: "PadV2",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var s = t[0],
        {
      paddings: r
    } = n,
        a = r.map(e => e[0]);
    return {
      x: () => _s(e, a, s.shape)
    };
  }
},
    cu = {
  kernelName: "SpaceToBatchND",
  gradFunc: (e, t, n) => {
    var {
      blockShape: s,
      paddings: r
    } = n;
    return {
      x: () => Ms(e, s, r)
    };
  }
},
    hu = {
  kernelName: "SplitV",
  gradFunc: (e, t, n) => {
    var {
      axis: s
    } = n;
    return {
      x: () => Fs(e, s)
    };
  }
},
    du = [rl, al, il, ol, {
  kernelName: "AddN",
  saveAllInputs: !0,
  gradFunc: (e, t) => {
    var n = {};
    return t.forEach((t, s) => {
      n[s] = () => e.clone();
    }), n;
  }
}, ll, ul, cl, hl, dl, pl, fl, ml, xl, yl, kl, wl, {
  kernelName: "Cast",
  gradFunc: e => ({
    x: () => e.clone()
  })
}, vl, Il, $l, Nl, Sl, Cl, El, Rl, Al, Fl, Dl, _l, {
  kernelName: "RealDiv",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = cr(n.shape, s.shape);
    return {
      a: () => {
        var t = ns(e, pn(s, "float32")),
            a = ur(n.shape, r);
        return a.length > 0 ? Es(Gr(t, a), n.shape) : t;
      },
      b: () => {
        var t = ss(e, pn(n, "float32"));
        var a = ur(s.shape, r);
        a.length > 0 && (t = Es(Gr(t, a), s.shape));
        var i = ga(s);
        return Br(ns(t, pn(i, "float32")));
      }
    };
  }
}, Ol, Ml, Ll, zl, Bl, Wl, Pl, Ul, Vl, jl, ql, Kl, Xl, Yl, Jl, Zl, Ql, eu, nu, ru, ru, au, ou, {
  kernelName: "MaxPool",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var [s, r] = t,
        {
      filterSize: a,
      strides: i,
      pad: o
    } = n;
    return {
      x: () => lu(e, s, r, a, i, o)
    };
  }
}, {
  kernelName: "Mean",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      axis: r
    } = n,
        a = y(r, s.shape),
        i = d(Kr(s.shape, a)[1]);
    return {
      x: () => {
        var t = s.shape.slice();
        a.forEach(e => {
          t[e] = 1;
        });
        var n = Es(e, t);
        return ns(ss(n, ca(s.shape, "float32")), i);
      }
    };
  }
}, {
  kernelName: "Min",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var s = n,
        {
      axis: r
    } = s,
        [a, i] = t,
        o = su(e, i, a, y(r, a.shape));
    return {
      x: () => o.x()
    };
  }
}, {
  kernelName: "Minimum",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t;
    return {
      a: () => ss(e, pn(_r(n, s), "float32")),
      b: () => ss(e, pn(Cr(n, s), "float32"))
    };
  }
}, {
  kernelName: "MirrorPad",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var s = t[0],
        {
      paddings: r
    } = n,
        a = r.map(e => e[0]);
    return {
      x: () => _s(e, a, s.shape)
    };
  }
}, {
  kernelName: "Mod",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = cr(n.shape, s.shape);
    return {
      a: () => {
        var t = ur(n.shape, r);
        return t.length > 0 ? Es(Gr(e, t), n.shape) : e;
      },
      b: () => {
        var t = ss(e, Br($r(ns(n, s)))),
            a = ur(s.shape, r);
        return a.length > 0 ? Es(Gr(t, a), s.shape) : t;
      }
    };
  }
}, {
  kernelName: "Multiply",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = cr(n.shape, s.shape);
    return {
      a: () => {
        var t = ss(e, pn(s, "float32")),
            a = ur(n.shape, r);
        return a.length > 0 ? Es(Gr(t, a), n.shape) : t;
      },
      b: () => {
        var t = ss(e, pn(n, "float32")),
            a = ur(s.shape, r);
        return a.length > 0 ? Es(Gr(t, a), s.shape) : t;
      }
    };
  }
}, {
  kernelName: "Neg",
  gradFunc: e => ({
    x: () => Br(e)
  })
}, {
  kernelName: "OneHot",
  inputsToSave: ["indices"],
  gradFunc: (e, t) => {
    var n = t[0];
    return {
      indices: () => ua(n.shape, "float32")
    };
  }
}, {
  kernelName: "OnesLike",
  gradFunc: e => ({
    x: () => pr(e)
  })
}, {
  kernelName: "Pack",
  saveAllInputs: !0,
  gradFunc: (e, t, n) => {
    var {
      axis: s
    } = n;
    return vi(e, s).map(e => () => e);
  }
}, uu, uu, {
  kernelName: "Pow",
  inputsToSave: ["a", "b"],
  outputsToSave: [!0],
  gradFunc: (e, t) => {
    var [n, s, r] = t,
        _a25 = n,
        i = s,
        o = cr(_a25.shape, i.shape);
    return {
      a: () => {
        var t = pn(i, "float32");
        var n = ss(e, ss(t, va(_a25, Vr(t, qa(1)))));
        var s = ur(_a25.shape, o);
        return s.length > 0 && (n = Gr(n, s)), Es(n, _a25.shape);
      },
      b: () => {
        var t = Cr(_a25, 0),
            n = dr(t, Mr(_a25), pr(_a25));
        var s = ss(e, ss(r, n));
        var l = ur(i.shape, o);
        return l.length > 0 && (s = Gr(s, l)), Es(s, i.shape);
      }
    };
  }
}, {
  kernelName: "Prelu",
  inputsToSave: ["x", "alpha"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = Cr(n, 0);
    return {
      x: () => dr(r, e, ss(e, s)),
      alpha: () => {
        var t = dr(r, pr(e), ss(e, n));
        var a = ur(s.shape, e.shape);
        return a.length > 0 && (t = Gr(t, a)), Es(t, s.shape);
      }
    };
  }
}, {
  kernelName: "Reciprocal",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ns(e, Br(ga(n)))
    };
  }
}, {
  kernelName: "Relu6",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t,
        s = ss(_r(n, 6), pi(n));
    return {
      x: () => ss(e, pn(s, "float32"))
    };
  }
}, {
  kernelName: "Relu",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, pn(pi(n), "float32"))
    };
  }
}, {
  kernelName: "Reshape",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => Es(e, n.shape)
    };
  }
}, {
  kernelName: "ResizeBilinear",
  inputsToSave: ["images"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        r = {
      dy: e,
      images: s
    };
    return {
      images: () => wt.runKernel("ResizeBilinearGrad", r, n)
    };
  }
}, {
  kernelName: "ResizeNearestNeighbor",
  inputsToSave: ["images"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        r = {
      dy: e,
      images: s
    };
    return {
      images: () => wt.runKernel("ResizeNearestNeighborGrad", r, n)
    };
  }
}, {
  kernelName: "Reverse",
  gradFunc: (e, t, n) => {
    var {
      dims: s
    } = n,
        r = y(s, e.shape);
    return {
      x: () => Ga(e, r)
    };
  }
}, {
  kernelName: "Round",
  gradFunc: e => ({
    x: () => pr(e)
  })
}, {
  kernelName: "Rsqrt",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => Br(ns(e, ss(va(n, 1.5), 2)))
    };
  }
}, {
  kernelName: "Select",
  inputsToSave: ["condition"],
  gradFunc: (_e87, t) => {
    var [n] = t;
    return {
      condition: () => pn(pr(n), "float32"),
      t: () => ss(_e87, pn(n, _e87.dtype)),
      e: () => ss(_e87, pn(na(n), _e87.dtype))
    };
  }
}, {
  kernelName: "Selu",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => {
        var t = Cr(n, qa(0)),
            s = qa(1.7580993408473768),
            r = qa(1.0507009873554805),
            a = ss(e, r),
            i = ss(ss(e, s), xr(pn(n, "float32")));
        return dr(t, a, i);
      }
    };
  }
}, {
  kernelName: "Sigmoid",
  outputsToSave: [!0],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, ss(n, Vr(qa(1), n)))
    };
  }
}, {
  kernelName: "Sign",
  gradFunc: e => ({
    x: () => pr(e)
  })
}, {
  kernelName: "Sin",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(nr(pn(n, "float32")), e)
    };
  }
}, {
  kernelName: "Sinh",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(sr(pn(n, "float32")), e)
    };
  }
}, {
  kernelName: "Slice",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      begin: r,
      size: a
    } = n,
        i = s.shape,
        [o, l] = Un(s, r, a),
        u = [];

    for (var _t84 = 0; _t84 < e.rank; _t84++) {
      u.push([o[_t84], i[_t84] - o[_t84] - l[_t84]]);
    }

    return {
      x: () => ya(e, u)
    };
  }
}, {
  kernelName: "Softmax",
  outputsToSave: [!0],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      dim: r
    } = n,
        a = ss(e, s);
    return {
      logits: () => Vr(a, ss(Gr(a, [r], !0), s))
    };
  }
}, {
  kernelName: "Softplus",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, Ds(n))
    };
  }
}, cu, cu, hu, hu, {
  kernelName: "Sqrt",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ns(e, ss(ui(pn(n, "float32")), 2))
    };
  }
}, {
  kernelName: "SquaredDifference",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = qa(2);
    return {
      a: () => ss(e, ss(r, Vr(n, s))),
      b: () => ss(e, ss(r, Vr(s, n)))
    };
  }
}, {
  kernelName: "Square",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(e, ss(pn(n, "float32"), 2))
    };
  }
}, {
  kernelName: "Step",
  gradFunc: e => ({
    x: () => pr(e)
  })
}, {
  kernelName: "Sub",
  inputsToSave: ["a", "b"],
  gradFunc: (e, t) => {
    var [n, s] = t,
        r = cr(n.shape, s.shape);
    return {
      a: () => {
        var t = e;
        var s = ur(n.shape, r);
        return s.length > 0 && (t = Gr(t, s)), Es(t, n.shape);
      },
      b: () => {
        var t = e;
        var n = ur(s.shape, r);
        return n.length > 0 && (t = Gr(t, n)), Es(Br(t), s.shape);
      }
    };
  }
}, {
  kernelName: "Sum",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        r = s.shape.slice(),
        {
      axis: a
    } = n;
    y(a, s.shape).forEach(e => {
      r[e] = 1;
    });
    var i = Es(e, r),
        o = ss(i, ca(s.shape, "float32"));
    return {
      x: () => o
    };
  }
}, {
  kernelName: "Tan",
  inputsToSave: ["x"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ns(e, ga(nr(n)))
    };
  }
}, {
  kernelName: "Tanh",
  outputsToSave: [!0],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => ss(Vr(qa(1), ga(n)), e)
    };
  }
}, {
  kernelName: "Tile",
  inputsToSave: ["x"],
  gradFunc: (e, t, n) => {
    var [s] = t,
        {
      reps: r
    } = n;
    return {
      x: () => {
        var t = pr(s);
        if (1 === s.rank) for (var _n46 = 0; _n46 < r[0]; ++_n46) {
          t = es(t, _s(e, [_n46 * s.shape[0]], [s.shape[0]]));
        } else if (2 === s.rank) for (var _n47 = 0; _n47 < r[0]; ++_n47) {
          for (var _a26 = 0; _a26 < r[1]; ++_a26) {
            t = es(t, _s(e, [_n47 * s.shape[0], _a26 * s.shape[1]], [s.shape[0], s.shape[1]]));
          }
        } else if (3 === s.rank) for (var _n48 = 0; _n48 < r[0]; ++_n48) {
          for (var _a27 = 0; _a27 < r[1]; ++_a27) {
            for (var _i16 = 0; _i16 < r[2]; ++_i16) {
              t = es(t, _s(e, [_n48 * s.shape[0], _a27 * s.shape[1], _i16 * s.shape[2]], [s.shape[0], s.shape[1], s.shape[2]]));
            }
          }
        } else {
          if (4 !== s.rank) throw new Error("Gradient for tile operation is not implemented for rank-".concat(s.rank, " tensors yet."));

          for (var _n49 = 0; _n49 < r[0]; ++_n49) {
            for (var _a28 = 0; _a28 < r[1]; ++_a28) {
              for (var _i17 = 0; _i17 < r[2]; ++_i17) {
                for (var _o14 = 0; _o14 < r[3]; ++_o14) {
                  t = es(t, _s(e, [_n49 * s.shape[0], _a28 * s.shape[1], _i17 * s.shape[2], _o14 * s.shape[3]], [s.shape[0], s.shape[1], s.shape[2], s.shape[3]]));
                }
              }
            }
          }
        }
        return t;
      }
    };
  }
}, {
  kernelName: "Transpose",
  gradFunc: (e, t, n) => {
    var s = n,
        {
      perm: r
    } = s,
        a = Zr(r);
    return {
      x: () => $n(e, a)
    };
  }
}, {
  kernelName: "Unpack",
  gradFunc: (e, t, n) => {
    var s = n,
        {
      axis: r
    } = s;
    return {
      value: () => di(e, r)
    };
  }
}, {
  kernelName: "UnsortedSegmentSum",
  inputsToSave: ["segmentIds"],
  gradFunc: (e, t) => {
    var [n] = t;
    return {
      x: () => function (e, t) {
        var n = oa(t, pr(t)),
            s = Nr(e, n);
        var r = Sr(t, qa(0, "int32"));
        var a = s.rank - r.rank;

        for (var _e88 = 0; _e88 < a; ++_e88) {
          r = yr(r, _e88 + 1);
        }

        r = ta(r, ca(s.shape, "bool"));
        var i = pr(s);
        return dr(r, s, i);
      }(e, n)
    };
  }
}, {
  kernelName: "ZerosLike",
  gradFunc: e => ({
    x: () => pr(e)
  })
}];

for (var _e89 of du) {
  ee(_e89);
}

var pu;

function fu() {
  return null == pu && (pu = wt.backend.epsilon()), pu;
}

rt().prototype.abs = function () {
  return this.throwIfDisposed(), rs(this);
}, rt().prototype.acos = function () {
  return this.throwIfDisposed(), as(this);
}, rt().prototype.acosh = function () {
  return this.throwIfDisposed(), is(this);
}, rt().prototype.add = function (e) {
  return this.throwIfDisposed(), es(this, e);
}, rt().prototype.all = function (e, t) {
  return this.throwIfDisposed(), os(this, e, t);
}, rt().prototype.any = function (e, t) {
  return this.throwIfDisposed(), ls(this, e, t);
}, rt().prototype.argMax = function (e) {
  return this.throwIfDisposed(), us(this, e);
}, rt().prototype.argMin = function (e) {
  return this.throwIfDisposed(), cs(this, e);
}, rt().prototype.asScalar = function () {
  return this.throwIfDisposed(), l(1 === this.size, () => "The array must have only 1 element."), Es(this, []);
}, rt().prototype.asType = function (e) {
  return this.throwIfDisposed(), pn(this, e);
}, rt().prototype.as1D = function () {
  return this.throwIfDisposed(), Es(this, [this.size]);
}, rt().prototype.as2D = function (e, t) {
  return this.throwIfDisposed(), Es(this, [e, t]);
}, rt().prototype.as3D = function (e, t, n) {
  return this.throwIfDisposed(), Es(this, [e, t, n]);
}, rt().prototype.as4D = function (e, t, n, s) {
  return this.throwIfDisposed(), Es(this, [e, t, n, s]);
}, rt().prototype.as5D = function (e, t, n, s, r) {
  return this.throwIfDisposed(), Es(this, [e, t, n, s, r]);
}, rt().prototype.asin = function () {
  return this.throwIfDisposed(), hs(this);
}, rt().prototype.asinh = function () {
  return this.throwIfDisposed(), ds(this);
}, rt().prototype.atan = function () {
  return this.throwIfDisposed(), ps(this);
}, rt().prototype.atan2 = function (e) {
  return this.throwIfDisposed(), fs(this, e);
}, rt().prototype.atanh = function () {
  return this.throwIfDisposed(), gs(this);
}, rt().prototype.avgPool = function (e, t, n, s) {
  return this.throwIfDisposed(), Rs(this, e, t, n, s);
}, rt().prototype.batchToSpaceND = function (e, t) {
  return this.throwIfDisposed(), Ms(this, e, t);
}, rt().prototype.batchNorm = function (e, t, n, s, r) {
  return this.throwIfDisposed(), Ls(this, e, t, n, s, r);
}, rt().prototype.broadcastTo = function (e) {
  return this.throwIfDisposed(), Us(this, e);
}, rt().prototype.cast = function (e) {
  return this.throwIfDisposed(), pn(this, e);
}, rt().prototype.ceil = function () {
  return this.throwIfDisposed(), Vs(this);
}, rt().prototype.clipByValue = function (e, t) {
  return this.throwIfDisposed(), Gs(this, e, t);
}, rt().prototype.concat = function (e, t) {
  return this.throwIfDisposed(), e instanceof st && (e = [e]), Fs([this, ...e], t);
}, rt().prototype.conv1d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), Ys(this, e, t, n, s, r, a);
}, rt().prototype.conv2dTranspose = function (e, t, n, s, r) {
  return this.throwIfDisposed(), Zs(this, e, t, n, s, r);
}, rt().prototype.conv2d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), Xs(this, e, t, n, s, r, a);
}, rt().prototype.cos = function () {
  return this.throwIfDisposed(), nr(this);
}, rt().prototype.cosh = function () {
  return this.throwIfDisposed(), sr(this);
}, rt().prototype.cumsum = function (e, t, n) {
  return this.throwIfDisposed(), rr(this, e, t, n);
}, rt().prototype.depthToSpace = function (e, t) {
  return this.throwIfDisposed(), ar(this, e, t);
}, rt().prototype.depthwiseConv2d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), ir(this, e, t, n, s, r, a);
}, rt().prototype.dilation2d = function (e, t, n, s, r) {
  return this.throwIfDisposed(), or(this, e, t, n, s, r);
}, rt().prototype.divNoNan = function (e) {
  return this.throwIfDisposed(), fr(this, e);
}, rt().prototype.div = function (e) {
  return this.throwIfDisposed(), ns(this, e);
}, rt().prototype.dot = function (e) {
  return this.throwIfDisposed(), gr(this, e);
}, rt().prototype.elu = function () {
  return this.throwIfDisposed(), mr(this);
}, rt().prototype.equal = function (e) {
  return this.throwIfDisposed(), hr(this, e);
}, rt().prototype.erf = function () {
  return this.throwIfDisposed(), br(this);
}, rt().prototype.exp = function () {
  return this.throwIfDisposed(), xr(this);
}, rt().prototype.expandDims = function (e) {
  return this.throwIfDisposed(), yr(this, e);
}, rt().prototype.expm1 = function () {
  return this.throwIfDisposed(), kr(this);
}, rt().prototype.fft = function () {
  return this.throwIfDisposed(), ri(this);
}, rt().prototype.flatten = function () {
  return this.throwIfDisposed(), Es(this, [this.size]);
}, rt().prototype.floor = function () {
  return this.throwIfDisposed(), $r(this);
}, rt().prototype.floorDiv = function (e) {
  return this.throwIfDisposed(), ts(this, e);
}, rt().prototype.gather = function (e, t) {
  return this.throwIfDisposed(), Nr(this, e, t);
}, rt().prototype.greaterEqual = function (e) {
  return this.throwIfDisposed(), Sr(this, e);
}, rt().prototype.greater = function (e) {
  return this.throwIfDisposed(), Cr(this, e);
}, rt().prototype.ifft = function () {
  return this.throwIfDisposed(), ai(this);
}, rt().prototype.irfft = function () {
  return this.throwIfDisposed(), ii(this);
}, rt().prototype.isFinite = function () {
  return this.throwIfDisposed(), Er(this);
}, rt().prototype.isInf = function () {
  return this.throwIfDisposed(), Rr(this);
}, rt().prototype.isNaN = function () {
  return this.throwIfDisposed(), Ar(this);
}, rt().prototype.leakyRelu = function (e) {
  return this.throwIfDisposed(), Fr(this, e);
}, rt().prototype.lessEqual = function (e) {
  return this.throwIfDisposed(), _r(this, e);
}, rt().prototype.less = function (e) {
  return this.throwIfDisposed(), Dr(this, e);
}, rt().prototype.localResponseNormalization = function (e, t, n, s) {
  return this.throwIfDisposed(), Or(this, e, t, n, s);
}, rt().prototype.logSigmoid = function () {
  return this.throwIfDisposed(), Wr(this);
}, rt().prototype.logSoftmax = function (e) {
  return this.throwIfDisposed(), Hr(this, e);
}, rt().prototype.logSumExp = function (e, t) {
  return this.throwIfDisposed(), ea(this, e, t);
}, rt().prototype.log = function () {
  return this.throwIfDisposed(), Mr(this);
}, rt().prototype.log1p = function () {
  return this.throwIfDisposed(), Lr(this);
}, rt().prototype.logicalAnd = function (e) {
  return this.throwIfDisposed(), ta(this, e);
}, rt().prototype.logicalNot = function () {
  return this.throwIfDisposed(), na(this);
}, rt().prototype.logicalOr = function (e) {
  return this.throwIfDisposed(), sa(this, e);
}, rt().prototype.logicalXor = function (e) {
  return this.throwIfDisposed(), ra(this, e);
}, rt().prototype.matMul = function (e, t, n) {
  return this.throwIfDisposed(), vn(this, e, t, n);
}, rt().prototype.maxPool = function (e, t, n, s) {
  return this.throwIfDisposed(), aa(this, e, t, n, s);
}, rt().prototype.max = function (e, t) {
  return this.throwIfDisposed(), Ur(this, e, t);
}, rt().prototype.maximum = function (e) {
  return this.throwIfDisposed(), oa(this, e);
}, rt().prototype.mean = function (e, t) {
  return this.throwIfDisposed(), la(this, e, t);
}, rt().prototype.min = function (e, t) {
  return this.throwIfDisposed(), ha(this, e, t);
}, rt().prototype.minimum = function (e) {
  return this.throwIfDisposed(), da(this, e);
}, rt().prototype.mirrorPad = function (e, t) {
  return this.throwIfDisposed(), pa(this, e, t);
}, rt().prototype.mod = function (e) {
  return this.throwIfDisposed(), fa(this, e);
}, rt().prototype.mul = function (e) {
  return this.throwIfDisposed(), ss(this, e);
}, rt().prototype.neg = function () {
  return this.throwIfDisposed(), Br(this);
}, rt().prototype.norm = function (e, t, n) {
  return this.throwIfDisposed(), Ni(this, e, t, n);
}, rt().prototype.notEqual = function (e) {
  return this.throwIfDisposed(), ba(this, e);
}, rt().prototype.oneHot = function (e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return this.throwIfDisposed(), In(this, e, t, n);
}, rt().prototype.onesLike = function () {
  return this.throwIfDisposed(), xa(this);
}, rt().prototype.pad = function (e, t) {
  return this.throwIfDisposed(), ya(this, e, t);
}, rt().prototype.pool = function (e, t, n, s, r) {
  return this.throwIfDisposed(), wa(this, e, t, n, s, r);
}, rt().prototype.pow = function (e) {
  return this.throwIfDisposed(), va(this, e);
}, rt().prototype.prelu = function (e) {
  return this.throwIfDisposed(), Ia(this, e);
}, rt().prototype.prod = function (e, t) {
  return this.throwIfDisposed(), $a(this, e, t);
}, rt().prototype.reciprocal = function () {
  return this.throwIfDisposed(), Wa(this);
}, rt().prototype.relu = function () {
  return this.throwIfDisposed(), Ua(this);
}, rt().prototype.relu6 = function () {
  return this.throwIfDisposed(), Va(this);
}, rt().prototype.reshapeAs = function (e) {
  return this.throwIfDisposed(), Es(this, e.shape);
}, rt().prototype.reshape = function (e) {
  return this.throwIfDisposed(), Es(this, e);
}, rt().prototype.resizeBilinear = function (e, t, n) {
  return this.throwIfDisposed(), to(this, e, t, n);
}, rt().prototype.resizeNearestNeighbor = function (e, t, n) {
  return this.throwIfDisposed(), no(this, e, t, n);
}, rt().prototype.reverse = function (e) {
  return this.throwIfDisposed(), Ga(this, e);
}, rt().prototype.rfft = function () {
  return this.throwIfDisposed(), li(this);
}, rt().prototype.round = function () {
  return this.throwIfDisposed(), Ha(this);
}, rt().prototype.rsqrt = function () {
  return this.throwIfDisposed(), ja(this);
}, rt().prototype.selu = function () {
  return this.throwIfDisposed(), Ka(this);
}, rt().prototype.separableConv2d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), Xa(this, e, t, n, s, r, a);
}, rt().prototype.sigmoid = function () {
  return this.throwIfDisposed(), Ds(this);
}, rt().prototype.sign = function () {
  return this.throwIfDisposed(), Ya(this);
}, rt().prototype.sin = function () {
  return this.throwIfDisposed(), Ja(this);
}, rt().prototype.sinh = function () {
  return this.throwIfDisposed(), Za(this);
}, rt().prototype.slice = function (e, t) {
  return this.throwIfDisposed(), _s(this, e, t);
}, rt().prototype.softmax = function (e) {
  return this.throwIfDisposed(), si(this, e);
}, rt().prototype.softplus = function () {
  return this.throwIfDisposed(), Pr(this);
}, rt().prototype.spaceToBatchND = function (e, t) {
  return this.throwIfDisposed(), ka(this, e, t);
}, rt().prototype.split = function (e, t) {
  return this.throwIfDisposed(), oi(this, e, t);
}, rt().prototype.sqrt = function () {
  return this.throwIfDisposed(), ui(this);
}, rt().prototype.square = function () {
  return this.throwIfDisposed(), ga(this);
}, rt().prototype.squaredDifference = function (e) {
  return this.throwIfDisposed(), ci(this, e);
}, rt().prototype.squeeze = function (e) {
  return this.throwIfDisposed(), hi(this, e);
}, rt().prototype.stack = function (e, t) {
  this.throwIfDisposed();
  var n = e instanceof st ? [this, e] : [this, ...e];
  return di(n, t);
}, rt().prototype.step = function (e) {
  return this.throwIfDisposed(), pi(this, e);
}, rt().prototype.stridedSlice = function (e, t, n, s, r, a, i, o) {
  return this.throwIfDisposed(), fi(this, e, t, n, s, r, a, i, o);
}, rt().prototype.sub = function (e) {
  return this.throwIfDisposed(), Vr(this, e);
}, rt().prototype.sum = function (e, t) {
  return this.throwIfDisposed(), Gr(this, e, t);
}, rt().prototype.tan = function () {
  return this.throwIfDisposed(), gi(this);
}, rt().prototype.tanh = function () {
  return this.throwIfDisposed(), Os(this);
}, rt().prototype.tile = function (e) {
  return this.throwIfDisposed(), wr(this, e);
}, rt().prototype.toBool = function () {
  return this.throwIfDisposed(), pn(this, "bool");
}, rt().prototype.toFloat = function () {
  return this.throwIfDisposed(), pn(this, "float32");
}, rt().prototype.toInt = function () {
  return this.throwIfDisposed(), pn(this, "int32");
}, rt().prototype.topk = function (e, t) {
  return this.throwIfDisposed(), xi(this, e, t);
}, rt().prototype.transpose = function (e) {
  return this.throwIfDisposed(), $n(this, e);
}, rt().prototype.unique = function (e) {
  return this.throwIfDisposed(), ki(this, e);
}, rt().prototype.unsortedSegmentSum = function (e, t) {
  return this.throwIfDisposed(), wi(this, e, t);
}, rt().prototype.unstack = function (e) {
  return this.throwIfDisposed(), vi(this, e);
}, rt().prototype.where = function (e, t) {
  return this.throwIfDisposed(), dr(e, this, t);
}, rt().prototype.zerosLike = function () {
  return this.throwIfDisposed(), pr(this);
};

class gu extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, gu.prototype);
  }

}

class mu extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, mu.prototype);
  }

}

class bu extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, bu.prototype);
  }

}

class xu extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, xu.prototype);
  }

}

class yu extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, yu.prototype);
  }

}

function ku(e, t) {
  if (Array.isArray(e)) {
    var _n50 = [];

    for (var _s52 = 0; _s52 < t; _s52++) {
      _n50 = _n50.concat(e);
    }

    return _n50;
  }

  {
    var _n51 = new Array(t);

    return _n51.fill(e), _n51;
  }
}

function wu(e, t) {
  if (!e) throw new yu(t);
}

function vu(e, t) {
  var n = 0;

  for (var _s53 of e) {
    _s53 === t && n++;
  }

  return n;
}

function Iu(e) {
  return 1 === e.length ? e[0] : e;
}

function $u(e) {
  return Array.isArray(e) ? e : [e];
}

function Nu(e) {
  var t = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  return "_" !== t[0] ? t : "private" + t;
}

function Cu(e) {
  return e.length <= 1 || -1 === e.indexOf("_") ? e : e.replace(/[_]+(\w|$)/g, (e, t) => t.toUpperCase());
}

var Su = {};

function Tu(e) {
  if (null == e) return null;
  var t = {};
  return t.className = e.getClassName(), t.config = e.getConfig(), t;
}

function Eu(e) {
  if (null != e && "object" == typeof e) if (Array.isArray(e)) e.forEach(e => Eu(e));else {
    var _t85 = Object.keys(e);

    for (var _n52 of _t85) {
      var _t86 = e[_n52];
      null != _t86 && "object" == typeof _t86 && (Array.isArray(_t86) || "ndarray" !== _t86.type || "number" != typeof _t86.value ? Eu(_t86) : e[_n52] = _t86.value);
    }
  }
}

function Ru(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "object";
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;

  if ("string" == typeof e) {
    var _r38 = e;

    var _a29;

    if (_r38 in n) _a29 = n[_r38];else if (_r38 in Su) _a29 = Su[_r38];else if (_a29 = t[_r38], null == _a29) throw new bu("Unknown ".concat(s, ": ").concat(e, ". This may be due to one of the following reasons:\n1. The ").concat(s, " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ").concat(s, " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."));
    return _a29;
  }

  {
    var _a30 = e;
    if (null == _a30.className || null == _a30.config) throw new bu("".concat(s, ": Improper config format: ").concat(JSON.stringify(_a30), ".\n'className' and 'config' must set."));
    var _i18 = _a30.className;

    var _o15, _l9;

    if (_i18 in n ? [_o15, _l9] = n[_i18] : _i18 in Su ? [_o15, _l9] = Su.className : _i18 in t && ([_o15, _l9] = t[_i18]), null == _o15) throw new bu("Unknown ".concat(s, ": ").concat(_i18, ". This may be due to one of the following reasons:\n1. The ").concat(s, " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ").concat(s, " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."));

    if (null != _l9) {
      var _e90 = {};

      for (var _t88 of Object.keys(Su)) {
        _e90[_t88] = Su[_t88];
      }

      for (var _t89 of Object.keys(n)) {
        _e90[_t89] = n[_t89];
      }

      _a30.config.customObjects = _e90;

      var _t87 = Object.assign({}, Su);

      for (var _e91 of Object.keys(n)) {
        Su[_e91] = n[_e91];
      }

      Eu(_a30.config);

      var _s54 = _l9(_o15, _a30.config, n, r);

      return Su = Object.assign({}, _t87), _s54;
    }

    {
      var _e92 = Object.assign({}, Su);

      for (var _e93 of Object.keys(n)) {
        Su[_e93] = n[_e93];
      }

      var _t90 = new _o15(_a30.config);

      return Su = Object.assign({}, _e92), _t90;
    }
  }
}

function Au(e, t) {
  return -1 * function (e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
  }(e, t);
}

function Fu(e) {
  if (null == e) return e;
  var t = [];

  for (var _n53 of e) {
    -1 === t.indexOf(_n53) && t.push(_n53);
  }

  return t;
}

function Du(e) {
  if (null == e) throw new bu("Invalid value in obj: ".concat(JSON.stringify(e)));

  for (var _t91 in e) {
    if (e.hasOwnProperty(_t91)) return !1;
  }

  return !0;
}

function _u(e, t, n) {
  if (null != n && e.indexOf(n) < 0) throw new bu("".concat(n, " is not a valid ").concat(t, ".  Valid values are ").concat(e, " or null/undefined."));
}

function Ou(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
  return wu(n >= 0), wu(s >= n), Array.isArray(e) && e.length >= n && e.length <= s && e.every(e => typeof e === t);
}

function Mu(e, t) {
  Array.isArray(e) ? (l(e.length > 0, () => "".concat(t, " is unexpectedly an empty array.")), e.forEach((e, n) => Mu(e, "element ".concat(n + 1, " of ").concat(t)))) : l(Number.isInteger(e) && e > 0, () => "Expected ".concat(t, " to be a positive integer, but got ").concat(Lu(e), "."));
}

function Lu(e) {
  return null === e ? "null" : Array.isArray(e) ? "[" + e.map(e => Lu(e)).join(",") + "]" : "string" == typeof e ? "\"".concat(e, "\"") : "".concat(e);
}

function zu(e) {
  return "relu" === e ? "relu" : "linear" === e ? "linear" : "elu" === e ? "elu" : null;
}

function Bu(e, t) {
  return Yn(() => ui(Gr(ss(e, e), t, !0)));
}

class Pu extends Hn {
  getConfig() {
    return {};
  }

}

class Wu extends Pu {
  constructor(e) {
    super(), this.defaultMaxValue = 2, this.defaultAxis = 0, this.maxValue = null != e.maxValue ? e.maxValue : this.defaultMaxValue, this.axis = null != e.axis ? e.axis : this.defaultAxis;
  }

  apply(e) {
    return Yn(() => {
      var t = Bu(e, this.axis),
          n = Gs(t, 0, this.maxValue);
      return ss(e, ns(n, es(fu(), t)));
    });
  }

  getConfig() {
    return {
      maxValue: this.maxValue,
      axis: this.axis
    };
  }

}

Wu.className = "MaxNorm", qn(Wu);

class Uu extends Pu {
  constructor(e) {
    super(), this.defaultAxis = 0, this.axis = null != e.axis ? e.axis : this.defaultAxis;
  }

  apply(e) {
    return Yn(() => ns(e, es(fu(), Bu(e, this.axis))));
  }

  getConfig() {
    return {
      axis: this.axis
    };
  }

}

Uu.className = "UnitNorm", qn(Uu);

class Vu extends Pu {
  apply(e) {
    return Ua(e);
  }

}

Vu.className = "NonNeg", qn(Vu);

class Gu extends Pu {
  constructor(e) {
    super(), this.defaultMinValue = 0, this.defaultMaxValue = 1, this.defaultRate = 1, this.defaultAxis = 0, this.minValue = null != e.minValue ? e.minValue : this.defaultMinValue, this.maxValue = null != e.maxValue ? e.maxValue : this.defaultMaxValue, this.rate = null != e.rate ? e.rate : this.defaultRate, this.axis = null != e.axis ? e.axis : this.defaultAxis;
  }

  apply(e) {
    return Yn(() => {
      var t = Bu(e, this.axis),
          n = es(ss(this.rate, Gs(t, this.minValue, this.maxValue)), ss(1 - this.rate, t));
      return ss(e, ns(n, es(fu(), t)));
    });
  }

  getConfig() {
    return {
      minValue: this.minValue,
      maxValue: this.maxValue,
      rate: this.rate,
      axis: this.axis
    };
  }

}

Gu.className = "MinMaxNorm", qn(Gu);
var Hu = {
  maxNorm: "MaxNorm",
  minMaxNorm: "MinMaxNorm",
  nonNeg: "NonNeg",
  unitNorm: "UnitNorm"
};

function ju(e) {
  return Tu(e);
}

function qu(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Ru(e, jn.getMap().classNameMap, t, "constraint");
}

function Ku(e) {
  return null == e ? null : "string" == typeof e ? qu({
    className: e in Hu ? Hu[e] : e,
    config: {}
  }) : e instanceof Pu ? e : qu(e);
}

var Xu = ["channelsFirst", "channelsLast"],
    Yu = ["nearest", "bilinear"],
    Ju = ["valid", "same", "causal"],
    Zu = ["max", "avg"],
    Qu = ["sum", "mul", "concat", "ave"],
    ec = new Map();

function tc(e) {
  _u(Xu, "DataFormat", e);
}

function nc(e) {
  _u(Ju, "PaddingMode", e);
}

function sc(e) {
  _u(Zu, "PoolMode", e);
}

var rc = [];

function ac(e, t) {
  rc.push(e);

  try {
    var _e94 = t();

    return rc.pop(), _e94;
  } catch (e) {
    throw rc.pop(), e;
  }
}

function ic(e) {
  if (!uc(e)) throw new Error("Not a valid tensor name: '" + e + "'");
  return (0 === rc.length ? "" : rc.join("/") + "/") + e;
}

function oc(e) {
  if (!uc(e)) throw new Error("Not a valid tensor name: '" + e + "'");
  ec.has(e) || ec.set(e, 0);
  var t = ec.get(e);

  if (ec.set(e, ec.get(e) + 1), t > 0) {
    var _n54 = "".concat(e, "_").concat(t);

    return ec.set(_n54, 1), _n54;
  }

  return e;
}

var lc = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);

function uc(e) {
  return !!e.match(lc);
}

function cc(e, t, n) {
  null == t && (t = 0), null == n && (n = e.length);
  var s = 1;

  for (var _r39 = t; _r39 < n; ++_r39) {
    s *= e[_r39];
  }

  return s;
}

function hc(e) {
  if (0 === e.length) return Number.NaN;
  var t = Number.POSITIVE_INFINITY;

  for (var _n55 = 0; _n55 < e.length; _n55++) {
    var _s55 = e[_n55];
    _s55 < t && (t = _s55);
  }

  return t;
}

function dc(e) {
  if (0 === e.length) return Number.NaN;
  var t = Number.NEGATIVE_INFINITY;

  for (var _n56 = 0; _n56 < e.length; _n56++) {
    var _s56 = e[_n56];
    _s56 > t && (t = _s56);
  }

  return t;
}

function pc(e, t) {
  if (t < e) throw new bu("end (".concat(t, ") < begin (").concat(e, ") is forbidden."));
  var n = [];

  for (var _s57 = e; _s57 < t; ++_s57) {
    n.push(_s57);
  }

  return n;
}

function fc(e, t) {
  return pn(e, t);
}

function gc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
  var n = e.shape.slice();
  return t < 0 && (t = n.length + t + 1), n.splice(t, 0, 1), Es(e, n);
}

function mc(e, t, n) {
  return Yn(() => {
    switch (e.rank) {
      case 1:
        return Qa(e, t, n);

      case 2:
        return ei(e, [t, 0], [n, e.shape[1]]);

      case 3:
        return ti(e, [t, 0, 0], [n, e.shape[1], e.shape[2]]);

      case 4:
        return ni(e, [t, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3]]);

      case 5:
        return _s(e, [t, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);

      case 6:
        return _s(e, [t, 0, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);

      default:
        throw new bu("sliceAlongFirstAxis() received an unsupported tensor rank: ".concat(e.rank));
    }
  });
}

function bc(e, t, n) {
  return Yn(() => {
    switch (e.rank) {
      case 1:
        return Qa(e, t, n);

      case 2:
        return ei(e, [0, t], [e.shape[0], n]);

      case 3:
        return ti(e, [0, 0, t], [e.shape[0], e.shape[1], n]);

      case 4:
        return ni(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n]);

      default:
        throw new bu("sliceAlongLastAxis() received an unsupported tensor rank: ".concat(e.rank));
    }
  });
}

function xc(e, t, n, s) {
  return Yn(() => {
    switch (e.rank) {
      case 1:
        return Qa(e, t, n);

      case 2:
        switch (s) {
          case 1:
            return mc(e, t, n);

          case 2:
            return bc(e, t, n);

          default:
            throw new bu("The axis is not within the rank of the tensor ".concat(s));
        }

      case 3:
        switch (s) {
          case 1:
            return mc(e, t, n);

          case 2:
            return ti(e, [0, t, 0], [e.shape[0], n, e.shape[2]]);

          case 3:
            return bc(e, t, n);

          default:
            throw new bu("The axis is not within the rank of the tensor ".concat(s));
        }

      case 4:
        switch (s) {
          case 1:
            return mc(e, t, n);

          case 2:
            return ni(e, [0, t, 0, 0], [e.shape[0], n, e.shape[2], e.shape[3]]);

          case 3:
            return ni(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n, e.shape[3]]);

          case 4:
            return bc(e, t, n);

          default:
            throw new bu("The axis is not within the rank of the tensor ".concat(s));
        }

      default:
        throw new bu("sliceAlongLastAxis() received an unsupported tensor rank: ".concat(e.rank));
    }
  });
}

function yc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
  var n;
  return t < 0 && (n = e[0].rank, t = 0 !== n ? n : 0), t === e[0].rank && (t = -1), Fs(e, t);
}

function kc(e, t) {
  switch (e.rank) {
    case 1:
      return Hs([e, t]);

    case 2:
      return js([e, t], 0);

    case 3:
      return qs([e, t], 0);

    case 4:
      return Ks([e, t], 0);

    default:
      throw new bu("concatAlongFirstAxis() received an unsupported tensor rank: ".concat(e.rank));
  }
}

function wc(e, t) {
  if (Array.isArray(t) || (t = [t]), e.rank !== t.length) throw new bu("The length of input n (".concat(t.length, ") does not match the number of dimensions in input x (").concat(e.rank, ")"));
  return wr(e, t);
}

function vc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var s = arguments.length > 3 ? arguments[3] : undefined;
  var r = arguments.length > 4 ? arguments[4] : undefined;
  return La(e, t, n, s, r);
}

function Ic(e, t, n, s) {
  if (e.rank < 2 || t.rank < 2) throw new xu("dot requires both inputs to be rank >= 2 but got x shape = ".concat(e.shape, " and y shape = ").concat(t.shape));
  if (t.rank >= 3 && e.shape.slice(-1)[0] !== t.shape.slice(-2)[0]) throw new xu("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ".concat(e.shape, " and  y shape = ").concat(t.shape));
  if (2 === e.rank && 2 === t.rank) return Mi({
    a: e,
    b: t,
    transposeA: !1,
    transposeB: !1,
    bias: s ? Cc(e.rank, s, "channelsLast") : null,
    activation: n
  });
  {
    var _r40 = e.shape.slice(),
        _a31 = _r40.pop();

    e = Es(e, [-1, _a31]);

    var _i19 = t.shape.slice(),
        _o16 = _i19.pop(),
        _l10 = _i19.pop(),
        _u6 = [..._i19, _o16],
        _c5 = Array.from({
      length: t.rank
    }, (e, n) => 0 === n ? t.rank - 2 : n <= t.rank - 2 ? n - 1 : n);

    t = Es($n(t, _c5), [_l10, -1]);
    var _h4 = [..._r40, ..._u6];
    return Es(Mi({
      a: e,
      b: t,
      transposeA: !1,
      transposeB: !1,
      bias: s ? Cc(e.rank, s, "channelsLast") : null,
      activation: n
    }), _h4);
  }
}

function $c(e, t, n) {
  return Yn(() => (t = Array.isArray(t) ? mi(t, "int32") : pn(t, "int32"), Nr(e, t, n)));
}

function Nc(e) {
  return ss(e, e);
}

function Cc(e, t, n) {
  var s = t.shape;
  if (1 !== t.rank && t.rank !== e) throw new bu("Unexpected bias dimensions: ".concat(t.rank, "; expected it to be 1 or ").concat(e));

  if (5 === e) {
    if ("channelsFirst" === n) return Es(t, 1 === s.length ? [1, s[0], 1, 1, 1] : [1, s[3], s[0], s[1], s[2]]);
    if ("channelsLast" === n) return Es(t, 1 === s.length ? [1, 1, 1, 1, s[0]] : [1].concat(s));
  } else if (4 === e) {
    if ("channelsFirst" === n) return Es(t, 1 === s.length ? [1, s[0], 1, 1] : [1, s[2], s[0], s[1]]);
    if ("channelsLast" === n) return Es(t, 1 === s.length ? [1, 1, 1, s[0]] : [1].concat(s));
  } else if (3 === e) {
    if ("channelsFirst" === n) return Es(t, 1 === s.length ? [1, s[0], 1] : [1, s[1], s[0]]);
    if ("channelsLast" === n) return Es(t, 1 === s.length ? [1, 1, s[0]] : [1].concat(s));
  } else if (e < 3) return t;

  throw new bu("Unsupported input rank by biasAdd: ".concat(t.rank));
}

function Sc(e, t, n) {
  return Yn(() => (null == n && (n = "channelsLast"), tc(n), es(e, Cc(e.rank, t, n))));
}

function Tc(e, t, n, s) {
  return Yn(() => Ci(e, t, n, s));
}

function Ec(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return n ? e() : t();
}

var Rc = ["fanIn", "fanOut", "fanAvg"],
    Ac = ["normal", "uniform", "truncatedNormal"];

class Fc extends Hn {
  fromConfigUsesCustomObjects() {
    return !1;
  }

  getConfig() {
    return {};
  }

}

class Dc extends Fc {
  apply(e, t) {
    return ua(e, t);
  }

}

Dc.className = "Zeros", qn(Dc);

class _c extends Fc {
  apply(e, t) {
    return ca(e, t);
  }

}

_c.className = "Ones", qn(_c);

class Oc extends Fc {
  constructor(e) {
    if (super(), "object" != typeof e) throw new bu("Expected argument of type ConstantConfig but got ".concat(e));
    if (void 0 === e.value) throw new bu("config must have value set but got ".concat(e));
    this.value = e.value;
  }

  apply(e, t) {
    return Yn(() => ss(qa(this.value), ca(e, t)));
  }

  getConfig() {
    return {
      value: this.value
    };
  }

}

Oc.className = "Constant", qn(Oc);

class Mc extends Fc {
  constructor(e) {
    super(), this.DEFAULT_MINVAL = -.05, this.DEFAULT_MAXVAL = .05, this.minval = e.minval || this.DEFAULT_MINVAL, this.maxval = e.maxval || this.DEFAULT_MAXVAL, this.seed = e.seed;
  }

  apply(e, t) {
    return za(e, this.minval, this.maxval, t);
  }

  getConfig() {
    return {
      minval: this.minval,
      maxval: this.maxval,
      seed: this.seed
    };
  }

}

Mc.className = "RandomUniform", qn(Mc);

class Lc extends Fc {
  constructor(e) {
    super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = .05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed;
  }

  apply(e, t) {
    if ("float32" !== (t = t || "float32") && "int32" !== t) throw new xu("randomNormal does not support dType ".concat(t, "."));
    return vc(e, this.mean, this.stddev, t, this.seed);
  }

  getConfig() {
    return {
      mean: this.mean,
      stddev: this.stddev,
      seed: this.seed
    };
  }

}

Lc.className = "RandomNormal", qn(Lc);

class zc extends Fc {
  constructor(e) {
    super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = .05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed;
  }

  apply(e, t) {
    if ("float32" !== (t = t || "float32") && "int32" !== t) throw new xu("truncatedNormal does not support dType ".concat(t, "."));
    return yi(e, this.mean, this.stddev, t, this.seed);
  }

  getConfig() {
    return {
      mean: this.mean,
      stddev: this.stddev,
      seed: this.seed
    };
  }

}

zc.className = "TruncatedNormal", qn(zc);

class Bc extends Fc {
  constructor(e) {
    super(), this.gain = null != e.gain ? e.gain : 1;
  }

  apply(e, t) {
    return Yn(() => {
      if (2 !== e.length || e[0] !== e[1]) throw new bu("Identity matrix initializer can only be used for 2D square matrices.");
      return ss(this.gain, vr(e[0]));
    });
  }

  getConfig() {
    return {
      gain: this.gain
    };
  }

}

Bc.className = "Identity", qn(Bc);

class Pc extends Fc {
  constructor(e) {
    if (super(), e.scale < 0) throw new bu("scale must be a positive float. Got: ".concat(e.scale));
    this.scale = null == e.scale ? 1 : e.scale, this.mode = null == e.mode ? "fanIn" : e.mode, _u(Rc, "FanMode", this.mode), this.distribution = null == e.distribution ? "normal" : e.distribution, _u(Ac, "Distribution", this.distribution), this.seed = e.seed;
  }

  apply(e, t) {
    var n = function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "channelsLast";
      var n, s;
      if (tc(t), 2 === e.length) n = e[0], s = e[1];else if (-1 !== [3, 4, 5].indexOf(e.length)) {
        if ("channelsFirst" === t) {
          var _t92 = cc(e, 2);

          n = e[1] * _t92, s = e[0] * _t92;
        } else if ("channelsLast" === t) {
          var _t93 = cc(e, 0, e.length - 2);

          n = e[e.length - 2] * _t93, s = e[e.length - 1] * _t93;
        }
      } else {
        var _t94 = cc(e);

        n = Math.sqrt(_t94), s = Math.sqrt(_t94);
      }
      return [n, s];
    }(e),
        s = n[0],
        r = n[1];

    var a = this.scale;

    if (a /= "fanIn" === this.mode ? Math.max(1, s) : "fanOut" === this.mode ? Math.max(1, r) : Math.max(1, (s + r) / 2), "normal" === this.distribution) {
      var _n57 = Math.sqrt(a);

      if ("float32" !== (t = t || "float32") && "int32" !== t) throw new xu("".concat(this.getClassName(), " does not support dType ").concat(t, "."));
      return yi(e, 0, _n57, t, this.seed);
    }

    {
      var _n58 = Math.sqrt(3 * a);

      return za(e, -_n58, _n58, t);
    }
  }

  getConfig() {
    return {
      scale: this.scale,
      mode: this.mode,
      distribution: this.distribution,
      seed: this.seed
    };
  }

}

Pc.className = "VarianceScaling", qn(Pc);

class Wc extends Pc {
  constructor(e) {
    super({
      scale: 1,
      mode: "fanAvg",
      distribution: "uniform",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Pc.className;
  }

}

Wc.className = "GlorotUniform", qn(Wc);

class Uc extends Pc {
  constructor(e) {
    super({
      scale: 1,
      mode: "fanAvg",
      distribution: "normal",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Pc.className;
  }

}

Uc.className = "GlorotNormal", qn(Uc);

class Vc extends Pc {
  constructor(e) {
    super({
      scale: 2,
      mode: "fanIn",
      distribution: "normal",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Pc.className;
  }

}

Vc.className = "HeNormal", qn(Vc);

class Gc extends Pc {
  constructor(e) {
    super({
      scale: 2,
      mode: "fanIn",
      distribution: "uniform",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Pc.className;
  }

}

Gc.className = "HeUniform", qn(Gc);

class Hc extends Pc {
  constructor(e) {
    super({
      scale: 1,
      mode: "fanIn",
      distribution: "normal",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Pc.className;
  }

}

Hc.className = "LeCunNormal", qn(Hc);

class jc extends Pc {
  constructor(e) {
    super({
      scale: 1,
      mode: "fanIn",
      distribution: "uniform",
      seed: null == e ? null : e.seed
    });
  }

  getClassName() {
    return Pc.className;
  }

}

jc.className = "LeCunNormal", qn(jc);

class qc extends Fc {
  constructor(e) {
    if (super(), this.DEFAULT_GAIN = 1, this.gain = null == e.gain ? this.DEFAULT_GAIN : e.gain, this.seed = e.seed, null != this.seed) throw new xu("Random seed is not implemented for Orthogonal Initializer yet.");
  }

  apply(e, t) {
    return Yn(() => {
      if (e.length < 2) throw new xu("Shape must be at least 2D.");
      e[0] * e[1] > 2e3 && console.warn("Orthogonal initializer is being called on a matrix with more than 2000 (".concat(e[0] * e[1], ") elements: Slowness may result."));
      var t = vc(e[0] > e[1] ? [e[1], e[0]] : e, 0, 1, "float32");
      var n = po.gramSchmidt(t);
      return e[0] > e[1] && (n = $n(n)), ss(this.gain, n);
    });
  }

  getConfig() {
    return {
      gain: this.gain,
      seed: this.seed
    };
  }

}

qc.className = "Orthogonal", qn(qc);
var Kc = {
  constant: "Constant",
  glorotNormal: "GlorotNormal",
  glorotUniform: "GlorotUniform",
  heNormal: "HeNormal",
  heUniform: "HeUniform",
  identity: "Identity",
  leCunNormal: "LeCunNormal",
  leCunUniform: "LeCunUniform",
  ones: "Ones",
  orthogonal: "Orthogonal",
  randomNormal: "RandomNormal",
  randomUniform: "RandomUniform",
  truncatedNormal: "TruncatedNormal",
  varianceScaling: "VarianceScaling",
  zeros: "Zeros"
};

function Xc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Ru(e, jn.getMap().classNameMap, t, "initializer");
}

function Yc(e) {
  return Tu(e);
}

function Jc(e) {
  if ("string" == typeof e) {
    var _t95 = e in Kc ? Kc[e] : e;

    if ("GlorotNormal" === _t95) return new Uc();
    if ("GlorotUniform" === _t95) return new Wc();
    if ("HeNormal" === _t95) return new Vc();
    if ("HeUniform" === _t95) return new Gc();
    if ("LeCunNormal" === _t95) return new Hc();
    if ("LeCunUniform" === _t95) return new jc();
    {
      var _e95 = {};
      return _e95.className = _t95, _e95.config = {}, Xc(_e95);
    }
  }

  return e instanceof Fc ? e : Xc(e);
}

var Zc = 0;

function Qc() {
  return Zc++;
}

var eh = {};

function th() {
  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  return e in eh || (eh[e] = 0), eh[e] += 1, e + eh[e].toString();
}

function nh(e) {
  return Array.isArray(e) && Array.isArray(e[0]);
}

function sh(e) {
  return 0 === e.length ? [] : Array.isArray(e[0]) ? e : [e];
}

function rh(e) {
  var t;

  if (Array.isArray(e)) {
    if (1 !== e.length) throw new bu("Expected Tensor length to be 1; got ".concat(e.length));
    t = e[0];
  } else t = e;

  return t;
}

function ah(e) {
  if (Array.isArray(e) && Array.isArray(e[0])) {
    if (1 === e.length) return (e = e)[0];
    throw new bu("Expected exactly 1 Shape; got ".concat(e.length));
  }

  return e;
}

function ih(e) {
  var t = 0;

  for (var _n59 of e) {
    t += 0 === _n59.shape.length ? 1 : _n59.shape.reduce((e, t) => e * t);
  }

  return t;
}

class oh {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Variable";
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    this.dtype = null == t ? "float32" : t, this.shape = e.shape, this.id = Qc(), this.originalName = ic(n = null == n ? "Variable" : n), this.name = oc(this.originalName), this.trainable_ = s, this.constraint = r, this.val = function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var n = arguments.length > 2 ? arguments[2] : undefined;
      var s = arguments.length > 3 ? arguments[3] : undefined;
      return wt.makeVariable(e, t, n, s);
    }(e, this.trainable_, this.name, this.dtype);
  }

  read() {
    return this.assertNotDisposed(), this.val;
  }

  write(e) {
    return this.assertNotDisposed(), function (e, t) {
      if (e.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape));
    }(this.val, e), this.val.id !== e.id && (this.val.assign(e), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this;
  }

  dispose() {
    this.assertNotDisposed(), this.val.dispose();
  }

  assertNotDisposed() {
    if (this.val.isDisposed) throw new Error("LayersVariable ".concat(this.name, " is already disposed."));
  }

  get trainable() {
    return this.trainable_;
  }

  set trainable(e) {
    this.trainable_ = e, this.val.trainable = e;
  }

}

function lh(e) {
  return e.map(e => e.read());
}

function uh(e) {
  e.forEach(e => {
    e[0].write(e[1]);
  });
}

class ch {
  constructor(e) {
    this.dtype = e.dtype, this.shape = e.shape, this.ndim = null != e.shape ? e.shape.length : e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {};
  }

}

class hh {
  constructor(e, t, n, s, r, a, i) {
    this.dtype = e, this.shape = t, this.sourceLayer = n, this.inputs = s, this.callArgs = r, this.outputTensorIndex = i, this.id = Qc(), null != a && (this.originalName = ic(a), this.name = oc(this.originalName)), this.rank = t.length;
  }

}

var dh = 0;

class ph {
  constructor(e, t) {
    this.callArgs = t, this.id = dh++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;

    for (var _t96 of e.inboundLayers) {
      null != _t96 && _t96.outboundNodes.push(this);
    }

    e.outboundLayer.inboundNodes.push(this);
  }

  getConfig() {
    var e = [];

    for (var _t97 of this.inboundLayers) {
      e.push(null != _t97 ? _t97.name : null);
    }

    return {
      outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
      inboundLayers: e,
      nodeIndices: this.nodeIndices,
      tensorIndices: this.tensorIndices
    };
  }

}

var fh = 0;

class gh extends Hn {
  constructor() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(), this._callHook = null, this._addedWeightNames = [], this._stateful = !1, this.id = fh++, this.activityRegularizer = null, this.inputSpec = null, this.supportsMasking = !1, this._trainableWeights = [], this._nonTrainableWeights = [], this._losses = [], this._updates = [], this._built = !1, this.inboundNodes = [], this.outboundNodes = [];
    var t = e.name;

    if (!t) {
      var _e96 = this.getClassName();

      t = Nu(_e96) + "_" + th(_e96);
    }

    if (this.name = t, this.trainable_ = null == e.trainable || e.trainable, null != e.inputShape || null != e.batchInputShape) {
      var _t98;

      if (null != e.batchInputShape) _t98 = e.batchInputShape;else if (null != e.inputShape) {
        var _n61 = null;
        null != e.batchSize && (_n61 = e.batchSize), _t98 = [_n61].concat(e.inputShape);
      }
      this.batchInputShape = _t98;
      var _n60 = e.dtype;
      null == _n60 && (_n60 = e.inputDType), null == _n60 && (_n60 = "float32"), this.dtype = _n60;
    }

    this.initialWeights = null != e.weights ? e.weights : null, this._refCount = null, this.fastWeightInitDuringBuild = !1;
  }

  static nodeKey(e, t) {
    return e.name + "_ib-" + t.toString();
  }

  getNodeAtIndex(e, t) {
    if (0 === this.inboundNodes.length) throw new mu("The layer has never been called and thus has no defined ".concat(t, "."));
    if (this.inboundNodes.length <= e) throw new bu("Asked to get ".concat(t, " at node ").concat(e, ", but the layer has only ").concat(this.inboundNodes.length, " inbound nodes."));
    return this.inboundNodes[e];
  }

  getInputAt(e) {
    return Iu(this.getNodeAtIndex(e, "input").inputTensors);
  }

  getOutputAt(e) {
    return Iu(this.getNodeAtIndex(e, "output").outputTensors);
  }

  get input() {
    if (this.inboundNodes.length > 1) throw new gu("Layer ".concat(this.name, " has multiple inbound nodes, hence the notion of \"layer input\" is ill-defined. Use `getInputAt(nodeIndex)` instead."));
    if (0 === this.inboundNodes.length) throw new gu("Layer ".concat(this.name, " is not connected, no input to return."));
    return Iu(this.getNodeAtIndex(0, "input").inputTensors);
  }

  get output() {
    if (0 === this.inboundNodes.length) throw new gu("Layer ".concat(this.name, " has no inbound nodes."));
    if (this.inboundNodes.length > 1) throw new gu("Layer ".concat(this.name, " has multiple inbound nodes, hence the notion of \"layer output\" is ill-defined. Use `getOutputAt(nodeIndex)` instead."));
    return Iu(this.getNodeAtIndex(0, "output").outputTensors);
  }

  get losses() {
    return this._losses;
  }

  calculateLosses() {
    return this.losses.map(e => e());
  }

  get updates() {
    return this._updates;
  }

  get built() {
    return this._built;
  }

  set built(e) {
    this._built = e;
  }

  get trainable() {
    return this.trainable_;
  }

  set trainable(e) {
    this._trainableWeights.forEach(t => t.trainable = e), this.trainable_ = e;
  }

  get trainableWeights() {
    return this.trainable_ ? this._trainableWeights.filter(e => e.trainable) : [];
  }

  set trainableWeights(e) {
    this._trainableWeights = e;
  }

  get nonTrainableWeights() {
    return this.trainable ? this._trainableWeights.filter(e => !e.trainable).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
  }

  set nonTrainableWeights(e) {
    this._nonTrainableWeights = e;
  }

  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }

  get stateful() {
    return this._stateful;
  }

  resetStates() {
    if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
  }

  assertInputCompatibility(e) {
    if (e = $u(e), null == this.inputSpec || 0 === this.inputSpec.length) return;
    var t = $u(this.inputSpec);
    if (e.length !== t.length) throw new bu("Layer ".concat(this.name, " expects ").concat(t.length, " inputs, but it received ").concat(e.length, " input tensors. Input received: ").concat(e));

    for (var _n62 = 0; _n62 < e.length; _n62++) {
      var _s58 = e[_n62],
          _r41 = t[_n62];
      if (null == _r41) continue;
      var _a32 = _s58.rank;
      if (null != _r41.ndim && _a32 !== _r41.ndim) throw new bu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, ": expected ndim=").concat(_r41.ndim, ", found ndim=").concat(_a32));
      if (null != _r41.maxNDim && _a32 > _r41.maxNDim) throw new bu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, ": expected max_ndim=").concat(_r41.maxNDim, ", found ndim=").concat(_a32));
      if (null != _r41.minNDim && _a32 < _r41.minNDim) throw new bu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, ": expected min_ndim=").concat(_r41.minNDim, ", found ndim=").concat(_a32, "."));
      if (null != _r41.dtype && _s58.dtype !== _r41.dtype) throw new bu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, " : expected dtype=").concat(_r41.dtype, ", found dtype=").concat(_s58.dtype, "."));

      if (_r41.axes) {
        var _e97 = _s58.shape;

        for (var _t99 in _r41.axes) {
          var _s59 = Number(_t99),
              _a33 = _r41.axes[_t99],
              _i20 = _s59 >= 0 ? _e97[_s59] : _e97[_e97.length + _s59];

          if (null != _a33 && -1 === [_a33, null].indexOf(_i20)) throw new bu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, ": expected axis ").concat(_s59, " of input shape to have value ").concat(_a33, " but got shape ").concat(_e97, "."));
        }
      }

      if (null != _r41.shape) for (var _e98 = 0; _e98 < _r41.shape.length; ++_e98) {
        var _t100 = _r41.shape[_e98],
            _a34 = _s58.shape[_e98];
        if (null != _t100 && null != _a34 && _t100 !== _a34) throw new bu("Input ".concat(_n62, " is incompatible with layer ").concat(this.name, ": expected shape=").concat(_r41.shape, ", found shape=").concat(_s58.shape, "."));
      }
    }
  }

  call(e, t) {
    return e;
  }

  invokeCallHook(e, t) {
    null != this._callHook && this._callHook(e, t);
  }

  setCallHook(e) {
    this._callHook = e;
  }

  clearCallHook() {
    this._callHook = null;
  }

  apply(e, t) {
    t = t || {}, this.assertNotDisposed();
    var n = $u(e);
    var s = !0;

    for (var _e99 of n) {
      if (!(_e99 instanceof hh)) {
        s = !1;
        break;
      }
    }

    var r = !0;

    for (var _e100 of n) {
      if (_e100 instanceof hh) {
        r = !1;
        break;
      }
    }

    if (s === r) throw new bu("Arguments to apply() must be all SymbolicTensors or all Tensors");
    return ac(this.name, () => {
      if (!this.built) {
        this.assertInputCompatibility(e);
        var _t101 = [];

        for (var _n63 of $u(e)) {
          _t101.push(_n63.shape);
        }

        this.build(Iu(_t101)), this.built = !0, this.initialWeights && this.setWeights(this.initialWeights), null === this._refCount && r && (this._refCount = 1);
      }

      if (this.assertInputCompatibility(e), r) {
        var _s60 = this.call(e, t);

        var _r42 = $u(_s60),
            _a35 = [];

        for (var _e101 of _r42) {
          -1 !== n.indexOf(_e101) && (_e101 = _e101.clone()), _a35.push(_e101);
        }

        if (_s60 = Iu(_a35), null != this.activityRegularizer) throw new xu("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return _s60;
      }

      {
        var _n64 = function (e) {
          e = $u(e);
          var t = [];

          for (var _n65 of e) {
            t.push(_n65.shape);
          }

          return Iu(t);
        }(e),
            _s61 = this.computeOutputShape(_n64);

        var _r43;

        var _a36 = "float32";
        if (this.warnOnIncompatibleInputShape(Array.isArray(e) ? _n64[0] : _n64), _r43 = null != _s61 && _s61.length > 0 && Array.isArray(_s61[0]) ? _s61.map((n, s) => new hh(_a36, n, this, $u(e), t, this.name, s)) : new hh(_a36, _s61, this, $u(e), t, this.name), this.addInboundNode(e, _r43, null, null, _n64, _s61, t), this._refCount++, null != this.activityRegularizer) throw new xu("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return _r43;
      }
    });
  }

  warnOnIncompatibleInputShape(e) {
    if (null != this.batchInputShape) if (e.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: ".concat(JSON.stringify(e), ") does not match that of the batchInputShape (").concat(JSON.stringify(this.batchInputShape), ") of the layer ").concat(this.name));else {
      var _t102 = !1;

      this.batchInputShape.forEach((n, s) => {
        null != n && null != e[s] && e[s] !== n && (_t102 = !0);
      }), _t102 && console.warn("The shape of the input tensor (".concat(JSON.stringify(e), ") does not match the expectation of layer ").concat(this.name, ": ").concat(JSON.stringify(this.batchInputShape)));
    }
  }

  get outputShape() {
    if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new gu("The layer ".concat(this.name, " has never been called and thus has no defined output shape."));
    var e = [];

    for (var _t103 of this.inboundNodes) {
      var _n66 = JSON.stringify(_t103.outputShapes);

      -1 === e.indexOf(_n66) && e.push(_n66);
    }

    if (1 === e.length) {
      var _e102 = this.inboundNodes[0].outputShapes;
      return Array.isArray(_e102) && Array.isArray(_e102[0]) && 1 === _e102.length ? _e102[0] : _e102;
    }

    throw new gu("The layer ".concat(this.name, " has multiple inbound nodes with different output shapes. Hence the notion of \"output shape\" is ill-defined for the layer."));
  }

  countParams() {
    if (!this.built) throw new mu("You tried to call countParams() on ".concat(this.name, ", but the layer is not built yet. Build it first by calling build(batchInputShape)."));
    return ih(this.weights);
  }

  build(e) {
    this.built = !0;
  }

  getWeights() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    return lh(e ? this.trainableWeights : this.weights);
  }

  setWeights(e) {
    Yn(() => {
      var t = this.weights;
      if (t.length !== e.length) throw new bu("You called setWeights(weights) on layer \"".concat(this.name, "\" with a weight list of length ").concat(e.length, ", but the layer was expecting ").concat(t.length, " weights. Provided weights: ").concat(e, "..."));
      if (0 === t.length) return;
      var n = [],
          s = lh(t);

      for (var _r44 = 0; _r44 < s.length; ++_r44) {
        var _a37 = s[_r44],
            _i21 = t[_r44],
            _o17 = e[_r44];
        if (!p(_a37.shape, _o17.shape)) throw new bu("Layer weight shape ".concat(_a37.shape, " not compatible with provided weight shape ").concat(_o17.shape));
        n.push([_i21, _o17]);
      }

      uh(n);
    });
  }

  addWeight(e, t, n, s, r, a, i) {
    if (-1 !== this._addedWeightNames.indexOf(e)) throw new bu("Duplicate weight name ".concat(e, " for layer ").concat(this.name));
    this._addedWeightNames.push(e), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (s = Jc("zeros"));
    var o = s.apply(t, n),
        l = new oh(o, n, e, a, i);
    return o.dispose(), null != r && this.addLoss(() => r.apply(l.read())), null == a && (a = !0), a ? this._trainableWeights.push(l) : this._nonTrainableWeights.push(l), l;
  }

  setFastWeightInitDuringBuild(e) {
    this.fastWeightInitDuringBuild = e;
  }

  addLoss(e) {
    null == e || Array.isArray(e) && 0 === e.length || (e = $u(e), null != this._losses && this.losses.push(...e));
  }

  computeOutputShape(e) {
    return e;
  }

  computeMask(e, t) {
    if (!this.supportsMasking) {
      if (null != t) {
        if (!Array.isArray(t)) throw new TypeError("Layer ".concat(this.name, " does not support masking, but was passed an inputMask."));
        t.forEach(e => {
          if (null != e) throw new TypeError("Layer ".concat(this.name, " does not support masking, but was passed an inputMask."));
        });
      }

      return null;
    }

    return t;
  }

  addInboundNode(e, t, n, s, r, a) {
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var o = $u(e);
    t = $u(t), n = $u(n), s = $u(s), r = sh(r), a = sh(a);
    var l = [],
        u = [],
        c = [];

    for (var _e103 of o) {
      l.push(_e103.sourceLayer), u.push(_e103.nodeIndex), c.push(_e103.tensorIndex);
    }

    new ph({
      outboundLayer: this,
      inboundLayers: l,
      nodeIndices: u,
      tensorIndices: c,
      inputTensors: o,
      outputTensors: t,
      inputMasks: n,
      outputMasks: s,
      inputShapes: r,
      outputShapes: a
    }, i);

    for (var _e104 = 0; _e104 < t.length; _e104++) {
      t[_e104].sourceLayer = this, t[_e104].nodeIndex = this.inboundNodes.length - 1, t[_e104].tensorIndex = _e104;
    }
  }

  getConfig() {
    var e = {
      name: this.name,
      trainable: this.trainable
    };
    return null != this.batchInputShape && (e.batchInputShape = this.batchInputShape), null != this.dtype && (e.dtype = this.dtype), e;
  }

  disposeWeights() {
    return this.weights.forEach(e => e.dispose()), this.weights.length;
  }

  assertNotDisposed() {
    if (0 === this._refCount) throw new Error("Layer '".concat(this.name, "' is already disposed."));
  }

  dispose() {
    if (!this.built) throw new Error("Cannot dispose Layer ".concat(this.name, " because it has not been built yet."));
    if (null === this._refCount) throw new Error("Cannot dispose Layer ".concat(this.name, " because it has not been used yet."));
    this.assertNotDisposed();
    var e = 0;
    return 0 == --this._refCount && (e = this.disposeWeights()), {
      refCountAfterDispose: this._refCount,
      numDisposedVariables: e
    };
  }

}

function mh(e, t, n) {
  if ((null == t || null != n && n > 0) && (t = e.sourceLayer, n = e.nodeIndex), 0 === t.inboundNodes.length) return [e];
  {
    var _e105 = t.inboundNodes[n];
    if (0 === _e105.inboundLayers.length) return _e105.inputTensors;
    {
      var _t104 = [];

      for (var _n67 = 0; _n67 < _e105.inboundLayers.length; _n67++) {
        var _s62 = mh(_e105.inputTensors[_n67], _e105.inboundLayers[_n67], _e105.nodeIndices[_n67]);

        for (var _e106 of _s62) {
          -1 === _t104.indexOf(_e106) && _t104.push(_e106);
        }
      }

      return _t104;
    }
  }
}

class bh extends gh {
  constructor(e) {
    if (super({
      dtype: e.dtype,
      name: null != e.name ? e.name : th("input").toString()
    }), null == e.batchSize && (e.batchSize = null), null == e.sparse && (e.sparse = !1), this.trainable = !1, this.built = !0, this.sparse = e.sparse, null != e.inputShape && null != e.batchInputShape) throw new bu("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
    var t = e.batchInputShape;

    if (null == t) {
      if (null == e.inputShape) throw new bu("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
      t = [e.batchSize].concat(e.inputShape);
    } else if (null != e.batchSize) throw new bu("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");

    var n = e.dtype || "float32";
    this.batchInputShape = t, this.dtype = n, this.inputSpec = [{
      shape: t
    }];
    var s = new hh(this.dtype, this.batchInputShape, this, [], {}, this.name);
    s.nodeIndex = 0, s.tensorIndex = 0, new ph({
      outboundLayer: this,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: [s],
      outputTensors: [s],
      inputMasks: [null],
      outputMasks: [null],
      inputShapes: [t],
      outputShapes: [t]
    });
  }

  apply(e, t) {
    throw new bu("Cannot pass any input to an InputLayer's apply() method. InputLayer name: ".concat(this.name));
  }

  dispose() {
    return {
      refCountAfterDispose: this._refCount,
      numDisposedVariables: 0
    };
  }

  getConfig() {
    return {
      batchInputShape: this.batchInputShape,
      dtype: this.dtype,
      sparse: this.sparse,
      name: this.name
    };
  }

}

function xh(_x19) {
  return _xh.apply(this, arguments);
}

function _xh() {
  _xh = _asyncToGenerator(function* (e) {
    if (null == e) return;
    var t = [],
        n = [],
        s = [];

    for (var _r174 in e) {
      var _a147 = e[_r174];

      if ("number" != typeof _a147) {
        var _e527 = _a147;
        t.push(_e527.data()), n.push(_r174), s.push(_e527);
      }
    }

    if (t.length > 0) {
      var _r175 = yield Promise.all(t);

      for (var _t426 = 0; _t426 < _r175.length; ++_t426) {
        e[n[_t426]] = _r175[_t426][0];
      }

      Jn(s);
    }
  });
  return _xh.apply(this, arguments);
}

function yh(e) {
  if (null != e) for (var _t105 in e) {
    var _n68 = e[_t105];
    "number" != typeof _n68 && _n68.dispose();
  }
}

var kh;
bh.className = "InputLayer", qn(bh), function (e) {
  e[e.SILENT = 0] = "SILENT", e[e.VERBOSE = 1] = "VERBOSE";
}(kh || (kh = {}));

class wh {
  constructor() {
    this.validationData = null;
  }

  setParams(e) {
    this.params = e;
  }

  onEpochBegin(e, t) {
    return _asyncToGenerator(function* () {})();
  }

  onEpochEnd(e, t) {
    return _asyncToGenerator(function* () {})();
  }

  onBatchBegin(e, t) {
    return _asyncToGenerator(function* () {})();
  }

  onBatchEnd(e, t) {
    return _asyncToGenerator(function* () {})();
  }

  onTrainBegin(e) {
    return _asyncToGenerator(function* () {})();
  }

  onTrainEnd(e) {
    return _asyncToGenerator(function* () {})();
  }

  setModel(e) {}

}

class vh {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    null == e && (e = []), this.callbacks = e, this.queueLength = t;
  }

  append(e) {
    this.callbacks.push(e);
  }

  setParams(e) {
    for (var _t106 of this.callbacks) {
      _t106.setParams(e);
    }
  }

  setModel(e) {
    for (var _t107 of this.callbacks) {
      _t107.setModel(e);
    }
  }

  onEpochBegin(e, t) {
    var _this38 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {});

      for (var _n69 of _this38.callbacks) {
        yield _n69.onEpochBegin(e, t);
      }
    })();
  }

  onEpochEnd(e, t) {
    var _this39 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {});

      for (var _n70 of _this39.callbacks) {
        yield _n70.onEpochEnd(e, t);
      }
    })();
  }

  onBatchBegin(e, t) {
    var _this40 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {});

      for (var _n71 of _this40.callbacks) {
        yield _n71.onBatchBegin(e, t);
      }
    })();
  }

  onBatchEnd(e, t) {
    var _this41 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {});

      for (var _n72 of _this41.callbacks) {
        yield _n72.onBatchEnd(e, t);
      }
    })();
  }

  onTrainBegin(e) {
    var _this42 = this;

    return _asyncToGenerator(function* () {
      null == e && (e = {});

      for (var _t108 of _this42.callbacks) {
        yield _t108.onTrainBegin(e);
      }
    })();
  }

  onTrainEnd(e) {
    var _this43 = this;

    return _asyncToGenerator(function* () {
      null == e && (e = {});

      for (var _t109 of _this43.callbacks) {
        yield _t109.onTrainEnd(e);
      }
    })();
  }

}

class Ih extends wh {
  constructor() {
    super();
  }

  onEpochBegin(e) {
    var _this44 = this;

    return _asyncToGenerator(function* () {
      _this44.seen = 0, _this44.totals = {};
    })();
  }

  onBatchEnd(e, t) {
    var _this45 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {});
      var n = null == t.size ? 0 : t.size;
      _this45.seen += n;

      var _loop12 = function _loop12(_e107) {
        var s = t[_e107];
        if ("number" == typeof s) _this45.totals.hasOwnProperty(_e107) || (_this45.totals[_e107] = 0), _this45.totals[_e107] = _this45.totals[_e107] + s * n;else {
          var _t110;

          _e107 in _this45.totals ? _t110 = _this45.totals[_e107] : _this45.totals[_e107] = 0;

          var _r45 = Yn(() => es(_this45.totals[_e107], ss(s, n)));

          _this45.totals[_e107] = _r45, null != _t110 && _t110.dispose();
        }
      };

      for (var _e107 in t) {
        _loop12(_e107);
      }
    })();
  }

  onEpochEnd(e, t) {
    var _this46 = this;

    return _asyncToGenerator(function* () {
      if (null != t) {
        var _loop13 = function _loop13(_e108) {
          null != _this46.totals[_e108] && ("number" == typeof _this46.totals[_e108] ? t[_e108] = _this46.totals[_e108] / _this46.seen : Yn(() => {
            var n = ss(ns(1, _this46.seen), _this46.totals[_e108]);
            t[_e108] = n, _this46.totals[_e108].dispose(), Zn(t[_e108]);
          }));
        };

        for (var _e108 of _this46.params.metrics) {
          _loop13(_e108);
        }
      }
    })();
  }

}

class $h extends wh {
  onTrainBegin(e) {
    var _this47 = this;

    return _asyncToGenerator(function* () {
      _this47.epoch = [], _this47.history = {};
    })();
  }

  onEpochEnd(e, t) {
    var _this48 = this;

    return _asyncToGenerator(function* () {
      null == t && (t = {}), _this48.epoch.push(e);

      for (var _e109 in t) {
        null == _this48.history[_e109] && (_this48.history[_e109] = []), _this48.history[_e109].push(t[_e109]);
      }
    })();
  }

  syncData() {
    var _this49 = this;

    return _asyncToGenerator(function* () {
      var e = [],
          t = [],
          n = [];

      for (var _s63 in _this49.history) {
        var _r46 = _this49.history[_s63];

        for (var _a38 = 0; _a38 < _r46.length; ++_a38) {
          "number" != typeof _r46[_a38] && (e.push(_r46[_a38].data()), t.push(_s63), n.push(_a38));
        }
      }

      var s = yield Promise.all(e);

      for (var _e110 = 0; _e110 < s.length; ++_e110) {
        _this49.history[t[_e110]][n[_e110]].dispose(), _this49.history[t[_e110]][n[_e110]] = s[_e110][0];
      }
    })();
  }

}

class Nh extends wh {
  constructor(e, t) {
    if (super(), this.currentEpoch = 0, this.yieldEvery = t || "auto", "auto" === this.yieldEvery && (this.yieldEvery = 125), "never" === this.yieldEvery && null != e.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
    S(this.yieldEvery) && (this.maybeWait = function (e, t) {
      var n,
          s = Ve();
      return function () {
        var a = Ve();
        return a - s < t || (s = a, n = e(...arguments)), n;
      };
    }(this.maybeWait.bind(this), this.yieldEvery)), this.trainBegin = e.onTrainBegin, this.trainEnd = e.onTrainEnd, this.epochBegin = e.onEpochBegin, this.epochEnd = e.onEpochEnd, this.batchBegin = e.onBatchBegin, this.batchEnd = e.onBatchEnd, this.yield = e.onYield;
  }

  maybeWait(e, t, n) {
    var _this50 = this;

    return _asyncToGenerator(function* () {
      var s = [];
      null != _this50.yield && (yield xh(n), s.push(_this50.yield(e, t, n))), s.push(No()), yield Promise.all(s);
    })();
  }

  onEpochBegin(e, t) {
    var _this51 = this;

    return _asyncToGenerator(function* () {
      _this51.currentEpoch = e, null != _this51.epochBegin && (yield xh(t), yield _this51.epochBegin(e, t));
    })();
  }

  onEpochEnd(e, t) {
    var _this52 = this;

    return _asyncToGenerator(function* () {
      var n = [];
      null != _this52.epochEnd && (yield xh(t), n.push(_this52.epochEnd(e, t))), "epoch" === _this52.yieldEvery && n.push(No()), yield Promise.all(n);
    })();
  }

  onBatchBegin(e, t) {
    var _this53 = this;

    return _asyncToGenerator(function* () {
      null != _this53.batchBegin && (yield xh(t), yield _this53.batchBegin(e, t));
    })();
  }

  onBatchEnd(e, t) {
    var _this54 = this;

    return _asyncToGenerator(function* () {
      var n = [];
      null != _this54.batchEnd && (yield xh(t), n.push(_this54.batchEnd(e, t))), "batch" === _this54.yieldEvery ? n.push(No()) : S(_this54.yieldEvery) && n.push(_this54.maybeWait(_this54.currentEpoch, e, t)), yield Promise.all(n);
    })();
  }

  onTrainBegin(e) {
    var _this55 = this;

    return _asyncToGenerator(function* () {
      null != _this55.trainBegin && (yield xh(e), yield _this55.trainBegin(e));
    })();
  }

  onTrainEnd(e) {
    var _this56 = this;

    return _asyncToGenerator(function* () {
      null != _this56.trainEnd && (yield xh(e), yield _this56.trainEnd(e));
    })();
  }

}

function Ch(e, t) {
  return null == e && (e = {}), e instanceof wh ? [e] : Array.isArray(e) && e[0] instanceof wh ? e : $u(e).map(e => new Nh(e, t));
}

class Sh {
  constructor() {}

  static registerCallbackConstructor(e, t) {
    l(e >= 0 && Number.isInteger(e), () => "Verbosity level is expected to be an integer >= 0, but got ".concat(e)), Sh.checkForDuplicate(t), null == Sh.constructors[e] && (Sh.constructors[e] = []), Sh.constructors[e].push(t);
  }

  static checkForDuplicate(e) {
    for (var _t111 in Sh.constructors) {
      Sh.constructors[+_t111].forEach(t => {
        if (t === e) throw new bu("Duplicate callback constructor.");
      });
    }
  }

  static clear() {
    Sh.constructors = {};
  }

  static createCallbacks(e) {
    var t = [];

    for (var _n73 in Sh.constructors) {
      var _s64 = +_n73;

      e >= _s64 && t.push(...Sh.constructors[_s64]);
    }

    return t.map(e => new e());
  }

}

function Th(e, t, n, s, r, a, i, o, l) {
  var u = new $h(),
      c = [new Ih(), ...Sh.createCallbacks(t)];
  null != e && c.push(...e), c.push(u);
  var h = new vh(c);
  return h.setParams({
    epochs: n,
    initialEpoch: s,
    samples: r,
    steps: a,
    batchSize: i,
    verbose: t,
    doValidation: o,
    metrics: l
  }), {
    callbackList: h,
    history: u
  };
}

function Eh(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return Ru(e, jn.getMap().classNameMap, t, "layer", n);
}

function Rh(e, t) {
  return Yn(() => {
    "float32" !== e.dtype && (e = pn(e, "float32"));
    var n = Gr(Nc(e), t, !0),
        s = Ir(n.shape, fu()),
        r = ui(oa(n, s));
    return ns(e, r);
  });
}

function Ah(e, t) {
  return Yn(() => la(Nc(Vr(t, e)), -1));
}

function Fh(e, t) {
  return Yn(() => la(rs(Vr(t, e)), -1));
}

function Dh(e, t) {
  return Yn(() => {
    var n = Vr(e, t),
        s = Gs(rs(e), fu(), Number.MAX_VALUE),
        r = rs(ns(n, s));
    return ss(100, la(r, -1));
  });
}

function _h(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return Yn(() => {
    if (n) t = si(t);else {
      var _e111 = Gr(t, t.shape.length - 1, !0);

      t = ns(t, _e111);
    }
    return t = Gs(t, fu(), 1 - fu()), Br(Gr(ss(pn(e, "float32"), Mr(t)), t.shape.length - 1));
  });
}

function Oh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return Yn(() => {
    var s = pn($r(function (e) {
      var t = [cc(e.shape)];
      return Es(e, t);
    }(e)), "int32"),
        r = (t = Gs(t, fu(), 1 - fu())).shape;
    return _h(Es(In(s, r[r.length - 1]), r), t, n);
  });
}

function Mh(e, t) {
  return Yn(() => {
    var n;
    return n = Gs(t, fu(), 1 - fu()), n = Mr(ns(n, Vr(1, n))), la(function (e, t) {
      if (!p(e.shape, t.shape)) throw new bu("logits and labels must have the same shape, but got shapes ".concat(JSON.stringify(e.shape), " and ").concat(JSON.stringify(t.shape)));
      return Yn(() => {
        var n = Ua(t),
            s = Br(rs(t));
        return es(Vr(n, ss(t, e)), Lr(xr(s)));
      });
    }(e, n), -1);
  });
}

function Lh(e, t) {
  return Yn(() => {
    var n = Rh(e, -1),
        s = Rh(t, -1),
        r = ss(n, s);
    return Br(Gr(r, -1));
  });
}

Sh.constructors = {};
var zh = {
  meanSquaredError: Ah,
  meanAbsoluteError: Fh,
  meanAbsolutePercentageError: Dh,
  meanSquaredLogarithmicError: function meanSquaredLogarithmicError(e, t) {
    return Yn(() => {
      var n = Gs(t, fu(), Number.MAX_VALUE),
          s = Mr(es(1, n)),
          r = Gs(e, fu(), Number.MAX_VALUE),
          a = Mr(es(1, r));
      return la(Nc(Vr(s, a)), -1);
    });
  },
  squaredHinge: function squaredHinge(e, t) {
    return Yn(() => {
      var n = oa(0, Vr(1, ss(e, t)));
      return la(Nc(n), -1);
    });
  },
  hinge: function hinge(e, t) {
    return Yn(() => {
      var n = oa(0, Vr(1, ss(e, t)));
      return la(n, -1);
    });
  },
  categoricalHinge: function categoricalHinge(e, t) {
    return Yn(() => {
      var n = Gr(ss(e, t), -1),
          s = Ur(ss(Vr(1, e), t), -1);
      return oa(0, es(1, Vr(s, n)));
    });
  },
  logcosh: function logcosh(e, t) {
    return Yn(() => {
      var n = Math.log(2),
          s = Vr(t, e),
          r = Vr(es(s, Pr(ss(-2, s))), n);
      return la(r, -1);
    });
  },
  categoricalCrossentropy: _h,
  sparseCategoricalCrossentropy: Oh,
  binaryCrossentropy: Mh,
  kullbackLeiblerDivergence: function kullbackLeiblerDivergence(e, t) {
    return Yn(() => {
      var n = Gs(e, fu(), 1),
          s = Gs(t, fu(), 1);
      return Gr(ss(e, Mr(ns(n, s))), -1);
    });
  },
  poisson: function poisson(e, t) {
    return Yn(() => {
      var n = Mr(es(fu(), t));
      return la(Vr(t, ss(e, n)), -1);
    });
  },
  cosineProximity: Lh
};

function Bh(e) {
  if ("string" == typeof e) {
    if (e in zh) return zh[e];

    var _t112 = "Unknown loss ".concat(e);

    throw e.toLowerCase().includes("softmaxcrossentropy") && (_t112 = "Unknown loss ".concat(e, ". Use \"categoricalCrossentropy\" as the string name for tf.losses.softmaxCrossEntropy")), new bu(_t112);
  }

  return e;
}

function Ph(e, t) {
  return Yn(() => {
    var n = ss(.5, xa(t)),
        s = fc(Cr(t, n), e.dtype);
    return la(hr(e, s), -1);
  });
}

function Wh(e, t) {
  return Yn(() => fc(hr(us(e, -1), us(t, -1)), "float32"));
}

function Uh(e, t) {
  return Mh(e, t);
}

function Vh(e, t) {
  return e.rank === t.rank && (e = hi(e, [e.rank - 1])), (t = us(t, -1)).dtype !== e.dtype && (t = pn(t, e.dtype)), pn(hr(e, t), "float32");
}

var Gh = _h,
    Hh = Oh,
    jh = {
  binaryAccuracy: Ph,
  categoricalAccuracy: Wh,
  precision: function precision(e, t) {
    return Yn(() => {
      var n = function (e, t) {
        return Yn(() => pn(Gr(ta(hr(e, 1), hr(t, 1))), "float32"));
      }(e, t),
          s = function (e, t) {
        return Yn(() => pn(Gr(ta(hr(e, 0), hr(t, 1))), "float32"));
      }(e, t),
          r = es(n, s);

      return pn(dr(Cr(r, 0), ns(n, r), 0), "float32");
    });
  },
  categoricalCrossentropy: Gh,
  sparseCategoricalCrossentropy: Hh,
  mse: Ah,
  MSE: Ah,
  mae: Fh,
  MAE: Fh,
  mape: Dh,
  MAPE: Dh,
  cosine: Lh
};

function qh(e) {
  if ("string" == typeof e && e in jh) return jh[e];
  if ("string" != typeof e && null != e) return e;
  throw new bu("Unknown metric ".concat(e));
}

function Kh(e) {
  if (wu(null !== e, "Unknown LossOrMetricFn ".concat(e)), "string" == typeof e) return e;
  {
    var _t113;

    for (var _n74 of Object.keys(zh)) {
      if (zh[_n74] === e) {
        _t113 = _n74;
        break;
      }
    }

    if (void 0 !== _t113) return _t113;

    for (var _n75 of Object.keys(jh)) {
      if (jh[_n75] === e) {
        _t113 = _n75;
        break;
      }
    }

    return void 0 !== _t113 ? _t113 : e.name;
  }
}

function Xh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  if (null == e || "object" != typeof e || Object.getPrototypeOf(e) !== Object.prototype || !Yh(e)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");

  if (n) {
    var _n76 = JSON.stringify(e);

    _n76.length > 1048576 && console.warn("User-defined metadata of model \"".concat(t, "\" is too large in size (length=").concat(_n76.length, " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576."));
  }
}

function Yh(e) {
  if (null === e) return !0;

  if ("object" == typeof e) {
    if (Object.getPrototypeOf(e) === Object.prototype) {
      var _t114 = Object.keys(e);

      for (var _n77 of _t114) {
        if ("string" != typeof _n77) return !1;
        if (!Yh(e[_n77])) return !1;
      }

      return !0;
    }

    if (Array.isArray(e)) {
      for (var _t115 of e) {
        if (!Yh(_t115)) return !1;
      }

      return !0;
    }

    return !1;
  }

  {
    var _t116 = typeof e;

    return "string" === _t116 || "number" === _t116 || "boolean" === _t116;
  }
}

function Jh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;
  var s = "";

  for (var _n78 = 0; _n78 < e.length; ++_n78) {
    _n78 > 0 && (s = s.slice(0, s.length - 1) + " "), s += e[_n78], s = s.slice(0, t[_n78]), s += " ".repeat(t[_n78] - s.length);
  }

  n(s);
}

function Zh(e, t, n) {
  var s;

  try {
    s = JSON.stringify(e.outputShape);
  } catch (e) {
    s = "multiple";
  }

  Jh(["".concat(e.name, " (").concat(e.getClassName(), ")"), s, e.countParams().toString()], t, n);
}

function Qh(e, t, n, s) {
  var r;

  try {
    r = JSON.stringify(e.outputShape);
  } catch (e) {
    r = "multiple";
  }

  var a = [];

  for (var _t117 of e.inboundNodes) {
    if (!(null != n && n.length > 0 && -1 === n.indexOf(_t117))) for (var _e112 = 0; _e112 < _t117.inboundLayers.length; ++_e112) {
      a.push("".concat(_t117.inboundLayers[_e112].name, "[").concat(_t117.nodeIndices[_e112], "][").concat(_t117.tensorIndices[_e112], "]"));
    }
  }

  var i = e.name,
      o = e.getClassName(),
      l = 0 === a.length ? "" : a[0];
  Jh(["".concat(i, " (").concat(o, ")"), r, e.countParams().toString(), l], t, s);

  for (var _e113 = 1; _e113 < a.length; ++_e113) {
    Jh(["", "", "", a[_e113]], t, s);
  }
}

function ed(e, t, n) {
  return ("inboundNodes" === e || "outputLayers" === e || "inputLayers" === e) && 0 === t && "string" == typeof n;
}

function td(e, t) {
  if (null === e) return null;
  if ("string" == typeof e) return Cu(e);
  if ("number" == typeof e || "boolean" == typeof e) return e;

  if (e instanceof Array) {
    var _n79 = [],
        _s65 = e.length;

    for (var _r47 = 0; _r47 < _s65; ++_r47) {
      var _s66 = e[_r47];
      ed(t, _r47, _s66) ? _n79.push(_s66) : _n79.push(td(_s66, t));
    }

    return _n79;
  }

  {
    var _t118 = {};

    for (var _n80 of Object.keys(e)) {
      var _s67 = e[_n80];
      if ("name" === _n80 && "string" == typeof _s67) _t118[_n80] = _s67;else {
        var _e114 = Cu(_n80);

        _t118[_e114] = td(_s67, _e114);
      }
    }

    return _t118;
  }
}

function nd(e, t) {
  if (null == e) return null;
  if ("string" == typeof e) return Nu(e);
  if ("number" == typeof e || "boolean" == typeof e) return e;

  if (e instanceof Array) {
    var _n81 = [],
        _s68 = e.length;

    for (var _r48 = 0; _r48 < _s68; ++_r48) {
      var _s69 = e[_r48];
      ed(t, _r48, _s69) ? _n81.push(_s69) : _n81.push(nd(_s69, t));
    }

    return _n81;
  }

  {
    var _t119 = {};

    for (var _n82 of Object.keys(e)) {
      var _s70 = e[_n82];
      _t119[Nu(_n82)] = "name" !== _n82 && "className" !== _n82 || "string" != typeof _s70 ? nd(_s70, _n82) : _s70;
    }

    return _t119;
  }
}

class sd {
  constructor(e) {
    if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, e instanceof sd) for (var _t120 in e.id2Value) {
      this.id2Value[_t120] = e.id2Value[_t120], _t120 in e.id2Mask && (this.id2Mask[_t120] = e.id2Mask[_t120]);
    } else {
      if (null == e) return;

      for (var _t121 of e) {
        this.add(_t121.key, _t121.value);
      }
    }
  }

  add(e, t, n) {
    if (null != this.id2Value[e.id]) throw new bu("Duplicate key: name=".concat(e.name, ", id=").concat(e.id));
    return this.id2Value[e.id] = function (e, t) {
      if (null == e.dtype || e.dtype === t.dtype) return t;

      try {
        return pn(t, e.dtype);
      } catch (n) {
        throw new bu("The dtype of the feed (".concat(t.dtype, ") can not be cast to the dtype of the key '").concat(e.name, "' (").concat(e.dtype, ")."));
      }
    }(e, t), this.name2Id[e.name] = e.id, null != n && (this.id2Mask[e.id] = n), this;
  }

  addFeed(e) {
    this.add(e.key, e.value);
  }

  hasKey(e) {
    return null != this.id2Value[e.id];
  }

  names() {
    return Object.keys(this.name2Id);
  }

  getValue(e) {
    if (e instanceof hh) {
      if (null == this.id2Value[e.id]) throw new bu("Nonexistent key: ".concat(e.name));
      return this.id2Value[e.id];
    }

    {
      var _t122 = this.name2Id[e];
      if (null == _t122) throw new bu("Feed dict has no SymbolicTensor name: ".concat(e));
      return this.id2Value[_t122];
    }
  }

  getMask(e) {
    if (e instanceof hh) {
      if (null == this.id2Value[e.id]) throw new bu("Nonexistent key: ".concat(e.name));
      return this.id2Mask[e.id];
    }

    {
      var _t123 = this.name2Id[e];
      if (null == _t123) throw new bu("Feed dict has no SymbolicTensor name: ".concat(e));
      return this.id2Mask[_t123];
    }
  }

  disposeMasks() {
    null != this.id2Mask && Jn(this.id2Mask);
  }

}

var rd = {},
    ad = {};

function id(e, t, n, s) {
  var r = null != n && n.training,
      a = Array.isArray(e),
      i = a ? e : [e],
      o = i.map(e => e.name),
      u = [],
      c = t.names();

  for (var _e115 of o) {
    -1 !== c.indexOf(_e115) ? u.push(t.getValue(_e115)) : u.push(null);
  }

  null != s && (s.maxNumTensors = -Infinity, s.minNumTensors = Infinity);
  var h = o.join(",") + "|" + t.names().join(",");
  var d, p;

  if (null == rd[h]) {
    var _e116 = function (e, t) {
      l(null != e && e.length > 0, () => "Expected at least one fetch, got none");
      var n = [],
          s = {};

      if (1 === e.length) {
        var _r49 = ld(e[0], t);

        n = _r49.sorted, s = _r49.recipientMap;
      } else {
        var _r50 = new Set();

        for (var _a39 of e) {
          var {
            sorted: _e117,
            recipientMap: _i22
          } = ld(_a39, t);

          for (var _t124 of _e117) {
            _r50.has(_t124.name) || (n.push(_t124), _r50.add(_t124.name));
          }

          var _loop14 = function _loop14(_e118) {
            null == s[_e118] && (s[_e118] = new Set()), _i22[_e118].forEach(t => s[_e118].add(t));
          };

          for (var _e118 in _i22) {
            _loop14(_e118);
          }
        }
      }

      return {
        sorted: n,
        recipientCounts: od(s)
      };
    }(i, t);

    d = _e116.sorted, p = _e116.recipientCounts, rd[h] = d, ad[h] = p;
  }

  d = rd[h], p = {}, r || Object.assign(p, ad[h]);
  var f = new sd(t);

  for (var _e119 = 0; _e119 < d.length; ++_e119) {
    if (null != s) {
      var _e120 = Xn().numTensors;
      _e120 > s.maxNumTensors && (s.maxNumTensors = _e120), _e120 < s.minNumTensors && (s.minNumTensors = _e120);
    }

    var _a40 = d[_e119],
        _i23 = _a40.sourceLayer;
    if (_i23 instanceof bh) continue;
    var _l11 = [],
        _c6 = [],
        _h5 = [];

    var _g5 = !1;

    for (var _e121 of _a40.inputs) {
      var _n83 = f.getValue(_e121),
          _s71 = f.getMask(_e121);

      _l11.push(_n83), _c6.push(_s71), null != _s71 && (_g5 = !0), r || (p[_e121.name]--, 0 !== p[_e121.name] || t.hasKey(_e121) || -1 !== o.indexOf(_e121.name) || _n83.isDisposed || !0 === _e121.sourceLayer.stateful || _h5.push(_n83));
    }

    _g5 && ((n = n || {}).mask = _c6[0]);

    var _m4 = $u(_i23.apply(_l11, n));

    var _b4 = null;
    _i23.supportsMasking && (_b4 = _i23.computeMask(_l11, _c6));

    var _x20 = ud(_a40),
        _y4 = Array.isArray(_x20) ? _x20 : [_x20];

    for (var _e122 = 0; _e122 < _y4.length; ++_e122) {
      f.hasKey(_y4[_e122]) || f.add(_y4[_e122], _m4[_e122], Array.isArray(_b4) ? _b4[0] : _b4);

      var _t125 = o.indexOf(_y4[_e122].name);

      -1 !== _t125 && (u[_t125] = _m4[_e122]);
    }

    r || Jn(_h5);
  }

  return f.disposeMasks(), a ? u : u[0];
}

function od(e) {
  var t = {};

  for (var _n84 in e) {
    t[_n84] = e[_n84].size;
  }

  return t;
}

function ld(e, t) {
  var n = new Set(),
      s = [],
      r = {};

  for (var _e123 of t.names()) {
    n.add(_e123);
  }

  var a = [],
      i = [];

  for (a.push(e); a.length > 0;) {
    var _e124 = a[a.length - 1];

    if (n.has(_e124.name)) {
      a.pop();
      continue;
    }

    var _t126 = i[i.length - 1] === a.length - 1;

    if (0 === _e124.inputs.length || _t126) a.pop(), s.push(_e124), n.add(_e124.name), _t126 && i.pop();else {
      i.push(a.length - 1);

      for (var _t127 of _e124.inputs) {
        null == r[_t127.name] && (r[_t127.name] = new Set()), r[_t127.name].add(_e124.name), n.has(_t127.name) || a.push(_t127);
      }
    }
  }

  return {
    sorted: s,
    recipientMap: r
  };
}

function ud(e) {
  var t;
  if (1 === e.sourceLayer.inboundNodes.length) t = e.sourceLayer.output;else {
    var _n85 = null;

    for (var _t128 = 0; _t128 < e.sourceLayer.inboundNodes.length; ++_t128) {
      for (var _s72 of e.sourceLayer.inboundNodes[_t128].outputTensors) {
        if (_s72.id === e.id) {
          _n85 = _t128;
          break;
        }
      }
    }

    t = e.sourceLayer.getOutputAt(_n85);
  }
  return t;
}

class cd extends gh {
  constructor(e) {
    if (super({}), this.containerNodes = new Set(), this.name = e.name, null == this.name) {
      var _e125 = this.getClassName().toLowerCase();

      this.name = th(_e125);
    }

    if (this.supportsMasking = !1, this.trainable_ = !0, this.inputs = Array.isArray(e.inputs) ? e.inputs.slice() : [e.inputs], this.outputs = Array.isArray(e.outputs) ? e.outputs.slice() : [e.outputs], Fu(this.inputs).length !== this.inputs.length) throw new bu("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ".concat(this.inputs.map(e => e.name)));
    Fu(this.outputs).length !== this.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ".concat(this.outputs.map(e => e.name))), this.inputLayers = [], this.inputLayersNodeIndices = [], this.inputLayersTensorIndices = [], this.outputLayers = [], this.outputLayersNodeIndices = [], this.outputLayersTensorIndices = [], this.layers = [], this.internalContainerRefs = [];

    for (var _e126 of this.outputs) {
      var _t129 = _e126.nodeIndex,
          _n86 = _e126.tensorIndex;
      this.outputLayers.push(_e126.sourceLayer), this.outputLayersNodeIndices.push(_t129), this.outputLayersTensorIndices.push(_n86);
    }

    for (var _e127 of this.inputs) {
      var _t130 = _e127.sourceLayer,
          _n87 = _e127.nodeIndex,
          _s73 = _e127.tensorIndex;
      wu(0 === _n87, "input layer has >1 nodes"), wu(0 === _s73, "input layer has >1 tensors"), this.inputLayers.push(_t130), this.inputLayersNodeIndices.push(_n87), this.inputLayersTensorIndices.push(_s73);
    }

    this.inputNames = [], this.outputNames = [], this.feedInputShapes = [], this.feedInputNames = [], this.feedOutputNames = [];

    for (var _t131 = 0; _t131 < this.inputLayers.length; _t131++) {
      var _n88 = this.inputLayers[_t131];
      if (!(_n88 instanceof bh)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: ".concat(e.inputs, ". Input ").concat(_t131, " (0-based) originates from layer type ").concat(_n88.getClassName(), "."));
      this.inputNames.push(_n88.name), this.feedInputShapes.push(_n88.batchInputShape), this.feedInputNames.push(_n88.name);
    }

    for (var _e128 of this.outputLayers) {
      this.outputNames.push(_e128.name);
    }

    this.internalInputShapes = this.inputs.map(e => e.shape), this.internalOutputShapes = this.outputs.map(e => e.shape);

    var t = {},
        n = {},
        s = {},
        r = {},
        a = {},
        i = [],
        o = (e, t, n, s, r, l) => {
      null != s && null != r && null != l || (s = e.sourceLayer, r = e.nodeIndex, l = e.tensorIndex);
      var u = s.inboundNodes[r];
      if (-1 !== n.indexOf(u)) throw new mu("The tensor ".concat(e.name, " at layer \"").concat(s.name, "\" is part of a cycle."));
      if (-1 !== t.indexOf(u)) return;
      this.containerNodes.add(cd.nodeKey(s, r)), s.id in a || (a[s.id] = Object.keys(a).length), -1 === n.indexOf(u) && n.push(u);
      var c = u.inboundLayers.length;

      for (var _e129 = 0; _e129 < c; _e129++) {
        o(u.inputTensors[_e129], t, n, u.inboundLayers[_e129], u.nodeIndices[_e129], u.tensorIndices[_e129]);
      }

      for (t.push(u); n.indexOf(u) >= 0;) {
        n.splice(n.indexOf(u), 1);
      }

      i.push(u);
    },
        l = [],
        u = [];

    for (var _e130 of this.outputs) {
      o(_e130, l, u);
    }

    var c = i.slice().reverse();

    for (var _e131 of c) {
      n[_e131.id] = _e131, _e131.id in t || (t[_e131.id] = 0);
      var _a41 = t[_e131.id];
      _a41 = Math.max(_a41, null == s[_e131.outboundLayer.id] ? 0 : s[_e131.outboundLayer.id]), s[_e131.outboundLayer.id] = _a41, r[_e131.outboundLayer.id] = _e131.outboundLayer, t[_e131.id] = _a41;

      for (var _s74 = 0; _s74 < _e131.inboundLayers.length; _s74++) {
        var _r51 = _e131.inboundLayers[_s74].inboundNodes[_e131.nodeIndices[_s74]];
        t[_r51.id] = Math.max(_a41 + 1, null == t[_r51.id] ? 0 : t[_r51.id]), n[_r51.id] = _r51;
      }
    }

    var h = {};

    for (var _e132 in t) {
      var _s75 = t[_e132];
      _s75 in h || (h[_s75] = []), h[_s75].push(n[_e132]);
    }

    var d = {};

    for (var _e133 in s) {
      var _t132 = s[_e133];
      _t132 in d || (d[_t132] = []), d[_t132].push(r[_e133]);
    }

    var p = Object.keys(d).map(e => parseInt(e, 10)).sort(Au);
    this.layers = [];

    for (var _e134 of p) {
      var _t133 = d[_e134];

      _t133.sort((e, t) => {
        var n = a[e.id],
            s = a[t.id];
        return n < s ? -1 : n > s ? 1 : 0;
      });

      for (var _e135 of _t133) {
        _e135 instanceof cd && this.internalContainerRefs.push(_e135), this.layers.push(_e135);
      }
    }

    this.layersByDepth = d, p = Object.keys(h).map(e => parseInt(e, 10)).sort(Au);
    var f = this.inputs.slice(),
        g = [];

    for (var _e136 of p) {
      for (var _t134 of h[_e136]) {
        var _e137 = _t134.outboundLayer;

        if (null != _e137) {
          for (var _n89 of _t134.inputTensors) {
            if (-1 === f.indexOf(_n89)) throw new mu("Graph disconnected: cannot obtain value for tensor ".concat(_n89, " at layer \"").concat(_e137.name, "\". The following previous layers were accessed without issue: ").concat(g));
          }

          for (var _e138 of _t134.outputTensors) {
            f.push(_e138);
          }

          g.push(_e137.name);
        }
      }
    }

    this.nodesByDepth = h;
    var m = this.layers.map(e => e.name);

    var _loop15 = function _loop15(_e139) {
      var t = m.filter(t => t === _e139).length;
      if (1 !== t) throw new mu("The name \"".concat(_e139, "\" is used ").concat(t, " times in the model. All layer names should be unique. Layer names: ") + JSON.stringify(m));
    };

    for (var _e139 of m) {
      _loop15(_e139);
    }

    this.outboundNodes = [], this.inboundNodes = [], new ph({
      outboundLayer: this,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: this.inputs,
      outputTensors: this.outputs,
      inputMasks: this.inputs.map(e => null),
      outputMasks: this.outputs.map(e => null),
      inputShapes: this.inputs.map(e => e.shape),
      outputShapes: this.outputs.map(e => e.shape)
    }), this.built = !0, this._refCount = 1;
  }

  assertNotDisposed() {
    if (0 === this._refCount) throw new Error("Container '".concat(this.name, "' is already disposed."));
  }

  dispose() {
    this.assertNotDisposed();
    var e = {
      refCountAfterDispose: null,
      numDisposedVariables: 0
    };

    if (0 == --this._refCount) {
      for (var _t135 of this.layers) {
        e.numDisposedVariables += _t135.dispose().numDisposedVariables;
      }

      for (var _t136 of this.internalContainerRefs) {
        e.numDisposedVariables += _t136.dispose().numDisposedVariables;
      }
    }

    return e.refCountAfterDispose = this._refCount, e;
  }

  get trainable() {
    return this.trainable_;
  }

  set trainable(e) {
    this.layers.forEach(t => {
      t._trainableWeights.forEach(t => t.trainable = e);
    }), this.trainable_ = e;
  }

  get trainableWeights() {
    if (this._trainableWeights.length > 0) throw new bu("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
    if (!this.trainable) return [];
    var e = [];

    for (var _t137 of this.layers) {
      e = e.concat(_t137.trainableWeights);
    }

    return e;
  }

  get nonTrainableWeights() {
    var e = [];

    for (var _t138 of this.layers) {
      e.push(..._t138.nonTrainableWeights);
    }

    if (!this.trainable) {
      var _t139 = [];

      for (var _e140 of this.layers) {
        _t139.push(..._e140.trainableWeights);
      }

      return _t139.concat(e);
    }

    return e;
  }

  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }

  loadWeights(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    var n = {};
    var s = 0;

    for (var _e141 of this.layers) {
      for (var _t140 of _e141.weights) {
        if (null != n[_t140.originalName]) throw new bu("Duplicate weight name: ".concat(_t140.originalName));
        n[_t140.originalName] = _t140, s++;
      }
    }

    var r = [];

    for (var _s76 in e) {
      var _a42 = _s76;

      if (null == n[_s76]) {
        var _e142 = _s76.split("/");

        _a42 = _e142.slice(0, -2).concat([_e142[_e142.length - 1]]).join("/");
      }

      if (null != n[_a42]) r.push([n[_a42], e[_s76]]);else if (t) throw new bu("Provided weight data has no target variable: ".concat(_s76));
      delete n[_a42];
    }

    if (t) {
      var _e143 = [];

      for (var _t141 in n) {
        _e143.push(_t141);
      }

      if (_e143.length > 0) throw new bu("".concat(_e143.length, " of ").concat(s, " weights are not set: ").concat(_e143));
    }

    uh(r);
  }

  updatedConfig() {
    var e = this.getConfig(),
        t = {};
    return t.className = this.getClassName(), t.config = e, t.kerasVersion = "tfjs-layers 3.8.0", t.backend = "TensorFlow.js", t;
  }

  toJSON(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    var n = nd(this.updatedConfig());
    return t ? JSON.stringify(n) : n;
  }

  call(e, t) {
    return Yn(() => {
      e = $u(e);
      var n = new sd();

      for (var _t142 = 0; _t142 < this.inputs.length; ++_t142) {
        n.add(this.inputs[_t142], e[_t142]);
      }

      return id(this.outputs, n, t);
    });
  }

  computeMask(e, t) {
    return Yn(() => {
      var n;
      return e = $u(e), n = null == t ? ku(null, e.length) : $u(t), this.runInternalGraph(e, n)[1];
    });
  }

  computeOutputShape(e) {
    var t = sh(e);
    if (t.length !== this.inputLayers.length) throw new bu("Invalid inputShape argument ".concat(e, ": model has ").concat(this.inputLayers.length, " tensor inputs."));
    var n = {};

    for (var _e144 = 0; _e144 < t.length; _e144++) {
      n[this.inputLayers[_e144].name + "_0_0"] = t[_e144];
    }

    var s = Object.keys(this.nodesByDepth).map(e => parseInt(e, 10)).sort(Au);
    if (s.length > 1) for (var _e145 of s) {
      var _t143 = this.nodesByDepth[_e145];

      for (var _e146 of _t143) {
        var _t144 = _e146.outboundLayer;
        if (-1 !== this.inputLayers.map(e => e.id).indexOf(_t144.id)) continue;
        var _s77 = [];

        for (var _t145 = 0; _t145 < _e146.inboundLayers.length; _t145++) {
          _s77.push(n["".concat(_e146.inboundLayers[_t145].name, "_").concat(_e146.nodeIndices[_t145], "_").concat(_e146.tensorIndices[_t145])]);
        }

        var _r52 = sh(_t144.computeOutputShape(Iu(_s77))),
            _a43 = _t144.inboundNodes.indexOf(_e146);

        for (var _e147 = 0; _e147 < _r52.length; _e147++) {
          n["".concat(_t144.name, "_").concat(_a43, "_").concat(_e147)] = _r52[_e147];
        }
      }
    }
    var r = [],
        a = [];

    for (var _e148 = 0; _e148 < this.outputLayers.length; _e148++) {
      a.push("".concat(this.outputLayers[_e148].name, "_").concat(this.outputLayersNodeIndices[_e148], "_").concat(this.outputLayersTensorIndices[_e148]));
    }

    for (var _e149 = 0; _e149 < a.length; _e149++) {
      var _t146 = a[_e149];
      wu(_t146 in n), r.push(n[_t146]);
    }

    return Iu(r);
  }

  runInternalGraph(e, t) {
    null == t && (t = ku(null, e.length));
    var n = {};

    for (var _s78 = 0; _s78 < this.inputs.length; ++_s78) {
      n[this.inputs[_s78].id] = [e[_s78], t[_s78]];
    }

    var s = Object.keys(this.nodesByDepth).map(e => parseInt(e, 10)).sort(Au);

    for (var _e150 of s) {
      var _t147 = this.nodesByDepth[_e150];

      for (var _e151 of _t147) {
        var _t148 = _e151.outboundLayer,
            _s79 = _e151.inputTensors,
            _r53 = _e151.outputTensors,
            _a44 = new Array();

        for (var _e152 of _s79) {
          _e152.id in n && _a44.push(n[_e152.id]);
        }

        if (_a44.length === _s79.length) {
          var _s80 = void 0,
              _i24 = void 0,
              _o18 = void 0,
              _l12 = void 0,
              _u7 = {};

          if (null != _e151.callArgs && (_u7 = _e151.callArgs), 1 === _a44.length) {
            var [_e153, _n90] = _a44[0];
            null == _u7.mask && (_u7.mask = _n90), _o18 = $u(_t148.call(_e153, _u7)), _l12 = $u(_t148.computeMask(_e153, _n90)), _s80 = [_e153], _i24 = [_n90];
          } else _s80 = _a44.map(e => e[0]), _i24 = _a44.map(e => e[1]), null == _u7.mask && (_u7.mask = _i24), _o18 = $u(_t148.call(_s80, _u7)), _l12 = $u(_t148.computeMask(_s80, _i24));

          if (_t148.activityRegularizer) throw new xu("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");

          for (var _e154 = 0; _e154 < _r53.length; ++_e154) {
            n[_r53[_e154].id] = [_o18[_e154], _l12[_e154]];
          }
        }
      }
    }

    var r = [],
        a = [],
        i = [];

    for (var _e155 of this.outputs) {
      wu(_e155.id in n, "Could not compute output ".concat(_e155.name, " : ").concat(_e155.id));
      var [_t149, _s81] = n[_e155.id];
      i.push(_t149.shape), r.push(_t149), a.push(_s81);
    }

    return [r, a, i];
  }

  buildNodeConversionMap(e) {
    var t = {};
    var n;

    for (var _e156 of this.layers) {
      n = _e156 instanceof cd ? 1 : 0;

      for (var _s82 = 0; _s82 < _e156.inboundNodes.length; _s82++) {
        var _r54 = cd.nodeKey(_e156, _s82);

        this.containerNodes.has(_r54) && (t[_r54] = n, n += 1);
      }
    }

    return t;
  }

  getLayer(e, t) {
    if (null != t) {
      if (this.layers.length <= t) throw new bu("Was asked to retrieve layer at index ".concat(t, ", but model only has ").concat(this.layers.length, " layer(s)."));
      return this.layers[t];
    }

    if (null == e) throw new bu("Provide either a layer name or layer index");

    for (var _t150 of this.layers) {
      if (_t150.name === e) return _t150;
    }

    throw new bu("No such layer: ".concat(e));
  }

  calculateLosses() {
    return Yn(() => {
      var e = [];

      for (var _t151 of this.layers) {
        for (var _n91 = 0; _n91 < _t151.inboundNodes.length; ++_n91) {
          var _s83 = cd.nodeKey(_t151, _n91);

          this.containerNodes.has(_s83) && e.push(..._t151.calculateLosses());
        }
      }

      return e;
    });
  }

  getConfig() {
    var e = {
      name: this.name
    },
        t = this.buildNodeConversionMap(this.layers),
        n = [];

    for (var _e157 of this.layers) {
      var _s84 = _e157.getClassName(),
          _r55 = _e157.getConfig(),
          _a45 = [];

      for (var _n92 = 0; _n92 < _e157.inboundNodes.length; _n92++) {
        var _s85 = _e157.inboundNodes[_n92],
            _r56 = cd.nodeKey(_e157, _n92);

        var _i26 = {};

        if (this.containerNodes.has(_r56)) {
          if (_s85.callArgs) try {
            JSON.stringify(_s85.callArgs), _i26 = _s85.callArgs;
          } catch (t) {
            console.warn("Layer ".concat(_e157.name, " was passed non-serializable keyword arguments: ").concat(_s85.callArgs, ". They will not be included in the serialized model (and thus will be missing at deserialization time).")), _i26 = {};
          }

          if (_s85.inboundLayers.length > 0) {
            var _e158 = [];

            for (var _n93 = 0; _n93 < _s85.inboundLayers.length; _n93++) {
              var _r57 = _s85.inboundLayers[_n93],
                  _a46 = _s85.tensorIndices[_n93];
              var _o19 = t[cd.nodeKey(_r57, _s85.nodeIndices[_n93])];
              null == _o19 && (_o19 = 0), _e158.push([_r57.name, _o19, _a46, _i26]);
            }

            _a45.push(_e158);
          }
        }
      }

      var _i25 = {};
      _i25.name = _e157.name, _i25.className = _s84, _i25.config = _r55, _i25.inboundNodes = _a45, n.push(_i25);
    }

    e.layers = n;
    var s = [];

    for (var _e159 = 0; _e159 < this.inputLayers.length; _e159++) {
      var _n94 = this.inputLayers[_e159],
          _r58 = cd.nodeKey(_n94, this.inputLayersNodeIndices[_e159]);

      if (!this.containerNodes.has(_r58)) continue;
      var _a47 = t[_r58];
      null == _a47 && (_a47 = 0), s.push([_n94.name, _a47, this.inputLayersTensorIndices[_e159]]);
    }

    e.inputLayers = s;
    var r = [];

    for (var _e160 = 0; _e160 < this.outputLayers.length; _e160++) {
      var _n95 = this.outputLayers[_e160],
          _s86 = cd.nodeKey(_n95, this.outputLayersNodeIndices[_e160]);

      if (!this.containerNodes.has(_s86)) continue;
      var _a48 = t[_s86];
      null == _a48 && (_a48 = 0), r.push([_n95.name, _a48, this.outputLayersTensorIndices[_e160]]);
    }

    return e.outputLayers = r, e;
  }

  static fromConfig(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = {},
        a = {};

    function i(e, t) {
      e.name in a ? a[e.name].push(t) : a[e.name] = [t];
    }

    function o(e, t) {
      var n = [];
      var s;

      for (var _a49 of t) {
        var _o20 = _a49[0],
            _l13 = _a49[1],
            _u8 = _a49[2];
        if (s = null == _a49[3] ? {} : _a49[3], !(_o20 in r)) return void i(e, t);
        var _c7 = r[_o20];
        if (_c7.inboundNodes.length <= _l13) return void i(e, t);
        n.push(_c7.inboundNodes[_l13].outputTensors[_u8]);
      }

      n.length > 0 && e.apply(Iu(n), s);
    }

    function l(e) {
      var n = e.name,
          a = Eh(e, null != t.customObjects ? t.customObjects : {});
      a.setFastWeightInitDuringBuild(s), r[n] = a, e.inboundNodes.forEach(e => {
        if (!(e instanceof Array)) throw new bu("Corrupted configuration, expected array for nodeData: ".concat(e));
        i(a, e);
      });
    }

    var u = t.name,
        c = t.layers;

    for (var _e161 of c) {
      l(_e161);
    }

    for (; !Du(a);) {
      for (var _e162 of c) {
        var _t152 = r[_e162.name];

        if (_t152.name in a) {
          var _e163 = a[_t152.name];
          delete a[_t152.name];

          for (var _n96 of _e163) {
            o(_t152, _n96);
          }
        }
      }
    }

    var h = [],
        d = [],
        p = t.inputLayers;

    for (var _e164 of p) {
      var _t153 = _e164[0],
          _n97 = _e164[1],
          _s87 = _e164[2];
      wu(_t153 in r), h.push(r[_t153].inboundNodes[_n97].outputTensors[_s87]);
    }

    var f = t.outputLayers;

    for (var _e165 of f) {
      var _t154 = _e165[0],
          _n98 = _e165[1],
          _s88 = _e165[2];
      wu(_t154 in r), d.push(r[_t154].inboundNodes[_n98].outputTensors[_s88]);
    }

    return new e({
      inputs: h,
      outputs: d,
      name: u
    });
  }

  get stateful() {
    if (this._stateful) throw new bu("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");

    for (var _e166 of this.layers) {
      if (_e166.stateful) return !0;
    }

    return !1;
  }

  resetStates() {
    Yn(() => {
      this.layers.forEach(e => {
        e.stateful && e.resetStates();
      });
    });
  }

}

function hd(e, t) {
  return function (e, t, n) {
    var s = t.length;
    if (null == e || Array.isArray(e) && 0 === e.length) return t.map(e => null);
    if (1 === s) return Array.isArray(e) && 1 === e.length ? e : "object" == typeof e && t[0] in e ? [e[t[0]]] : [e];

    if (Array.isArray(e)) {
      if (e.length !== s) throw new Error("Provided classWeight is an array of ".concat(e.length, " element(s), but the model has ").concat(s, " outputs. Make sure a set of weights is provided for each model output."));
      return e;
    }

    if ("object" == typeof e && Object.keys(e).length > 0 && "object" == typeof e[Object.keys(e)[0]]) {
      var _n99 = [];
      return t.forEach(t => {
        _n99.push(t in e ? e[t] : null);
      }), _n99;
    }

    throw new Error("The model has multiple (".concat(s, ") outputs, so classWeight must be either an array with ").concat(s, " elements or an object with ").concat(t, " keys. Provided classWeight not understood: ").concat(JSON.stringify(e)));
  }(e, t);
}

function dd(_x21, _x22, _x23, _x24) {
  return _dd.apply(this, arguments);
}

function _dd() {
  _dd = _asyncToGenerator(function* (e, t, n, s) {
    if (null != t || null != s) throw new Error("Support sampleWeight is not implemented yet");

    if (null != n) {
      var _t427 = Yn(() => {
        if (1 === e.shape.length) return fn(e);

        if (2 === e.shape.length) {
          if (e.shape[1] > 1) return us(e, 1);
          if (1 === e.shape[1]) return Es(e, [e.shape[0]]);
          throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1], ") during handling of class weights. The size is expected to be >= 1."));
        }

        throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank, ") during handling of class weights. The rank is expected to be 1 or 2."));
      }),
          _s247 = Array.from(yield _t427.data());

      Jn(_t427);
      var _r176 = [];
      return _s247.forEach(e => {
        if (null == n[e]) throw new Error("classWeight must contain all classes in the training data. The class ".concat(e, " exists in the data but not in classWeight"));

        _r176.push(n[e]);
      }), mi(_r176, "float32");
    }

    return null;
  });
  return _dd.apply(this, arguments);
}

function pd(e, t) {
  return ss(e, t);
}

function fd(e, t) {
  var n, s;
  n = t.xs, s = t.ys, l(null != n && null != s, () => "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ".concat(t));
  var r = gd("input", e.inputNames, n),
      a = gd("output", e.outputNames, s),
      i = r[0].shape[0];
  l(r.length === e.inputs.length, () => "LayersModel has ".concat(e.inputs.length, " inputs, but the dataset provides ").concat(r.length, " inputs.  (Expected input keys: ").concat(JSON.stringify(e.inputNames), ")")), l(a.length === e.outputs.length, () => "LayersModel has ".concat(e.outputs.length, " outputs, but the dataset provides ").concat(a.length, " outputs.  (Expected output keys: ").concat(JSON.stringify(e.outputNames), ")"));

  var _loop16 = function _loop16(_t155) {
    l(r[_t155].shape[0] === i, () => "Batch size mismatch: input ".concat(e.inputNames[_t155], " has ").concat(r[_t155].shape[0], "; expected  ").concat(i, " based on input ").concat(e.inputNames[0], "."));
  };

  for (var _t155 = 0; _t155 < r.length; _t155++) {
    _loop16(_t155);
  }

  var _loop17 = function _loop17(_t156) {
    l(a[_t156].shape[0] === i, () => "Batch size mismatch: output ".concat(e.outputNames[_t156], " has ").concat(a[_t156].shape[0], "; expected  ").concat(i, " based on input ").concat(e.inputNames[0], "."));
  };

  for (var _t156 = 0; _t156 < a.length; _t156++) {
    _loop17(_t156);
  }

  return {
    xs: r,
    ys: a
  };
}

function gd(e, t, n) {
  if (n instanceof st) return [n];
  if (Array.isArray(n)) return l(n.length === t.length, () => "Received an array of ".concat(n.length, " Tensors, but expected ").concat(t.length, " to match the ").concat(e, " keys ").concat(t, ".")), n;
  {
    var _s89 = [];

    for (var _r59 of t) {
      if (null == n[_r59]) throw new bu("The feature data generated by the dataset lacks the required ".concat(e, " key '").concat(_r59, "'."));

      _s89.push(n[_r59]);
    }

    return _s89;
  }
}

function md(e) {
  return "function" == typeof e.iterator;
}

function bd(e) {
  l(e > 0 && Number.isInteger(e), () => "batchSize is required to be a positive integer, but got ".concat(e));
}

function xd(e, t, n) {
  return null == e ? [null] : Array.isArray(e) ? e.map(e => mc(e, t, n - t)) : mc(e, t, n - t);
}

function yd(e, t) {
  return Yn(() => null == e ? null : Array.isArray(e) ? e.map(e => yd(e, t)) : $c(e, "int32" === t.dtype ? t : pn(t, "int32")));
}

function kd(e, t) {
  var n = [];
  var s = 0,
      r = null;

  for (; s < e;) {
    r = s + t, r >= e && (r = e), n.push([s, r]), s = r;
  }

  return n;
}

function wd(e) {
  var t = [];
  e instanceof st && (e = [e]);

  for (var _n100 = 0; _n100 < e.length; ++_n100) {
    var _s90 = e[_n100];
    if (1 === _s90.rank) t.push(gc(_s90, 1));else {
      if (0 === _s90.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
      t.push(_s90);
    }
  }

  return t;
}

function vd(e, t) {
  if (null == e) return;
  var n = [];
  if (t instanceof st) n.push(t.id);else if (Array.isArray(t)) t.forEach(e => n.push(e.id));else if (null != t) for (var _e167 in t) {
    n.push(t[_e167].id);
  }
  var s = [];
  if (e instanceof st) -1 === n.indexOf(e.id) && s.push(e);else if (Array.isArray(e)) e.forEach(e => {
    -1 === n.indexOf(e.id) && s.push(e);
  });else if (null != e) for (var _t157 in e) {
    var _r60 = e[_t157];
    -1 === n.indexOf(_r60.id) && s.push(_r60);
  }
  s.forEach(e => {
    e.isDisposed || e.dispose();
  });
}

function Id(e) {
  return Array.isArray(e);
}

function $d(e) {
  return !function (e) {
    return e instanceof st;
  }(e) && !Id(e);
}

function Nd(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";

  if (null == t || 0 === t.length) {
    if (null != e) {
      var _t158 = !1;

      if (Id(e) && e.length > 0) _t158 = !0;else if ($d(e)) {
        for (var _n101 in e) {
          if (e.hasOwnProperty(_n101)) {
            _t158 = !0;
            break;
          }
        }
      } else _t158 = !0;
      if (_t158) throw new bu("Error when checking model ".concat(r, " expected no data, but got ").concat(e));
    }

    return [];
  }

  if (null == e) return t.map(e => null);
  var a;

  if ($d(e)) {
    e = e, a = [];

    for (var _n102 of t) {
      if (null == e[_n102]) throw new bu("No data provided for \"".concat(_n102, "\". Need data for each key in: ").concat(t));
      a.push(e[_n102]);
    }
  } else if (Id(e)) {
    if ((e = e).length !== t.length) throw new bu("Error when checking model ".concat(r, ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ").concat(t.length, " Tensor(s), but instead got the following list of Tensor(s): ").concat(e));
    a = e;
  } else {
    if (e = e, t.length > 1) throw new bu("The model ".concat(r, " expects ").concat(t.length, " Tensor(s), but only received one Tensor. Found: Tensor with shape ").concat(e.shape));
    a = [e];
  }

  if (a = wd(a), null != n) for (var _e168 = 0; _e168 < t.length; ++_e168) {
    if (null == n[_e168]) continue;
    var _i27 = a[_e168];
    if (_i27.shape.length !== n[_e168].length) throw new bu("Error when checking ".concat(r, ": expected ").concat(t[_e168], " to have ").concat(n[_e168].length, " dimension(s). but got array with shape ").concat(_i27.shape));

    for (var _a50 = 0; _a50 < n[_e168].length; ++_a50) {
      if (0 === _a50 && !s) continue;
      var _o21 = _i27.shape[_a50],
          _l14 = n[_e168][_a50];
      if (null != _l14 && _l14 >= 0 && _o21 !== _l14) throw new bu("Error when checking ".concat(r, ": expected ").concat(t[_e168], " to have shape [").concat(n[_e168], "], but got array with shape [").concat(_i27.shape, "]."));
    }
  }
  return a;
}

function Cd(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
  var a;

  if (Array.isArray(e)) {
    if (e.length !== t.length) throw new bu("Error when checking model ".concat(r, ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ").concat(t.length, " Tensor(s), but instead got ").concat(e.length, " Tensors(s)."));
    a = e;
  } else {
    if (t.length > 1) throw new bu("The model expects ".concat(t.length, " ").concat(r, " Tensors, but only received one Tensor. Found: array with shape ").concat(JSON.stringify(e.shape), "."));
    a = [e];
  }

  if (null != n) for (var _e169 = 0; _e169 < t.length; ++_e169) {
    if (null == n[_e169]) continue;
    var _i28 = a[_e169];
    if (_i28.shape.length !== n[_e169].length) throw new bu("Error when checking ".concat(r, ": expected ").concat(t[_e169], " to have ").concat(n[_e169].length, " dimension(s), but got array with shape ").concat(JSON.stringify(_i28.shape)));

    for (var _a51 = 0; _a51 < n[_e169].length; ++_a51) {
      if (0 === _a51 && !s) continue;
      var _o22 = _i28.shape[_a51],
          _l15 = n[_e169][_a51];
      if (null != _l15 && _l15 !== _o22) throw new bu("Error when checking ".concat(r, ": expected ").concat(t[_e169], " to have shape ").concat(JSON.stringify(n[_e169]), " but got array with shape ").concat(JSON.stringify(_i28.shape), "."));
    }
  }
}

class Sd extends cd {
  constructor(e) {
    super(e), this.isTraining = !1;
  }

  summary(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;
    if (!this.built) throw new bu("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
    !function (e, t, n) {
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : console.log;

      var r = function (e) {
        var t = !0;
        var n = [],
            s = [];

        for (var _t159 in e.nodesByDepth) {
          n.push(e.nodesByDepth[_t159]);
        }

        for (var _e170 of n) {
          if (_e170.length > 1 || 1 === _e170.length && _e170[0].inboundLayers.length > 1) {
            t = !1;
            break;
          }

          s.push(..._e170);
        }

        if (t) for (var _n103 of e.layers) {
          var _e171 = !1;

          for (var _r61 of _n103.inboundNodes) {
            if (-1 !== s.indexOf(_r61)) {
              if (_e171) {
                t = !1;
                break;
              }

              _e171 = !0;
            }
          }

          if (!t) break;
        }
        return t;
      }(e),
          a = ["Layer (type)", "Output shape", "Param #"];

      var i;

      if (r ? (t = t || 65, n = n || [.45, .85, 1]) : (t = t || 98, n = n || [.33, .55, .67, 1]), n[n.length - 1] <= 1 && (n = n.map(e => Math.floor(t * e))), !r) {
        a.push("Receives inputs"), i = [];

        for (var _t160 in e.nodesByDepth) {
          i.push(...e.nodesByDepth[_t160]);
        }
      }

      s("_".repeat(t)), Jh(a, n, s), s("=".repeat(t));
      var o = e.layers;

      for (var _e172 = 0; _e172 < o.length; ++_e172) {
        r ? Zh(o[_e172], n, s) : Qh(o[_e172], n, i, s), s((_e172 === o.length - 1 ? "=" : "_").repeat(t));
      }

      e.checkTrainableWeightsConsistency();

      var l = function (e) {
        var t;
        return t = ih(null != e.collectedTrainableWeights ? e.collectedTrainableWeights : e.trainableWeights), t;
      }(e),
          u = ih(e.nonTrainableWeights);

      s("Total params: ".concat(l + u)), s("Trainable params: ".concat(l)), s("Non-trainable params: ".concat(u)), s("_".repeat(t));
    }(this, e, t, n);
  }

  compile(e) {
    var _this57 = this;

    if (null == e.loss && (e.loss = []), this.loss = e.loss, "string" == typeof e.optimizer) this.optimizer_ = function (e) {
      var t = {
        Adagrad: () => Io.adagrad(.01),
        Adadelta: () => Io.adadelta(1, .95, fu()),
        Adam: () => Io.adam(.001, .9, .999, fu()),
        Adamax: () => Io.adamax(.002, .9, .999, fu(), 0),
        RMSProp: () => Io.rmsprop(.001, .9, 0, fu()),
        SGD: () => Io.sgd(.01)
      };
      if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e in t) return t[e]();
      throw new bu("Unknown Optimizer ".concat(e));
    }(e.optimizer), this.isOptimizerOwned = !0;else {
      if (!(e.optimizer instanceof fo)) throw new bu("User-defined optimizer must be an instance of tf.Optimizer.");
      this.optimizer_ = e.optimizer, this.isOptimizerOwned = !1;
    }
    var t = [];
    if (Array.isArray(e.loss) || "string" == typeof e.loss || "function" == typeof e.loss) {
      if (Array.isArray(e.loss)) {
        if (e.loss.length !== this.outputs.length) throw new bu("When passing an Array as loss, it should have one entry per model output. The model has ".concat(this.outputs.length, " output(s), but you passed loss=").concat(e.loss, "."));
        t = e.loss.map(e => Bh(e));
      } else {
        var _n104 = Bh(e.loss);

        this.outputs.forEach(e => {
          t.push(_n104);
        });
      }
    } else {
      e.loss = e.loss;

      for (var _t161 in e.loss) {
        if (-1 === this.outputNames.indexOf(_t161)) throw new bu("Unknown entry in loss dictionary: \"".concat(_t161, "\". Only expected the following keys: ").concat(this.outputNames));
      }

      for (var _n105 of this.outputNames) {
        null == e.loss[_n105] && console.warn("Output \"".concat(_n105, "\" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ").concat(_n105, " during training")), t.push(Bh(e.loss[_n105]));
      }
    }
    this.lossFunctions = t, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];

    for (var _e173 = 0; _e173 < this.outputs.length; ++_e173) {
      var _t162 = this.internalOutputShapes[_e173];
      this.feedOutputNames.push(this.outputNames[_e173]), this.feedOutputShapes.push(_t162), this.feedLossFns.push(this.lossFunctions[_e173]);
    }

    var n = [];
    this.metrics = e.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], ac("loss", () => {
      for (var _e174 = 0; _e174 < this.outputs.length; ++_e174) {
        if (-1 !== n.indexOf(_e174)) continue;
        var _t163 = this.lossFunctions[_e174];
        this.outputs.length > 1 && (this.metricsTensors.push([_t163, _e174]), this.metricsNames.push(this.outputNames[_e174] + "_loss"));
      }
    });

    var s = function (e, t) {
      if (null == e || Array.isArray(e) && 0 === e.length) return t.map(e => []);
      var n;
      if ("string" == typeof e || "function" == typeof e) n = [e];else {
        if (!Array.isArray(e) && "object" != typeof e) throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ".concat(e));
        n = e;
      }
      if (Array.isArray(n)) return t.map(e => n);
      {
        var _e175 = [];

        for (var _s91 of t) {
          var _t164 = n.hasOwnProperty(_s91) ? n[_s91] : [];

          Array.isArray(_t164) || (_t164 = [_t164]), _e175.push(_t164);
        }

        return _e175;
      }
    }(e.metrics, this.outputNames),
        r = (e, t, n) => {
      this.outputNames.length > 1 && (t = this.outputNames[e] + "_" + t), this.metricsNames.push(t), this.metricsTensors.push([n, e]);
    };

    ac("metric", () => {
      var _loop18 = function _loop18(_e176) {
        -1 === n.indexOf(_e176) && (t => {
          var n, s, a;

          for (var _i29 of t) {
            if ("string" == typeof _i29 && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(_i29)) {
              var _t166 = _this57.internalOutputShapes[_e176];

              var _r62 = void 0;

              1 === _t166[_t166.length - 1] || _this57.lossFunctions[_e176] === Mh ? -1 !== ["accuracy", "acc"].indexOf(_i29) ? s = Ph : -1 !== ["crossentropy", "ce"].indexOf(_i29) && (s = Uh) : _this57.lossFunctions[_e176] === Oh ? -1 !== ["accuracy", "acc"].indexOf(_i29) ? s = Vh : -1 !== ["crossentropy", "ce"].indexOf(_i29) && (s = Hh) : -1 !== ["accuracy", "acc"].indexOf(_i29) ? s = Wh : -1 !== ["crossentropy", "ce"].indexOf(_i29) && (s = Gh), -1 !== ["accuracy", "acc"].indexOf(_i29) ? _r62 = "acc" : -1 !== ["crossentropy", "ce"].indexOf(_i29) && (_r62 = "ce"), a = s, n = "" + _r62;
            } else {
              var _e177 = qh(_i29);

              a = _e177, n = "" + Kh(_i29);
            }

            var _t165 = void 0;

            ac(n, () => {
              _t165 = a;
            }), r(_e176, n, _t165);
          }
        })(s[_e176]);
      };

      for (var _e176 = 0; _e176 < this.outputs.length; ++_e176) {
        _loop18(_e176);
      }
    }), this.collectedTrainableWeights = this.trainableWeights;
  }

  checkTrainableWeightsConsistency() {
    null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
  }

  evaluate(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = null == n.batchSize ? 32 : n.batchSize;
    bd(s);
    var r = this.standardizeUserDataXY(e, t, !0, s);

    try {
      var _a52 = r[0].concat(r[1]);

      return this.makeTestFunction(), Iu(this.testLoop(this.testFunction, _a52, s, n.verbose, n.steps));
    } finally {
      vd(r[0], e), vd(r[1], t);
    }
  }

  evaluateDataset(e, t) {
    var _this58 = this;

    return _asyncToGenerator(function* () {
      return _this58.makeTestFunction(), function () {
        var _ref5 = _asyncToGenerator(function* (e, t, n) {
          var s = null != (n = n || {}).batches,
              r = e.testFunction;
          var a = [];
          if (n.verbose > 0) throw new xu("Verbose mode is not implemented yet.");
          l(!s || n.batches > 0 && Number.isInteger(n.batches), () => "Test loop expects `batches` to be a positive integer, but received ".concat(JSON.stringify(n.batches)));
          var i = "function" == typeof t.next ? t : yield t.iterator();
          var o = 0,
              u = 0;

          var _loop19 = function* _loop19() {
            var t = yield i.next();

            if (a = Yn(() => {
              if (t.value) {
                (function () {
                  var {
                    xs: n,
                    ys: s
                  } = fd(e, t.value),
                      i = n.concat(s),
                      l = Yn(() => r(i));
                  if (Jn(i), 0 === u) for (var _e179 = 0; _e179 < l.length; ++_e179) {
                    a.push(qa(0));
                  }
                  var c = i[0].shape[0];

                  var _loop20 = function _loop20(_e180) {
                    var t = l[_e180],
                        n = a[_e180];
                    a[_e180] = Yn(() => es(a[_e180], ss(c, t))), u > 0 && Jn(n);
                  };

                  for (var _e180 = 0; _e180 < l.length; ++_e180) {
                    _loop20(_e180);
                  }

                  Jn(l), o += c, ++u;
                })();
              }

              return a;
            }), t.done) {
              s && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, ".concat(n.batches, " batches). You may need to use the repeat() function when building your dataset."));
              return "break";
            }
          };

          for (; !s || u < n.batches;) {
            var _ret = yield* _loop19();

            if (_ret === "break") break;
          }

          for (var _e178 = 0; _e178 < a.length; ++_e178) {
            var _t167 = a[_e178];
            a[_e178] = ns(a[_e178], o), Jn(_t167);
          }

          return Iu(a);
        });

        return function (_x25, _x26, _x27) {
          return _ref5.apply(this, arguments);
        };
      }()(_this58, e, t);
    })();
  }

  checkNumSamples(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "steps";
    var r;

    if (null != n) {
      if (r = null, null != t) throw new bu("If ".concat(s, " is set, batchSize must be null or undefined.Got batchSize = ").concat(t));
    } else {
      if (null == e) throw new bu("Either the input data should have a defined shape, or ".concat(s, " shoud be specified."));
      r = Array.isArray(e) ? e[0].shape[0] : e.shape[0];
    }

    return r;
  }

  execute(e, t) {
    if (Array.isArray(t) && 0 === t.length) throw new bu("`outputs` is an empty Array, which is not allowed.");
    var n = Array.isArray(t),
        s = this.retrieveSymbolicTensors(n ? t : [t]),
        r = new sd();

    if (e instanceof st && (e = [e]), Array.isArray(e)) {
      if (e.length !== this.inputs.length) throw new bu("The number of inputs provided (".concat(e.length, ") does not match the number of inputs of this model (").concat(this.inputs.length, ")."));

      for (var _t168 = 0; _t168 < this.inputs.length; ++_t168) {
        r.add(this.inputs[_t168], e[_t168]);
      }
    } else for (var _t169 of this.inputs) {
      var _n106 = e[_t169.name];
      if (null == _n106) throw new bu("No value is provided for the model's input ".concat(_t169.name));
      r.add(_t169, _n106);
    }

    var a = id(s, r);
    return n ? a : a[0];
  }

  retrieveSymbolicTensors(e) {
    var t = ku(null, e.length);
    var n = e.length;

    for (var _s92 of this.layers) {
      var _r63 = Array.isArray(_s92.output) ? _s92.output : [_s92.output],
          _a53 = _r63.map(e => e.name);

      for (var _s93 = 0; _s93 < e.length; ++_s93) {
        var _i30 = _a53.indexOf(e[_s93]);

        if (-1 !== _i30 && (t[_s93] = _r63[_i30], n--), 0 === n) break;
      }

      if (0 === n) break;
    }

    if (n > 0) {
      var _n107 = [];
      throw t.forEach((t, s) => {
        null == t && _n107.push(e[s]);
      }), new bu("Cannot find SymbolicTensors for output name(s): ".concat(JSON.stringify(_n107)));
    }

    return t;
  }

  predictLoop(e) {
    var _this59 = this;

    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    return Yn(() => {
      var s = this.checkNumSamples(e);
      if (n) throw new xu("Verbose predictLoop() is not implemented yet.");
      var r = kd(s, t),
          a = this.outputs.map(e => []);

      var _loop21 = function _loop21(_t170) {
        Yn(() => {
          var n = xd(e, r[_t170][0], r[_t170][1]),
              s = [];
          if (Array.isArray(n)) for (var _e181 = 0; _e181 < n.length; ++_e181) {
            s.push({
              key: _this59.inputs[_e181],
              value: n[_e181]
            });
          } else s.push({
            key: _this59.inputs[0],
            value: n
          });
          var a = new sd(s);
          return id(_this59.outputs, a);
        }).forEach((e, t) => a[t].push(e));
      };

      for (var _t170 = 0; _t170 < r.length; ++_t170) {
        _loop21(_t170);
      }

      return Iu(a.map(e => Fs(e, 0)));
    });
  }

  predict(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var n = wd(e);
    Cd(n, this.inputNames, this.feedInputShapes, !1);

    try {
      var _s94 = null == t.batchSize ? 32 : t.batchSize;

      return bd(_s94), this.predictLoop(n, _s94);
    } finally {
      vd(n, e);
    }
  }

  predictOnBatch(e) {
    Cd(e, this.inputNames, this.feedInputShapes, !0);
    var t = (Array.isArray(e) ? e[0] : e).shape[0];
    return this.predictLoop(e, t);
  }

  standardizeUserDataXY(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    if (null == this.optimizer_) throw new mu("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
    var r = [];

    for (var _e182 = 0; _e182 < this.feedOutputShapes.length; ++_e182) {
      var _t171 = this.feedOutputShapes[_e182];
      r.push(this.feedLossFns[_e182] === Oh ? _t171.slice(0, _t171.length - 1).concat([1]) : _t171);
    }

    if (function (e, t, n) {
      var s = Fu(e.map(e => e.shape[0]));
      s.sort();
      var r = Fu(t.map(e => e.shape[0]));
      if (r.sort(), s.length > 1) throw new bu("All input Tensors (x) should have the same number of samples. Got array shapes: ".concat(JSON.stringify(e.map(e => e.shape))));
      if (r.length > 1) throw new bu("All target Tensors (y) should have the same number of samples. Got array shapes: ".concat(JSON.stringify(t.map(e => e.shape))));
      if (s.length > 0 && r.length > 0 && !p(s, r)) throw new bu("Input Tensors should have the same number of samples as target Tensors. Found ".concat(s[0], " input sample(s) and ").concat(r[0], " target sample(s)."));
    }(e = Nd(e, this.feedInputNames, this.feedInputShapes, !1, "input"), t = Nd(t, this.feedOutputNames, r, !1, "target")), function (e, t, n) {
      var s = [Ah, Mh, _h];

      for (var _r64 = 0; _r64 < e.length; ++_r64) {
        var _a54 = e[_r64],
            _i31 = t[_r64],
            _o23 = n[_r64];

        if (null != _i31) {
          if (_i31 === _h && 1 === _a54.shape[_a54.shape.length - 1]) throw new bu("You are passing a target array of shape ".concat(_a54.shape, " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes]."));

          if (-1 !== s.indexOf(_i31)) {
            var _e183 = _a54.shape.slice(1),
                _t172 = _o23.slice(1);

            for (var _n108 = 0; _n108 < _e183.length; ++_n108) {
              var _s95 = _e183[_n108],
                  _r65 = _t172[_n108];
              if (null != _r65 && _s95 !== _r65) throw new bu("A target Tensor with shape ".concat(_a54.shape, " was passed for an output of shape ").concat(_o23, ", while using a loss function that expects targets to have the same shape as the output."));
            }
          }
        }
      }
    }(t, this.feedLossFns, this.feedOutputShapes), this.stateful && null != s && s > 0 && e[0].shape[0] % s != 0) throw new bu("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ".concat(s, ". Found: ").concat(e[0].shape[0], " sample(s)."));
    return [e, t];
  }

  standardizeUserData(e, t, n, s) {
    var _arguments = arguments,
        _this60 = this;

    return _asyncToGenerator(function* () {
      var r = _arguments.length > 4 && _arguments[4] !== undefined ? _arguments[4] : !0;
      var a = _arguments.length > 5 ? _arguments[5] : undefined;

      var [i, o] = _this60.standardizeUserDataXY(e, t, r, a);

      if (null != n) throw new Error("sample weight is not supported yet.");
      var l = null;

      if (null != s) {
        var _e184 = hd(s, _this60.outputNames);

        l = [];

        for (var _t173 = 0; _t173 < _e184.length; ++_t173) {
          l.push(yield dd(o[_t173], null, _e184[_t173]));
        }
      }

      return [i, o, l];
    })();
  }

  testLoop(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    return Yn(() => {
      var a = this.checkNumSamples(t, n, r, "steps"),
          i = [];
      if (s > 0) throw new xu("Verbose mode is not implemented yet.");
      if (null != r) throw new xu("steps mode in testLoop() is not implemented yet");
      {
        var _s96 = kd(a, n),
            _r66 = mi(pc(0, a));

        for (var _n109 = 0; _n109 < _s96.length; ++_n109) {
          var _a55 = _s96[_n109][0],
              _o24 = _s96[_n109][1],
              _l16 = mc(_r66, _a55, _o24 - _a55),
              _u9 = yd(t, _l16),
              _c8 = e(_u9);

          if (0 === _n109) for (var _e185 = 0; _e185 < _c8.length; ++_e185) {
            i.push(qa(0));
          }

          for (var _e186 = 0; _e186 < _c8.length; ++_e186) {
            i[_e186] = es(i[_e186], ss(_o24 - _a55, _c8[_e186]));
          }
        }

        for (var _e187 = 0; _e187 < i.length; ++_e187) {
          i[_e187] = ns(i[_e187], a);
        }
      }
      return i;
    });
  }

  getDedupedMetricsNames() {
    var e = this.metricsNames,
        t = [];

    for (var _n110 = 0; _n110 < e.length; ++_n110) {
      var _s97 = e[_n110];
      var _r67 = _s97;
      vu(e, _s97) > 1 && (_r67 += "_".concat(vu(e.slice(0, _n110), _s97))), t.push(_r67);
    }

    return t;
  }

  makeTrainFunction() {
    return e => {
      var t = [],
          n = e.slice(0, this.inputs.length),
          s = e.slice(this.inputs.length, this.inputs.length + this.outputs.length),
          r = e.slice(this.inputs.length + this.outputs.length, this.inputs.length + 2 * this.outputs.length),
          a = [],
          i = this.collectedTrainableWeights.map(e => e.read());
      return [this.optimizer_.minimize(() => {
        var e = [];

        for (var _t174 = 0; _t174 < this.inputs.length; ++_t174) {
          e.push({
            key: this.inputs[_t174],
            value: n[_t174]
          });
        }

        var i = new sd(e),
            o = id(this.outputs, i, {
          training: !0
        });
        var l;

        for (var _e188 = 0; _e188 < this.lossFunctions.length; ++_e188) {
          var _n111 = (0, this.lossFunctions[_e188])(s[_e188], o[_e188]);

          null != r[_e188] && (_n111 = pd(_n111, r[_e188]));

          var _a56 = la(_n111);

          t.push(_a56), l = 0 === _e188 ? _n111 : es(l, _n111);
        }

        for (var _e189 = 0; _e189 < this.metricsTensors.length; ++_e189) {
          var _n112 = void 0;

          if (this.outputs.length > 1 && _e189 < this.outputs.length) _n112 = t[_e189];else {
            var _t175 = this.metricsTensors[_e189][1];
            _n112 = la((0, this.metricsTensors[_e189][0])(s[_t175], o[_t175]));
          }
          Zn(_n112), a.push(_n112);
        }

        return l = la(l), this.calculateLosses().forEach(e => {
          l = es(l, e);
        }), l;
      }, !0, i)].concat(a);
    };
  }

  makeTestFunction() {
    this.testFunction = e => Yn(() => {
      var t = [];
      var n;
      var s = e.slice(0, this.inputs.length),
          r = e.slice(this.inputs.length, this.inputs.length + this.outputs.length),
          a = [];

      for (var _e190 = 0; _e190 < this.inputs.length; ++_e190) {
        a.push({
          key: this.inputs[_e190],
          value: s[_e190]
        });
      }

      var i = new sd(a),
          o = id(this.outputs, i);

      for (var _e191 = 0; _e191 < this.lossFunctions.length; ++_e191) {
        var _s98 = la((0, this.lossFunctions[_e191])(r[_e191], o[_e191]));

        n = 0 === _e191 ? _s98 : es(n, _s98), t.push(n);
      }

      for (var _e192 = 0; _e192 < this.metricsTensors.length; ++_e192) {
        var _n113 = this.metricsTensors[_e192][1],
            _s99 = la((0, this.metricsTensors[_e192][0])(r[_n113], o[_n113]));

        t.push(_s99);
      }

      return t;
    });
  }

  fit(e, t) {
    var _arguments2 = arguments,
        _this61 = this;

    return _asyncToGenerator(function* () {
      var n = _arguments2.length > 2 && _arguments2[2] !== undefined ? _arguments2[2] : {};
      return function () {
        var _ref6 = _asyncToGenerator(function* (e, t, n) {
          var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
          if (e.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
          var a, i, o, l, u, c, h;
          e.isTraining = !0;

          try {
            var _d5 = null == s.batchSize ? 32 : s.batchSize;

            bd(_d5);

            var _p5 = !1,
                _f4 = yield e.standardizeUserData(t, n, s.sampleWeight, s.classWeight, _p5, _d5);

            a = _f4[0], i = _f4[1], h = _f4[2];

            var _g6,
                _m5 = !1;

            if (null != s.validationData && s.validationData.length > 0) {
              if (_m5 = !0, 2 !== s.validationData.length) throw 3 === s.validationData.length ? new xu("validationData including sample weights is not supported yet.") : new bu("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ".concat(s.validationData, " is invalid."));
              o = s.validationData[0], l = s.validationData[1];

              var _t176 = !0,
                  _n114 = yield e.standardizeUserData(o, l, null, null, _t176, _d5);

              u = _n114[0], c = _n114[1], _g6 = u.concat(c);
            } else if (null != s.validationSplit && s.validationSplit > 0 && s.validationSplit < 1) {
              _m5 = !0;

              var _e193 = Math.floor(a[0].shape[0] * (1 - s.validationSplit)),
                  _t177 = a[0].shape[0];

              u = xd(a, _e193, _t177), a = xd(a, 0, _e193), c = xd(i, _e193, _t177), i = xd(i, 0, _e193), _g6 = u.concat(c);
            } else null != s.validationSteps && (_m5 = !0);

            var _b5 = a.concat(i).concat(h);

            e.checkTrainableWeightsConsistency();

            var _x31 = e.makeTrainFunction(),
                _y5 = e.getDedupedMetricsNames();

            var _k3, _w2;

            _m5 ? (e.makeTestFunction(), _k3 = e.testFunction, _w2 = _y5.slice().concat(_y5.map(e => "val_" + e))) : (_k3 = null, _g6 = [], _w2 = _y5.slice());

            var _v2 = Ch(s.callbacks, s.yieldEvery);

            return yield function () {
              var _ref7 = _asyncToGenerator(function* (e, t, n, s, a, i, o, l, u, c, h, d, p, f, g) {
                null == a && (a = 32), null == i && (i = 1), null == h && (h = !0), null == p && (p = 0);
                var m = !1;
                null != u && null != c && (m = !0);
                var b = e.checkNumSamples(n, a, null, "steps_per_epoch");
                var x;
                null != b && (x = pc(0, b)), null == o && (o = 1);
                var {
                  callbackList: y,
                  history: k
                } = Th(l, o, i, p, b, null, a, m, d);
                y.setModel(e), e.history = k, yield y.onTrainBegin(), e.stopTraining_ = !1;

                var _loop22 = function* _loop22(_o25) {
                  yield y.onEpochBegin(_o25);
                  var i = {};
                  {
                    yield* function* () {
                      if ("batch" === h) throw new xu("batch shuffling is not implemneted yet");
                      h && r(x);
                      var o = mi(x),
                          l = kd(b, a);

                      var _loop23 = function* _loop23(_r68) {
                        var h = {};
                        if (yield y.onBatchBegin(_r68, h), Yn(() => {
                          var d = l[_r68][0],
                              p = l[_r68][1],
                              f = mc(o, d, p - d);
                          h.batch = _r68, h.size = p - d;
                          var g = yd(n, f),
                              b = t(g);

                          for (var _e194 = 0; _e194 < s.length; ++_e194) {
                            var _t178 = b[_e194];
                            h[s[_e194]] = _t178, Zn(_t178);
                          }

                          if (_r68 === l.length - 1 && m) {
                            var _t179 = e.testLoop(u, c, a);

                            for (var _e195 = 0; _e195 < s.length; ++_e195) {
                              var _n115 = s[_e195],
                                  _r69 = _t179[_e195];
                              Zn(_r69), i["val_" + _n115] = _r69;
                            }
                          }
                        }), yield y.onBatchEnd(_r68, h), yh(h), e.stopTraining_) return "break";
                      };

                      for (var _r68 = 0; _r68 < l.length; ++_r68) {
                        var _ret3 = yield* _loop23(_r68);

                        if (_ret3 === "break") break;
                      }

                      o.dispose();
                    }();
                  }
                  if (yield y.onEpochEnd(_o25, i), e.stopTraining_) return "break";
                };

                for (var _o25 = p; _o25 < i; ++_o25) {
                  var _ret2 = yield* _loop22(_o25);

                  if (_ret2 === "break") break;
                }

                return yield y.onTrainEnd(), yield e.history.syncData(), e.history;
              });

              return function (_x32, _x33, _x34, _x35, _x36, _x37, _x38, _x39, _x40, _x41, _x42, _x43, _x44, _x45, _x46) {
                return _ref7.apply(this, arguments);
              };
            }()(e, _x31, _b5, _y5, _d5, s.epochs, s.verbose, _v2, _k3, _g6, s.shuffle, _w2, s.initialEpoch);
          } finally {
            e.isTraining = !1, vd(a, t), vd(i, n), vd(u, o), vd(c, l), null != h && Jn(h);
          }
        });

        return function (_x28, _x29, _x30) {
          return _ref6.apply(this, arguments);
        };
      }()(_this61, e, t, n);
    })();
  }

  fitDataset(e, t) {
    var _this62 = this;

    return _asyncToGenerator(function* () {
      return function () {
        var _ref8 = _asyncToGenerator(function* (e, t, n) {
          var s = null != n.batchesPerEpoch;
          if (l(null != e.optimizer, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."), l(null != n, () => "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."), l(null != n.epochs && n.epochs > 0 && Number.isInteger(n.epochs), () => "For fitDataset(), config.epochs is expected to be a positive integer, but got ".concat(n.epochs)), l(!s || n.batchesPerEpoch > 0 && Number.isInteger(n.batchesPerEpoch), () => "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ".concat(n.batchesPerEpoch)), l(null == n.validationSplit, () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."), e.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
          e.isTraining = !0;

          try {
            var _r70 = null != n.validationData;

            var _a57, _i32;

            if (_r70) if (md(n.validationData)) l(null == n.validationBatches || n.validationBatches > 0 && Number.isInteger(n.validationBatches), () => "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ".concat(n.validationBatches));else {
              var _e196 = function (e) {
                if (3 === e.length) throw new xu("Validation with sample weights is not implemented yet.");
                return {
                  xs: e[0],
                  ys: e[1]
                };
              }(n.validationData);

              _a57 = _e196.xs, _i32 = _e196.ys;
            }

            var _o26 = e.makeTrainFunction(),
                _u10 = e.getDedupedMetricsNames();

            var _c9;

            _c9 = _r70 ? _u10.slice().concat(_u10.map(e => "val_" + e)) : _u10.slice();

            var _h6 = Ch(n.callbacks, n.yieldEvery),
                _d6 = null == n.verbose ? 1 : n.verbose,
                {
              callbackList: _p6,
              history: _f5
            } = Th(_h6, _d6, n.epochs, null, null, function (e, t) {
              var n = null;
              return null != t.batchesPerEpoch ? n = t.batchesPerEpoch : Number.isFinite(e.size) && (n = e.size), n;
            }(t, n), null, _r70, _c9);

            _p6.setModel(e), e.history = _f5, yield _p6.onTrainBegin(), e.stopTraining_ = !1;

            var _g7 = null == n.initialEpoch ? 0 : n.initialEpoch,
                _m6 = yield t.iterator();

            for (; _g7 < n.epochs;) {
              var _l17 = {};
              yield _p6.onEpochBegin(_g7);
              var _c10 = 0,
                  _h7 = 0;

              for (s || (_m6 = yield t.iterator()); !s || _c10 < n.batchesPerEpoch;) {
                var _t180 = yield _m6.next();

                if (s && _t180.done) {
                  console.warn("You provided `batchesPerEpoch` as ".concat(n.batchesPerEpoch, ", but your dataset iterator ran out of data after ").concat(_c10, " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, ") + n.batchesPerEpoch * n.epochs + " batches). You may need to use the repeat() function when building your dataset.");
                  break;
                }

                if (null != _t180.value) {
                  var {
                    xs: _s100,
                    ys: _r71
                  } = fd(e, _t180.value),
                      _a58 = {};
                  _a58.batch = _h7, _a58.size = _s100[0].shape[0], yield _p6.onBatchBegin(_h7, _a58);
                  var _i33 = [];

                  if (null != n.classWeight) {
                    var _t181 = hd(n.classWeight, e.outputNames);

                    for (var _e197 = 0; _e197 < _t181.length; ++_e197) {
                      _i33.push(yield dd(_r71[_e197], null, _t181[_e197]));
                    }
                  }

                  var _l18 = _s100.concat(_r71).concat(_i33),
                      _d7 = _o26(_l18);

                  Jn(_l18);

                  for (var _e198 = 0; _e198 < _u10.length; ++_e198) {
                    var _t182 = _d7[_e198];
                    _a58[_u10[_e198]] = _t182, Zn(_t182);
                  }

                  yield _p6.onBatchEnd(_h7, _a58), yh(_a58), _h7++, _c10++;
                }

                if (s ? _c10 >= n.batchesPerEpoch : _t180.done) {
                  if (_r70) {
                    var _t183 = void 0;

                    _t183 = md(n.validationData) ? $u(yield e.evaluateDataset(n.validationData, {
                      batches: n.validationBatches
                    })) : $u(e.evaluate(_a57, _i32, {
                      batchSize: null == n.validationBatchSize ? 32 : n.validationBatchSize,
                      verbose: 0
                    }));

                    for (var _n116 = 0; _n116 < e.metricsNames.length; ++_n116) {
                      _l17["val_".concat(e.metricsNames[_n116])] = _t183[_n116];
                    }
                  }

                  break;
                }

                if (e.stopTraining_) break;
              }

              if (yield _p6.onEpochEnd(_g7, _l17), _g7++, e.stopTraining_) break;
            }

            return yield _p6.onTrainEnd(), yield e.history.syncData(), e.history;
          } finally {
            e.isTraining = !1;
          }
        });

        return function (_x47, _x48, _x49) {
          return _ref8.apply(this, arguments);
        };
      }()(_this62, e, t);
    })();
  }

  trainOnBatch(e, t) {
    var _this63 = this;

    return _asyncToGenerator(function* () {
      var n = yield _this63.standardizeUserData(e, t),
          s = n[0],
          r = n[1],
          a = _this63.makeTrainFunction()(s.concat(r)),
          i = [];

      for (var _e199 of a) {
        var _t184 = yield _e199.data();

        i.push(_t184[0]);
      }

      return Jn(a), Iu(i);
    })();
  }

  getNamedWeights(e) {
    var t = [],
        n = null != e && e.trainableOnly,
        s = n ? this.trainableWeights : this.weights,
        r = this.getWeights(n);

    for (var _e200 = 0; _e200 < s.length; ++_e200) {
      n && !s[_e200].trainable || t.push({
        name: s[_e200].originalName,
        tensor: r[_e200]
      });
    }

    return t;
  }

  set stopTraining(e) {
    this.stopTraining_ = e;
  }

  get stopTraining() {
    return this.stopTraining_;
  }

  get optimizer() {
    return this.optimizer_;
  }

  set optimizer(e) {
    this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = !1);
  }

  dispose() {
    var e = super.dispose();

    if (0 === e.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
      var _t185 = Xn().numTensors;
      this.optimizer_.dispose(), e.numDisposedVariables += _t185 - Xn().numTensors;
    }

    return e;
  }

  getLossIdentifiers() {
    var e;
    if ("string" == typeof this.loss) e = Nu(this.loss);else if (Array.isArray(this.loss)) {
      for (var _e201 of this.loss) {
        if ("string" != typeof _e201) throw new Error("Serialization of non-string loss is not supported.");
      }

      e = this.loss.map(e => Nu(e));
    } else {
      var _t186 = Object.keys(this.loss);

      e = {};
      var _n117 = this.loss;

      for (var _s101 of _t186) {
        if ("string" != typeof _n117[_s101]) throw new Error("Serialization of non-string loss is not supported.");
        e[_s101] = Nu(_n117[_s101]);
      }
    }
    return e;
  }

  getMetricIdentifiers() {
    if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [Nu(Kh(this.metrics))];
    if (Array.isArray(this.metrics)) return this.metrics.map(e => Nu(Kh(e)));
    {
      var _e202 = {};

      for (var _t187 in this.metrics) {
        _e202[_t187] = Nu(Kh(this.metrics[_t187]));
      }

      return _e202;
    }
  }

  getTrainingConfig() {
    return {
      loss: this.getLossIdentifiers(),
      metrics: this.getMetricIdentifiers(),
      optimizer_config: {
        class_name: this.optimizer.getClassName(),
        config: this.optimizer.getConfig()
      }
    };
  }

  loadTrainingConfig(e) {
    if (null != e.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
    if (null != e.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
    if (null != e.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
    var t = Eh(td(e.optimizer_config));
    var n, s;
    if ("string" == typeof e.loss) n = Cu(e.loss);else if (Array.isArray(e.loss)) n = e.loss.map(e => Cu(e));else if (null != e.loss) {
      n = {};

      for (var _t188 in e.loss) {
        n[_t188] = Cu(e.loss[_t188]);
      }
    }
    if (Array.isArray(e.metrics)) s = e.metrics.map(e => Cu(e));else if (null != e.metrics) {
      s = {};

      for (var _t189 in e.metrics) {
        s[_t189] = Cu(e.metrics[_t189]);
      }
    }
    this.compile({
      loss: n,
      metrics: s,
      optimizer: t
    });
  }

  save(e, t) {
    var _this64 = this;

    return _asyncToGenerator(function* () {
      if ("string" == typeof e) {
        var _t190 = Gt.getSaveHandlers(e);

        if (0 === _t190.length) throw new bu("Cannot find any save handlers for URL '".concat(e, "'"));
        if (_t190.length > 1) throw new bu("Found more than one (".concat(_t190.length, ") save handlers for URL '").concat(e, "'"));
        e = _t190[0];
      }

      if (null == e.save) throw new bu("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
      var n = yield Mt(_this64.getNamedWeights(t)),
          s = {
        modelTopology: _this64.toJSON(null, !1),
        format: "layers-model",
        generatedBy: "TensorFlow.js tfjs-layers v3.8.0",
        convertedBy: null
      };

      if (null != t && t.includeOptimizer && null != _this64.optimizer) {
        s.trainingConfig = _this64.getTrainingConfig();
        var _e203 = "optimizer",
            {
          data: _t191,
          specs: _r72
        } = yield Mt(yield _this64.optimizer.getWeights(), _e203);
        n.specs.push(..._r72), n.data = Pt([n.data, _t191]);
      }

      return null != _this64.userDefinedMetadata && (Xh(_this64.userDefinedMetadata, _this64.name, !0), s.userDefinedMetadata = _this64.userDefinedMetadata), s.weightData = n.data, s.weightSpecs = n.specs, e.save(s);
    })();
  }

  setUserDefinedMetadata(e) {
    Xh(e, this.name), this.userDefinedMetadata = e;
  }

  getUserDefinedMetadata() {
    return this.userDefinedMetadata;
  }

}

Sd.className = "Model", qn(Sd);

class Td extends Sd {}

Td.className = "Functional", qn(Td);

class Ed extends Sd {
  constructor(e) {
    if (super({
      inputs: [],
      outputs: []
    }), e = e || {}, this.trainable = !0, this.built = !1, this.name = null != e.name ? e.name : th("sequential_"), null != e.layers) for (var _t192 of e.layers) {
      this.add(_t192);
    }
  }

  checkShape(e) {
    if (e.inboundNodes[0].outputTensors[0].shape.some(e => e < 0)) throw new bu("Negative dimension size caused by adding layer ".concat(e.name, " with input shape [").concat(e.inboundNodes[0].inputTensors[0].shape, "]"));
  }

  add(e) {
    var t = e instanceof Ed || e instanceof Sd;
    var n;

    if (t) {
      if (n = e, 1 !== n.outputs.length) throw new bu("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      if (1 !== n.inputs.length) throw new bu("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
    }

    if (0 === this.outputs.length) {
      if (0 === e.inboundNodes.length) {
        if (null == e.batchInputShape) throw new bu("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");

        var _t193 = function (e) {
          if (null == e.batchShape && null == e.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
          if (null != e.batchShape && null != e.shape) throw new bu("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
          var t = e.batchShape;
          null != e.shape && null == t && (t = [null].concat(e.shape));
          var n = e.dtype;
          return null == n && (n = "float32"), new bh({
            batchInputShape: t,
            name: e.name,
            dtype: n,
            sparse: e.sparse
          }).inboundNodes[0].outputTensors[0];
        }({
          batchShape: e.batchInputShape,
          dtype: e.dtype,
          name: e.name + "_input"
        });

        e.apply(_t193);
      }

      if (t) this.outputs = n.outputs, this.inputs = n.inputs;else {
        if (1 !== e.inboundNodes.length) throw new bu("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ".concat(e.name, " which has ").concat(e.inboundNodes.length, " pre-existing inbound connections."));
        if (1 !== e.inboundNodes[0].outputTensors.length) throw new bu("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(e), this.outputs = [e.inboundNodes[0].outputTensors[0]], this.inputs = mh(this.outputs[0]);
      }
      this.inboundNodes = [], new ph({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        inputMasks: ku(null, this.inputs.length),
        outputMasks: [null],
        inputShapes: this.inputs.map(e => e.shape),
        outputShapes: this.outputs[0].shape
      });
    } else {
      var _t194 = e.apply(this.outputs[0]);

      if (Array.isArray(_t194)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      this.checkShape(e), this.outputs = [_t194], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }

    this.layers.push(e), this.built = !1;
  }

  pop() {
    if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
    if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];else {
      var _e204 = this.layers.length - 1;

      this.layers[_e204].outboundNodes = [], this.outputs = [this.layers[_e204].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
  }

  call(e, t) {
    return null == this.model && this.build(), this.model.call(e, t);
  }

  build(e) {
    if (ah(e), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
    this.model = new Sd({
      inputs: this.inputs,
      outputs: this.outputs[0],
      name: this.name + "_model"
    }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0;
  }

  countParams() {
    return this.built || this.build(), super.countParams();
  }

  summary(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;
    this.built || this.build(), super.summary(e, t, n);
  }

  setWeights(e) {
    null == this.model && this.build(), this.model.setWeights(e);
  }

  evaluate(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!this.built) throw new mu("The model needs to be compiled before being used.");
    return this.model.evaluate(e, t, n);
  }

  evaluateDataset(e, t) {
    var _this65 = this;

    return _asyncToGenerator(function* () {
      if (!_this65.built) throw new mu("The model needs to be compiled before being used.");
      return _this65.model.evaluateDataset(e, t);
    })();
  }

  predict(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return null == this.model && this.build(), this.model.predict(e, t);
  }

  predictOnBatch(e) {
    return null == this.model && this.build(), this.model.predictOnBatch(e);
  }

  compile(e) {
    this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
  }

  get optimizer() {
    return null == this.model ? void 0 : this.model.optimizer;
  }

  set optimizer(e) {
    this.model.optimizer = e;
  }

  fit(e, t) {
    var _arguments3 = arguments,
        _this66 = this;

    return _asyncToGenerator(function* () {
      var n = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : {};
      if (!_this66.built) throw new mu("The model needs to be compiled before being used.");
      return _this66.model.fit(e, t, n);
    })();
  }

  fitDataset(e, t) {
    var _this67 = this;

    return _asyncToGenerator(function* () {
      if (!_this67.built) throw new mu("The model needs to be compiled before being used.");
      return _this67.model.fitDataset(e, t);
    })();
  }

  trainOnBatch(e, t) {
    var _this68 = this;

    return _asyncToGenerator(function* () {
      return _this68.model.trainOnBatch(e, t);
    })();
  }

  static fromConfig(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r,
        a = {};

    if (t instanceof Array) {
      if (null == t[0].className || "Merge" === t[0].className) throw new bu("Legacy serialization format not supported yet.");
      r = t;
    } else l(null != t.layers, () => "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."), r = t.layers, delete t.layers, a = t;

    var i = new e(a);
    if (!(i instanceof Ed)) throw new xu("Sequential.fromConfig called on non-Sequential input: ".concat(i));

    for (var _e205 of r) {
      var _t195 = Eh(_e205, void 0, s);

      s && _t195.setFastWeightInitDuringBuild(!0), i.add(_t195);
    }

    return i;
  }

  set stopTraining(e) {
    if (null == this.model) throw new bu("Cannot set the stopTraining property of a sequential model before it is compiled.");
    this.model.stopTraining = e;
  }

  get stopTraining() {
    if (null == this.model) throw new bu("Cannot get the stopTraining property of a sequential model before it is compiled.");
    return this.model.stopTraining;
  }

  getConfig() {
    var e = [];

    for (var _t196 of this.layers) {
      var _n118 = {};
      _n118.className = _t196.getClassName(), _n118.config = _t196.getConfig(), e.push(_n118);
    }

    return {
      name: this.name,
      layers: e
    };
  }

}

Ed.className = "Sequential", qn(Ed);

class Rd extends Hn {
  getConfig() {
    return {};
  }

}

class Ad extends Rd {
  apply(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (1 !== t) throw new xu("Support for alpha values other than 1 (".concat(t, ") is not implemented yet."));
      return mr(e);
    }(e, t);
  }

}

Ad.className = "elu", qn(Ad);

class Fd extends Rd {
  apply(e) {
    return Ka(e);
  }

}

Fd.className = "selu", qn(Fd);

class Dd extends Rd {
  apply(e) {
    return Ua(e);
  }

}

Dd.className = "relu", qn(Dd);

class _d extends Rd {
  apply(e) {
    return Yn(() => da(6, Ua(e)));
  }

}

_d.className = "relu6", qn(_d);

class Od extends Rd {
  apply(e) {
    return e;
  }

}

Od.className = "linear", qn(Od);

class Md extends Rd {
  apply(e) {
    return Ds(e);
  }

}

Md.className = "sigmoid", qn(Md);

class Ld extends Rd {
  apply(e) {
    return function (e) {
      return Yn(() => {
        var t = es(.5, ss(.2, e));
        return Gs(t, 0, 1);
      });
    }(e);
  }

}

Ld.className = "hardSigmoid", qn(Ld);

class zd extends Rd {
  apply(e) {
    return Pr(e);
  }

}

zd.className = "softplus", qn(zd);

class Bd extends Rd {
  apply(e) {
    return function (e) {
      return Yn(() => ns(e, es(rs(e), 1)));
    }(e);
  }

}

Bd.className = "softsign", qn(Bd);

class Pd extends Rd {
  apply(e) {
    return Os(e);
  }

}

Pd.className = "tanh", qn(Pd);

class Wd extends Rd {
  apply(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    return si(e, t);
  }

}

Wd.className = "softmax", qn(Wd);

class Ud extends Rd {
  apply(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    return Hr(e, t);
  }

}

Ud.className = "logSoftmax", qn(Ud);

class Vd extends Rd {
  apply(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return Yn(() => ss(Ds(ss(e, t)), e));
  }

}

Vd.className = "swish", qn(Vd);

class Gd extends Rd {
  apply(e) {
    return Yn(() => ss(e, Os(Pr(e))));
  }

}

function Hd(e) {
  return e.getClassName();
}

function jd(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Ru(e, jn.getMap().classNameMap, t, "activation");
}

function qd(e) {
  if (null == e) return jd({
    className: "linear",
    config: {}
  });

  if ("string" == typeof e) {
    var _t197 = {};
    return _t197.className = e, _t197.config = {}, jd(_t197);
  }

  return e instanceof Rd ? e : jd(e);
}

Gd.className = "mish", qn(Gd);

class Kd extends Hn {}

class Xd extends Kd {
  constructor(e) {
    super(), function (e) {
      if (null != e && "object" != typeof e) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: ".concat(e));
    }(e), this.l1 = null == e || null == e.l1 ? .01 : e.l1, this.l2 = null == e || null == e.l2 ? .01 : e.l2, this.hasL1 = 0 !== this.l1, this.hasL2 = 0 !== this.l2;
  }

  apply(e) {
    return Yn(() => {
      var t = ua([1]);
      return this.hasL1 && (t = es(t, Gr(ss(this.l1, rs(e))))), this.hasL2 && (t = es(t, Gr(ss(this.l2, Nc(e))))), Es(t, []);
    });
  }

  getConfig() {
    return {
      l1: this.l1,
      l2: this.l2
    };
  }

  static fromConfig(e, t) {
    return new e({
      l1: t.l1,
      l2: t.l2
    });
  }

}

Xd.className = "L1L2", qn(Xd);
var Yd = {
  l1l2: "L1L2"
};

function Jd(e) {
  return Tu(e);
}

function Zd(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Ru(e, jn.getMap().classNameMap, t, "regularizer");
}

function Qd(e) {
  return null == e ? null : "string" == typeof e ? Zd({
    className: e in Yd ? Yd[e] : e,
    config: {}
  }) : e instanceof Kd ? e : Zd(e);
}

class ep extends gh {
  constructor(e) {
    super(null == e ? {} : e), this.supportsMasking = !0, null != e && (this.maxValue = e.maxValue);
  }

  call(e, t) {
    e = rh(e);
    var n = Ua(e);
    return null != this.maxValue && (n = Gs(n, 0, this.maxValue)), n;
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = {
      maxValue: this.maxValue
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

ep.className = "ReLU", qn(ep);

class tp extends gh {
  constructor(e) {
    super(null == e ? {} : e), this.DEFAULT_ALPHA = .3, null == e && (e = {}), this.alpha = null == e.alpha ? this.DEFAULT_ALPHA : e.alpha;
  }

  call(e, t) {
    var n = rh(e);
    return Fr(n, this.alpha);
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = {
      alpha: this.alpha
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

tp.className = "LeakyReLU", qn(tp);

class np extends gh {
  constructor(e) {
    if (super(null == e ? {} : e), this.DEFAULT_ALPHA_INITIALIZER = "zeros", null == e && (e = {}), this.supportsMasking = !0, this.alphaInitializer = Jc(e.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER), this.alphaRegularizer = Qd(e.alphaRegularizer), this.alphaConstraint = Ku(e.alphaConstraint), null == e.sharedAxes) this.sharedAxes = null;else if (Array.isArray(e.sharedAxes)) this.sharedAxes = e.sharedAxes;else {
      if ("number" != typeof e.sharedAxes) throw new bu("Expected sharedAxes to be a number or an array of numbers, but got ".concat(e.sharedAxes));
      this.sharedAxes = [e.sharedAxes];
    }
  }

  build(e) {
    var t = (e = ah(e)).slice(1);
    if (null != this.sharedAxes) for (var _e206 of this.sharedAxes) {
      t[_e206 - 1] = 1;
    }
    this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
    var n = {};
    if (null != this.sharedAxes) for (var _t198 = 1; _t198 < e.length; ++_t198) {
      n[_t198] = e[_t198];
    }
    this.inputSpec = [new ch({
      ndim: e.length,
      axes: n
    })], this.built = !0;
  }

  call(e, t) {
    return e = rh(e), Ia(e, this.alpha.read());
  }

  getConfig() {
    var e = {
      alphaInitializer: Yc(this.alphaInitializer),
      alphaRegularizer: Jd(this.alphaRegularizer),
      alphaConstraint: ju(this.alphaConstraint),
      sharedAxes: this.sharedAxes
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

np.className = "PReLU", qn(np);

class sp extends gh {
  constructor(e) {
    if (super(null == e ? {} : e), this.DEFAULT_ALPHA = 1, null == e && (e = {}), null != e.alpha && e.alpha !== this.DEFAULT_ALPHA) throw new xu("Non-default alpha value (".concat(e.alpha, ") is not supported by the ELU layer yet."));
    this.alpha = null == e.alpha ? this.DEFAULT_ALPHA : e.alpha;
  }

  call(e, t) {
    var n = rh(e);
    return mr(n);
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = {
      alpha: this.alpha
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

sp.className = "ELU", qn(sp);

class rp extends gh {
  constructor(e) {
    super(null == e ? {} : e), this.DEFAULT_THETA = 1, null == e && (e = {}), this.theta = null == e.theta ? this.DEFAULT_THETA : e.theta;
  }

  call(e, t) {
    var n = rh(e);
    return ss(n, pn(Cr(n, this.theta), "float32"));
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = {
      theta: this.theta
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

rp.className = "ThresholdedReLU", qn(rp);

class ap extends gh {
  constructor(e) {
    super(null == e ? {} : e), this.DEFAULT_AXIS = 1, null == e && (e = {}), this.softmax = new Wd().apply, this.axis = null == e.axis ? this.DEFAULT_AXIS : e.axis;
  }

  call(e, t) {
    var n = rh(e);
    return this.softmax(n, this.axis);
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = {
      axis: this.axis
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

function ip(e, t, n) {
  if ("number" == typeof e) return ku(e, t);
  if (e.length !== t) throw new bu("The ".concat(n, " argument must be an integer or tuple of ").concat(t, " integers. Received: ").concat(e.length, " elements."));

  for (var _r73 = 0; _r73 < t; ++_r73) {
    var _a59 = e[_r73];
    if ((s = _a59) !== parseInt(s.toString(), 10)) throw new bu("The ".concat(n, " argument must be an integer or tuple of ").concat(t, " integers. Received: ").concat(JSON.stringify(e), " including a non-integer number ").concat(_a59));
  }

  return e;
  var s;
}

function op(e, t, n, s) {
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
  if (null == e) return e;
  var a;
  return a = "same" === n ? e : e - (t + (t - 1) * (r - 1)) + 1, Math.floor((a + s - 1) / s);
}

function lp(e, t, n, s) {
  if (null == e) return null;
  if ("valid" === s) e = e * t + dc([n - t, 0]);else {
    if ("same" !== s) throw new bu("Unsupport padding mode: ".concat(s, "."));
    e *= t;
  }
  return e;
}

function up(e, t) {
  return Yn(() => (tc(t), "channelsFirst" === t ? $n(e, [0, 2, 3, 1]) : e));
}

function cp(e, t) {
  return Yn(() => (tc(t), "channelsFirst" === t ? $n(e, [0, 2, 3, 4, 1]) : e));
}

function hp(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [1, 1];
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "valid";
  var a = arguments.length > 5 ? arguments[5] : undefined;
  var i = arguments.length > 6 ? arguments[6] : undefined;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
  return Yn(() => {
    if (null == a && (a = "channelsLast"), tc(a), 3 !== e.rank && 4 !== e.rank) throw new bu("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ".concat(e.rank, "."));
    if (3 !== t.rank && 4 !== t.rank) throw new bu("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ".concat(e.rank, "."));
    var l = up(e, a);
    if ("causal" === r) throw new xu("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    return l = Di({
      x: l,
      filter: t,
      strides: s,
      pad: "same" === r ? "same" : "valid",
      dilations: i,
      dataFormat: "NHWC",
      bias: n,
      activation: o
    }), "channelsFirst" === a && (l = $n(l, [0, 3, 1, 2])), l;
  });
}

ap.className = "Softmax", qn(ap);

class dp extends gh {
  constructor(e, t) {
    if (super(t), this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", dp.verifyArgs(t), this.rank = e, Mu(this.rank, "rank"), 1 !== this.rank && 2 !== this.rank && 3 !== this.rank) throw new xu("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank, ") is not implemented yet."));
    if (this.kernelSize = ip(t.kernelSize, e, "kernelSize"), this.strides = ip(null == t.strides ? 1 : t.strides, e, "strides"), this.padding = null == t.padding ? "valid" : t.padding, nc(this.padding), this.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, tc(this.dataFormat), this.activation = qd(t.activation), this.useBias = null == t.useBias || t.useBias, this.biasInitializer = Jc(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.biasConstraint = Ku(t.biasConstraint), this.biasRegularizer = Qd(t.biasRegularizer), this.activityRegularizer = Qd(t.activityRegularizer), this.dilationRate = ip(null == t.dilationRate ? 1 : t.dilationRate, e, "dilationRate"), 1 === this.rank && Array.isArray(this.dilationRate) && 1 !== this.dilationRate.length) throw new bu("dilationRate must be a number or an array of a single number for 1D convolution, but received ".concat(JSON.stringify(this.dilationRate)));

    if (2 === this.rank) {
      if ("number" == typeof this.dilationRate) this.dilationRate = [this.dilationRate, this.dilationRate];else if (2 !== this.dilationRate.length) throw new bu("dilationRate must be a number or array of two numbers for 2D convolution, but received ".concat(JSON.stringify(this.dilationRate)));
    } else if (3 === this.rank) if ("number" == typeof this.dilationRate) this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];else if (3 !== this.dilationRate.length) throw new bu("dilationRate must be a number or array of three numbers for 3D convolution, but received ".concat(JSON.stringify(this.dilationRate)));
  }

  static verifyArgs(e) {
    if (wu("kernelSize" in e, "required key 'kernelSize' not in config"), "number" != typeof e.kernelSize && !Ou(e.kernelSize, "number", 1, 3)) throw new bu("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize), "."));
  }

  getConfig() {
    var e = {
      kernelSize: this.kernelSize,
      strides: this.strides,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      activation: Hd(this.activation),
      useBias: this.useBias,
      biasInitializer: Yc(this.biasInitializer),
      biasRegularizer: Jd(this.biasRegularizer),
      activityRegularizer: Jd(this.activityRegularizer),
      biasConstraint: ju(this.biasConstraint)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

class pp extends dp {
  constructor(e, t) {
    super(e, t), this.kernel = null, pp.verifyArgs(t), this.filters = t.filters, Mu(this.filters, "filters"), this.kernelInitializer = Jc(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.kernelConstraint = Ku(t.kernelConstraint), this.kernelRegularizer = Qd(t.kernelRegularizer);
  }

  build(e) {
    e = ah(e);
    var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[t]) throw new bu("The channel dimension of the input should be defined. Found ".concat(e[t]));
    var n = e[t],
        s = this.kernelSize.concat([n, this.filters]);
    this.kernel = this.addWeight("kernel", s, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{
      ndim: this.rank + 2,
      axes: {
        [t]: n
      }
    }], this.built = !0;
  }

  call(e, t) {
    return Yn(() => {
      var t;
      e = rh(e);
      var n = null == this.bias ? null : this.bias.read(),
          s = zu(this.activation.getClassName());
      if (null != s && 2 === this.rank) t = hp(e, this.kernel.read(), n, this.strides, this.padding, this.dataFormat, this.dilationRate, s);else {
        if (1 === this.rank) t = function (e, t, n) {
          var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
          var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "valid";
          var a = arguments.length > 5 ? arguments[5] : undefined;
          var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
          return Yn(() => {
            if (null == a && (a = "channelsLast"), tc(a), 3 !== e.shape.length) throw new bu("The input of a conv1dWithBias operation should be 3, but is ".concat(e.shape.length, " instead."));
            if (3 !== t.shape.length) throw new bu("The kernel for a conv1dWithBias operation should be 3, but is ".concat(t.shape.length, " instead"));
            if (null != n && 1 !== n.shape.length) throw new bu("The bias for a conv1dWithBias operation should be 1, but is ".concat(t.shape.length, " instead"));
            if ("channelsFirst" === a && (e = $n(e, [0, 2, 1])), "causal" === r) throw new xu("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
            var o = Ys(e, t, s, "same" === r ? "same" : "valid", "NWC", i);
            return null != n && (o = Sc(o, n)), o;
          });
        }(e, this.kernel.read(), n, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);else if (2 === this.rank) t = hp(e, this.kernel.read(), n, this.strides, this.padding, this.dataFormat, this.dilationRate);else {
          if (3 !== this.rank) throw new xu("convolutions greater than 3D are not implemented yet.");

          t = function (e, t, n) {
            var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [1, 1, 1];
            var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "valid";
            var a = arguments.length > 5 ? arguments[5] : undefined;
            var i = arguments.length > 6 ? arguments[6] : undefined;
            return Yn(() => {
              if (null == a && (a = "channelsLast"), tc(a), 4 !== e.rank && 5 !== e.rank) throw new bu("conv3dWithBias expects input to be of rank 4 or 5, but received ".concat(e.rank, "."));
              if (4 !== t.rank && 5 !== t.rank) throw new bu("conv3dWithBias expects kernel to be of rank 4 or 5, but received ".concat(e.rank, "."));
              var o = cp(e, a);
              if ("causal" === r) throw new xu("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
              return o = Qs(o, t, s, "same" === r ? "same" : "valid", "NDHWC", i), null != n && (o = Sc(o, n)), "channelsFirst" === a && (o = $n(o, [0, 4, 1, 2, 3])), o;
            });
          }(e, this.kernel.read(), n, this.strides, this.padding, this.dataFormat, this.dilationRate);
        }
        null != this.activation && (t = this.activation.apply(t));
      }
      return t;
    });
  }

  computeOutputShape(e) {
    e = ah(e);
    var t = [],
        n = "channelsLast" === this.dataFormat ? e.slice(1, e.length - 1) : e.slice(2);

    for (var _e207 = 0; _e207 < n.length; ++_e207) {
      var _s102 = op(n[_e207], this.kernelSize[_e207], this.padding, this.strides[_e207], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[_e207]);

      t.push(_s102);
    }

    var s = [e[0]];
    return "channelsLast" === this.dataFormat ? (s = s.concat(t), s.push(this.filters)) : (s.push(this.filters), s = s.concat(t)), s;
  }

  getConfig() {
    var e = {
      filters: this.filters,
      kernelInitializer: Yc(this.kernelInitializer),
      kernelRegularizer: Jd(this.kernelRegularizer),
      kernelConstraint: ju(this.kernelConstraint)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

  static verifyArgs(e) {
    if (!("filters" in e) || "number" != typeof e.filters || e.filters < 1) throw new bu("Convolution layer expected config.filters to be a 'number' > 0 but got ".concat(JSON.stringify(e.filters)));
  }

}

class fp extends pp {
  constructor(e) {
    super(2, e), fp.verifyArgs(e);
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.rank, e;
  }

  static verifyArgs(e) {
    if ("number" != typeof e.kernelSize && !Ou(e.kernelSize, "number", 1, 2)) throw new bu("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize), "."));
  }

}

fp.className = "Conv2D", qn(fp);

class gp extends pp {
  constructor(e) {
    super(3, e), gp.verifyArgs(e);
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.rank, e;
  }

  static verifyArgs(e) {
    if ("number" != typeof e.kernelSize && (!Array.isArray(e.kernelSize) || 1 !== e.kernelSize.length && 3 !== e.kernelSize.length)) throw new bu("Conv3D expects config.kernelSize to be number or [number, number, number], but received ".concat(JSON.stringify(e.kernelSize), "."));
  }

}

gp.className = "Conv3D", qn(gp);

class mp extends fp {
  constructor(e) {
    if (super(e), this.inputSpec = [new ch({
      ndim: 4
    })], "same" !== this.padding && "valid" !== this.padding) throw new bu("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ".concat(this.padding));
  }

  build(e) {
    if (4 !== (e = ah(e)).length) throw new bu("Input should have rank 4; Received input shape: " + JSON.stringify(e));
    var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[t]) throw new bu("The channel dimension of the inputs should be defined. Found `None`.");
    var n = e[t],
        s = this.kernelSize.concat([this.filters, n]);
    this.kernel = this.addWeight("kernel", s, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new ch({
      ndim: 4,
      axes: {
        [t]: n
      }
    })], this.built = !0;
  }

  call(e, t) {
    return Yn(() => {
      var t = rh(e);
      if (4 !== t.shape.length) throw new bu("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-".concat(t.shape.length));
      var n = t.shape;
      var s, r;
      "channelsFirst" === this.dataFormat ? (s = 2, r = 3) : (s = 1, r = 2);
      var a = n[r],
          i = this.kernelSize[1],
          o = this.strides[1],
          l = [n[0], lp(n[s], this.strides[0], this.kernelSize[0], this.padding), lp(a, o, i, this.padding), this.filters];
      "channelsLast" !== this.dataFormat && (t = $n(t, [0, 2, 3, 1]));
      var u = Zs(t, this.kernel.read(), l, this.strides, this.padding);
      return "channelsLast" !== this.dataFormat && (u = $n(u, [0, 3, 1, 2])), null != this.bias && (u = Sc(u, this.bias.read(), this.dataFormat)), null != this.activation && (u = this.activation.apply(u)), u;
    });
  }

  computeOutputShape(e) {
    var t = (e = ah(e)).slice();
    var n, s, r;
    "channelsFirst" === this.dataFormat ? (n = 1, s = 2, r = 3) : (n = 3, s = 1, r = 2);
    var a = this.kernelSize[0],
        i = this.kernelSize[1],
        o = this.strides[0],
        l = this.strides[1];
    return t[n] = this.filters, t[s] = lp(t[s], o, a, this.padding), t[r] = lp(t[r], l, i, this.padding), t;
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.dilationRate, e;
  }

}

mp.className = "Conv2DTranspose", qn(mp);

class bp extends gp {
  constructor(e) {
    if (super(e), this.inputSpec = [new ch({
      ndim: 5
    })], "same" !== this.padding && "valid" !== this.padding) throw new bu("Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ".concat(this.padding));
  }

  build(e) {
    if (5 !== (e = ah(e)).length) throw new bu("Input should have rank 5; Received input shape: " + JSON.stringify(e));
    var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[t]) throw new bu("The channel dimension of the inputs should be defined. Found `None`.");
    var n = e[t],
        s = this.kernelSize.concat([this.filters, n]);
    this.kernel = this.addWeight("kernel", s, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new ch({
      ndim: 5,
      axes: {
        [t]: n
      }
    })], this.built = !0;
  }

  call(e, t) {
    return Yn(() => {
      var t = rh(e);
      if (5 !== t.shape.length) throw new bu("Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-".concat(t.shape.length));
      var n = t.shape;
      var s, r, a;
      "channelsFirst" === this.dataFormat ? (a = 2, s = 3, r = 4) : (a = 1, s = 2, r = 3);
      var i = n[s],
          o = n[r],
          l = this.kernelSize[1],
          u = this.kernelSize[2],
          c = this.strides[1],
          h = this.strides[2],
          d = [n[0], lp(n[a], this.strides[0], this.kernelSize[0], this.padding), lp(i, c, l, this.padding), lp(o, h, u, this.padding), this.filters];
      "channelsLast" !== this.dataFormat && (t = $n(t, [0, 2, 3, 4, 1]));
      var p = tr(t, this.kernel.read(), d, this.strides, this.padding);
      return "channelsLast" !== this.dataFormat && (p = $n(p, [0, 4, 1, 2, 3])), null !== this.bias && (p = Sc(p, this.bias.read(), this.dataFormat)), null !== this.activation && (p = this.activation.apply(p)), p;
    });
  }

  computeOutputShape(e) {
    var t = (e = ah(e)).slice();
    var n, s, r, a;
    "channelsFirst" === this.dataFormat ? (n = 1, s = 2, r = 3, a = 4) : (n = 4, s = 1, r = 2, a = 3);
    var i = this.kernelSize[0],
        o = this.kernelSize[1],
        l = this.kernelSize[2],
        u = this.strides[0],
        c = this.strides[1],
        h = this.strides[2];
    return t[n] = this.filters, t[s] = lp(t[s], u, i, this.padding), t[r] = lp(t[r], c, o, this.padding), t[a] = lp(t[a], h, l, this.padding), t;
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.dilationRate, e;
  }

}

bp.className = "Conv3DTranspose", qn(bp);

class xp extends pp {
  constructor(e, t) {
    if (super(e, t), this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", this.depthwiseKernel = null, this.pointwiseKernel = null, null == t.filters) throw new bu("The `filters` configuration field is required by SeparableConv, but is unspecified.");
    if (null != t.kernelInitializer || null != t.kernelRegularizer || null != t.kernelConstraint) throw new bu("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
    if (null != t.padding && "same" !== t.padding && "valid" !== t.padding) throw new bu("SeparableConv".concat(this.rank, "D supports only padding modes: 'same' and 'valid', but received ").concat(JSON.stringify(t.padding)));
    this.depthMultiplier = null == t.depthMultiplier ? 1 : t.depthMultiplier, this.depthwiseInitializer = Jc(t.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER), this.depthwiseRegularizer = Qd(t.depthwiseRegularizer), this.depthwiseConstraint = Ku(t.depthwiseConstraint), this.pointwiseInitializer = Jc(t.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER), this.pointwiseRegularizer = Qd(t.pointwiseRegularizer), this.pointwiseConstraint = Ku(t.pointwiseConstraint);
  }

  build(e) {
    if ((e = ah(e)).length < this.rank + 2) throw new bu("Inputs to SeparableConv".concat(this.rank, "D should have rank ").concat(this.rank + 2, ", but received input shape: ").concat(JSON.stringify(e)));
    var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[t] || e[t] < 0) throw new bu("The channel dimension of the inputs should be defined, but found ".concat(JSON.stringify(e[t])));
    var n = e[t],
        s = this.kernelSize.concat([n, this.depthMultiplier]),
        r = [];

    for (var _e208 = 0; _e208 < this.rank; ++_e208) {
      r.push(1);
    }

    r.push(n * this.depthMultiplier, this.filters);
    var a = !0;
    this.depthwiseKernel = this.addWeight("depthwise_kernel", s, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, a, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", r, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, a, this.pointwiseConstraint), this.bias = this.useBias ? this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, a, this.biasConstraint) : null, this.inputSpec = [new ch({
      ndim: this.rank + 2,
      axes: {
        [t]: n
      }
    })], this.built = !0;
  }

  call(e, t) {
    return Yn(() => {
      var t;
      if (e = rh(e), 1 === this.rank) throw new xu("1D separable convolution is not implemented yet.");
      return 2 === this.rank && ("channelsFirst" === this.dataFormat && (e = $n(e, [0, 2, 3, 1])), t = Xa(e, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC")), this.useBias && (t = Sc(t, this.bias.read(), this.dataFormat)), null != this.activation && (t = this.activation.apply(t)), "channelsFirst" === this.dataFormat && (t = $n(t, [0, 3, 1, 2])), t;
    });
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.rank, delete e.kernelInitializer, delete e.kernelRegularizer, delete e.kernelConstraint, e.depthwiseInitializer = Yc(this.depthwiseInitializer), e.pointwiseInitializer = Yc(this.pointwiseInitializer), e.depthwiseRegularizer = Jd(this.depthwiseRegularizer), e.pointwiseRegularizer = Jd(this.pointwiseRegularizer), e.depthwiseConstraint = ju(this.depthwiseConstraint), e.pointwiseConstraint = ju(this.pointwiseConstraint), e;
  }

}

xp.className = "SeparableConv";

class yp extends xp {
  constructor(e) {
    super(2, e);
  }

}

yp.className = "SeparableConv2D", qn(yp);

class kp extends pp {
  constructor(e) {
    super(1, e), kp.verifyArgs(e), this.inputSpec = [{
      ndim: 3
    }];
  }

  getConfig() {
    var e = super.getConfig();
    return delete e.rank, delete e.dataFormat, e;
  }

  static verifyArgs(e) {
    if ("number" != typeof e.kernelSize && !Ou(e.kernelSize, "number", 1, 1)) throw new bu("Conv1D expects config.kernelSize to be number or number[] with length 1, but received ".concat(JSON.stringify(e.kernelSize), "."));
  }

}

kp.className = "Conv1D", qn(kp);

class wp extends gh {
  constructor(e) {
    super(e), this.cropping = "number" == typeof e.cropping ? [[e.cropping, e.cropping], [e.cropping, e.cropping]] : "number" == typeof e.cropping[0] ? [[e.cropping[0], e.cropping[0]], [e.cropping[1], e.cropping[1]]] : e.cropping, this.dataFormat = void 0 === e.dataFormat ? "channelsLast" : e.dataFormat, this.inputSpec = [{
      ndim: 4
    }];
  }

  computeOutputShape(e) {
    return "channelsFirst" === this.dataFormat ? [e[0], e[1], e[2] - this.cropping[0][0] - this.cropping[0][1], e[3] - this.cropping[1][0] - this.cropping[1][1]] : [e[0], e[1] - this.cropping[0][0] - this.cropping[0][1], e[2] - this.cropping[1][0] - this.cropping[1][1], e[3]];
  }

  call(e, t) {
    return Yn(() => {
      if (e = rh(e), "channelsLast" === this.dataFormat) {
        var _t199 = xc(e, this.cropping[0][0], e.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);

        return xc(_t199, this.cropping[1][0], e.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
      }

      {
        var _t200 = xc(e, this.cropping[0][0], e.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);

        return xc(_t200, this.cropping[1][0], e.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
      }
    });
  }

  getConfig() {
    var e = {
      cropping: this.cropping,
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

wp.className = "Cropping2D", qn(wp);

class vp extends gh {
  constructor(e) {
    super(e), this.DEFAULT_SIZE = [2, 2], this.inputSpec = [{
      ndim: 4
    }], this.size = null == e.size ? this.DEFAULT_SIZE : e.size, this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, tc(this.dataFormat), this.interpolation = null == e.interpolation ? "nearest" : e.interpolation, _u(Yu, "InterpolationFormat", this.interpolation);
  }

  computeOutputShape(e) {
    return "channelsFirst" === this.dataFormat ? [e[0], e[1], null == e[2] ? null : this.size[0] * e[2], null == e[3] ? null : this.size[1] * e[3]] : [e[0], null == e[1] ? null : this.size[0] * e[1], null == e[2] ? null : this.size[1] * e[2], e[3]];
  }

  call(e, t) {
    return Yn(() => {
      var t = rh(e);
      var n = t.shape;

      if ("channelsFirst" === this.dataFormat) {
        t = $n(t, [0, 2, 3, 1]);

        var _e209 = this.size[0] * n[2],
            _s103 = this.size[1] * n[3],
            _r74 = "nearest" === this.interpolation ? ho.resizeNearestNeighbor(t, [_e209, _s103]) : ho.resizeBilinear(t, [_e209, _s103]);

        return $n(_r74, [0, 3, 1, 2]);
      }

      {
        var _e210 = this.size[0] * n[1],
            _s104 = this.size[1] * n[2];

        return "nearest" === this.interpolation ? ho.resizeNearestNeighbor(t, [_e210, _s104]) : ho.resizeBilinear(t, [_e210, _s104]);
      }
    });
  }

  getConfig() {
    var e = {
      size: this.size,
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

vp.className = "UpSampling2D", qn(vp);

class Ip extends dp {
  constructor(e) {
    super(2, e), this.depthwiseKernel = null, this.depthMultiplier = null == e.depthMultiplier ? 1 : e.depthMultiplier, this.depthwiseInitializer = Jc(e.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.depthwiseConstraint = Ku(e.depthwiseConstraint), this.depthwiseRegularizer = Qd(e.depthwiseRegularizer);
  }

  build(e) {
    if ((e = ah(e)).length < 4) throw new bu("Inputs to DepthwiseConv2D should have rank 4. Received input shape: ".concat(JSON.stringify(e), "."));
    var t = "channelsFirst" === this.dataFormat ? 1 : 3;
    if (null == e[t] || e[t] < 0) throw new bu("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (".concat(e[t], ")."));
    var n = e[t];
    this.depthwiseKernel = this.addWeight("depthwise_kernel", [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier], null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.bias = this.useBias ? this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : null, this.built = !0;
  }

  call(e, t) {
    return Yn(() => {
      var t = function (e, t) {
        var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1];
        var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "valid";
        var r = arguments.length > 4 ? arguments[4] : undefined;
        var a = arguments.length > 5 ? arguments[5] : undefined;
        return Yn(() => {
          null == r && (r = "channelsLast"), tc(r);
          var i = up(e, r);
          if (4 !== e.rank) throw new bu("Input for depthwiseConv2d is required to be 4-D, but is instead ".concat(e.rank, "-D"));
          if (4 !== t.rank) throw new bu("depthwiseKernel is required to be 4-D, but is instead ".concat(t.rank, "-D"));
          return i = ir(i, t, n, "same" === s ? "same" : "valid", "NHWC", a), "channelsFirst" === r && (i = $n(i, [0, 3, 1, 2])), i;
        });
      }(e = rh(e), this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);

      return this.useBias && (t = Sc(t, this.bias.read(), this.dataFormat)), null != this.activation && (t = this.activation.apply(t)), t;
    });
  }

  computeOutputShape(e) {
    e = ah(e);
    var t = "channelsFirst" === this.dataFormat ? e[3] : e[2],
        n = "channelsFirst" === this.dataFormat ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier,
        s = op("channelsFirst" === this.dataFormat ? e[2] : e[1], this.kernelSize[0], this.padding, this.strides[0]),
        r = op(t, this.kernelSize[1], this.padding, this.strides[1]);
    return "channelsFirst" === this.dataFormat ? [e[0], n, s, r] : [e[0], s, r, n];
  }

  getConfig() {
    var e = super.getConfig();
    return e.depthMultiplier = this.depthMultiplier, e.depthwiseInitializer = Yc(this.depthwiseInitializer), e.depthwiseRegularizer = Jd(this.depthwiseRegularizer), e.depthwiseConstraint = ju(this.depthwiseRegularizer), e;
  }

}

function $p(e, t, n, s) {
  if (Array.isArray(e)) {
    if (null != t || null != n) throw new bu("When inputs is an array, neither initialState or constants should be provided");
    null != s && (n = e.slice(e.length - s, e.length), e = e.slice(0, e.length - s)), e.length > 1 && (t = e.slice(1, e.length)), e = e[0];
  }

  function r(e) {
    return null == e || Array.isArray(e) ? e : [e];
  }

  return {
    inputs: e,
    initialState: t = r(t),
    constants: n = r(n)
  };
}

function Np(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  var r = arguments.length > 4 ? arguments[4] : undefined;
  var a = arguments.length > 5 ? arguments[5] : undefined;
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : !1;
  return Yn(() => {
    var l = t.shape.length;
    if (l < 3) throw new bu("Input should be at least 3D, but is ".concat(l, "D."));
    var u = [1, 0].concat(pc(2, l));
    if (t = $n(t, u), null != a) throw new xu("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
    i && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != r && ((r = pn(pn(r, "bool"), "float32")).rank === l - 1 && (r = yr(r, -1)), r = $n(r, u)), s && (t = Ga(t, 0), null != r && (r = Ga(r, 0)));
    var c = [];
    var h,
        d = n;
    var p = t.shape[0],
        f = vi(t);
    var g, m;
    null != r && (g = vi(r));

    var _loop24 = function _loop24(_t201) {
      var n = f[_t201],
          s = Yn(() => e(n, d));
      if (null == r) h = s[0], d = s[1];else {
        var _e211 = Yn(() => {
          var e = g[_t201],
              n = Vr(xa(e), e);
          return {
            output: es(ss(s[0], e), ss(d[0], n)),
            newStates: d.map((t, r) => es(ss(s[1][r], e), ss(t, n)))
          };
        });

        h = _e211.output, d = _e211.newStates;
      }
      o && c.push(h);
    };

    for (var _t201 = 0; _t201 < p; ++_t201) {
      _loop24(_t201);
    }

    return o && (m = di(c, 1)), [h, m, d];
  });
}

Ip.className = "DepthwiseConv2D", qn(Ip);

class Cp extends gh {
  constructor(e) {
    var t;
    if (super(e), null == e.cell) throw new bu("cell property is missing for the constructor of RNN.");
    if (t = Array.isArray(e.cell) ? new _p({
      cells: e.cell
    }) : e.cell, null == t.stateSize) throw new bu("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
    this.cell = t, this.returnSequences = null != e.returnSequences && e.returnSequences, this.returnState = null != e.returnState && e.returnState, this.goBackwards = null != e.goBackwards && e.goBackwards, this._stateful = null != e.stateful && e.stateful, this.unroll = null != e.unroll && e.unroll, this.supportsMasking = !0, this.inputSpec = [new ch({
      ndim: 3
    })], this.stateSpec = null, this.states_ = null, this.numConstants = null, this.keptStates = [];
  }

  getStates() {
    return null == this.states_ ? pc(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(e => null) : this.states_;
  }

  setStates(e) {
    this.states_ = e;
  }

  computeOutputShape(e) {
    nh(e) && (e = e[0]), e = e;
    var t = this.cell.stateSize;
    Array.isArray(t) || (t = [t]);
    var n = t[0];
    var s;

    if (s = this.returnSequences ? [e[0], e[1], n] : [e[0], n], this.returnState) {
      var _n119 = [];

      for (var _s105 of t) {
        _n119.push([e[0], _s105]);
      }

      return [s].concat(_n119);
    }

    return s;
  }

  computeMask(e, t) {
    return Yn(() => {
      Array.isArray(t) && (t = t[0]);
      var e = this.returnSequences ? t : null;

      if (this.returnState) {
        var _t202 = this.states.map(e => null);

        return [e].concat(_t202);
      }

      return e;
    });
  }

  get states() {
    if (null == this.states_) {
      var _e212 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1,
          _t203 = [];

      for (var _n120 = 0; _n120 < _e212; ++_n120) {
        _t203.push(null);
      }

      return _t203;
    }

    return this.states_;
  }

  set states(e) {
    this.states_ = e;
  }

  build(e) {
    if (null != this.numConstants) throw new xu("Constants support is not implemented in RNN yet.");
    nh(e) && (e = e[0]), e = e;
    var t = this.stateful ? e[0] : null,
        n = e.slice(2);
    this.inputSpec[0] = new ch({
      shape: [t, null, ...n]
    });
    var s = [e[0]].concat(e.slice(2));
    var r;

    if (this.cell.build(s), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
      if (!p(this.stateSpec.map(e => e.shape[e.shape.length - 1]), r)) throw new bu("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=".concat(this.stateSpec, "; However cell.stateSize is ").concat(this.cell.stateSize));
    } else this.stateSpec = r.map(e => new ch({
      shape: [null, e]
    }));

    this.stateful && this.resetStates();
  }

  resetStates(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    Yn(() => {
      if (!this.stateful) throw new gu("Cannot call resetStates() on an RNN Layer that is not stateful.");
      var n = this.inputSpec[0].shape[0];
      if (null == n) throw new bu("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (null == this.states_) this.states_ = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map(e => ua([n, e])) : [ua([n, this.cell.stateSize])];else if (null == e) Jn(this.states_), null != this.keptStates && (Jn(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(e => ua([n, e])) : this.states_[0] = ua([n, this.cell.stateSize]);else {
        if (Array.isArray(e) || (e = [e]), e.length !== this.states_.length) throw new bu("Layer ".concat(this.name, " expects ").concat(this.states_.length, " state(s), but it received ").concat(e.length, " state value(s). Input received: ").concat(e));
        !0 === t ? this.keptStates.push(this.states_.slice()) : Jn(this.states_);

        for (var _t204 = 0; _t204 < this.states_.length; ++_t204) {
          var _s106 = e[_t204],
              _r75 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[_t204] : this.cell.stateSize,
              _a60 = [n, _r75];

          if (!p(_s106.shape, _a60)) throw new bu("State ".concat(_t204, " is incompatible with layer ").concat(this.name, ": expected shape=").concat(_a60, ", received shape=").concat(_s106.shape));
          this.states_[_t204] = _s106;
        }
      }
      this.states_ = this.states_.map(e => Zn(e.clone()));
    });
  }

  apply(e, t) {
    var n = null == t ? null : t.initialState,
        s = null == t ? null : t.constants;
    null == t && (t = {});
    var r = $p(e, n, s, this.numConstants);
    e = r.inputs, n = r.initialState, s = r.constants;
    var a = [],
        i = [];

    if (null != n) {
      t.initialState = n, a = a.concat(n), this.stateSpec = [];

      for (var _e213 of n) {
        this.stateSpec.push(new ch({
          shape: _e213.shape
        }));
      }

      i = i.concat(this.stateSpec);
    }

    if (null != s && (t.constants = s, a = a.concat(s), this.numConstants = s.length), a[0] instanceof hh) {
      var _n121 = [e].concat(a),
          _s107 = this.inputSpec.concat(i),
          _r76 = this.inputSpec;

      this.inputSpec = _s107;

      var _o27 = super.apply(_n121, t);

      return this.inputSpec = _r76, _o27;
    }

    return super.apply(e, t);
  }

  call(e, t) {
    return Yn(() => {
      var n = null == t ? null : t.mask,
          s = null == t ? null : t.training;
      var r = null == t ? null : t.initialState;
      e = rh(e), null == r && (r = this.stateful ? this.states_ : this.getInitialState(e));
      var a = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      if (r.length !== a) throw new bu("RNN Layer has ".concat(a, " state(s) but was passed ").concat(r.length, " initial state(s)."));
      this.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
      var i = {
        training: s
      },
          o = Np((e, t) => {
        var n = this.cell.call([e].concat(t), i);
        return [n[0], n.slice(1)];
      }, e, r, this.goBackwards, n, null, this.unroll, this.returnSequences),
          l = o[0],
          u = o[1],
          c = o[2];
      this.stateful && this.resetStates(c, s);
      var h = this.returnSequences ? u : l;
      return this.returnState ? [h].concat(c) : h;
    });
  }

  getInitialState(e) {
    return Yn(() => {
      var t = ua(e.shape);
      return t = Gr(t, [1, 2]), t = gc(t), Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map(e => e > 1 ? wc(t, [1, e]) : t) : this.cell.stateSize > 1 ? [wc(t, [1, this.cell.stateSize])] : [t];
    });
  }

  get trainableWeights() {
    return this.trainable ? this.cell.trainableWeights : [];
  }

  get nonTrainableWeights() {
    return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
  }

  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), null != this.cell && this.cell.setFastWeightInitDuringBuild(e);
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      returnSequences: this.returnSequences,
      returnState: this.returnState,
      goBackwards: this.goBackwards,
      stateful: this.stateful,
      unroll: this.unroll
    };
    null != this.numConstants && (t.numConstants = this.numConstants);
    var n = this.cell.getConfig();
    return this.getClassName() === Cp.className && (t.cell = {
      className: this.cell.getClassName(),
      config: n
    }), Object.assign({}, n, e, t);
  }

  static fromConfig(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = Eh(t.cell, n);
    return new e(Object.assign(t, {
      cell: s
    }));
  }

}

Cp.className = "RNN", qn(Cp);

class Sp extends gh {}

class Tp extends Sp {
  constructor(e) {
    super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, Mu(this.units, "units"), this.activation = qd(null == e.activation ? this.DEFAULT_ACTIVATION : e.activation), this.useBias = null == e.useBias || e.useBias, this.kernelInitializer = Jc(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Jc(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Jc(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = Qd(e.kernelRegularizer), this.recurrentRegularizer = Qd(e.recurrentRegularizer), this.biasRegularizer = Qd(e.biasRegularizer), this.kernelConstraint = Ku(e.kernelConstraint), this.recurrentConstraint = Ku(e.recurrentConstraint), this.biasConstraint = Ku(e.biasConstraint), this.dropout = hc([1, dc([0, null == e.dropout ? 0 : e.dropout])]), this.recurrentDropout = hc([1, dc([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
  }

  build(e) {
    e = ah(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.bias = this.useBias ? this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : null, this.built = !0;
  }

  call(e, t) {
    return Yn(() => {
      if (2 !== (e = e).length) throw new bu("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length, "."));
      var n = e[1];
      e = e[0];
      var s = null != t.training && t.training;
      var r;
      0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Op({
        ones: () => xa(e),
        rate: this.dropout,
        training: s
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Op({
        ones: () => xa(n),
        rate: this.recurrentDropout,
        training: s
      }));
      var a = this.dropoutMask,
          i = this.recurrentDropoutMask;
      r = Ic(null != a ? ss(e, a) : e, this.kernel.read()), null != this.bias && (r = Sc(r, this.bias.read())), null != i && (n = ss(n, i));
      var o = es(r, Ic(n, this.recurrentKernel.read()));
      return null != this.activation && (o = this.activation.apply(o)), [o, o];
    });
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      units: this.units,
      activation: Hd(this.activation),
      useBias: this.useBias,
      kernelInitializer: Yc(this.kernelInitializer),
      recurrentInitializer: Yc(this.recurrentInitializer),
      biasInitializer: Yc(this.biasInitializer),
      kernelRegularizer: Jd(this.kernelRegularizer),
      recurrentRegularizer: Jd(this.recurrentRegularizer),
      biasRegularizer: Jd(this.biasRegularizer),
      activityRegularizer: Jd(this.activityRegularizer),
      kernelConstraint: ju(this.kernelConstraint),
      recurrentConstraint: ju(this.recurrentConstraint),
      biasConstraint: ju(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout
    };
    return Object.assign({}, e, t);
  }

}

Tp.className = "SimpleRNNCell", qn(Tp);

class Ep extends Cp {
  constructor(e) {
    e.cell = new Tp(e), super(e);
  }

  call(e, t) {
    return Yn(() => (null != this.cell.dropoutMask && (Jn(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (Jn(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), super.call(e, {
      mask: null == t ? null : t.mask,
      training: null == t ? null : t.training,
      initialState: null == t ? null : t.initialState
    })));
  }

  static fromConfig(e, t) {
    return new e(t);
  }

}

Ep.className = "SimpleRNN", qn(Ep);

class Rp extends Sp {
  constructor(e) {
    if (super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", e.resetAfter) throw new bu("GRUCell does not support reset_after parameter set to true.");
    this.units = e.units, Mu(this.units, "units"), this.activation = qd(void 0 === e.activation ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = qd(void 0 === e.recurrentActivation ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = null == e.useBias || e.useBias, this.kernelInitializer = Jc(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Jc(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Jc(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = Qd(e.kernelRegularizer), this.recurrentRegularizer = Qd(e.recurrentRegularizer), this.biasRegularizer = Qd(e.biasRegularizer), this.kernelConstraint = Ku(e.kernelConstraint), this.recurrentConstraint = Ku(e.recurrentConstraint), this.biasConstraint = Ku(e.biasConstraint), this.dropout = hc([1, dc([0, null == e.dropout ? 0 : e.dropout])]), this.recurrentDropout = hc([1, dc([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), this.implementation = e.implementation, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
  }

  build(e) {
    e = ah(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.bias = this.useBias ? this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : null, this.built = !0;
  }

  call(e, t) {
    return Yn(() => {
      if (2 !== (e = e).length) throw new bu("GRUCell expects 2 input Tensors (inputs, h, c), got ".concat(e.length, "."));
      var n = null != t.training && t.training;
      var s = e[1];
      e = e[0], 0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Op({
        ones: () => xa(e),
        rate: this.dropout,
        training: n,
        count: 3
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Op({
        ones: () => xa(s),
        rate: this.recurrentDropout,
        training: n,
        count: 3
      }));
      var r = this.recurrentDropoutMask;
      var a, i, o;
      0 < this.dropout && this.dropout < 1 && (e = ss(e, this.dropoutMask[0]));
      var l = Ic(e, this.kernel.read());
      this.useBias && (l = Sc(l, this.bias.read())), 0 < this.recurrentDropout && this.recurrentDropout < 1 && (s = ss(s, r[0]));
      var u = this.recurrentKernel.read(),
          [c, h] = oi(u, [2 * this.units, this.units], u.rank - 1),
          d = Ic(s, c),
          [p, f, g] = oi(l, 3, l.rank - 1),
          [m, b] = oi(d, 2, d.rank - 1);
      a = this.recurrentActivation.apply(es(p, m)), i = this.recurrentActivation.apply(es(f, b));
      var x = Ic(ss(i, s), h);
      o = this.activation.apply(es(g, x));
      var y = es(ss(a, s), ss(es(1, Br(a)), o));
      return [y, y];
    });
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      units: this.units,
      activation: Hd(this.activation),
      recurrentActivation: Hd(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: Yc(this.kernelInitializer),
      recurrentInitializer: Yc(this.recurrentInitializer),
      biasInitializer: Yc(this.biasInitializer),
      kernelRegularizer: Jd(this.kernelRegularizer),
      recurrentRegularizer: Jd(this.recurrentRegularizer),
      biasRegularizer: Jd(this.biasRegularizer),
      activityRegularizer: Jd(this.activityRegularizer),
      kernelConstraint: ju(this.kernelConstraint),
      recurrentConstraint: ju(this.recurrentConstraint),
      biasConstraint: ju(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation,
      resetAfter: !1
    };
    return Object.assign({}, e, t);
  }

}

Rp.className = "GRUCell", qn(Rp);

class Ap extends Cp {
  constructor(e) {
    0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Rp(e), super(e);
  }

  call(e, t) {
    return Yn(() => (null != this.cell.dropoutMask && (Jn(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (Jn(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), super.call(e, {
      mask: null == t ? null : t.mask,
      training: null == t ? null : t.training,
      initialState: null == t ? null : t.initialState
    })));
  }

  static fromConfig(e, t) {
    return 0 === t.implmentation && (t.implementation = 1), new e(t);
  }

}

Ap.className = "GRU", qn(Ap);

class Fp extends Sp {
  constructor(e) {
    super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, Mu(this.units, "units"), this.activation = qd(void 0 === e.activation ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = qd(void 0 === e.recurrentActivation ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = null == e.useBias || e.useBias, this.kernelInitializer = Jc(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Jc(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Jc(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.unitForgetBias = e.unitForgetBias, this.kernelRegularizer = Qd(e.kernelRegularizer), this.recurrentRegularizer = Qd(e.recurrentRegularizer), this.biasRegularizer = Qd(e.biasRegularizer), this.kernelConstraint = Ku(e.kernelConstraint), this.recurrentConstraint = Ku(e.recurrentConstraint), this.biasConstraint = Ku(e.biasConstraint), this.dropout = hc([1, dc([0, null == e.dropout ? 0 : e.dropout])]), this.recurrentDropout = hc([1, dc([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), this.implementation = e.implementation, this.stateSize = [this.units, this.units], this.dropoutMask = null, this.recurrentDropoutMask = null;
  }

  build(e) {
    var t;
    var n;

    if (e = ah(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
      if (this.unitForgetBias) {
        var _e214 = this.biasInitializer,
            _s108 = this.units;
        n = new ((t = class extends Fc {
          apply(t, n) {
            var r = _e214.apply([_s108]),
                a = new _c().apply([_s108]),
                i = _e214.apply([2 * _s108]);

            return kc(kc(r, a), i);
          }

        }).className = "CustomInit", t)();
      } else n = this.biasInitializer;

      this.bias = this.addWeight("bias", [4 * this.units], null, n, this.biasRegularizer, !0, this.biasConstraint);
    } else this.bias = null;

    this.built = !0;
  }

  call(e, t) {
    return Yn(() => {
      var n = null != t.training && t.training;
      if (3 !== (e = e).length) throw new bu("LSTMCell expects 3 input Tensors (inputs, h, c), got ".concat(e.length, "."));
      var s = e[1];
      var r = e[2];
      e = e[0], 0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Op({
        ones: () => xa(e),
        rate: this.dropout,
        training: n,
        count: 4
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Op({
        ones: () => xa(s),
        rate: this.recurrentDropout,
        training: n,
        count: 4
      }));
      var a = this.recurrentDropoutMask;
      var i, o, l, u;
      0 < this.dropout && this.dropout < 1 && (e = ss(e, this.dropoutMask[0]));
      var c = Ic(e, this.kernel.read());
      0 < this.recurrentDropout && this.recurrentDropout < 1 && (s = ss(s, a[0])), c = es(c, Ic(s, this.recurrentKernel.read())), this.useBias && (c = Sc(c, this.bias.read()));
      var [h, d, p, f] = oi(c, 4, c.rank - 1);
      i = this.recurrentActivation.apply(h), o = this.recurrentActivation.apply(d), l = es(ss(o, r), ss(i, this.activation.apply(p))), u = this.recurrentActivation.apply(f);
      var g = ss(u, this.activation.apply(l));
      return [g, g, l];
    });
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      units: this.units,
      activation: Hd(this.activation),
      recurrentActivation: Hd(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: Yc(this.kernelInitializer),
      recurrentInitializer: Yc(this.recurrentInitializer),
      biasInitializer: Yc(this.biasInitializer),
      unitForgetBias: this.unitForgetBias,
      kernelRegularizer: Jd(this.kernelRegularizer),
      recurrentRegularizer: Jd(this.recurrentRegularizer),
      biasRegularizer: Jd(this.biasRegularizer),
      activityRegularizer: Jd(this.activityRegularizer),
      kernelConstraint: ju(this.kernelConstraint),
      recurrentConstraint: ju(this.recurrentConstraint),
      biasConstraint: ju(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    };
    return Object.assign({}, e, t);
  }

}

Fp.className = "LSTMCell", qn(Fp);

class Dp extends Cp {
  constructor(e) {
    0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Fp(e), super(e);
  }

  call(e, t) {
    return Yn(() => (null != this.cell.dropoutMask && (Jn(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (Jn(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), super.call(e, {
      mask: null == t ? null : t.mask,
      training: null == t ? null : t.training,
      initialState: null == t ? null : t.initialState
    })));
  }

  static fromConfig(e, t) {
    return 0 === t.implmentation && (t.implementation = 1), new e(t);
  }

}

Dp.className = "LSTM", qn(Dp);

class _p extends Sp {
  constructor(e) {
    super(e), this.cells = e.cells;
  }

  get stateSize() {
    var e = [];

    for (var _t205 of this.cells.slice().reverse()) {
      Array.isArray(_t205.stateSize) ? e.push(..._t205.stateSize) : e.push(_t205.stateSize);
    }

    return e;
  }

  call(e, t) {
    return Yn(() => {
      var n = (e = e).slice(1);
      var s = [];

      for (var _e215 of this.cells.slice().reverse()) {
        Array.isArray(_e215.stateSize) ? s.push(n.splice(0, _e215.stateSize.length)) : s.push(n.splice(0, 1));
      }

      s.reverse();
      var r = [];
      var a;

      for (var _i34 = 0; _i34 < this.cells.length; ++_i34) {
        var _o28 = this.cells[_i34];
        n = s[_i34], a = 0 === _i34 ? [e[0]].concat(n) : [a[0]].concat(n), a = _o28.call(a, t), r.push(a.slice(1));
      }

      n = [];

      for (var _e216 of r.slice().reverse()) {
        n.push(..._e216);
      }

      return [a[0]].concat(n);
    });
  }

  build(e) {
    var t;
    nh(e) && (e = e[0]), e = e, this.cells.forEach((n, s) => {
      ac("RNNCell_".concat(s), () => {
        n.build(e), t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, e = [e[0], t];
      });
    }), this.built = !0;
  }

  getConfig() {
    var e = super.getConfig(),
        t = this.cells.map(e => ({
      className: e.getClassName(),
      config: e.getConfig()
    }));
    return Object.assign({}, e, {
      cells: t
    });
  }

  static fromConfig(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = [];

    for (var _e217 of t.cells) {
      s.push(Eh(_e217, n));
    }

    return new e({
      cells: s
    });
  }

  get trainableWeights() {
    if (!this.trainable) return [];
    var e = [];

    for (var _t206 of this.cells) {
      e.push(..._t206.trainableWeights);
    }

    return e;
  }

  get nonTrainableWeights() {
    var e = [];

    for (var _t207 of this.cells) {
      e.push(..._t207.nonTrainableWeights);
    }

    if (!this.trainable) {
      var _t208 = [];

      for (var _e218 of this.cells) {
        _t208.push(..._e218.trainableWeights);
      }

      return _t208.concat(e);
    }

    return e;
  }

  getWeights() {
    var e = [];

    for (var _t209 of this.cells) {
      e.push(..._t209.weights);
    }

    return lh(e);
  }

  setWeights(e) {
    var t = [];

    for (var _n122 of this.cells) {
      var _s109 = e.splice(_n122.weights.length);

      for (var _e219 = 0; _e219 < _n122.weights.length; ++_e219) {
        t.push([_n122.weights[_e219], _s109[_e219]]);
      }
    }

    uh(t);
  }

}

function Op(e) {
  var {
    ones: t,
    rate: n,
    training: s = !1,
    count: r = 1
  } = e,
      a = () => Tc(t(), n),
      i = () => Ec(a, t, s);

  return !r || r <= 1 ? Zn(i().clone()) : Array(r).fill(void 0).map(i).map(e => Zn(e.clone()));
}

var Mp, Lp, zp;
_p.className = "StackedRNNCells", qn(_p);

class Bp extends Cp {
  constructor(e) {
    if (e.unroll) throw new xu("Unrolling is not possible with convolutional RNNs.");
    if (Array.isArray(e.cell)) throw new xu("It is not possible at the moment to stack convolutional cells.");
    super(e), this.inputSpec = [new ch({
      ndim: 5
    })];
  }

  call(e, t) {
    return Yn(() => {
      if (null != this.cell.dropoutMask && (Jn(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (Jn(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), t && t.constants) throw new bu("ConvRNN2D cell does not support constants");
      return super.call(e, {
        mask: null == t ? null : t.mask,
        training: null == t ? null : t.training,
        initialState: null == t ? null : t.initialState
      });
    });
  }

  computeOutputShape(e) {
    var t = this.computeSingleOutputShape(e);
    return this.returnSequences || (t = [t[0], ...t.slice(2)]), this.returnState && (t = [t, ...Array(2).fill([e[0], ...t.slice(-3)])]), t;
  }

  getInitialState(e) {
    return Yn(() => {
      var {
        stateSize: t
      } = this.cell,
          n = this.computeSingleOutputShape(e.shape),
          s = ua([n[0], ...n.slice(2)]);
      return Array.isArray(t) ? Array(t.length).fill(s) : [s];
    });
  }

  resetStates(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    Yn(() => {
      if (!this.stateful) throw new gu("Cannot call resetStates() on an RNN Layer that is not stateful.");
      var n = this.inputSpec[0].shape,
          s = this.computeSingleOutputShape(n),
          r = [s[0], ...s.slice(2)];
      if (null == n[0]) throw new bu("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (null == this.getStates()) this.states_ = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map(() => ua(r)) : [ua(r)];else if (null == e) Jn(this.states_), null != this.keptStates && (Jn(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => ua(r)) : this.states_[0] = ua(r);else {
        if (Array.isArray(e) || (e = [e]), e.length !== this.states_.length) throw new bu("Layer ".concat(this.name, " expects ").concat(this.states_.length, " state(s), but it received ").concat(e.length, " state value(s). Input received: ").concat(e));
        t ? this.keptStates.push(this.states_.slice()) : Jn(this.states_);

        for (var _t210 = 0; _t210 < this.states_.length; ++_t210) {
          var _n123 = e[_t210],
              _s110 = r;
          if (!p(_n123.shape, _s110)) throw new bu("State ".concat(_t210, " is incompatible with layer ").concat(this.name, ": expected shape=").concat(_s110, ", received shape=").concat(_n123.shape));
          this.states_[_t210] = _n123;
        }
      }
      this.states_ = this.states_.map(e => Zn(e.clone()));
    });
  }

  computeSingleOutputShape(e) {
    var {
      dataFormat: t,
      filters: n,
      kernelSize: s,
      padding: r,
      strides: a,
      dilationRate: i
    } = this.cell,
        o = "channelsFirst" === t,
        l = e[o ? 4 : 3],
        u = op(e[o ? 3 : 2], s[0], r, a[0], i[0]),
        c = op(l, s[1], r, a[1], i[1]);
    return [...e.slice(0, 2), ...(o ? [n, u, c] : [u, c, n])];
  }

}

Bp.className = "ConvRNN2D";

class Pp extends Fp {
  constructor(e) {
    var {
      filters: t,
      kernelSize: n,
      strides: s,
      padding: r,
      dataFormat: a,
      dilationRate: i
    } = e;
    super(Object.assign({}, e, {
      units: t
    })), this.filters = t, Mu(this.filters, "filters"), this.kernelSize = ip(n, 2, "kernelSize"), this.kernelSize.forEach(e => Mu(e, "kernelSize")), this.strides = ip(s || 1, 2, "strides"), this.strides.forEach(e => Mu(e, "strides")), this.padding = r || "valid", nc(this.padding), this.dataFormat = a || "channelsLast", tc(this.dataFormat), this.dilationRate = ip(i || 1, 2, "dilationRate"), this.dilationRate.forEach(e => Mu(e, "dilationRate"));
  }

  build(e) {
    var t;
    e = ah(e);
    var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
    if (null == e[n]) throw new bu("The channel dimension of the input should be defined. Found ".concat(e[n]));
    var s = this.kernelSize.concat([e[n], 4 * this.filters]);
    this.kernel = this.addWeight("kernel", s, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint);
    var r = this.kernelSize.concat([this.filters, 4 * this.filters]);

    if (this.recurrentKernel = this.addWeight("recurrent_kernel", r, null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
      var _e220;

      if (this.unitForgetBias) {
        var _n124 = this.biasInitializer,
            _s111 = this.filters;
        _e220 = new ((t = class extends Fc {
          apply(e, t) {
            return yc([_n124.apply([_s111]), ca([_s111]), _n124.apply([2 * _s111])]);
          }

        }).className = "CustomInit", t)();
      } else _e220 = this.biasInitializer;

      this.bias = this.addWeight("bias", [4 * this.filters], null, _e220, this.biasRegularizer, !0, this.biasConstraint);
    }

    this.built = !0;
  }

  call(e, t) {
    return Yn(() => {
      if (3 !== e.length) throw new bu("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ".concat(e.length, "."));
      var n = t.training || !1,
          s = e[0],
          r = e[1],
          a = e[2];
      0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Op({
        ones: () => xa(s),
        rate: this.dropout,
        training: n,
        count: 4
      }));

      var i = this.dropoutMask,
          o = (e, t, n) => t && t[n] ? ss(t[n], e) : e;

      var l = o(s, i, 0),
          u = o(s, i, 1),
          c = o(s, i, 2),
          h = o(s, i, 3);
      0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Op({
        ones: () => xa(r),
        rate: this.recurrentDropout,
        training: n,
        count: 4
      }));
      var d = this.recurrentDropoutMask;
      var p = o(r, d, 0),
          f = o(r, d, 1),
          g = o(r, d, 2),
          m = o(r, d, 3);
      var [b, x, y, k] = oi(this.kernel.read(), 4, 3),
          [w, v, I, $] = this.useBias ? oi(this.bias.read(), 4) : [null, null, null, null];
      l = this.inputConv(l, b, w, this.padding), u = this.inputConv(u, x, v, this.padding), c = this.inputConv(c, y, I, this.padding), h = this.inputConv(h, k, $, this.padding);
      var [N, C, S, T] = oi(this.recurrentKernel.read(), 4, 3);
      p = this.recurrentConv(p, N), f = this.recurrentConv(f, C), g = this.recurrentConv(g, S), m = this.recurrentConv(m, T);
      var E = this.recurrentActivation.apply(es(l, p)),
          R = this.recurrentActivation.apply(es(u, f)),
          A = es(ss(R, a), ss(E, this.activation.apply(es(c, g)))),
          F = ss(this.recurrentActivation.apply(es(h, m)), this.activation.apply(A));
      return [F, F, A];
    });
  }

  getConfig() {
    var e = function (e, t) {
      var n = {};

      for (var s in e) {
        Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
      }

      if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
        var r = 0;

        for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) {
          t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]]);
        }
      }

      return n;
    }(super.getConfig(), ["units"]);

    return Object.assign({}, e, {
      filters: this.filters,
      kernelSize: this.kernelSize,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      strides: this.strides
    });
  }

  inputConv(e, t, n, s) {
    var r = Xs(e, t, this.strides, s || "valid", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC", this.dilationRate);
    return n ? Sc(r, n, this.dataFormat) : r;
  }

  recurrentConv(e, t) {
    return Xs(e, t, 1, "same", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC");
  }

}

Pp.className = "ConvLSTM2DCell", qn(Pp);

class Wp extends Bp {
  constructor(e) {
    var t = new Pp(e);
    super(Object.assign({}, e, {
      cell: t
    }));
  }

  static fromConfig(e, t) {
    return new e(t);
  }

}

Wp.className = "ConvLSTM2D", qn(Wp);

class Up extends gh {
  constructor(e) {
    super(e), this.rate = Math.max(Math.min(e.rate, 1), 0), this.noiseShape = e.noiseShape, this.seed = e.seed, this.supportsMasking = !0;
  }

  getNoiseShape(e) {
    if (null == this.noiseShape) return this.noiseShape;
    var t = e.shape,
        n = [];

    for (var _e221 = 0; _e221 < this.noiseShape.length; ++_e221) {
      n.push(null == this.noiseShape[_e221] ? t[_e221] : this.noiseShape[_e221]);
    }

    return n;
  }

  call(e, t) {
    return Yn(() => {
      this.invokeCallHook(e, t);
      var n = rh(e);

      if (0 < this.rate && this.rate < 1) {
        var _e222 = null != t.training && t.training,
            _s112 = this.getNoiseShape(n);

        return Ec(() => Tc(n, this.rate, _s112, this.seed), () => n, _e222);
      }

      return e;
    });
  }

  getConfig() {
    var e = {
      rate: this.rate,
      noiseShape: this.noiseShape,
      seed: this.seed
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

  dispose() {
    return super.dispose();
  }

}

Up.className = "Dropout", qn(Up);

class Vp extends Up {
  constructor(e) {
    super(e), this.inputSpec = [{
      ndim: 3
    }];
  }

  getNoiseShape(e) {
    var t = e.shape;
    return [t[0], 1, t[2]];
  }

}

Vp.className = "SpatialDropout1D", qn(Vp);

class Gp extends gh {
  constructor(e) {
    if (super(e), this.activation = null, this.useBias = !0, this.kernel = null, this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", null == e.batchInputShape && null == e.inputShape && null != e.inputDim) {
      var _t211 = null;
      null != e.batchSize && (_t211 = e.batchSize), this.batchInputShape = [_t211, e.inputDim];
    }

    this.units = e.units, Mu(this.units, "units"), this.activation = qd(e.activation), null != e.useBias && (this.useBias = e.useBias), this.kernelInitializer = Jc(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.biasInitializer = Jc(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelConstraint = Ku(e.kernelConstraint), this.biasConstraint = Ku(e.biasConstraint), this.kernelRegularizer = Qd(e.kernelRegularizer), this.biasRegularizer = Qd(e.biasRegularizer), this.activityRegularizer = Qd(e.activityRegularizer), this.supportsMasking = !0, this.inputSpec = [{
      minNDim: 2
    }];
  }

  build(e) {
    var t = (e = ah(e))[e.length - 1];
    null == this.kernel && (this.kernel = this.addWeight("kernel", [t, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{
      minNDim: 2,
      axes: {
        [-1]: t
      }
    }], this.built = !0;
  }

  computeOutputShape(e) {
    var t = (e = ah(e)).slice();
    return t[t.length - 1] = this.units, t;
  }

  call(e, t) {
    return Yn(() => {
      this.invokeCallHook(e, t);
      var n = rh(e),
          s = zu(this.activation.getClassName());
      var r;
      return null != s ? r = Ic(n, this.kernel.read(), s, this.bias ? this.bias.read() : null) : (r = Ic(n, this.kernel.read()), null != this.bias && (r = Sc(r, this.bias.read())), null != this.activation && (r = this.activation.apply(r))), r;
    });
  }

  getConfig() {
    var e = {
      units: this.units,
      activation: Hd(this.activation),
      useBias: this.useBias,
      kernelInitializer: Yc(this.kernelInitializer),
      biasInitializer: Yc(this.biasInitializer),
      kernelRegularizer: Jd(this.kernelRegularizer),
      biasRegularizer: Jd(this.biasRegularizer),
      activityRegularizer: Jd(this.activityRegularizer),
      kernelConstraint: ju(this.kernelConstraint),
      biasConstraint: ju(this.biasConstraint)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Gp.className = "Dense", qn(Gp);

class Hp extends gh {
  constructor(e) {
    super(e = e || {}), this.inputSpec = [{
      minNDim: 3
    }], this.dataFormat = e.dataFormat;
  }

  computeOutputShape(e) {
    e = ah(e);

    for (var _t212 of e.slice(1)) {
      if (null == _t212) throw new bu("The shape of the input to \"Flatten\" is not fully defined (got ".concat(e.slice(1), "). Make sure to pass a complete \"input_shape\" or \"batch_input_shape\" argument to the first layer in your model."));
    }

    return [e[0], cc(e, 1)];
  }

  call(e, t) {
    return Yn(() => {
      this.invokeCallHook(e, t);
      var n = rh(e);

      if ("channelsFirst" === this.dataFormat && n.rank > 1) {
        var _e223 = [0];

        for (var _t213 = 2; _t213 < n.rank; ++_t213) {
          _e223.push(_t213);
        }

        _e223.push(1), n = $n(n, _e223);
      }

      return function (e) {
        if (e.rank <= 1) throw new bu("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank, "."));
        var t = [e.shape[0], cc(e.shape, 1)];
        return Es(e, t);
      }(n);
    });
  }

  getConfig() {
    var e = {};
    null != this.dataFormat && (e.dataFormat = this.dataFormat);
    var t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Hp.className = "Flatten", qn(Hp);

class jp extends gh {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.activation = qd(e.activation);
  }

  call(e, t) {
    return Yn(() => {
      this.invokeCallHook(e, t);
      var n = rh(e);
      return this.activation.apply(n);
    });
  }

  getConfig() {
    var e = {
      activation: Hd(this.activation)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

jp.className = "Activation", qn(jp);

class qp extends gh {
  constructor(e) {
    super(e), this.n = e.n, this.inputSpec = [{
      ndim: 2
    }];
  }

  computeOutputShape(e) {
    return [e[0], this.n, e[1]];
  }

  call(e, t) {
    return Yn(() => {
      return e = rh(e), t = e, n = this.n, Yn(() => {
        if (2 !== t.shape.length) throw new bu("repeat() expects a rank-2 tensor, but received a rank-".concat(t.shape.length, " tensor."));
        return wc(gc(t, 1), [1, n, 1]);
      });
      var t, n;
    });
  }

  getConfig() {
    var e = {
      n: this.n
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

qp.className = "RepeatVector", qn(qp);

class Kp extends gh {
  constructor(e) {
    super(e), this.targetShape = e.targetShape;

    for (var _e224 = 0; _e224 < this.targetShape.length; ++_e224) {
      this.isUnknown(this.targetShape[_e224]) && (this.targetShape[_e224] = null);
    }
  }

  isUnknown(e) {
    return e < 0 || null == e;
  }

  fixUnknownDimension(e, t) {
    var n = "Total size of new array must be unchanged.",
        s = t.slice();
    var r = 1,
        a = null;

    for (var _e225 = 0; _e225 < s.length; ++_e225) {
      var _t214 = s[_e225];

      if (this.isUnknown(_t214)) {
        if (null !== a) throw new bu("Can only specifiy one unknown dimension.");
        a = _e225;
      } else r *= _t214;
    }

    var i = cc(e);

    if (null !== a) {
      if (0 === r || i % r != 0) throw new bu(n);
      s[a] = i / r;
    } else if (i !== r) throw new bu(n);

    return s;
  }

  computeOutputShape(e) {
    var t = !1;

    for (var _n125 = 0; _n125 < e.length; ++_n125) {
      if (this.isUnknown(e[_n125])) {
        t = !0;
        break;
      }
    }

    return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
  }

  call(e, t) {
    return Yn(() => {
      this.invokeCallHook(e, t);
      var n = rh(e),
          s = n.shape,
          r = s.slice(0, 1).concat(this.fixUnknownDimension(s.slice(1), this.targetShape));
      return Es(n, r);
    });
  }

  getConfig() {
    var e = {
      targetShape: this.targetShape
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Kp.className = "Reshape", qn(Kp);

class Xp extends gh {
  constructor(e) {
    if (super(e), null == e.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
    if (!Array.isArray(e.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received ".concat(e.dims, " instead."));
    var t = pc(1, e.dims.length + 1);
    if (!p(e.dims.slice().sort(), t)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
    this.dims = e.dims, this.dimsIncludingBatch = [0].concat(this.dims), this.inputSpec = [new ch({
      ndim: this.dims.length + 1
    })];
  }

  computeOutputShape(e) {
    var t = (e = ah(e)).slice();
    return this.dims.forEach((n, s) => {
      t[s + 1] = e[n];
    }), t;
  }

  call(e, t) {
    return $n(rh(e), this.dimsIncludingBatch);
  }

  getConfig() {
    var e = {
      dims: this.dims
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Xp.className = "Permute", qn(Xp);

class Yp extends gh {
  constructor(e) {
    super(null == e ? {} : e), this.supportsMasking = !0, this.maskValue = null != e ? null == e.maskValue ? 0 : e.maskValue : 0;
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      maskValue: this.maskValue
    };
    return Object.assign(t, e), t;
  }

  computeMask(e, t) {
    var n = rh(e);
    return ls(ba(n, this.maskValue), -1);
  }

  call(e, t) {
    return Yn(() => {
      this.invokeCallHook(e, t);
      var n = rh(e),
          s = ls(ba(n, this.maskValue), -1, !0);
      return ss(n, pn(s, n.dtype));
    });
  }

}

Yp.className = "Masking", qn(Yp);

class Jp extends gh {
  constructor(e) {
    if (super(e), this.embeddings = null, this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == e.batchInputShape && null == e.inputShape) {
      var _t215 = null;
      null != e.batchSize && (_t215 = e.batchSize), this.batchInputShape = null == e.inputLength ? [_t215, null] : [_t215].concat($u(e.inputLength));
    }

    this.inputDim = e.inputDim, Mu(this.inputDim, "inputDim"), this.outputDim = e.outputDim, Mu(this.outputDim, "outputDim"), this.embeddingsInitializer = Jc(e.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER), this.embeddingsRegularizer = Qd(e.embeddingsRegularizer), this.activityRegularizer = Qd(e.activityRegularizer), this.embeddingsConstraint = Ku(e.embeddingsConstraint), this.maskZero = e.maskZero, this.supportsMasking = e.maskZero, this.inputLength = e.inputLength;
  }

  build(e) {
    this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0;
  }

  warnOnIncompatibleInputShape(e) {}

  computeMask(e, t) {
    return Yn(() => this.maskZero ? (e = rh(e), ba(e, pr(e))) : null);
  }

  computeOutputShape(e) {
    if (e = ah(e), null == this.inputLength) return [...e, this.outputDim];
    var t = $u(this.inputLength);
    if (t.length !== e.length - 1) throw new bu("\"inputLength\" is ".concat(this.inputLength, ", but received input shape has shape ").concat(e));
    {
      var _n126 = 0;

      for (var _s113 = 0; _s113 < t.length; ++_s113) {
        var _r77 = t[_s113],
            _a61 = e[_s113 + 1];
        if (null != _r77 && null != _a61 && _r77 !== _a61) throw new bu("\"inputLength\" is ".concat(this.inputLength, ", but received input shape has shape ").concat(e));
        null == _r77 && (t[_n126] = _a61), _n126++;
      }
    }
    return [e[0], ...t, this.outputDim];
  }

  call(e, t) {
    return Yn(() => {
      this.invokeCallHook(e, t);
      var n = rh(e);
      "int32" !== n.dtype && (n = fc(n, "int32"));
      var s = $c(this.embeddings.read(), Es(n, [n.size]));
      return Es(s, ah(this.computeOutputShape(n.shape)));
    });
  }

  getConfig() {
    var e = {
      inputDim: this.inputDim,
      outputDim: this.outputDim,
      embeddingsInitializer: Yc(this.embeddingsInitializer),
      embeddingsRegularizer: Jd(this.embeddingsRegularizer),
      activityRegularizer: Jd(this.activityRegularizer),
      embeddingsConstraint: ju(this.embeddingsConstraint),
      maskZero: this.maskZero,
      inputLength: this.inputLength
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

Jp.className = "Embedding", qn(Jp);

class Zp extends gh {
  constructor(e) {
    super(e || {}), this.supportsMasking = !0;
  }

  mergeFunction(e) {
    throw new xu();
  }

  computeElementwiseOpOutputShape(e, t) {
    if (null == e || null == t) return null;
    if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
    if (0 === t.length) return e;
    var n = e.slice(0, e.length - t.length);

    for (var _s114 = 0; _s114 < t.length; ++_s114) {
      var _r78 = e[e.length - t.length + _s114],
          _a62 = t[_s114];
      if (null == _r78 || null == _a62 || _r78 < 0 || _a62 < 0) n.push(null);else if (1 === _r78) n.push(_a62);else if (1 === _a62) n.push(_r78);else {
        if (_r78 !== _a62) throw new bu("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
        n.push(_r78);
      }
    }

    return n;
  }

  build(e) {
    if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [ah(e)]), (e = e).length < 2) throw new bu("A merge layer should be called on an Array of at least 2 inputs. Got ".concat(e.length, " input(s)."));
    var t = [];

    for (var _n127 of e) {
      null != _n127 && null !== _n127[0] && t.push(_n127[0]);
    }

    if (t = Fu(t), t.length > 1) throw new bu("Can not merge tensors with different batch sizes. Got tensors with shapes: ".concat(JSON.stringify(e), "."));
    var n = null == e[0] ? null : e[0].slice(1);

    for (var _t216 = 1; _t216 < e.length; ++_t216) {
      var _s115 = null == e[_t216] ? null : e[_t216].slice(1);

      n = this.computeElementwiseOpOutputShape(n, _s115);
    }

    var s = e.map(e => e.length);
    this.reshapeRequired = -1 !== e.indexOf(null) || 1 !== Fu(s).length;
  }

  call(e, t) {
    return Yn(() => {
      if (e = e, this.reshapeRequired) {
        var _t217 = [],
            _n128 = e.map(e => e.rank);

        if (-1 === _n128.indexOf(null)) {
          var _s116 = dc(_n128);

          for (var _n129 of e) {
            var _e226 = _n129.rank;

            for (var _t218 = 0; _t218 < _s116 - _e226; ++_t218) {
              _n129 = gc(_n129, 1);
            }

            _t217.push(_n129);
          }

          return this.mergeFunction(_t217);
        }

        {
          var _n130 = !1;

          for (var _s118 of e) {
            var _e227 = _s118.rank;

            if (null == _e227) {
              var _e228 = _s118.shape,
                  _r80 = _e228[0],
                  _a63 = _e228.slice(1).concat([_r80]);

              var _i35 = Es(_s118, [_r80].concat(cc(_e228.slice(1))));

              _i35 = $n(_i35, [1, 0]), _i35 = Es(_i35, _a63), _t217.push(_i35), _n130 = !0;
            } else if (_e227 > 1) {
              var _r81 = pc(1, _e227).concat([0]);

              _t217.push($n(_s118, _r81)), _n130 = !0;
            } else _t217.push(_s118);
          }

          var _s117 = this.mergeFunction(_t217);

          var _r79 = _s117.rank;
          if (_n130) if (null == _r79) {
            var _e229 = _s117.shape,
                _t219 = _e229[_e229.length - 1],
                _n131 = [_t219].concat(_e229.slice(0, _e229.length - 1));

            _s117 = Es($n(Es(_s117, [-1, _t219]), [1, 0]), _n131);
          } else if (_r79 > 1) {
            var _e230 = [_r79 - 1].concat(pc(0, _r79 - 1));

            _s117 = $n(_s117, _e230);
          }
          return _s117;
        }
      }

      return this.mergeFunction(e);
    });
  }

  computeOutputShape(e) {
    var t;
    t = null == (e = e)[0] ? null : e[0].slice(1);

    for (var _n132 = 1; _n132 < e.length; ++_n132) {
      var _s119 = null == e[_n132] ? null : e[_n132].slice(1);

      t = this.computeElementwiseOpOutputShape(t, _s119);
    }

    var n = [];

    for (var _t220 of e) {
      null != _t220 && null !== _t220[0] && n.push(_t220[0]);
    }

    return n = Fu(n), t = 1 === n.length ? n.concat(t) : [null].concat(t), t;
  }

  computeMask(e, t) {
    return Yn(() => {
      if (null == t) return null;
      if (!Array.isArray(t)) throw new bu("`mask` should be an Array");
      if (!Array.isArray(e)) throw new bu("`inputs` should be an Array");
      if (t.length !== e.length) throw new bu("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (".concat(e.length, " vs ").concat(t.length, ")"));
      if (t.every(e => null == e)) return null;
      var n = (t = t.map(e => null == e ? e : yr(e, 0)))[0];

      for (var _e231 = 1; _e231 < t.length - 1; ++_e231) {
        n = ta(n, t[_e231]);
      }

      return n;
    });
  }

}

class Qp extends Zp {
  constructor(e) {
    super(e);
  }

  mergeFunction(e) {
    return Yn(() => {
      var t = e[0].clone();

      for (var _n133 = 1; _n133 < e.length; ++_n133) {
        t = es(t, e[_n133]);
      }

      return t;
    });
  }

}

Qp.className = "Add", qn(Qp);

class ef extends Zp {
  constructor(e) {
    super(e);
  }

  mergeFunction(e) {
    return Yn(() => {
      var t = e[0].clone();

      for (var _n134 = 1; _n134 < e.length; ++_n134) {
        t = ss(t, e[_n134]);
      }

      return t;
    });
  }

}

ef.className = "Multiply", qn(ef);

class tf extends Zp {
  constructor(e) {
    super(e);
  }

  mergeFunction(e) {
    return Yn(() => {
      var t = e[0].clone();

      for (var _n135 = 1; _n135 < e.length; ++_n135) {
        t = es(t, e[_n135]);
      }

      return ss(1 / e.length, t);
    });
  }

}

tf.className = "Average", qn(tf);

class nf extends Zp {
  constructor(e) {
    super(e);
  }

  mergeFunction(e) {
    return Yn(() => {
      var t = e[0];

      for (var _n136 = 1; _n136 < e.length; ++_n136) {
        t = oa(t, e[_n136]);
      }

      return t;
    });
  }

}

nf.className = "Maximum", qn(nf);

class sf extends Zp {
  constructor(e) {
    super(e);
  }

  mergeFunction(e) {
    return Yn(() => {
      var t = e[0];

      for (var _n137 = 1; _n137 < e.length; ++_n137) {
        t = da(t, e[_n137]);
      }

      return t;
    });
  }

}

sf.className = "Minimum", qn(sf);

class rf extends Zp {
  constructor(e) {
    super(e), this.DEFAULT_AXIS = -1, null == e && (e = {}), this.axis = null == e.axis ? this.DEFAULT_AXIS : e.axis, this.supportsMasking = !0, this.reshapeRequired = !1;
  }

  build(e) {
    if (!Array.isArray(e) || !Array.isArray(e[0]) || 1 === e.length) throw new bu("A `Concatenate` layer should be called on a list of at least 2 inputs");
    e = e;
    var t = !0;

    for (var _n138 of e) {
      if (null != _n138) {
        t = !1;
        break;
      }
    }

    if (t) return;
    var n = [];

    for (var _t221 = 0; _t221 < e.length; ++_t221) {
      var _s120 = e[_t221].slice();

      _s120.splice(this.axis, 1);

      var _r82 = !1;

      for (var _e232 of n) {
        if (p(_e232, _s120)) {
          _r82 = !0;
          break;
        }
      }

      _r82 || n.push(_s120);
    }

    if (n.length > 1) throw new bu("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e));
  }

  mergeFunction(e) {
    return Yn(() => yc(e, this.axis));
  }

  computeOutputShape(e) {
    if (!Array.isArray(e) || !Array.isArray(e[0])) throw new bu("A `Concatenate` layer should be called on a list of inputs.");
    var t = e,
        n = t[0].slice(),
        s = this.axis < 0 ? n.length + this.axis : this.axis;

    for (var _e233 of t.slice(1)) {
      if (null == n[s] || null == _e233[s]) {
        n[s] = null;
        break;
      }

      n[s] += _e233[s];
    }

    return n;
  }

  computeMask(e, t) {
    if (null == t) return null;
    if (!Array.isArray(t)) throw new bu("`mask` should be an array for Concatenate");
    if (!Array.isArray(e)) throw new bu("`inputs` should be an array for Concatenate");
    if (t.length !== e.length) throw new bu("Mismatch in the length of mask (".concat(t.length, ") and the legnth of inputs (").concat(e.length, ")"));
    return Yn(() => {
      var n = !0;
      if (t.forEach(e => {
        null == e || (n = !1);
      }), n) return null;
      var s = [];

      for (var _n139 = 0; _n139 < e.length; ++_n139) {
        s.push(null == t[_n139] ? pn(xa(e[_n139]), "bool") : t[_n139].rank < e[_n139].rank ? yr(t[_n139], -1) : t[_n139]);
      }

      var r = Fs(s, this.axis);
      return os(r, -1, !1);
    });
  }

  getConfig() {
    var e = {
      axis: this.axis
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

function af(e, t) {
  for (; e < 0;) {
    e += t;
  }

  return e;
}

rf.className = "Concatenate", qn(rf);

class of extends Zp {
  constructor(e) {
    super(e), this.axes = e.axes, this.normalize = null != e.normalize && e.normalize, this.supportsMasking = !0, this.reshapeRequired = !1;
  }

  build(e) {
    l(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    var t = e[0],
        n = e[1];
    if (t.length > 3 || n.length > 3) throw new xu("Dot layer does not support tensors of 4D or higher rank yet.");
    var s = this.interpretAxes(t, n);
    if (t[s[0]] !== n[s[1]]) throw new bu("Dimension incompatibility: ".concat(t[s[0]], " !== ").concat(n[s[1]]));
  }

  mergeFunction(e) {
    if (2 !== e.length) throw new bu("A `Dot` layer must be called on exactly 2 inputs, but received ".concat(e.length, " input(s)."));
    var t,
        n = e[0],
        s = e[1];
    return t = Array.isArray(this.axes) ? this.axes.map((t, n) => af(t, e[n].shape.length)) : [af(this.axes, n.shape.length), af(this.axes, s.shape.length)], this.normalize && (n = Rh(n, t[0]), s = Rh(s, t[1])), function (e, t, n) {
      if (e.shape.length > 3 || t.shape.length > 3) throw new xu("batchDot is not implemented for tensors of 4D or higher rank yet");
      if (l(e.shape.length >= 2, () => "batchDot requires the rank of x to be >= 2, but got ".concat(e.shape.length)), l(e.shape.length >= 2, () => "batchDot requires the rank of y to be >= 2, but got ".concat(t.shape.length)), "number" == typeof n && (n = [n, n]), "complex64" === e.dtype || "complex64" === t.dtype) throw new xu("batchDot is not implemented for complex64-type Tensors yet.");
      var s = e.shape.length,
          r = t.shape.length;
      null == n && (n = [s - 1, r - 2]);
      var a = n;
      return Yn(() => {
        var n, i;

        if (s > r) {
          n = s - r;
          var _e234 = [];

          for (var _t222 = 0; _t222 < n; ++_t222) {
            _e234.push(1);
          }

          t = Es(t, t.shape.concat(_e234));
        } else if (r > s) {
          n = r - s;
          var _t223 = [];

          for (var _e235 = 0; _e235 < n; ++_e235) {
            _t223.push(1);
          }

          e = Es(e, e.shape.concat(_t223));
        } else n = 0;

        if (i = 2 === e.shape.length && 2 === t.shape.length ? a[0] === a[1] ? Gr(ss(e, t), a[0]) : Gr(ss($n(e, [1, 0]), t), a[1]) : vn(e, t, a[0] !== e.shape.length - 1, a[1] === t.shape.length - 1), n > 0) {
          var _e236;

          _e236 = s > r ? s + r - 3 : s - 1;
          var _t224 = [];

          for (var _s121 = _e236; _s121 < _e236 + n; ++_s121) {
            _t224.push(_s121);
          }

          i = hi(i, _t224);
        }

        return 1 === i.shape.length && (i = yr(i, 1)), i;
      });
    }(n, s, t);
  }

  interpretAxes(e, t) {
    var n;
    return n = Array.isArray(this.axes) ? this.axes : [af(this.axes, e.length), af(this.axes, t.length)], n;
  }

  computeOutputShape(e) {
    l(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    var t = e[0].slice(),
        n = e[1].slice();
    if (t.length > 3 || n.length > 3) throw new xu("Dot layer does not support tensors of 4D or higher rank yet.");
    var s = this.interpretAxes(t, n);
    t.splice(s[0], 1), n.splice(s[1], 1), n.splice(0, 1);
    var r = t.concat(n);
    return 1 === r.length && r.push(1), r;
  }

  computeMask(e, t) {
    return null;
  }

  getConfig() {
    var e = {
      axes: this.axes,
      normalize: this.normalize
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

of.className = "Dot", qn(of);

class lf extends gh {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.stddev = e.stddev;
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      stddev: this.stddev
    };
    return Object.assign(t, e), t;
  }

  call(e, t) {
    return Yn(() => {
      this.invokeCallHook(e, t);
      var n = rh(e);
      return Ec(() => es(vc(n.shape, 0, this.stddev), n), () => n, t.training || !1);
    });
  }

}

lf.className = "GaussianNoise", qn(lf);

class uf extends gh {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.rate = e.rate;
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      rate: this.rate
    };
    return Object.assign(t, e), t;
  }

  call(e, t) {
    return Yn(() => {
      this.invokeCallHook(e, t);
      var n = rh(e);
      return this.rate > 0 && this.rate < 1 ? Ec(() => {
        var e = Math.sqrt(this.rate / (1 - this.rate));
        return ss(n, vc(n.shape, 1, e));
      }, () => n, t.training || !1) : n;
    });
  }

}

uf.className = "GaussianDropout", qn(uf);

class cf extends gh {
  constructor(e) {
    super(e), this.supportsMasking = !0, this.rate = e.rate, this.noiseShape = e.noiseShape;
  }

  _getNoiseShape(e) {
    return this.noiseShape || rh(e).shape;
  }

  computeOutputShape(e) {
    return e;
  }

  getConfig() {
    var e = super.getConfig(),
        t = {
      rate: this.rate
    };
    return Object.assign(t, e), t;
  }

  call(e, t) {
    return Yn(() => {
      if (this.rate < 1 && this.rate > 0) {
        var _n140 = this._getNoiseShape(e);

        return Ec(() => {
          var t = rh(e),
              s = -1.7580993408473766;
          var r = Sr(za(_n140), this.rate);
          r = fc(r, "float32");
          var a = ((1 - this.rate) * (1 + this.rate * s ** 2)) ** -.5,
              i = -a * s * this.rate,
              o = es(ss(t, r), ss(es(r, -1), s));
          return es(ss(o, a), i);
        }, () => rh(e), t.training || !1);
      }

      return e;
    });
  }

}

function hf(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : .001;
  var i;
  if (2 === e.rank) i = zs(e, t, n, s, r, a);else if (3 === e.rank) i = Bs(e, t, n, s, r, a);else {
    if (4 !== e.rank) throw new xu("batchNormalization is not implemented for array of rank ".concat(e.rank, " yet"));
    i = Ps(e, t, n, s, r, a);
  }
  return i;
}

cf.className = "AlphaDropout", qn(cf);

class df extends gh {
  constructor(e) {
    null == e && (e = {}), super(e), this.supportsMasking = !0, this.axis = null == e.axis ? -1 : e.axis, this.momentum = null == e.momentum ? .99 : e.momentum, this.epsilon = null == e.epsilon ? .001 : e.epsilon, this.center = null == e.center || e.center, this.scale = null == e.scale || e.scale, this.betaInitializer = Jc(e.betaInitializer || "zeros"), this.gammaInitializer = Jc(e.gammaInitializer || "ones"), this.movingMeanInitializer = Jc(e.movingMeanInitializer || "zeros"), this.movingVarianceInitializer = Jc(e.movingVarianceInitializer || "ones"), this.betaConstraint = Ku(e.betaConstraint), this.gammaConstraint = Ku(e.gammaConstraint), this.betaRegularizer = Qd(e.betaRegularizer), this.gammaRegularizer = Qd(e.gammaRegularizer);
  }

  build(e) {
    e = ah(e);
    var t = this.axis >= 0 ? this.axis : this.axis + e.length,
        n = e[t];
    if (null == n) throw new bu("Axis ".concat(t, " of input tensor should have a defined dimension but the layer received an input with shape ").concat(JSON.stringify(e), "."));
    this.inputSpec = [new ch({
      ndim: e.length,
      axes: {
        [t]: n
      }
    })];
    var s = [n];
    this.scale && (this.gamma = this.addWeight("gamma", s, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", s, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", s, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", s, null, this.movingVarianceInitializer, null, !1), this.built = !0;
  }

  call(e, t) {
    return Yn(() => {
      var n = null != t.training && t.training,
          s = rh(e),
          r = s.shape,
          a = r.length,
          i = pc(0, a),
          o = this.axis >= 0 ? this.axis : this.axis + a;
      i.splice(o, 1);
      var l = ku(1, a);
      l[o] = r[o];
      var u = i.slice();
      u.sort();
      var c = !p(u, pc(0, a).slice(0, a - 1));
      if (!n) return (() => {
        if (c) {
          var _e237 = Es(this.movingMean.read(), l),
              _t225 = Es(this.movingVariance.read(), l),
              _n141 = this.center ? Es(this.beta.read(), l) : null,
              _r83 = this.scale ? Es(this.gamma.read(), l) : null;

          return hf(s, _e237, _t225, _n141, _r83, this.epsilon);
        }

        return hf(s, this.movingMean.read(), this.movingVariance.read(), null == this.beta ? null : this.beta.read(), null == this.gamma ? null : this.gamma.read(), this.epsilon);
      })();

      var [h, d, f] = function (e, t, n, s) {
        var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .001;
        return p(s.slice().sort(), pc(0, e.rank - 1)) ? function (e, t, n, s) {
          var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .001;
          return Yn(() => {
            var a = ma(e, s),
                i = a.mean,
                o = a.variance;
            return [hf(e, i, o, n, t, r), i, o];
          });
        }(e, t, n, s, r) : function (e, t, n, s) {
          var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .001;
          return Yn(() => {
            var a = ma(e, s),
                i = a.mean,
                o = a.variance,
                l = [];

            for (var _t226 of pc(0, e.rank)) {
              -1 !== s.indexOf(_t226) ? l.push(1) : l.push(e.shape[_t226]);
            }

            var u = Es(i, l),
                c = Es(o, l),
                h = null == t ? null : Es(t, l),
                d = null == n ? null : Es(n, l);
            return [hf(e, u, c, d, h, r), i, o];
          });
        }(e, t, n, s, r);
      }(s, this.gamma.read(), this.beta.read(), i, this.epsilon),
          g = (e, t, n) => {
        Yn(() => {
          var s = 1 - n,
              r = e.read(),
              a = ss(Vr(r, t), s);
          e.write(Vr(r, a));
        });
      };

      return (() => {
        g(this.movingMean, d, this.momentum), g(this.movingVariance, f, this.momentum);
      })(), h;
    });
  }

  getConfig() {
    var e = {
      axis: this.axis,
      momentum: this.momentum,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: Yc(this.betaInitializer),
      gammaInitializer: Yc(this.gammaInitializer),
      movingMeanInitializer: Yc(this.movingMeanInitializer),
      movingVarianceInitializer: Yc(this.movingVarianceInitializer),
      betaRegularizer: Jd(this.betaRegularizer),
      gammaRegularizer: Jd(this.gammaRegularizer),
      betaConstraint: ju(this.betaConstraint),
      gammaConstraint: ju(this.gammaConstraint)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

df.className = "BatchNormalization", qn(df);

class pf extends gh {
  constructor(e) {
    if (null == e && (e = {}), super(e), this.axis = null == e.axis ? -1 : e.axis, "number" == typeof this.axis) {
      if (!Number.isInteger(this.axis)) throw new Error("Expected axis to be an integer, but received ".concat(this.axis));
    } else {
      if (!Array.isArray(this.axis)) throw new Error("Expected axis to be an integer or an array of integers, but received ".concat(JSON.stringify(this.axis)));

      for (var _e238 of this.axis) {
        if (!Number.isInteger(_e238)) throw new Error("Expected axis to be an array of integers, but received ".concat(JSON.stringify(this.axis)));
      }
    }

    this.epsilon = null == e.epsilon ? .001 : e.epsilon, this.center = null == e.center || e.center, this.scale = null == e.scale || e.scale, this.betaInitializer = Jc(e.betaInitializer || "zeros"), this.gammaInitializer = Jc(e.gammaInitializer || "ones"), this.betaRegularizer = Qd(e.betaRegularizer), this.gammaRegularizer = Qd(e.gammaRegularizer), this.supportsMasking = !0;
  }

  build(e) {
    var t = (e = ah(e)).length;
    "number" == typeof this.axis && (this.axis = [this.axis]);

    for (var _e239 = 0; _e239 < this.axis.length; ++_e239) {
      this.axis[_e239] < 0 && (this.axis[_e239] += t);
    }

    for (var _e240 of this.axis) {
      if (_e240 < 0 || _e240 >= t) throw new Error("Invalid axis: ".concat(_e240));
    }

    if (this.axis.length !== Fu(this.axis).length) throw new Error("Found duplicate axes in: ".concat(this.axis));
    var n = this.axis.map(t => e[t]);
    this.gamma = this.scale ? this.addWeight("gamma", n, "float32", this.gammaInitializer, this.gammaRegularizer, !0) : null, this.beta = this.center ? this.addWeight("beta", n, "float32", this.betaInitializer, this.betaRegularizer, !0) : null, this.built = !0;
  }

  call(e, t) {
    var n = rh(e),
        s = n.shape,
        r = s.length;
    return Yn(() => {
      var {
        mean: e,
        variance: t
      } = ma(n, this.axis, !0);
      var a = ku(1, r);

      for (var _e241 of this.axis) {
        a[_e241] = s[_e241];
      }

      var i = e => null != e && e.shape.length !== r && this.axis !== [r - 1] ? Es(e, a) : e;

      var o = i(this.gamma.read()),
          l = i(this.beta.read());
      var u = [],
          c = [];

      for (var _e242 = 0; _e242 < r; ++_e242) {
        -1 !== this.axis.indexOf(_e242) ? (u.push(s[_e242]), c.push(1)) : (u.push(1), c.push(s[_e242]));
      }

      return e = wr(e, u), t = wr(t, u), o = wr(o, c), l = wr(l, c), hf(n, e, t, l, o, this.epsilon);
    });
  }

  getConfig() {
    var e = {
      axis: this.axis,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: Yc(this.betaInitializer),
      gammaInitializer: Yc(this.gammaInitializer),
      betaRegularizer: Jd(this.betaRegularizer),
      gammaRegularizer: Jd(this.gammaRegularizer)
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

pf.className = "LayerNormalization", qn(pf);

class ff extends gh {
  constructor(e) {
    if (null == e && (e = {}), super(e), this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, null == e.padding) this.padding = [[1, 1], [1, 1]];else if ("number" == typeof e.padding) this.padding = [[e.padding, e.padding], [e.padding, e.padding]];else {
      if (e.padding = e.padding, 2 !== e.padding.length) throw new bu("ZeroPadding2D expects padding to be a length-2 array, but received a length-".concat(e.padding.length, " array."));

      var _t227, _n142;

      if ("number" == typeof e.padding[0]) _t227 = [e.padding[0], e.padding[0]], _n142 = [e.padding[1], e.padding[1]];else {
        if (e.padding = e.padding, 2 !== e.padding[0].length) throw new bu("ZeroPadding2D expects height padding to be a length-2 array, but received a length-".concat(e.padding[0].length, " array."));
        if (_t227 = e.padding[0], 2 !== e.padding[1].length) throw new bu("ZeroPadding2D expects width padding to be a length-2 array, but received a length-".concat(e.padding[1].length, " array."));
        _n142 = e.padding[1];
      }
      this.padding = [_t227, _n142];
    }
    this.inputSpec = [new ch({
      ndim: 4
    })];
  }

  computeOutputShape(e) {
    var t, n;
    return e = ah(e), "channelsFirst" === this.dataFormat ? (t = null != e[2] && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[3] && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null, [e[0], e[1], t, n]) : (t = null != e[1] && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[2] && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null, [e[0], t, n, e[3]]);
  }

  call(e, t) {
    return Yn(() => {
      return t = rh(e), n = this.padding, s = this.dataFormat, Yn(() => {
        if (4 !== t.rank) throw new bu("temporalPadding expects input tensor to be 4-D, but received a ".concat(t.rank, "-D tensor."));
        if (null == n && (n = [[1, 1], [1, 1]]), 2 !== n.length || 2 !== n[0].length || 2 !== n[1].length) throw new bu("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
        if (null == s && (s = "channelsLast"), "channelsLast" !== s && "channelsFirst" !== s) throw new bu("Unknown data format: ".concat(s, ". Supported data formats are 'channelsLast' and 'channelsFirst."));
        var e;
        return e = "channelsFirst" === s ? [[0, 0], [0, 0], n[0], n[1]] : [[0, 0], n[0], n[1], [0, 0]], ya(t, e);
      });
      var t, n, s;
    });
  }

  getConfig() {
    var e = {
      padding: this.padding,
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

function gf(e, t, n, s, r, a) {
  return Yn(() => {
    var i;
    tc(r), sc(a), nc(s), null == n && (n = [1, 1]), null == s && (s = "valid"), null == r && (r = "channelsLast"), null == a && (a = "max"), e = up(e, r);
    var o = "same" === s ? "same" : "valid";
    return i = "max" === a ? aa(e, t, n, o) : Rs(e, t, n, o), "channelsFirst" === r && (i = $n(i, [0, 3, 1, 2])), i;
  });
}

function mf(e, t, n, s, r, a) {
  return Yn(() => {
    var i;
    tc(r), sc(a), nc(s), null == n && (n = [1, 1, 1]), null == s && (s = "valid"), null == r && (r = "channelsLast"), null == a && (a = "max"), e = cp(e, r);
    var o = "same" === s ? "same" : "valid";
    return i = "max" === a ? ia(e, t, n, o) : As(e, t, n, o), "channelsFirst" === r && (i = $n(i, [0, 4, 1, 2, 3])), i;
  });
}

ff.className = "ZeroPadding2D", qn(ff);

class bf extends gh {
  constructor(e) {
    if (null == e.poolSize && (e.poolSize = 2), super(e), "number" == typeof e.poolSize) this.poolSize = [e.poolSize];else {
      if (!Array.isArray(e.poolSize) || 1 !== e.poolSize.length || "number" != typeof e.poolSize[0]) throw new bu("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ".concat(JSON.stringify(e.poolSize)));
      this.poolSize = e.poolSize;
    }
    if (Mu(this.poolSize, "poolSize"), null == e.strides) this.strides = this.poolSize;else if ("number" == typeof e.strides) this.strides = [e.strides];else {
      if (!Array.isArray(e.strides) || 1 !== e.strides.length || "number" != typeof e.strides[0]) throw new bu("strides for 1D convolutional layer must be a number or an Array of a single number, but received ".concat(JSON.stringify(e.strides)));
      this.strides = e.strides;
    }
    Mu(this.strides, "strides"), this.padding = null == e.padding ? "valid" : e.padding, nc(this.padding), this.inputSpec = [new ch({
      ndim: 3
    })];
  }

  computeOutputShape(e) {
    var t = op((e = ah(e))[1], this.poolSize[0], this.padding, this.strides[0]);
    return [e[0], t, e[2]];
  }

  call(e, t) {
    return Yn(() => {
      this.invokeCallHook(e, t), e = gc(rh(e), 2);
      var n = this.poolingFunction(rh(e), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
      return hi(n, [2]);
    });
  }

  getConfig() {
    var e = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

class xf extends bf {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return tc(r), nc(s), gf(e, t, n, s, r, "max");
  }

}

xf.className = "MaxPooling1D", qn(xf);

class yf extends bf {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return tc(r), nc(s), gf(e, t, n, s, r, "avg");
  }

}

yf.className = "AveragePooling1D", qn(yf);

class kf extends gh {
  constructor(e) {
    if (null == e.poolSize && (e.poolSize = [2, 2]), super(e), this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize], null == e.strides) this.strides = this.poolSize;else if (Array.isArray(e.strides)) {
      if (2 !== e.strides.length) throw new bu("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ".concat(e.strides.length, "."));
      this.strides = e.strides;
    } else this.strides = [e.strides, e.strides];
    Mu(this.poolSize, "poolSize"), Mu(this.strides, "strides"), this.padding = null == e.padding ? "valid" : e.padding, this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, tc(this.dataFormat), nc(this.padding), this.inputSpec = [new ch({
      ndim: 4
    })];
  }

  computeOutputShape(e) {
    e = ah(e);
    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
        n = "channelsFirst" === this.dataFormat ? e[3] : e[2];
    return t = op(t, this.poolSize[0], this.padding, this.strides[0]), n = op(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n] : [e[0], t, n, e[3]];
  }

  call(e, t) {
    return Yn(() => (this.invokeCallHook(e, t), this.poolingFunction(rh(e), this.poolSize, this.strides, this.padding, this.dataFormat)));
  }

  getConfig() {
    var e = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

class wf extends kf {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return tc(r), nc(s), gf(e, t, n, s, r, "max");
  }

}

wf.className = "MaxPooling2D", qn(wf);

class vf extends kf {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return tc(r), nc(s), gf(e, t, n, s, r, "avg");
  }

}

vf.className = "AveragePooling2D", qn(vf);

class If extends gh {
  constructor(e) {
    if (null == e.poolSize && (e.poolSize = [2, 2, 2]), super(e), this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize, e.poolSize], null == e.strides) this.strides = this.poolSize;else if (Array.isArray(e.strides)) {
      if (3 !== e.strides.length) throw new bu("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ".concat(e.strides.length, "."));
      this.strides = e.strides;
    } else this.strides = [e.strides, e.strides, e.strides];
    Mu(this.poolSize, "poolSize"), Mu(this.strides, "strides"), this.padding = null == e.padding ? "valid" : e.padding, this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, tc(this.dataFormat), nc(this.padding), this.inputSpec = [new ch({
      ndim: 5
    })];
  }

  computeOutputShape(e) {
    e = ah(e);
    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
        n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
        s = "channelsFirst" === this.dataFormat ? e[4] : e[3];
    return t = op(t, this.poolSize[0], this.padding, this.strides[0]), n = op(n, this.poolSize[1], this.padding, this.strides[1]), s = op(s, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n, s] : [e[0], t, n, s, e[4]];
  }

  call(e, t) {
    return Yn(() => (this.invokeCallHook(e, t), this.poolingFunction(rh(e), this.poolSize, this.strides, this.padding, this.dataFormat)));
  }

  getConfig() {
    var e = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

class $f extends If {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return tc(r), nc(s), mf(e, t, n, s, r, "max");
  }

}

$f.className = "MaxPooling3D", qn($f);

class Nf extends If {
  constructor(e) {
    super(e);
  }

  poolingFunction(e, t, n, s, r) {
    return tc(r), nc(s), mf(e, t, n, s, r, "avg");
  }

}

Nf.className = "AveragePooling3D", qn(Nf);

class Cf extends gh {
  constructor(e) {
    super(e), this.inputSpec = [new ch({
      ndim: 3
    })];
  }

  computeOutputShape(e) {
    return [e[0], e[2]];
  }

  call(e, t) {
    throw new xu();
  }

}

class Sf extends Cf {
  constructor(e) {
    super(e || {});
  }

  call(e, t) {
    return Yn(() => {
      var t = rh(e);
      return la(t, 1);
    });
  }

}

Sf.className = "GlobalAveragePooling1D", qn(Sf);

class Tf extends Cf {
  constructor(e) {
    super(e || {});
  }

  call(e, t) {
    return Yn(() => {
      var t = rh(e);
      return Ur(t, 1);
    });
  }

}

Tf.className = "GlobalMaxPooling1D", qn(Tf);

class Ef extends gh {
  constructor(e) {
    super(e), this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, tc(this.dataFormat), this.inputSpec = [new ch({
      ndim: 4
    })];
  }

  computeOutputShape(e) {
    return e = e, "channelsLast" === this.dataFormat ? [e[0], e[3]] : [e[0], e[1]];
  }

  call(e, t) {
    throw new xu();
  }

  getConfig() {
    var e = {
      dataFormat: this.dataFormat
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

}

class Rf extends Ef {
  call(e, t) {
    return Yn(() => {
      var t = rh(e);
      return la(t, "channelsLast" === this.dataFormat ? [1, 2] : [2, 3]);
    });
  }

}

Rf.className = "GlobalAveragePooling2D", qn(Rf);

class Af extends Ef {
  call(e, t) {
    return Yn(() => {
      var t = rh(e);
      return Ur(t, "channelsLast" === this.dataFormat ? [1, 2] : [2, 3]);
    });
  }

}

Af.className = "GlobalMaxPooling2D", qn(Af);

class Ff extends gh {
  constructor(e) {
    super(e), this.layer = e.layer;
  }

  build(e) {
    this.built = !0;
  }

  get trainable() {
    return null != this.layer && this.layer.trainable;
  }

  set trainable(e) {
    null != this.layer && (this.layer.trainable = e);
  }

  get trainableWeights() {
    return this.layer.trainableWeights;
  }

  get nonTrainableWeights() {
    return this.layer.nonTrainableWeights;
  }

  get updates() {
    return this.layer._updates;
  }

  get losses() {
    return this.layer.losses;
  }

  getWeights() {
    return this.layer.getWeights();
  }

  setWeights(e) {
    this.layer.setWeights(e);
  }

  getConfig() {
    var e = {
      layer: {
        className: this.layer.getClassName(),
        config: this.layer.getConfig()
      }
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), null != this.layer && this.layer.setFastWeightInitDuringBuild(e);
  }

  static fromConfig(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var s = Eh(t.layer, n);
    delete t.layer;
    var r = {
      layer: s
    };
    return Object.assign(r, t), new e(r);
  }

}

class Df extends Ff {
  constructor(e) {
    super(e), this.supportsMasking = !0;
  }

  build(e) {
    if ((e = ah(e)).length < 3) throw new bu("TimeDistributed layer expects an input shape >= 3D, but received input shape ".concat(JSON.stringify(e)));
    this.inputSpec = [{
      shape: e
    }];
    var t = [e[0]].concat(e.slice(2));
    this.layer.built || (this.layer.build(t), this.layer.built = !0), super.build(e);
  }

  computeOutputShape(e) {
    var t = [(e = ah(e))[0]].concat(e.slice(2)),
        n = this.layer.computeOutputShape(t);
    return [n[0], e[1]].concat(n.slice(1));
  }

  call(e, t) {
    return Yn(() => Np((e, n) => [rh(this.layer.call(e, t)), []], e = rh(e), [], !1, null, null, !1, !0)[1]);
  }

}

Df.className = "TimeDistributed", qn(Df);

class _f extends Ff {
  constructor(e) {
    super(e);
    var t = e.layer.getConfig(),
        n = {};
    n.className = e.layer.getClassName(), n.config = t, this.forwardLayer = Eh(n), t.goBackwards = !0 !== t.goBackwards;
    var s = {};
    if (s.className = e.layer.getClassName(), s.config = t, this.backwardLayer = Eh(s), this.forwardLayer.name = "forward_" + this.forwardLayer.name, this.backwardLayer.name = "backward_" + this.backwardLayer.name, this.mergeMode = void 0 === e.mergeMode ? "concat" : e.mergeMode, _u(Qu, "BidirectionalMergeMode", this.mergeMode), e.weights) throw new xu("weights support is not implemented for Bidirectional layer yet.");
    this._stateful = e.layer.stateful, this.returnSequences = e.layer.returnSequences, this.returnState = e.layer.returnState, this.supportsMasking = !0, this._trainable = !0, this.inputSpec = e.layer.inputSpec, this.numConstants = null;
  }

  get trainable() {
    return this._trainable;
  }

  set trainable(e) {
    this._trainable = e, null != this.forwardLayer && (this.forwardLayer.trainable = e), null != this.backwardLayer && (this.backwardLayer.trainable = e);
  }

  getWeights() {
    return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
  }

  setWeights(e) {
    var t = Math.floor(e.length / 2);
    this.forwardLayer.setWeights(e.slice(0, t)), this.backwardLayer.setWeights(e.slice(t));
  }

  computeOutputShape(e) {
    var t,
        n,
        s,
        r = this.forwardLayer.computeOutputShape(e);
    return Array.isArray(r) && Array.isArray(r[0]) || (r = [r]), r = r, this.returnState ? (s = r.slice(1), t = r[0]) : t = r[0], t = t, "concat" === this.mergeMode ? (t[t.length - 1] *= 2, n = [t]) : n = null == this.mergeMode ? [t, t.slice()] : [t], this.returnState ? null == this.mergeMode ? n.concat(s).concat(s.slice()) : [t].concat(s).concat(s.slice()) : Iu(n);
  }

  apply(e, t) {
    var n = null == t ? null : t.initialState,
        s = null == t ? null : t.constants;
    null == t && (t = {});
    var r = $p(e, n, s, this.numConstants);
    if (e = r.inputs, n = r.initialState, s = r.constants, Array.isArray(e) && (n = e.slice(1), e = e[0]), (null == n || 0 === n.length) && null == s) return super.apply(e, t);
    var a = [],
        i = [];

    if (null != n) {
      var _e243 = n.length;
      if (_e243 % 2 > 0) throw new bu("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
      t.initialState = n, a.push(...n);

      var _s122 = n.map(e => new ch({
        shape: e.shape
      }));

      this.forwardLayer.stateSpec = _s122.slice(0, _e243 / 2), this.backwardLayer.stateSpec = _s122.slice(_e243 / 2), i.push(..._s122);
    }

    if (null != s) throw new xu("Support for constants in Bidirectional layers is not implemented yet.");
    var o = a[0] instanceof hh;

    for (var _e244 of a) {
      if (_e244 instanceof hh !== o) throw new bu("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
    }

    if (o) {
      var _n143 = [e].concat(a),
          _s123 = this.inputSpec.concat(i),
          _r84 = this.inputSpec;

      this.inputSpec = _s123;

      var _o29 = super.apply(_n143, t);

      return this.inputSpec = _r84, _o29;
    }

    return super.apply(e, t);
  }

  call(e, t) {
    return Yn(() => {
      var n = t.initialState;
      var s, r, a, i;
      if (null == n) s = this.forwardLayer.call(e, t), r = this.backwardLayer.call(e, t);else {
        var _a64 = n.slice(0, n.length / 2),
            _i36 = n.slice(n.length / 2);

        s = this.forwardLayer.call(e, Object.assign(t, {
          initialState: _a64
        })), r = this.backwardLayer.call(e, Object.assign(t, {
          initialState: _i36
        }));
      }
      return this.returnState && (Array.isArray(s) && (a = s.slice(1).concat(r.slice(1))), s = s[0], r = r[0]), this.returnSequences && (r = Ga(r, 1)), "concat" === this.mergeMode ? i = yc([s, r]) : "sum" === this.mergeMode ? i = es(s, r) : "ave" === this.mergeMode ? i = ss(.5, es(s, r)) : "mul" === this.mergeMode ? i = ss(s, r) : null == this.mergeMode && (i = [s, r]), this.returnState ? null == this.mergeMode ? i.concat(a) : [i].concat(a) : i;
    });
  }

  resetStates(e) {
    this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
  }

  build(e) {
    ac(this.forwardLayer.name, () => {
      this.forwardLayer.build(e);
    }), ac(this.backwardLayer.name, () => {
      this.backwardLayer.build(e);
    }), this.built = !0;
  }

  computeMask(e, t) {
    var n;

    if (Array.isArray(t) && (t = t[0]), n = this.returnSequences ? null == this.mergeMode ? [t, t] : t : null == this.mergeMode ? [null, null] : null, this.returnState) {
      var _e245 = this.forwardLayer.states.map(e => null);

      return Array.isArray(n) ? n.concat(_e245).concat(_e245) : [n].concat(_e245).concat(_e245);
    }

    return n;
  }

  get trainableWeights() {
    return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
  }

  get nonTrainableWeights() {
    return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
  }

  setFastWeightInitDuringBuild(e) {
    super.setFastWeightInitDuringBuild(e), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(e), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(e);
  }

  getConfig() {
    var e = {
      mergeMode: this.mergeMode
    },
        t = super.getConfig();
    return Object.assign(e, t), e;
  }

  static fromConfig(e, t) {
    var n = Eh(t.layer);
    if (delete t.layer, null != t.numConstants) throw new xu("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
    var s = t;
    return s.layer = n, new e(s);
  }

}

function Of(e) {
  return new kp(e);
}

function Mf(e) {
  return new Up(e);
}

function Lf(e) {
  return new xf(e);
}

function zf(e, t) {
  Array.isArray(e) || (e = [e]), e.forEach(e => {
    null != e && l("complex64" !== e.dtype, () => "".concat(t, " does not support complex64 tensors in the CPU backend."));
  });
}

_f.className = "Bidirectional", qn(_f), function (e) {
  e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
}(Mp || (Mp = {})), function (e) {
  var t;
  (t = e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}))[t.LEGACY = 0] = "LEGACY", t[t.V1 = 1] = "V1", t[t.V2 = 2] = "V2";
}(Lp || (Lp = {})), function (e) {
  e[e.FAIL = 0] = "FAIL", e[e.SHORTEST = 1] = "SHORTEST", e[e.LONGEST = 2] = "LONGEST";
}(zp || (zp = {}));
var Bf = Ii;

class Pf extends n {
  constructor() {
    super(), this.blockSize = 48, this.firstUse = !0, this.data = new t(this, Kn());
  }

  nextDataId() {
    return Pf.nextDataId++;
  }

  write(e, t, n) {
    this.firstUse && (this.firstUse = !1, V().get("IS_NODE") && Oo("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
    var s = {
      id: this.nextDataId()
    };
    return this.data.set(s, {
      values: e,
      dtype: n,
      refCount: 1
    }), s;
  }

  makeTensorInfo(e, t, n) {
    var s;

    if ("string" === t && null != n && n.length > 0 && C(n[0])) {
      var _r85 = n.map(e => Ge(e));

      s = this.write(_r85, e, t);
    } else s = this.write(n, e, t);

    return {
      dataId: s,
      shape: e,
      dtype: t
    };
  }

  refCount(e) {
    return this.data.has(e) ? this.data.get(e).refCount : 0;
  }

  incRef(e) {
    this.data.get(e).refCount++;
  }

  decRef(e) {
    this.data.has(e) && this.data.get(e).refCount--;
  }

  move(e, t, n, s, r) {
    this.data.set(e, {
      values: t,
      dtype: s,
      refCount: r
    });
  }

  numDataIds() {
    return this.data.numDataIds();
  }

  read(e) {
    var _this69 = this;

    return _asyncToGenerator(function* () {
      return _this69.readSync(e);
    })();
  }

  readSync(e) {
    var {
      dtype: t,
      complexTensorInfos: n
    } = this.data.get(e);
    return "complex64" === t ? Mo(this.readSync(n.real.dataId), this.readSync(n.imag.dataId)) : this.data.get(e).values;
  }

  bufferSync(e) {
    var t = this.readSync(e.dataId);
    var n = t;
    if ("string" === e.dtype) try {
      n = t.map(e => He(e));
    } catch (e) {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return dn(e.shape, e.dtype, n);
  }

  makeOutput(e, t, n) {
    var s = this.write(e, t, n);
    return Kn().makeTensorFromDataId(s, t, n, this);
  }

  disposeData(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;

    if (this.data.has(e)) {
      if (this.data.get(e).refCount--, !t && this.data.get(e).refCount > 0) return !1;
      var {
        complexTensorInfos: _n144
      } = this.data.get(e);
      null != _n144 && (this.disposeData(_n144.real.dataId, !0), this.disposeData(_n144.imag.dataId, !0)), this.data.delete(e);
    }

    return !0;
  }

  disposeIntermediateTensorInfo(e) {
    this.disposeData(e.dataId);
  }

  time(e) {
    return _asyncToGenerator(function* () {
      var t = Ve();
      return e(), {
        kernelMs: Ve() - t
      };
    })();
  }

  memory() {
    return {
      unreliable: !0,
      reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
    };
  }

  where(e) {
    zf([e], "where");
    var t = this.readSync(e.dataId);
    return Bf(e.shape, t);
  }

  dispose() {}

  floatPrecision() {
    return 32;
  }

  epsilon() {
    return super.epsilon();
  }

}

function Wf(e) {
  var t = new Float32Array(e.length);

  for (var _n145 = 0; _n145 < e.length; ++_n145) {
    t[_n145] = Math.abs(e[_n145]);
  }

  return t;
}

Pf.nextDataId = 0;
var Uf = {
  kernelName: "Abs",
  backendName: "cpu",
  kernelFunc: e => {
    var {
      x: t
    } = e.inputs,
        n = e.backend;
    zf(t, "abs");
    var s = new Float32Array(d(t.shape));
    return s = Wf(n.data.get(t.dataId).values), n.makeOutput(s, t.shape, "float32");
  }
};

function Vf(e) {
  return (t, n, s, r, a) => {
    var i = cr(t, n),
        o = i.length,
        l = A(i),
        u = w(a, d(i)),
        c = t.length,
        h = n.length,
        p = A(t),
        f = A(n),
        g = lr(t, i),
        m = lr(n, i);
    if (g.length + m.length === 0) for (var _t228 = 0; _t228 < u.length; ++_t228) {
      u[_t228] = e(s[_t228 % s.length], r[_t228 % r.length]);
    } else {
      var _loop25 = function _loop25(_t229) {
        var n = B(_t229, o, l),
            a = n.slice(-c);
        g.forEach(e => a[e] = 0);
        var i = z(a, c, p),
            d = n.slice(-h);
        m.forEach(e => d[e] = 0);
        var b = z(d, h, f);
        u[_t229] = e(s[i], r[b]);
      };

      for (var _t229 = 0; _t229 < u.length; ++_t229) {
        _loop25(_t229);
      }
    }
    return [u, i];
  };
}

function Gf(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    real: s,
    imag: r
  } = t,
      a = n.data.get(s.dataId).values,
      i = n.data.get(r.dataId).values,
      o = n.makeTensorInfo(s.shape, "complex64");
  return n.data.get(o.dataId).complexTensorInfos = {
    real: n.makeTensorInfo(s.shape, "float32", a),
    imag: n.makeTensorInfo(r.shape, "float32", i)
  }, o;
}

var Hf = {
  kernelName: "Complex",
  backendName: "cpu",
  kernelFunc: Gf
};

function jf(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "float32";
  if ("complex64" === n) return Gf({
    inputs: {
      real: jf(e, t, "float32"),
      imag: jf(e, t, "float32")
    },
    backend: e
  });
  var s = O(d(t), n);
  return e.makeTensorInfo(t, n, s);
}

function qf(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    x: s
  } = t;
  return n.incRef(s.dataId), {
    dataId: s.dataId,
    shape: s.shape,
    dtype: s.dtype
  };
}

var Kf = {
  kernelName: "Identity",
  backendName: "cpu",
  kernelFunc: qf
};

function Xf(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    input: s
  } = t,
      r = n.data.get(s.dataId).complexTensorInfos.real,
      a = n.data.get(r.dataId).values;
  return n.makeTensorInfo(r.shape, r.dtype, a);
}

var Yf = {
  kernelName: "Real",
  backendName: "cpu",
  kernelFunc: Xf
};

function Jf(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    dtype: a
  } = s;

  if ("complex64" === a) {
    if ("complex64" === r.dtype) return qf({
      inputs: {
        x: r
      },
      backend: n
    });

    var _e246 = jf(n, r.shape, r.dtype),
        _t230 = Jf({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        dtype: "float32"
      }
    }),
        _s124 = Gf({
      inputs: {
        real: _t230,
        imag: _e246
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_e246), n.disposeIntermediateTensorInfo(_t230), _s124;
  }

  if ("complex64" === r.dtype) {
    var _e247 = Xf({
      inputs: {
        input: r
      },
      backend: n
    }),
        _t231 = Jf({
      inputs: {
        x: _e247
      },
      backend: n,
      attrs: {
        dtype: a
      }
    });

    return n.disposeIntermediateTensorInfo(_e247), _t231;
  }

  if (!I(r.dtype, a)) {
    var _e248 = qf({
      inputs: {
        x: r
      },
      backend: n
    });

    return {
      dataId: _e248.dataId,
      shape: _e248.shape,
      dtype: a
    };
  }

  if ("int32" === a) {
    var _e249 = n.data.get(r.dataId).values,
        _t232 = Int32Array.from(_e249);

    return n.makeTensorInfo(r.shape, "int32", _t232);
  }

  if ("bool" === a) {
    var _e250 = n.data.get(r.dataId).values,
        _t233 = Ue([0], r.dtype),
        [_s125, _a65] = Vf((e, t) => e !== t ? 1 : 0)(r.shape, [], _e250, _t233, "bool");

    return n.makeTensorInfo(_a65, "bool", _s125);
  }

  throw new Error("Error in Cast: failed to cast ".concat(r.dtype, " to ").concat(a));
}

var Zf = {
  kernelName: "Cast",
  backendName: "cpu",
  kernelFunc: Jf
};

function Qf(e, t, n, s) {
  return null == n ? _ref9 => {
    var {
      inputs: n,
      backend: r
    } = _ref9;
    var {
      a,
      b: i
    } = n,
        o = r;
    zf([a, i], e);
    var l = o.data.get(a.dataId).values,
        u = o.data.get(i.dataId).values,
        c = "string" === a.dtype ? tl(l) : l,
        h = "string" === a.dtype ? tl(u) : u,
        d = s || a.dtype,
        [p, f] = t(a.shape, i.shape, c, h, d);
    return o.makeTensorInfo(f, d, p);
  } : _ref10 => {
    var {
      inputs: e,
      backend: r
    } = _ref10;
    var {
      a,
      b: i
    } = e,
        o = r;

    if ("complex64" === a.dtype || "complex64" === i.dtype) {
      var _e251 = Jf({
        inputs: {
          x: a
        },
        backend: o,
        attrs: {
          dtype: "complex64"
        }
      }),
          _t234 = o.data.get(_e251.dataId),
          _s126 = _t234.complexTensorInfos.imag,
          _r86 = o.data.get(_t234.complexTensorInfos.real.dataId).values,
          _l19 = o.data.get(_s126.dataId).values,
          _u11 = Jf({
        inputs: {
          x: i
        },
        backend: o,
        attrs: {
          dtype: "complex64"
        }
      }),
          _c11 = o.data.get(_u11.dataId),
          _h8 = _c11.complexTensorInfos.imag,
          _d8 = o.data.get(_c11.complexTensorInfos.real.dataId).values,
          _p7 = o.data.get(_h8.dataId).values,
          [_f6, _g8, _m7] = n(a.shape, i.shape, _r86, _l19, _d8, _p7),
          _b6 = o.makeTensorInfo(_m7, "float32", _f6),
          _x50 = o.makeTensorInfo(_m7, "float32", _g8),
          _y6 = Gf({
        inputs: {
          real: _b6,
          imag: _x50
        },
        backend: o
      });

      return o.disposeIntermediateTensorInfo(_e251), o.disposeIntermediateTensorInfo(_u11), o.disposeIntermediateTensorInfo(_b6), o.disposeIntermediateTensorInfo(_x50), _y6;
    }

    {
      var _e252 = o.data.get(a.dataId).values,
          _n146 = o.data.get(i.dataId).values,
          _r87 = s || a.dtype,
          [_l20, _u12] = t(a.shape, i.shape, _e252, _n146, _r87);

      return o.makeTensorInfo(_u12, _r87, _l20);
    }
  };
}

function eg(e) {
  return (t, n, s, r, a, i) => {
    var o = cr(t, n),
        l = d(o),
        u = o.length,
        c = A(o),
        h = w("float32", l),
        p = w("float32", l),
        f = lr(t, o),
        g = lr(n, o),
        m = Mo(s, r),
        b = Mo(a, i),
        x = t.length,
        y = A(t),
        k = n.length,
        v = A(n);
    if (f.length + g.length === 0) for (var _t235 = 0; _t235 < h.length; _t235++) {
      var _n147 = _t235 % m.length,
          _s127 = _t235 % b.length,
          _r88 = e(m[2 * _n147], m[2 * _n147 + 1], b[2 * _s127], b[2 * _s127 + 1]);

      h[_t235] = _r88.real, p[_t235] = _r88.imag;
    } else {
      var _loop26 = function _loop26(_t236) {
        var n = B(_t236, u, c),
            s = n.slice(-x);
        f.forEach(e => s[e] = 0);
        var r = z(s, x, y),
            a = n.slice(-k);
        g.forEach(e => a[e] = 0);
        var i = z(a, k, v),
            o = e(m[2 * r], m[2 * r + 1], b[2 * i], b[2 * i + 1]);
        h[_t236] = o.real, p[_t236] = o.imag;
      };

      for (var _t236 = 0; _t236 < h.length; _t236++) {
        _loop26(_t236);
      }
    }
    return [h, p, o];
  };
}

var tg = Vf((e, t) => e + t),
    ng = Qf("Add", tg, eg((e, t, n, s) => ({
  real: e + n,
  imag: t + s
}))),
    sg = {
  kernelName: "Add",
  backendName: "cpu",
  kernelFunc: ng
};

function rg(e, t, n, s, r) {
  var a = d(s),
      i = O(r, n);

  for (var _n148 = 0; _n148 < e.length; _n148++) {
    var _s128 = e[_n148];
    if (_s128 < 0) throw new Error("Input x must be non-negative!");
    _s128 >= r || (i[_s128] += a > 0 ? t[_n148] : 1);
  }

  return i;
}

function ag(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  var r = e.shape[0],
      a = e.shape[1],
      i = dn([r, n], t.dtype);

  for (var _o30 = 0; _o30 < r; _o30++) {
    for (var _r89 = 0; _r89 < a; _r89++) {
      var _a66 = e.get(_o30, _r89);

      if (_a66 < 0) throw new Error("Input x must be non-negative!");
      _a66 >= n || i.set(s ? 1 : t.size > 0 ? i.get(_o30, _a66) + t.get(_o30, _r89) : i.get(_o30, _a66) + 1, _o30, _a66);
    }
  }

  return i;
}

function ig(e) {
  return (t, n, s) => {
    var r = w(n, t.length);

    for (var _n149 = 0; _n149 < t.length; ++_n149) {
      r[_n149] = e(t[_n149], s);
    }

    return r;
  };
}

function og(e, t, n) {
  return _ref11 => {
    var {
      inputs: s,
      attrs: r,
      backend: a
    } = _ref11;
    var {
      x: i
    } = s;
    if (zf(i, e), "string" === i.dtype || "string" === n) throw new Error("unaryKernelFunc does not support string input/output");
    var o = a,
        l = o.data.get(i.dataId).values,
        u = d(i.shape),
        c = n || i.dtype,
        h = v(c, u);

    for (var _e253 = 0; _e253 < u; ++_e253) {
      h[_e253] = t(l[_e253], r);
    }

    return o.makeTensorInfo(i.shape, c, h);
  };
}

function lg(e, t, n) {
  return _ref12 => {
    var {
      inputs: s,
      attrs: r,
      backend: a
    } = _ref12;
    var {
      x: i
    } = s;
    if (zf(i, e), "string" === i.dtype || "string" === n) throw new Error("unaryKernelFunc does not support string input/output");
    var o = a,
        l = o.data.get(i.dataId).values,
        u = n || i.dtype,
        c = t(l, u, r);
    return o.makeTensorInfo(i.shape, u, c);
  };
}

var ug = ig(e => Math.ceil(e)),
    cg = {
  kernelName: "Ceil",
  backendName: "cpu",
  kernelFunc: lg("Ceil", ug)
};

function hg(e, t, n, s) {
  var r = v(n, d(t));

  if (s && "string" !== n) {
    var _t237 = 0;
    e.forEach(e => {
      var n = d(e.shape);
      r.set(e.vals, _t237), _t237 += n;
    });
  } else {
    var _s129 = 0;
    e.forEach(e => {
      var a = "string" === n ? tl(e.vals) : e.vals;
      var i = 0;

      for (var _n150 = 0; _n150 < e.shape[0]; ++_n150) {
        var _o31 = _n150 * t[1] + _s129;

        for (var _t238 = 0; _t238 < e.shape[1]; ++_t238) {
          r[_o31 + _t238] = a[i++];
        }
      }

      _s129 += e.shape[1];
    });
  }

  return r;
}

var dg = Vf((e, t) => e === t ? 1 : 0),
    pg = Qf("Equal", dg, null, "bool"),
    fg = {
  kernelName: "Equal",
  backendName: "cpu",
  kernelFunc: pg
},
    gg = ig(e => Math.exp(e)),
    mg = lg("Exp", gg),
    bg = {
  kernelName: "Exp",
  backendName: "cpu",
  kernelFunc: mg
},
    xg = ig(e => Math.expm1(e)),
    yg = {
  kernelName: "Expm1",
  backendName: "cpu",
  kernelFunc: lg("Expm1", xg)
},
    kg = ig(e => Math.floor(e)),
    wg = {
  kernelName: "Floor",
  backendName: "cpu",
  kernelFunc: lg("Floor", kg)
};

function vg(e, t, n, s, r, a, i, o, l) {
  var u = dn([s, a], n);

  for (var _n151 = 0; _n151 < s; _n151++) {
    var _s130 = [];
    var _c12 = 0;

    for (var _t239 = 0; _t239 < r; _t239++) {
      var _a67 = e[_n151 * r + _t239];
      _c12 += _a67 * i[_t239], _s130.push(_a67);
    }

    if (_c12 < 0 || _c12 >= l / a) throw new Error("Invalid indices: ".concat(_s130, " does not index into ").concat(o));

    for (var _e254 = 0; _e254 < a; _e254++) {
      u.values[_n151 * a + _e254] = t.get(...t.indexToLoc(_c12 * a + _e254));
    }
  }

  return u;
}

function Ig(e, t, n) {
  var s = dn(n, e.dtype);

  for (var _n152 = 0; _n152 < s.size; ++_n152) {
    var _r90 = s.indexToLoc(_n152).slice(),
        _a68 = t.locToIndex([_r90[0], _r90[2]]);

    _r90[2] = t.values[_a68];

    var _i37 = e.locToIndex(_r90);

    s.values[_n152] = e.values[_i37];
  }

  return s;
}

var $g = Vf((e, t) => e > t ? 1 : 0),
    Ng = {
  kernelName: "Greater",
  backendName: "cpu",
  kernelFunc: Qf("Greater", $g, null, "bool")
},
    Cg = Vf((e, t) => e >= t ? 1 : 0),
    Sg = {
  kernelName: "GreaterEqual",
  backendName: "cpu",
  kernelFunc: Qf("GreaterEqual", Cg, null, "bool")
},
    Tg = Vf((e, t) => e < t ? 1 : 0),
    Eg = {
  kernelName: "Less",
  backendName: "cpu",
  kernelFunc: Qf("Less", Tg, null, "bool")
},
    Rg = Vf((e, t) => e <= t ? 1 : 0),
    Ag = {
  kernelName: "LessEqual",
  backendName: "cpu",
  kernelFunc: Qf("LessEqual", Rg, null, "bool")
};

function Fg(e, t, n) {
  var s = (t - e) / (n - 1),
      r = O(n, "float32");
  r[0] = e;

  for (var _e255 = 1; _e255 < r.length; _e255++) {
    r[_e255] = r[_e255 - 1] + s;
  }

  return r;
}

var Dg = ig(e => Math.log(e)),
    _g = {
  kernelName: "Log",
  backendName: "cpu",
  kernelFunc: lg("Log", Dg)
};

function Og(e, t, n, s) {
  var r = w(s, d(n));

  for (var _n153 = 0; _n153 < r.length; ++_n153) {
    var _s131 = _n153 * t;

    var _a69 = e[_s131];

    for (var _n154 = 0; _n154 < t; ++_n154) {
      var _t240 = e[_s131 + _n154];
      (Number.isNaN(_t240) || _t240 > _a69) && (_a69 = _t240);
    }

    r[_n153] = _a69;
  }

  return r;
}

var Mg = Vf((e, t) => Math.max(e, t)),
    Lg = {
  kernelName: "Maximum",
  backendName: "cpu",
  kernelFunc: Qf("Maximum", Mg)
},
    zg = Vf((e, t) => Math.min(e, t)),
    Bg = {
  kernelName: "Minimum",
  backendName: "cpu",
  kernelFunc: Qf("Minimum", zg)
},
    Pg = Vf((e, t) => e * t),
    Wg = eg((e, t, n, s) => ({
  real: e * n - t * s,
  imag: e * s + t * n
})),
    Ug = Qf("Multiply", Pg, Wg),
    Vg = {
  kernelName: "Multiply",
  backendName: "cpu",
  kernelFunc: Ug
};

function Gg(e, t, n) {
  var s = We(-1, n);
  return Pg([], t, s, e, n);
}

var Hg = {
  kernelName: "Neg",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t;
    zf(s, "neg");
    var r = n.data.get(s.dataId).values,
        [a, i] = Gg(r, s.shape, s.dtype);
    return n.makeTensorInfo(i, s.dtype, a);
  }
},
    jg = Vf((e, t) => e !== t ? 1 : 0),
    qg = {
  kernelName: "NotEqual",
  backendName: "cpu",
  kernelFunc: Qf("NotEqual", jg, null, "bool")
};

function Kg(e, t, n, s, r) {
  var a = t.length,
      i = d(t),
      o = A(t),
      l = A(r),
      u = w(n, d(r));

  for (var _t241 = 0; _t241 < i; ++_t241) {
    var _n155 = B(_t241, a, o),
        _r91 = new Array(_n155.length);

    for (var _e256 = 0; _e256 < _r91.length; _e256++) {
      _r91[_e256] = _n155[s[_e256]];
    }

    u[z(_r91, a, l)] = e[_t241];
  }

  return u;
}

function Xg(e) {
  var {
    inputs: t,
    attrs: n,
    backend: s
  } = e,
      {
    x: r
  } = t,
      {
    perm: a
  } = n;
  zf(r, "transpose");
  var i = new Array(r.shape.length);

  for (var _e257 = 0; _e257 < i.length; _e257++) {
    i[_e257] = r.shape[a[_e257]];
  }

  var o = Kg(s.data.get(r.dataId).values, r.shape, r.dtype, a, i);
  return {
    dataId: s.write(o, i, r.dtype),
    shape: i,
    dtype: r.dtype
  };
}

var Yg = {
  kernelName: "Transpose",
  backendName: "cpu",
  kernelFunc: Xg
};

function Jg(e, t, n, s) {
  var [r, a] = Kr(e, s),
      i = dt(t, "int32"),
      o = O(d(r), i),
      l = d(a);

  for (var _e258 = 0; _e258 < o.length; ++_e258) {
    var _t242 = _e258 * l;

    var _s132 = 1;

    for (var _e259 = 0; _e259 < l; ++_e259) {
      _s132 *= n[_t242 + _e259];
    }

    o[_e258] = _s132;
  }

  return {
    outVals: o,
    outShape: r,
    outDtype: i
  };
}

var Zg = {
  kernelName: "Prod",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s;
    zf(r, "prod");
    var o = r.shape.length,
        l = y(a, r.shape),
        u = Jr(l, o);
    var c = l,
        h = r;
    var d = [];
    null != u && (h = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), d.push(h), c = Qr(c.length, o));
    var p = n.data.get(h.dataId).values,
        {
      outVals: f,
      outShape: g,
      outDtype: m
    } = Jg(h.shape, h.dtype, p, c);
    var b = g;
    return i && (b = Xr(g, l)), d.forEach(e => n.disposeIntermediateTensorInfo(e)), n.makeTensorInfo(b, m, f);
  }
};

function Qg(e, t, n, s) {
  if (e === t || e < t && n < 0 || t < e && n > 1) return O(0, s);
  var r = O(Math.abs(Math.ceil((t - e) / n)), s);
  t < e && 1 === n && (n = -1), r[0] = e;

  for (var _e260 = 1; _e260 < r.length; _e260++) {
    r[_e260] = r[_e260 - 1] + n;
  }

  return r;
}

var em = ig(e => 1 / Math.sqrt(e)),
    tm = {
  kernelName: "Rsqrt",
  backendName: "cpu",
  kernelFunc: lg("Rsqrt", em)
};

function nm(e, t, n, s, r) {
  var a = Pn(s, t, n),
      i = d(n),
      o = A(s);

  if (a) {
    var _n156 = Wn(t, o);

    return "string" === r ? e.slice(_n156, _n156 + i) : e.subarray(_n156, _n156 + i);
  }

  var l = dn(s, r, "string" === r ? tl(e) : e),
      u = dn(n, r);

  for (var _e261 = 0; _e261 < u.size; ++_e261) {
    var _n157 = u.indexToLoc(_e261),
        _s133 = _n157.map((e, n) => e + t[n]);

    u.set(l.get(..._s133), ..._n157);
  }

  return "string" === r ? nl(u.values) : u.values;
}

function sm(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    begin: a,
    size: i
  } = s;
  zf(r, "slice");
  var [o, l] = Un(r, a, i);
  Tn(r, o, l);
  var u = nm(n.data.get(r.dataId).values, o, l, r.shape, r.dtype);
  return n.makeTensorInfo(l, r.dtype, u);
}

var rm = {
  kernelName: "Slice",
  backendName: "cpu",
  kernelFunc: sm
};

function am(e, t, n, s, r, a, i) {
  var o = t[0],
      l = a[0],
      u = new Array(l),
      c = new Array(o),
      h = t[1];

  if (0 === l) {
    if (0 !== o) throw new Error("Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ".concat(o));
    return [v(n, 0), [0, h], v(r, 0), u, c];
  }

  var d = !0,
      p = 0;
  var f = new Array(l).fill(0);

  for (var _t243 = 0; _t243 < o; ++_t243) {
    var _n158 = e[_t243 * h];
    if (_n158 < 0) throw new Error("indices(".concat(_t243, ", 0) is invalid: ").concat(_n158, " < 0"));
    if (_n158 >= l) throw new Error("indices(".concat(_t243, ", 0) is invalid: ").concat(_n158, " >= ").concat(l));
    ++f[_n158], d = d && _n158 >= p, p = _n158;
  }

  var g = !0;

  for (var _e262 = 0; _e262 < l; ++_e262) {
    var _t244 = 0 === f[_e262];

    u[_e262] = _t244, g = g && !_t244, f[_e262] = Math.max(f[_e262], 1), _e262 > 0 && (f[_e262] += f[_e262 - 1]);
  }

  if (g && d) {
    var _t245 = e,
        _n159 = s;

    for (var _e263 = 0; _e263 < o; ++_e263) {
      c[_e263] = _e263;
    }

    return [_t245, [o, h], _n159, u, c];
  }

  {
    var _t246 = f[l - 1],
        _a70 = v(n, _t246 * h),
        _d9 = v(r, _t246),
        _p8 = new Array(l).fill(0);

    for (var _t247 = 0; _t247 < o; ++_t247) {
      var _n160 = e[_t247 * h],
          _r92 = (0 === _n160 ? 0 : f[_n160 - 1]) + _p8[_n160];

      _p8[_n160]++;

      for (var _n161 = 0; _n161 < h; ++_n161) {
        _a70[_r92 * h + _n161] = e[_t247 * h + _n161];
      }

      _d9[_r92] = s[_t247], c[_t247] = _r92;
    }

    for (var _e264 = 0; _e264 < l; ++_e264) {
      if (0 === _p8[_e264]) {
        var _t248 = 0 === _e264 ? 0 : f[_e264 - 1];

        _a70[_t248 * h + 0] = _e264;

        for (var _e265 = 1; _e265 < h; ++_e265) {
          _a70[_t248 * h + _e265] = 0;
        }

        _d9[_t248] = i;
      }
    }

    return [_a70, [_t246, h], _d9, u, c];
  }
}

function im(e, t, n, s, r) {
  var a = d(s),
      i = t[0],
      o = r.length,
      l = [];
  var u = 1,
      c = -1;

  for (var _e266 = 0; _e266 < o; ++_e266) {
    var _t249 = r[_e266];

    if (-1 === _t249) {
      if (-1 !== c) throw new Error("only one output dimension may be -1, not both ".concat(c, " and ").concat(_e266));
      c = _e266, l.push(1);
    } else {
      if (_t249 < 0) throw new Error("size ".concat(_e266, " must be non-negative, not ").concat(_t249));
      u *= _t249, l.push(_t249);
    }
  }

  if (-1 !== c) {
    if (u <= 0) throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");

    var _e267 = Math.trunc(a / u);

    if (u * _e267 !== a) throw new Error("Input to reshape is a SparseTensor with ".concat(a, "\n          dense values, but the requested shape requires a multiple of ").concat(u, ". inputShape=").concat(s, " outputShape= ").concat(l));
    l[c] = _e267;
  }

  var h = d(l);
  if (h !== a) throw new Error("Input to reshape is a tensor with ".concat(a, " dense values, but the requested shape has ").concat(h, ". inputShape=").concat(s, " outputShape=").concat(l));
  var p = s.length,
      f = [];

  if (p > 0) {
    f[p - 1] = 1;

    for (var _e268 = p - 2; _e268 >= 0; --_e268) {
      f[_e268] = f[_e268 + 1] * s[_e268 + 1];
    }
  }

  var g = [];

  if (o > 0) {
    g[o - 1] = 1;

    for (var _e269 = o - 2; _e269 >= 0; --_e269) {
      g[_e269] = g[_e269 + 1] * l[_e269 + 1];
    }
  }

  var m = v(n, i * o);

  for (var _t250 = 0; _t250 < i; ++_t250) {
    var _n162 = 0;

    for (var _s134 = 0; _s134 < p; ++_s134) {
      _n162 += e[_t250 * p + _s134] * f[_s134];
    }

    for (var _e270 = 0; _e270 < o; ++_e270) {
      m[_t250 * o + _e270] = Math.trunc(_n162 / g[_e270]), _n162 %= g[_e270];
    }
  }

  return [m, [i, o], l];
}

function om(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var o = s.length;
  if (o !== r.length) throw new Error("segmentIds and indices should have same size.");
  var l = [t[0], e.length / t[0]],
      u = l[1],
      c = o > 0 ? r[o - 1] + 1 : 0;
  if (c < 0) throw new Error("segment ids must be >= 0");
  var h = t.slice();
  h[0] = c;
  var d = v(n, h.reduce((e, t) => e * t, 1));
  if (0 === o) return c > 0 && d.fill(i), [d, h];
  if (c <= 0) throw new Error("segment ids must be >= 0");
  var p = 0,
      f = 1,
      g = 0,
      m = r[p];

  for (;;) {
    var _t251 = 0;

    if (f < o) {
      if (_t251 = r[f], m === _t251) {
        ++f;
        continue;
      }

      if (m >= _t251) throw new Error("segment ids are not increasing");
    }

    if (m < 0 || m >= c) throw new Error("Segment id ".concat(m, " out of range [0, ").concat(c, "), possibly because segmentIds input is not sorted."));
    m > g && d.fill(i, g * u, m * u);

    for (var _t252 = p; _t252 < f; ++_t252) {
      var _n163 = s[_t252];
      if (_n163 < 0 || _n163 >= l[0]) throw new Error("Bad: indices[".concat(_t252, "] == ").concat(s[_t252], " out of range [0, ").concat(l[0], ")"));

      for (var _t253 = 0; _t253 < u; _t253++) {
        d[m * u + _t253] += e[_n163 * u + _t253];
      }
    }

    if (a) for (var _e271 = 0; _e271 < u; _e271++) {
      d[m * u + _e271] /= f - p;
    }
    if (p = f, ++f, g = m + 1, m = _t251, f > o) break;
  }

  return g < c && d.fill(i, g * u, c * u), [d, h];
}

var lm = Vf((e, t) => {
  var n = e - t;
  return n * n;
}),
    um = {
  kernelName: "SquaredDifference",
  backendName: "cpu",
  kernelFunc: Qf("SquaredDifference", lm)
};

function cm(e, t, n, s) {
  var r = dn(e, t.dtype);

  for (var _e272 = 0; _e272 < r.size; _e272++) {
    var _a71 = r.indexToLoc(_e272),
        _i38 = new Array(_a71.length);

    for (var _e273 = 0; _e273 < _i38.length; _e273++) {
      _i38[_e273] = _a71[_e273] * n[_e273] + s[_e273];
    }

    r.set(t.get(..._i38), ..._a71);
  }

  return r;
}

class hm {
  constructor(e, t, n, s, r, a) {
    this.separator = Ge(e), this.nGramWidths = t, this.leftPad = Ge(n), this.rightPad = Ge(s), this.padWidth = r, this.preserveShort = a;
  }

  getPadWidth(e) {
    return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
  }

  getNumNGrams(e, t) {
    var n = this.getPadWidth(t);
    return Math.max(0, e + 2 * n - t + 1);
  }

  createNGrams(e, t, n, s, r, a) {
    var _this70 = this;

    var _loop27 = function _loop27(_i39) {
      var o = _this70.getPadWidth(a),
          l = Math.max(0, o - _i39),
          u = Math.max(0, o - (r - (_i39 + 1))),
          c = a - (l + u),
          h = t + (l > 0 ? 0 : _i39 - o);

      var d = 0;
      d += l * _this70.leftPad.length;

      for (var _t254 = 0; _t254 < c; ++_t254) {
        d += e[h + _t254].length;
      }

      d += u * _this70.rightPad.length, d += (l + u + c - 1) * _this70.separator.length, n[s + _i39] = new Uint8Array(d);
      var p = n[s + _i39];
      var f = 0;

      var g = e => e.forEach(e => p[f++] = e);

      for (var _e274 = 0; _e274 < l; ++_e274) {
        g(_this70.leftPad), g(_this70.separator);
      }

      for (var _t255 = 0; _t255 < c - 1; ++_t255) {
        g(e[h + _t255]), g(_this70.separator);
      }

      if (c > 0) {
        g(e[h + c - 1]);

        for (var _e275 = 0; _e275 < u; ++_e275) {
          g(_this70.separator), g(_this70.rightPad);
        }
      } else {
        for (var _e276 = 0; _e276 < u - 1; ++_e276) {
          g(_this70.rightPad), g(_this70.separator);
        }

        g(_this70.rightPad);
      }
    };

    for (var _i39 = 0; _i39 < r; ++_i39) {
      _loop27(_i39);
    }
  }

  compute(e, t) {
    var _this71 = this;

    var n = e.length,
        s = t.length;

    if (s > 0) {
      var _e277 = t[0];
      if (0 !== _e277) throw new Error("First split value must be 0, got ".concat(_e277));

      for (var _r93 = 1; _r93 < s; ++_r93) {
        var _s135 = t[_r93] >= _e277;

        if (_s135 = _s135 && t[_r93] <= n, !_s135) throw new Error("Invalid split value ".concat(t[_r93], ", must be in [").concat(_e277, ", ").concat(n, "]"));
        _e277 = t[_r93];
      }

      if (_e277 !== n) throw new Error("Last split value must be data size. Expected ".concat(n, ", got ").concat(_e277));
    }

    var r = s - 1,
        a = v("int32", s);

    if (0 === n || 0 === s) {
      var _e278 = new Array(n);

      for (var _e279 = 0; _e279 <= r; ++_e279) {
        a[_e279] = 0;
      }

      return [_e278, a];
    }

    a[0] = 0;

    var _loop28 = function _loop28(_e280) {
      var n = t[_e280] - t[_e280 - 1];
      var s = 0;
      _this71.nGramWidths.forEach(e => {
        s += _this71.getNumNGrams(n, e);
      }), _this71.preserveShort && n > 0 && 0 === s && (s = 1), a[_e280] = a[_e280 - 1] + s;
    };

    for (var _e280 = 1; _e280 <= r; ++_e280) {
      _loop28(_e280);
    }

    var i = new Array(a[r]);

    var _loop29 = function _loop29(_n164) {
      var s = t[_n164];
      var r = a[_n164];

      if (_this71.nGramWidths.forEach(a => {
        var o = _this71.getNumNGrams(t[_n164 + 1] - t[_n164], a);

        _this71.createNGrams(e, s, i, r, o, a), r += o;
      }), _this71.preserveShort && r === a[_n164]) {
        var _a72 = t[_n164 + 1] - t[_n164];

        if (0 === _a72) return "continue";

        _this71.createNGrams(e, s, i, r, 1, _a72 + 2 * _this71.padWidth);
      }
    };

    for (var _n164 = 0; _n164 < r; ++_n164) {
      var _ret4 = _loop29(_n164);

      if (_ret4 === "continue") continue;
    }

    return [i, a];
  }

}

function dm(e, t, n, s, r, a, i, o) {
  return new hm(n, s, r, a, i, o).compute(e, t);
}

function pm(e, t, n) {
  if (!e.length) return [];

  if (0 === t.length) {
    var _t256 = new Array(e.length);

    for (var _n165 = 0; _n165 < e.length; ++_n165) {
      _t256[_n165] = e.subarray(_n165, _n165 + 1);
    }

    return _t256;
  }

  if (1 === t.length) {
    var _s136 = t[0],
        _r94 = [];

    var _a73 = e.indexOf(_s136);

    for (; -1 !== _a73;) {
      var _t257 = e.subarray(0, _a73);

      n && 0 === _t257.length || _r94.push(_t257), _a73 = (e = e.subarray(_a73 + 1)).indexOf(_s136);
    }

    return n && 0 === e.length || _r94.push(e), _r94;
  }

  var s = [];
  var r = 0;

  for (var _a74 = 0; _a74 < e.length + 1; _a74++) {
    if (_a74 === e.length || -1 !== t.indexOf(e[_a74])) {
      var _t258 = e.subarray(r, _a74);

      n && 0 === _t258.length || s.push(_t258), r = _a74 + 1;
    }
  }

  return s;
}

function fm(e, t, n) {
  var s = e.length,
      r = [];
  var a = 0,
      i = 0;
  var o = new Array(s);

  for (var _l21 = 0; _l21 < s; ++_l21) {
    var _s137 = pm(e[_l21], t, n),
        _u13 = _s137.length;

    o[_l21] = _u13, a += _u13, i = Math.max(i, _u13), r.push(..._s137);
  }

  var l = v("int32", 2 * a),
      u = new Array(a),
      c = [s, i];
  var h = 0;

  for (var _e281 = 0; _e281 < s; ++_e281) {
    for (var _t259 = 0; _t259 < o[_e281]; ++_t259) {
      l[2 * h] = _e281, l[2 * h + 1] = _t259, u[h] = r[h], ++h;
    }
  }

  return [l, u, c];
}

function gm(e, t) {
  var n = v("int32", e.length);

  for (var _s138 = 0; _s138 < e.length; ++_s138) {
    n[_s138] = Pe(e[_s138]).modulo(t).getLowBitsUnsigned();
  }

  return n;
}

var mm = Vf((e, t) => e - t),
    bm = Qf("Sub", mm, eg((e, t, n, s) => ({
  real: e - n,
  imag: t - s
}))),
    xm = {
  kernelName: "Sub",
  backendName: "cpu",
  kernelFunc: bm
};

function ym(e, t) {
  var n = new Array(e.rank);

  for (var _s139 = 0; _s139 < n.length; _s139++) {
    n[_s139] = e.shape[_s139] * t[_s139];
  }

  var s = dn(n, e.dtype);

  for (var _t260 = 0; _t260 < s.values.length; ++_t260) {
    var _n166 = s.indexToLoc(_t260),
        _r95 = new Array(e.rank);

    for (var _t261 = 0; _t261 < _r95.length; _t261++) {
      _r95[_t261] = _n166[_t261] % e.shape[_t261];
    }

    var _a75 = e.locToIndex(_r95);

    s.values[_t260] = e.values[_a75];
  }

  return s;
}

var km = (e, t) => {
  var n = t.value - e.value;
  return 0 === n ? e.index - t.index : n;
};

function wm(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : e.length - 1;

  for (; s > n;) {
    if (s - n > 600) {
      var _r97 = s - n + 1,
          _a77 = t - n + 1,
          _i41 = Math.log(_r97),
          _o32 = .5 * Math.exp(2 * _i41 / 3),
          _l22 = .5 * Math.sqrt(_i41 * _o32 * (_r97 - _o32) / _r97) * Math.sign(_a77 - _r97 / 2);

      wm(e, t, Math.max(n, Math.floor(t - _a77 * _o32 / _r97 + _l22)), Math.min(s, Math.floor(t + (_r97 - _a77) * _o32 / _r97 + _l22)));
    }

    var _r96 = e[t];
    var _a76 = n,
        _i40 = s;

    for (o(e, n, t), km(e[s], _r96) > 0 && o(e, n, s); _a76 < _i40;) {
      for (o(e, _a76, _i40), _a76++, _i40--; km(e[_a76], _r96) < 0;) {
        _a76 += 1;
      }

      for (; km(e[_i40], _r96) > 0;) {
        _i40 -= 1;
      }
    }

    0 === km(e[n], _r96) ? o(e, n, _i40) : (_i40 += 1, o(e, _i40, s)), _i40 <= t && (n = _i40 + 1), t <= _i40 && (s = _i40 - 1);
  }
}

function vm(e, t, n, s, r) {
  var a = t[t.length - 1],
      [i, o] = [e.length / a, a],
      l = w(n, i * s),
      u = w("int32", i * s);

  var _loop30 = function _loop30(_t262) {
    var n = _t262 * o,
        a = e.subarray(n, n + o);
    var i = new Array(a.length);
    a.forEach((e, t) => i[t] = {
      value: e,
      index: t
    }), s < i.length && (wm(i, s), i = i.slice(0, s)), r && i.sort(km);
    var c = _t262 * s,
        h = l.subarray(c, c + s),
        d = u.subarray(c, c + s);

    for (var _e282 = 0; _e282 < s; _e282++) {
      h[_e282] = i[_e282].value, d[_e282] = i[_e282].index;
    }
  };

  for (var _t262 = 0; _t262 < i; _t262++) {
    _loop30(_t262);
  }

  var c = t.slice();
  return c[c.length - 1] = s, [dn(c, n, l), dn(c, "int32", u)];
}

function Im(e, t, n, s) {
  var r = y(t, n)[0],
      a = [1, n[0], 1];

  for (var _e283 = 0; _e283 < r; _e283++) {
    a[0] *= n[_e283];
  }

  a[1] = n[r];

  for (var _e284 = r + 1; _e284 < n.length; _e284++) {
    a[2] *= n[_e284];
  }

  var i = {},
      o = new Int32Array(n[r]),
      l = new et(a, s, e),
      u = [],
      c = 1 === a[0] && 1 === a[2];

  for (var _t263 = 0; _t263 < n[r]; _t263++) {
    var _n167 = void 0;

    if (c) _n167 = e[_t263].toString();else {
      var _e285 = [];

      for (var _n168 = 0; _n168 < a[0]; _n168++) {
        for (var _s140 = 0; _s140 < a[2]; _s140++) {
          _e285.push(l.get(_n168, _t263, _s140));
        }
      }

      _n167 = _e285.join(",");
    }
    if (void 0 !== i[_n167]) o[_t263] = i[_n167];else {
      var _e286 = Object.keys(i).length;
      i[_n167] = _e286, o[_t263] = _e286, u.push(_t263);
    }
  }

  var h = a.slice();
  h[1] = Object.keys(i).length;
  var d = new et(h, s);
  u.forEach((e, t) => {
    for (var _n169 = 0; _n169 < a[0]; _n169++) {
      for (var _s141 = 0; _s141 < a[2]; _s141++) {
        d.set(l.get(_n169, e, _s141), _n169, t, _s141);
      }
    }
  });
  var p = n.slice();
  return p[r] = h[1], {
    outputValues: d.values,
    outputShape: p,
    indices: o
  };
}

var $m = {
  __proto__: null,
  simpleAbsImpl: Wf,
  addImpl: tg,
  bincountImpl: rg,
  bincountReduceImpl: ag,
  ceilImpl: ug,
  concatImpl: hg,
  equalImpl: dg,
  expImpl: gg,
  expm1Impl: xg,
  floorImpl: kg,
  gatherNdImpl: vg,
  gatherV2Impl: Ig,
  greaterImpl: $g,
  greaterEqualImpl: Cg,
  lessImpl: Tg,
  lessEqualImpl: Rg,
  linSpaceImpl: Fg,
  logImpl: Dg,
  maxImpl: Og,
  maximumImpl: Mg,
  minimumImpl: zg,
  multiplyImpl: Pg,
  negImpl: Gg,
  notEqualImpl: jg,
  prodImpl: Jg,
  rangeImpl: Qg,
  rsqrtImpl: em,
  sliceImpl: nm,
  sparseFillEmptyRowsImpl: am,
  sparseReshapeImpl: im,
  sparseSegmentReductionImpl: om,
  squaredDifferenceImpl: lm,
  stridedSliceImpl: cm,
  stringNGramsImpl: dm,
  stringSplitImpl: fm,
  stringToHashBucketFastImpl: gm,
  subImpl: mm,
  tileImpl: ym,
  topKImpl: vm,
  transposeImpl: Kg,
  uniqueImpl: Im
};
Qn("cpu", () => new Pf(), 1);
var Nm = og("Elu", e => e >= 0 ? e : Math.exp(e) - 1),
    Cm = {
  kernelName: "Elu",
  backendName: "cpu",
  kernelFunc: Nm
};

function Sm(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    alpha: a
  } = s;
  zf([r], "leakyRelu");
  var i = d(r.shape),
      o = n.data.get(r.dataId).values,
      l = w("float32", i);

  for (var _e287 = 0; _e287 < o.length; _e287++) {
    l[_e287] = o[_e287] < 0 ? a * o[_e287] : o[_e287];
  }

  return n.makeTensorInfo(r.shape, "float32", l);
}

var Tm = {
  kernelName: "LeakyRelu",
  backendName: "cpu",
  kernelFunc: Sm
},
    Em = Vf((e, t) => e < 0 ? t * e : e);

function Rm(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    x: s,
    alpha: r
  } = t;
  zf([s, r], "prelu");
  var a = n.data.get(s.dataId).values,
      i = n.data.get(r.dataId).values,
      [o, l] = Em(s.shape, r.shape, a, i, s.dtype);
  return n.makeTensorInfo(l, s.dtype, o);
}

var Am = {
  kernelName: "Prelu",
  backendName: "cpu",
  kernelFunc: Rm
},
    Fm = og("Relu", e => Math.max(0, e)),
    Dm = {
  kernelName: "Relu",
  backendName: "cpu",
  kernelFunc: Fm
},
    _m = og("Relu6", e => Math.min(Math.max(0, e), 6)),
    Om = {
  kernelName: "Relu6",
  backendName: "cpu",
  kernelFunc: _m
},
    Mm = og("Sigmoid", e => 1 / (1 + Math.exp(-e))),
    Lm = {
  kernelName: "Sigmoid",
  backendName: "cpu",
  kernelFunc: Mm
};

function zm(e, t, n, s, r) {
  if ("linear" === n) return qf({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("relu" === n) return Fm({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("elu" === n) return Nm({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("relu6" === n) return _m({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("prelu" === n) return Rm({
    inputs: {
      x: t,
      alpha: s
    },
    backend: e
  });
  if ("leakyrelu" === n) return Sm({
    inputs: {
      x: t
    },
    backend: e,
    attrs: {
      alpha: r
    }
  });
  if ("sigmoid" === n) return Mm({
    inputs: {
      x: t
    },
    backend: e
  });
  throw new Error("Activation ".concat(n, " has not been implemented for the CPU backend."));
}

function Bm(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    shape: a
  } = s,
      i = d(r.shape),
      o = x(a, i),
      u = d(o);
  l(i === u, () => "The new shape (".concat(o, ") has ").concat(u, " elements and the old shape (").concat(r.shape, ") has ").concat(i, " elements. The new shape and old shape must have the same number of elements.")), n.incRef(r.dataId);
  var c = n.data.get(r.dataId);

  if (null != c.complexTensorInfos) {
    var _e288 = c.complexTensorInfos.imag;
    c.complexTensorInfos.real.shape = o, _e288.shape = o;
  }

  return {
    dataId: r.dataId,
    shape: o,
    dtype: r.dtype
  };
}

var Pm = {
  kernelName: "Reshape",
  backendName: "cpu",
  kernelFunc: Bm
};

function Wm(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    a: r,
    b: a
  } = t,
      {
    transposeA: i,
    transposeB: o
  } = s;
  zf([r, a], "matMul");
  var u = r.shape.length,
      c = a.shape.length,
      h = i ? r.shape[u - 2] : r.shape[u - 1],
      p = o ? a.shape[c - 1] : a.shape[c - 2],
      f = i ? r.shape[u - 1] : r.shape[u - 2],
      g = o ? a.shape[c - 2] : a.shape[c - 1],
      m = r.shape.slice(0, -2),
      b = a.shape.slice(0, -2),
      x = d(m),
      y = d(b);
  l(u >= 2 && c >= 2 && (x === y || 1 === x || 1 === y), () => "Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (".concat(m, ") and (").concat(b, ")."));
  var k = (x > y ? r.shape.slice(0, -2) : a.shape.slice(0, -2)).concat([f, g]);
  l(h === p, () => "Error in matMul: inner shapes (".concat(h, ") and (").concat(p, ") of Tensors with shapes ").concat(r.shape, " and ").concat(a.shape, " and transposeA=").concat(i, " and transposeB=").concat(o, " must match."));
  var w = o ? [y, g, p] : [y, p, g],
      v = Bm({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      shape: i ? [x, h, f] : [x, f, h]
    }
  }),
      I = Bm({
    inputs: {
      x: a
    },
    backend: n,
    attrs: {
      shape: w
    }
  }),
      $ = i ? v.shape[1] : v.shape[2],
      N = i ? v.shape[2] : v.shape[1],
      C = o ? I.shape[1] : I.shape[2],
      S = Math.max(x, y),
      T = n.data.get(v.dataId).values,
      E = n.data.get(I.dataId).values,
      R = A(v.shape),
      F = A(I.shape),
      [D, _, O] = i ? [R[0], 1, R[1]] : [R[0], R[1], 1],
      [M, L, z] = o ? [1, F[1], F[0]] : [F[1], 1, F[0]],
      B = N * C,
      P = dn([S, N, C], v.dtype),
      W = P.values,
      U = n.blockSize;

  for (var _e289 = 0; _e289 < S; _e289++) {
    for (var _t264 = 0; _t264 < N; _t264 += U) {
      for (var _n170 = 0; _n170 < C; _n170 += U) {
        for (var _s142 = 0; _s142 < $; _s142 += U) {
          var _r98 = Math.min(_t264 + U, N),
              _a78 = Math.min(_n170 + U, C),
              _i42 = Math.min(_s142 + U, $);

          for (var _o33 = _t264; _o33 < _r98; _o33++) {
            for (var _t265 = _n170; _t265 < _a78; _t265++) {
              var _n171 = 0;

              for (var _r99 = _s142; _r99 < _i42; _r99++) {
                var _s143 = Math.min(_e289, x - 1) * D,
                    _a79 = Math.min(_e289, y - 1) * z;

                _n171 += T[_s143 + _o33 * _ + _r99 * O] * E[_r99 * M + _t265 * L + _a79];
              }

              W[_e289 * B + (_o33 * C + _t265)] += _n171;
            }
          }
        }
      }
    }
  }

  return n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(I), n.makeTensorInfo(k, P.dtype, P.values);
}

var Um = {
  kernelName: "BatchMatMul",
  backendName: "cpu",
  kernelFunc: Wm
},
    Vm = {
  kernelName: "_FusedMatMul",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      a: r,
      b: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      transposeA: l,
      transposeB: u,
      activation: c,
      leakyreluAlpha: h
    } = s;
    var d, p, f;
    var g = [];
    d = Wm({
      inputs: {
        a: r,
        b: a
      },
      attrs: {
        transposeA: l,
        transposeB: u
      },
      backend: n
    }), i && (p = ng({
      inputs: {
        a: d,
        b: i
      },
      backend: n
    }), g.push(d), d = p), c && (f = zm(n, d, c, o, h), g.push(d), d = f);

    for (var _e290 of g) {
      n.disposeIntermediateTensorInfo(_e290);
    }

    return d;
  }
},
    Gm = {
  kernelName: "Acos",
  backendName: "cpu",
  kernelFunc: og("Acos", e => Math.acos(e))
},
    Hm = {
  kernelName: "Acosh",
  backendName: "cpu",
  kernelFunc: og("Acosh", e => Math.acosh(e))
},
    jm = {
  kernelName: "AddN",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        s = t;
    zf(t, "addN");
    var r = s.map(e => n.data.get(e.dataId).values),
        a = dn(s[0].shape, s[0].dtype),
        i = a.values;

    for (var _e291 = 0; _e291 < s.length; _e291++) {
      var _t266 = r[_e291];

      for (var _e292 = 0; _e292 < i.length; _e292++) {
        i[_e292] += _t266[_e292];
      }
    }

    return n.makeTensorInfo(a.shape, a.dtype, a.values);
  }
},
    qm = {
  kernelName: "All",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s;
    zf(r, "all");
    var o = y(a, r.shape);
    var l = o;
    var u = Jr(l, r.shape.length);
    var c = r;
    null != u && (c = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), l = Qr(l.length, r.shape.length)), Yr("all", l, c.shape.length);
    var [h, p] = Kr(c.shape, l),
        f = d(p),
        g = O(d(h), c.dtype),
        m = n.data.get(c.dataId).values;

    for (var _e293 = 0; _e293 < g.length; ++_e293) {
      var _t267 = _e293 * f;

      var _n172 = m[_t267];

      for (var _e294 = 0; _e294 < f; ++_e294) {
        var _s144 = m[_t267 + _e294];
        _n172 = _n172 && _s144;
      }

      g[_e293] = _n172;
    }

    null != u && n.disposeIntermediateTensorInfo(c);
    var b = n.makeTensorInfo(h, c.dtype, g);

    if (i) {
      var _e295 = Bm({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: Xr(h, o)
        }
      });

      return n.disposeIntermediateTensorInfo(b), _e295;
    }

    return b;
  }
},
    Km = {
  kernelName: "Any",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s;
    zf(r, "any");
    var o = y(a, r.shape);
    var l = o;
    var u = Jr(l, r.shape.length);
    var c = r;
    null != u && (c = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), l = Qr(l.length, r.shape.length)), Yr("any", l, c.shape.length);
    var [h, p] = Kr(c.shape, l),
        f = d(p),
        g = O(d(h), c.dtype),
        m = n.data.get(c.dataId).values;

    for (var _e296 = 0; _e296 < g.length; ++_e296) {
      var _t268 = _e296 * f;

      var _n173 = m[_t268];

      for (var _e297 = 0; _e297 < f; ++_e297) {
        var _s145 = m[_t268 + _e297];
        _n173 = _n173 || _s145;
      }

      g[_e296] = _n173;
    }

    null != u && n.disposeIntermediateTensorInfo(c);
    var b = n.makeTensorInfo(h, c.dtype, g);

    if (i) {
      var _e298 = Bm({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: Xr(h, o)
        }
      });

      return n.disposeIntermediateTensorInfo(b), _e298;
    }

    return b;
  }
},
    Xm = {
  kernelName: "ArgMax",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a
    } = s;
    zf(r, "argMax");
    var i = y(a, r.shape);
    var o = Jr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = Qr(i.length, l.shape.length)), i = [i[0]], Yr("argMax", i, l.shape.length);
    var [c, h] = Kr(l.shape, i),
        p = O(d(c), "int32"),
        f = d(h),
        g = n.data.get(l.dataId).values;

    for (var _e299 = 0; _e299 < p.length; ++_e299) {
      var _t269 = _e299 * f;

      var _n174 = g[_t269],
          _s146 = 0;

      for (var _e300 = 0; _e300 < f; ++_e300) {
        var _r100 = g[_t269 + _e300];
        _r100 > _n174 && (_n174 = _r100, _s146 = _e300);
      }

      p[_e299] = _s146;
    }

    return u.forEach(e => n.disposeIntermediateTensorInfo(e)), n.makeTensorInfo(c, "int32", p);
  }
},
    Ym = {
  kernelName: "ArgMin",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a
    } = s;
    zf(r, "argMin");
    var i = y(a, r.shape);
    var o = Jr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = Qr(i.length, l.shape.length)), i = [i[0]], Yr("argMin", i, l.shape.length);
    var [c, h] = Kr(l.shape, i),
        p = O(d(c), "int32"),
        f = d(h),
        g = n.data.get(l.dataId).values;

    for (var _e301 = 0; _e301 < p.length; ++_e301) {
      var _t270 = _e301 * f;

      var _n175 = g[_t270],
          _s147 = 0;

      for (var _e302 = 0; _e302 < f; ++_e302) {
        var _r101 = g[_t270 + _e302];
        _r101 < _n175 && (_n175 = _r101, _s147 = _e302);
      }

      p[_e301] = _s147;
    }

    return u.forEach(e => n.disposeIntermediateTensorInfo(e)), n.makeTensorInfo(c, "int32", p);
  }
},
    Jm = {
  kernelName: "Asin",
  backendName: "cpu",
  kernelFunc: og("Asin", e => Math.asin(e))
},
    Zm = {
  kernelName: "Asinh",
  backendName: "cpu",
  kernelFunc: og("Asinh", e => Math.asinh(e))
},
    Qm = {
  kernelName: "Atan",
  backendName: "cpu",
  kernelFunc: og("Atan", e => Math.atan(e))
},
    eb = {
  kernelName: "Atan2",
  backendName: "cpu",
  kernelFunc: Qf("Atan2", Vf((e, t) => Math.atan2(e, t)))
},
    tb = {
  kernelName: "Atanh",
  backendName: "cpu",
  kernelFunc: og("Atanh", e => Math.atanh(e))
};

function nb(e, t, n, s, r, a) {
  var i = r.strideHeight,
      o = r.strideWidth,
      l = r.dilationHeight,
      u = r.dilationWidth,
      c = r.effectiveFilterHeight,
      h = r.effectiveFilterWidth,
      d = r.padInfo.top,
      p = r.padInfo.left,
      f = "max" === a ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      g = dn(r.outShape, n),
      m = g.values,
      b = r.outShape[1] * r.outShape[2] * r.outShape[3],
      x = r.outShape[2] * r.outShape[3],
      y = r.outShape[3];

  for (var _t271 = 0; _t271 < r.batchSize; ++_t271) {
    var _n176 = _t271 * b,
        _g9 = _t271 * s[0];

    for (var _t272 = 0; _t272 < r.inChannels; ++_t272) {
      for (var _b7 = 0; _b7 < r.outHeight; ++_b7) {
        var _k4 = _b7 * i - d,
            _w3 = Math.max(0, _k4),
            _v3 = Math.min(r.inHeight, c + _k4),
            _I2 = _n176 + _b7 * x;

        for (var _n177 = 0; _n177 < r.outWidth; ++_n177) {
          var _i43 = _n177 * o - p,
              _c13 = Math.max(0, _i43),
              _d10 = Math.min(r.inWidth, h + _i43);

          var _b8 = f,
              _x51 = 0,
              _k5 = 0;

          for (var _n178 = _w3; _n178 < _v3; _n178 += l) {
            var _r102 = _g9 + _n178 * s[1];

            for (var _n179 = _c13; _n179 < _d10; _n179 += u) {
              var _i44 = e[_r102 + _n179 * s[2] + _t272];
              "max" === a && _i44 > _b8 ? _b8 = _i44 : "avg" === a && (_x51 += _i44, _k5++);
            }

            if (isNaN(_b8)) break;
          }

          m[_I2 + _n177 * y + _t272] = "avg" === a ? _x51 / _k5 : _b8;
        }
      }
    }
  }

  return g;
}

function sb(e, t, n, s) {
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
  var i = dn(s.outShape, "int32"),
      o = s.strideHeight,
      l = s.strideWidth,
      u = s.dilationHeight,
      c = s.dilationWidth,
      h = s.effectiveFilterHeight,
      d = s.effectiveFilterWidth,
      p = s.padInfo.top,
      f = s.padInfo.left,
      g = dn(t, n, e);

  for (var _e303 = 0; _e303 < s.batchSize; ++_e303) {
    for (var _t273 = 0; _t273 < s.inChannels; ++_t273) {
      for (var _n180 = 0; _n180 < s.outHeight; ++_n180) {
        var _m8 = _n180 * o - p;

        var _b9 = _m8;

        for (; _b9 < 0;) {
          _b9 += u;
        }

        var _x52 = Math.min(s.inHeight, h + _m8);

        for (var _o34 = 0; _o34 < s.outWidth; ++_o34) {
          var _h9 = _o34 * l - f;

          var _p9 = _h9;

          for (; _p9 < 0;) {
            _p9 += c;
          }

          var _y7 = Math.min(s.inWidth, d + _h9);

          var _k6 = Number.NEGATIVE_INFINITY,
              _w4 = -1;

          for (var _n181 = _b9; _n181 < _x52; _n181 += u) {
            var _i45 = _n181 - _m8;

            for (var _o35 = _p9; _o35 < _y7; _o35 += c) {
              var _l23 = _o35 - _h9,
                  _u14 = g.get(_e303, _n181, _o35, _t273);

              _u14 > _k6 && (_k6 = _u14, _w4 = r ? a ? ((_e303 * s.inHeight + _n181) * s.inWidth + _o35) * s.inChannels + _t273 : (_n181 * s.inWidth + _o35) * s.inChannels + _t273 : _i45 * d + _l23);
            }
          }

          i.set(_w4, _e303, _n180, _o34, _t273);
        }
      }
    }
  }

  return i;
}

function rb(e, t, n, s, r, a) {
  var i = r.strideDepth,
      o = r.strideHeight,
      l = r.strideWidth,
      u = r.dilationDepth,
      c = r.dilationHeight,
      h = r.dilationWidth,
      d = r.effectiveFilterDepth,
      p = r.effectiveFilterHeight,
      f = r.effectiveFilterWidth,
      g = r.padInfo.front,
      m = r.padInfo.top,
      b = r.padInfo.left,
      x = "max" === a ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      y = dn(r.outShape, n),
      k = y.values,
      w = r.outShape[1] * r.outShape[2] * r.outShape[3] * r.outShape[4],
      v = r.outShape[2] * r.outShape[3] * r.outShape[4],
      I = r.outShape[3] * r.outShape[4],
      $ = r.outShape[4];

  for (var _t274 = 0; _t274 < r.batchSize; ++_t274) {
    var _n182 = _t274 * w,
        _y8 = _t274 * s[0];

    for (var _t275 = 0; _t275 < r.inChannels; ++_t275) {
      for (var _w5 = 0; _w5 < r.outDepth; ++_w5) {
        var _N2 = _w5 * i - g;

        var _C2 = _N2;

        for (; _C2 < 0;) {
          _C2 += u;
        }

        var _S = Math.min(r.inDepth, d + _N2),
            _T = _n182 + _w5 * v;

        for (var _n183 = 0; _n183 < r.outHeight; ++_n183) {
          var _i46 = _n183 * o - m;

          var _d11 = _i46;

          for (; _d11 < 0;) {
            _d11 += c;
          }

          var _g10 = Math.min(r.inHeight, p + _i46),
              _w6 = _T + _n183 * I;

          for (var _n184 = 0; _n184 < r.outWidth; ++_n184) {
            var _i47 = _n184 * l - b;

            var _o36 = _i47;

            for (; _o36 < 0;) {
              _o36 += h;
            }

            var _p10 = Math.min(r.inWidth, f + _i47),
                _m9 = _w6 + _n184 * $;

            var _v4 = x,
                _I3 = 0,
                _N3 = 0;

            for (var _n185 = _C2; _n185 < _S; _n185 += u) {
              var _r103 = _y8 + _n185 * s[1];

              for (var _n186 = _d11; _n186 < _g10; _n186 += c) {
                var _i48 = _r103 + _n186 * s[2];

                for (var _n187 = _o36; _n187 < _p10; _n187 += h) {
                  var _r104 = e[_i48 + _n187 * s[3] + _t275];
                  if ("max" === a && _r104 > _v4 ? _v4 = _r104 : "avg" === a && (_I3 += _r104, _N3++), isNaN(_v4)) break;
                }

                if (isNaN(_v4)) break;
              }

              if (isNaN(_v4)) break;
            }

            k[_m9 + _t275] = "avg" === a ? _I3 / _N3 : _v4;
          }
        }
      }
    }
  }

  return y;
}

var ab = {
  kernelName: "AvgPool",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t;
    zf(r, "avgPool");
    var {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: u
    } = s;
    l(Ss(i, 1), () => "Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'"));
    var c = bs(r.shape, a, i, 1, o, u);
    var h;
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) h = qf({
      inputs: {
        x: r
      },
      backend: n
    });else {
      var _e304 = n.data.get(r.dataId).values,
          _t276 = A(r.shape),
          _s148 = nb(_e304, 0, r.dtype, _t276, c, "avg");

      h = n.makeTensorInfo(c.outShape, r.dtype, _s148.values);
    }
    return h;
  }
},
    ib = {
  kernelName: "AvgPool3D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: l,
      dataFormat: u
    } = s;
    zf(r, "avgPool3d");
    var c = xs(r.shape, a, i, 1, o, l, u),
        h = rb(n.data.get(r.dataId).values, 0, r.dtype, A(r.shape), c, "avg");
    return n.makeTensorInfo(h.shape, "float32", h.values);
  }
},
    ob = {
  kernelName: "AvgPool3DGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        {
      filterSize: i,
      strides: o,
      pad: l,
      dimRoundingMode: u
    } = s;
    zf([r, a], "avgPool3DGrad");
    var c = xs(a.shape, i, o, 1, l, u),
        h = c.strideDepth,
        d = c.strideHeight,
        p = c.strideWidth,
        f = c.filterDepth,
        g = c.filterHeight,
        m = c.filterWidth,
        b = c.dilationDepth,
        x = c.dilationHeight,
        y = c.dilationWidth,
        k = c.effectiveFilterDepth,
        w = c.effectiveFilterHeight,
        v = c.effectiveFilterWidth,
        I = k - 1 - c.padInfo.front,
        $ = v - 1 - c.padInfo.left,
        N = w - 1 - c.padInfo.top,
        C = dn(a.shape, "float32"),
        S = 1 / (f * g * m),
        T = n.bufferSync(r);

    for (var _e305 = 0; _e305 < c.batchSize; ++_e305) {
      for (var _t277 = 0; _t277 < c.inChannels; ++_t277) {
        for (var _n188 = 0; _n188 < c.inDepth; ++_n188) {
          for (var _s149 = 0; _s149 < c.inHeight; ++_s149) {
            for (var _r105 = 0; _r105 < c.inWidth; ++_r105) {
              var _a80 = _n188 - I,
                  _i49 = _s149 - N,
                  _o37 = _r105 - $;

              var _l24 = 0;

              for (var _n189 = 0; _n189 < k; _n189 += b) {
                var _s150 = (_a80 + _n189) / h;

                if (!(_s150 < 0 || _s150 >= c.outDepth || Math.floor(_s150) !== _s150)) for (var _n190 = 0; _n190 < w; _n190 += x) {
                  var _r106 = (_i49 + _n190) / d;

                  if (!(_r106 < 0 || _r106 >= c.outHeight || Math.floor(_r106) !== _r106)) for (var _n191 = 0; _n191 < v; _n191 += y) {
                    var _a81 = (_o37 + _n191) / p;

                    _a81 < 0 || _a81 >= c.outWidth || Math.floor(_a81) !== _a81 || (_l24 += T.get(_e305, _s150, _r106, _a81, _t277));
                  }
                }
              }

              C.set(_l24 * S, _e305, _n188, _s149, _r105, _t277);
            }
          }
        }
      }
    }

    return n.makeTensorInfo(C.shape, C.dtype, C.values);
  }
},
    lb = {
  kernelName: "AvgPoolGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        i = a;
    zf([r, a], "avgPoolGrad");
    var {
      filterSize: o,
      strides: l,
      pad: u
    } = s,
        c = bs(i.shape, o, l, 1, u),
        h = c.strideHeight,
        d = c.strideWidth,
        p = c.filterHeight,
        f = c.filterWidth,
        g = c.dilationHeight,
        m = c.dilationWidth,
        b = c.effectiveFilterHeight,
        x = c.effectiveFilterWidth,
        y = x - 1 - c.padInfo.left,
        k = b - 1 - c.padInfo.top,
        w = dn(i.shape, "float32"),
        v = 1 / (p * f),
        I = n.data.get(r.dataId).values,
        $ = dn(r.shape, "float32", I);

    for (var _e306 = 0; _e306 < c.batchSize; ++_e306) {
      for (var _t278 = 0; _t278 < c.inChannels; ++_t278) {
        for (var _n192 = 0; _n192 < c.inHeight; ++_n192) {
          for (var _s151 = 0; _s151 < c.inWidth; ++_s151) {
            var _r107 = _n192 - k,
                _a82 = _s151 - y;

            var _i50 = 0;

            for (var _n193 = 0; _n193 < b; _n193 += g) {
              var _s152 = (_r107 + _n193) / h;

              if (!(_s152 < 0 || _s152 >= c.outHeight || Math.floor(_s152) !== _s152)) for (var _n194 = 0; _n194 < x; _n194 += m) {
                var _r108 = (_a82 + _n194) / d;

                _r108 < 0 || _r108 >= c.outWidth || Math.floor(_r108) !== _r108 || (_i50 += $.get(_e306, _s152, _r108, _t278));
              }
            }

            w.set(_i50 * v, _e306, _n192, _s151, _t278);
          }
        }
      }
    }

    return n.makeTensorInfo(w.shape, w.dtype, w.values);
  }
},
    ub = {
  kernelName: "FusedBatchNorm",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      scale: a,
      offset: i,
      mean: o,
      variance: u
    } = t;
    l(o.shape.length === u.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), l(null == i || o.shape.length === i.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), l(null == a || o.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), zf([r, o, u, a, i], "batchNorm");
    var {
      varianceEpsilon: c
    } = s;
    null == c && (c = .001);
    var h = n.data.get(r.dataId).values,
        d = n.data.get(o.dataId).values,
        p = n.data.get(u.dataId).values,
        f = a ? n.data.get(a.dataId).values : new Float32Array([1]),
        g = i ? n.data.get(i.dataId).values : new Float32Array([0]),
        m = new Float32Array(h.length),
        b = g.length,
        x = f.length,
        y = p.length,
        k = d.length;
    var w = 0,
        v = 0,
        I = 0,
        $ = 0;

    for (var _e307 = 0; _e307 < h.length; ++_e307) {
      m[_e307] = g[w++] + (h[_e307] - d[v++]) * f[I++] / Math.sqrt(p[$++] + c), w >= b && (w = 0), v >= k && (v = 0), I >= x && (I = 0), $ >= y && ($ = 0);
    }

    return n.makeTensorInfo(r.shape, r.dtype, m);
  }
},
    cb = {
  kernelName: "BatchToSpaceND",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockShape: a,
      crops: i
    } = s;
    zf([r], "batchToSpaceND");

    var o = a.reduce((e, t) => e * t),
        l = Ro(r.shape, a, o),
        u = Ao(l.length, a.length),
        c = Fo(r.shape, a, o),
        h = Do(i, a.length),
        d = _o(c, i, a.length),
        p = Bm({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: l
      }
    }),
        f = Xg({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        perm: u
      }
    }),
        g = Bm({
      inputs: {
        x: f
      },
      backend: n,
      attrs: {
        shape: c
      }
    }),
        m = sm({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        begin: h,
        size: d
      }
    });

    return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
  }
},
    hb = {
  kernelName: "Bincount",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      weights: a
    } = t,
        {
      size: i
    } = s,
        o = rg(n.data.get(r.dataId).values, n.data.get(a.dataId).values, a.dtype, a.shape, i);
    return n.makeTensorInfo([i], a.dtype, o);
  }
},
    db = {
  kernelName: "ClipByValue",
  backendName: "cpu",
  kernelFunc: og("ClipByValue", (e, t) => e > t.clipValueMax ? t.clipValueMax : e < t.clipValueMin ? t.clipValueMin : e)
},
    pb = {
  kernelName: "ComplexAbs",
  backendName: "cpu",
  kernelFunc: e => {
    var {
      x: t
    } = e.inputs,
        n = e.backend,
        s = new Float32Array(d(t.shape)),
        r = n.data.get(t.dataId),
        a = r.complexTensorInfos.imag,
        i = n.data.get(r.complexTensorInfos.real.dataId).values,
        o = n.data.get(a.dataId).values;

    for (var _e308 = 0; _e308 < i.length; _e308++) {
      s[_e308] = Math.hypot(i[_e308], o[_e308]);
    }

    return n.makeOutput(s, t.shape, "float32");
  }
};

function fb(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    input: s
  } = t,
      r = n.data.get(s.dataId).complexTensorInfos.imag,
      a = n.data.get(r.dataId).values;
  return n.makeTensorInfo(r.shape, r.dtype, a);
}

var gb = {
  kernelName: "Imag",
  backendName: "cpu",
  kernelFunc: fb
};

function mb(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    axis: r
  } = s,
      a = y(r, t[0].shape)[0];
  var i = So(t.map(e => e.shape), a);
  if (0 === d(i)) return n.makeTensorInfo(i, t[0].dtype, []);
  var o = t.filter(e => d(e.shape) > 0);
  if (1 === o.length) return qf({
    inputs: {
      x: o[0]
    },
    backend: n
  });

  if (Co(o.map(e => e.shape), a), "complex64" === o[0].dtype) {
    var _e309 = o.map(e => Xf({
      inputs: {
        input: e
      },
      backend: n
    })),
        _t279 = o.map(e => fb({
      inputs: {
        input: e
      },
      backend: n
    })),
        _s153 = mb({
      inputs: _e309,
      backend: n,
      attrs: {
        axis: a
      }
    }),
        _r109 = mb({
      inputs: _t279,
      backend: n,
      attrs: {
        axis: a
      }
    }),
        _i51 = Gf({
      inputs: {
        real: _s153,
        imag: _r109
      },
      backend: n
    });

    return _e309.forEach(e => n.disposeIntermediateTensorInfo(e)), _t279.forEach(e => n.disposeIntermediateTensorInfo(e)), n.disposeIntermediateTensorInfo(_s153), n.disposeIntermediateTensorInfo(_r109), _i51;
  }

  var l = o.map(e => {
    var t = d(e.shape.slice(a));
    return Bm({
      inputs: {
        x: e
      },
      backend: n,
      attrs: {
        shape: [-1, t]
      }
    });
  }),
      u = l.map(e => ({
    vals: n.data.get(e.dataId).values,
    shape: e.shape
  }));
  i = So(l.map(e => e.shape), 1);
  var c = hg(u, i, t[0].dtype, 1 === l[0].shape[0]),
      h = So(o.map(e => e.shape), a),
      p = n.makeTensorInfo(h, t[0].dtype, c);
  return l.forEach(e => n.disposeIntermediateTensorInfo(e)), p;
}

var bb = {
  kernelName: "Concat",
  backendName: "cpu",
  kernelFunc: mb
};

function xb(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r,
    filter: a
  } = t,
      {
    strides: i,
    pad: o,
    dataFormat: l,
    dilations: u,
    dimRoundingMode: c
  } = s;
  zf([r, a], "conv2d");
  var h = Ts(l),
      d = ys(r.shape, a.shape, i, u, o, c, !1, h),
      p = d.filterHeight,
      f = d.filterWidth,
      g = d.dilationHeight,
      m = d.dilationWidth,
      b = d.padInfo.left,
      x = d.padInfo.top,
      y = "channelsLast" === d.dataFormat,
      k = new et(d.outShape, r.dtype),
      w = A(r.shape),
      v = A(a.shape),
      I = w[0],
      $ = y ? w[1] : w[2],
      N = y ? w[2] : 1,
      C = y ? 1 : w[1],
      S = k.strides[0],
      T = y ? k.strides[1] : k.strides[2],
      E = y ? k.strides[2] : 1,
      R = y ? 1 : k.strides[1],
      F = n.data.get(r.dataId).values,
      D = n.data.get(a.dataId).values,
      _ = k.values;

  for (var _e310 = 0; _e310 < d.batchSize; ++_e310) {
    var _t280 = _e310 * I,
        _n195 = _e310 * S;

    for (var _e311 = 0; _e311 < d.outHeight; ++_e311) {
      var _s154 = _n195 + _e311 * T,
          _r110 = _e311 * d.strideHeight - x;

      for (var _e312 = 0; _e312 < p; ++_e312) {
        var _n196 = _r110 + _e312 * g;

        if (_n196 < 0 || _n196 >= d.inHeight) continue;

        var _a83 = _e312 * v[0],
            _i52 = _t280 + _n196 * $;

        for (var _e313 = 0; _e313 < d.outWidth; ++_e313) {
          var _t281 = _s154 + _e313 * E,
              _n197 = _e313 * d.strideWidth - b;

          for (var _e314 = 0; _e314 < f; ++_e314) {
            var _s155 = _n197 + _e314 * m;

            if (_s155 < 0 || _s155 >= d.inWidth) continue;

            var _r111 = _i52 + _s155 * N;

            var _o38 = _a83 + _e314 * v[1];

            for (var _e315 = 0; _e315 < d.inChannels; ++_e315) {
              var _n198 = F[_r111 + _e315 * C];

              for (var _e316 = 0; _e316 < d.outChannels; ++_e316) {
                _[_t281 + _e316 * R] += _n198 * D[_o38 + _e316];
              }

              _o38 += d.outChannels;
            }
          }
        }
      }
    }
  }

  return n.makeTensorInfo(k.shape, k.dtype, _);
}

var yb = {
  kernelName: "Conv2D",
  backendName: "cpu",
  kernelFunc: xb
},
    kb = {
  kernelName: "Conv2DBackpropFilter",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      pad: o,
      dataFormat: l,
      dimRoundingMode: u,
      filterShape: c
    } = s;
    zf([r, a], "conv2dBackpropFilter");
    var h = Ts(l),
        d = ys(r.shape, c, i, 1, o, u, !1, h),
        {
      strideHeight: p,
      strideWidth: f,
      filterHeight: g,
      filterWidth: m
    } = d,
        b = "channelsLast" === d.dataFormat,
        x = new et(d.filterShape, "float32"),
        y = d.padInfo.left,
        k = d.padInfo.top,
        w = n.data.get(r.dataId).values,
        v = n.data.get(a.dataId).values,
        I = new et(r.shape, r.dtype, w),
        $ = new et(a.shape, a.dtype, v);

    for (var _e317 = 0; _e317 < g; ++_e317) {
      var _t282 = Math.max(0, Math.ceil((k - _e317) / p)),
          _n199 = Math.min(d.outHeight, (d.inHeight + k - _e317) / p);

      for (var _s156 = 0; _s156 < m; ++_s156) {
        var _r112 = Math.max(0, Math.ceil((y - _s156) / f)),
            _a84 = Math.min(d.outWidth, (d.inWidth + y - _s156) / f);

        for (var _i53 = 0; _i53 < d.inChannels; ++_i53) {
          for (var _o39 = 0; _o39 < d.outChannels; ++_o39) {
            var _l25 = 0;

            for (var _u15 = 0; _u15 < d.batchSize; ++_u15) {
              for (var _c14 = _t282; _c14 < _n199; ++_c14) {
                var _t283 = _e317 + _c14 * p - k;

                for (var _e318 = _r112; _e318 < _a84; ++_e318) {
                  var _n200 = _s156 + _e318 * f - y;

                  _l25 += b ? I.get(_u15, _t283, _n200, _i53) * $.get(_u15, _c14, _e318, _o39) : I.get(_u15, _i53, _t283, _n200) * $.get(_u15, _o39, _c14, _e318);
                }
              }
            }

            x.set(_l25, _e317, _s156, _i53, _o39);
          }
        }
      }
    }

    return n.makeTensorInfo(x.shape, x.dtype, x.values);
  }
},
    wb = {
  kernelName: "Conv2DBackpropInput",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      inputShape: i,
      strides: o,
      pad: l,
      dataFormat: u,
      dimRoundingMode: c
    } = s;
    zf([r, a], "conv2dBackpropInput");
    var h = A(a.shape),
        d = A(r.shape);
    var p = Ts(u);
    var f = ys(i, a.shape, o, 1, l, c, !1, p),
        g = new et(f.inShape, "float32"),
        m = g.values,
        b = n.data.get(r.dataId).values,
        x = n.data.get(a.dataId).values,
        [y, k, w] = h,
        {
      batchSize: v,
      filterHeight: I,
      filterWidth: $,
      inChannels: N,
      inHeight: C,
      inWidth: S,
      outChannels: T,
      outHeight: E,
      outWidth: R,
      strideHeight: F,
      strideWidth: D
    } = f;
    p = f.dataFormat;

    var _ = I - 1 - f.padInfo.top,
        O = $ - 1 - f.padInfo.left,
        M = "channelsLast" === p,
        L = g.strides[0],
        z = M ? g.strides[1] : g.strides[2],
        B = M ? g.strides[2] : 1,
        P = M ? 1 : g.strides[1],
        W = d[0],
        U = M ? d[1] : d[2],
        V = M ? d[2] : 1,
        G = M ? 1 : d[1];

    for (var _e319 = 0; _e319 < v; ++_e319) {
      for (var _t284 = 0; _t284 < N; ++_t284) {
        for (var _n201 = 0; _n201 < C; ++_n201) {
          var _s157 = _n201 - _,
              _r113 = Math.max(0, Math.ceil(_s157 / F)),
              _a85 = Math.min(E, (I + _s157) / F);

          for (var _i54 = 0; _i54 < S; ++_i54) {
            var _o40 = _i54 - O,
                _l26 = Math.max(0, Math.ceil(_o40 / D)),
                _u16 = Math.min(R, ($ + _o40) / D);

            var _c15 = 0;

            for (var _n202 = _r113; _n202 < _a85; ++_n202) {
              var _r114 = _n202 * F - _s157;

              for (var _s158 = _l26; _s158 < _u16; ++_s158) {
                var _a86 = W * _e319 + U * _n202 + V * _s158,
                    _i55 = y * (I - 1 - _r114) + k * ($ - 1 - (_s158 * D - _o40)) + w * _t284;

                for (var _e320 = 0; _e320 < T; ++_e320) {
                  _c15 += b[_a86 + G * _e320] * x[_i55 + _e320];
                }
              }
            }

            m[L * _e319 + z * _n201 + B * _i54 + P * _t284] = _c15;
          }
        }
      }
    }

    return n.makeTensorInfo(g.shape, g.dtype, g.values);
  }
},
    vb = {
  kernelName: "Conv3D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a
    } = t,
        {
      strides: i,
      pad: o,
      dilations: l
    } = s;
    zf([r, a], "conv3d");
    var u = ks(r.shape, a.shape, i, l, o),
        {
      filterDepth: c,
      filterHeight: h,
      filterWidth: d,
      dilationDepth: p,
      dilationHeight: f,
      dilationWidth: g,
      padInfo: m
    } = u,
        b = m.front,
        x = m.left,
        y = m.top,
        k = new et(u.outShape, r.dtype),
        w = n.data.get(r.dataId).values,
        v = n.data.get(a.dataId).values,
        I = k.values,
        $ = A(r.shape),
        N = A(a.shape);

    for (var _e321 = 0; _e321 < u.batchSize; ++_e321) {
      var _t285 = _e321 * $[0],
          _n203 = _e321 * k.strides[0];

      for (var _e322 = 0; _e322 < u.outDepth; ++_e322) {
        var _s159 = _n203 + _e322 * k.strides[1],
            _r115 = _e322 * u.strideDepth - b;

        for (var _e323 = 0; _e323 < c; ++_e323) {
          var _n204 = _r115 + _e323 * p;

          if (_n204 < 0 || _n204 >= u.inDepth) continue;

          var _a87 = _e323 * N[0],
              _i56 = _t285 + _n204 * $[1];

          for (var _e324 = 0; _e324 < u.outHeight; ++_e324) {
            var _t286 = _s159 + _e324 * k.strides[2],
                _n205 = _e324 * u.strideHeight - y;

            for (var _e325 = 0; _e325 < h; ++_e325) {
              var _s160 = _n205 + _e325 * f;

              if (_s160 < 0 || _s160 >= u.inHeight) continue;

              var _r116 = _a87 + _e325 * N[1],
                  _o41 = _i56 + _s160 * $[2];

              for (var _e326 = 0; _e326 < u.outWidth; ++_e326) {
                var _n206 = _t286 + _e326 * u.outChannels,
                    _s161 = _e326 * u.strideWidth - x;

                for (var _e327 = 0; _e327 < d; ++_e327) {
                  var _t287 = _s161 + _e327 * g;

                  if (_t287 < 0 || _t287 >= u.inWidth) continue;

                  var _a88 = _o41 + _t287 * u.inChannels;

                  var _i57 = _r116 + _e327 * N[2];

                  for (var _e328 = 0; _e328 < u.inChannels; ++_e328) {
                    var _t288 = w[_a88 + _e328];

                    for (var _e329 = 0; _e329 < u.outChannels; ++_e329) {
                      I[_n206 + _e329] += _t288 * v[_i57 + _e329];
                    }

                    _i57 += u.outChannels;
                  }
                }
              }
            }
          }
        }
      }
    }

    return n.makeTensorInfo(k.shape, k.dtype, k.values);
  }
},
    Ib = {
  kernelName: "Conv3DBackpropFilterV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      pad: o,
      filterShape: l
    } = s;
    zf([r, a], "conv3dBackpropFilterV2");
    var u = A(r.shape),
        c = A(a.shape),
        h = ks(r.shape, l, i, 1, o),
        d = h.strideDepth,
        p = h.strideHeight,
        f = h.strideWidth,
        g = h.filterDepth,
        m = h.filterHeight,
        b = h.filterWidth,
        x = new et(h.filterShape, "float32"),
        y = x.values,
        [k, w, v, I] = x.strides,
        $ = n.data.get(a.dataId).values,
        [N, C, S, T] = c,
        E = n.data.get(r.dataId).values,
        [R, F, D, _] = u,
        O = h.padInfo.front,
        M = h.padInfo.left,
        L = h.padInfo.top;

    for (var _e330 = 0; _e330 < g; ++_e330) {
      var _t289 = Math.max(0, Math.ceil((O - _e330) / d)),
          _n207 = Math.min(h.outDepth, (h.inDepth + O - _e330) / d),
          _s162 = _e330 * k;

      for (var _r117 = 0; _r117 < m; ++_r117) {
        var _a89 = Math.max(0, Math.ceil((L - _r117) / p)),
            _i58 = Math.min(h.outHeight, (h.inHeight + L - _r117) / p),
            _o42 = _r117 * w + _s162;

        for (var _s163 = 0; _s163 < b; ++_s163) {
          var _l27 = Math.max(0, Math.ceil((M - _s163) / f)),
              _u17 = Math.min(h.outWidth, (h.inWidth + M - _s163) / f),
              _c16 = _s163 * v + _o42;

          for (var _o43 = 0; _o43 < h.inChannels; ++_o43) {
            var _g11 = _o43 * I + _c16;

            for (var _c17 = 0; _c17 < h.outChannels; ++_c17) {
              var _m10 = 0;

              for (var _g12 = 0; _g12 < h.batchSize; ++_g12) {
                var _h10 = _g12 * R,
                    _b10 = _g12 * N;

                for (var _g13 = _t289; _g13 < _n207; ++_g13) {
                  var _t290 = (_e330 + _g13 * d - O) * F + _h10,
                      _n208 = _g13 * C + _b10;

                  for (var _e331 = _a89; _e331 < _i58; ++_e331) {
                    var _a90 = (_r117 + _e331 * p - L) * D + _t290,
                        _i59 = _e331 * S + _n208;

                    for (var _e332 = _l27; _e332 < _u17; ++_e332) {
                      _m10 += E[(_s163 + _e332 * f - M) * _ + _a90 + _o43] * $[_e332 * T + _i59 + _c17];
                    }
                  }
                }
              }

              y[_g11 + _c17] = _m10;
            }
          }
        }
      }
    }

    return n.makeTensorInfo(x.shape, x.dtype, x.values);
  }
},
    $b = {
  kernelName: "Conv3DBackpropInputV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      pad: i,
      strides: o,
      inputShape: l
    } = s;
    zf([r], "conv3dBackpropInputV2");
    var u = A(r.shape),
        c = A(a.shape),
        h = ks(l, a.shape, o, 1, i),
        d = new et(h.inShape, "float32"),
        p = d.values,
        [f, g, m, b] = d.strides,
        x = n.data.get(r.dataId).values,
        [y, k, w, v] = u,
        I = n.data.get(a.dataId).values,
        [$, N, C, S] = c,
        {
      batchSize: T,
      filterDepth: E,
      filterHeight: R,
      filterWidth: F,
      inChannels: D,
      inDepth: _,
      inHeight: O,
      inWidth: M,
      outChannels: L,
      outDepth: z,
      outHeight: B,
      outWidth: P,
      strideDepth: W,
      strideHeight: U,
      strideWidth: V
    } = h,
        G = E - 1 - h.padInfo.front,
        H = R - 1 - h.padInfo.top,
        j = F - 1 - h.padInfo.left;

    for (var _e333 = 0; _e333 < T; ++_e333) {
      for (var _t291 = 0; _t291 < D; ++_t291) {
        for (var _n209 = 0; _n209 < _; ++_n209) {
          var _s164 = _n209 - G,
              _r118 = Math.max(0, Math.ceil(_s164 / W)),
              _a91 = Math.min(z, (E + _s164) / W);

          for (var _i60 = 0; _i60 < O; ++_i60) {
            var _o44 = _i60 - H,
                _l28 = Math.max(0, Math.ceil(_o44 / U)),
                _u18 = Math.min(B, (R + _o44) / U);

            for (var _c18 = 0; _c18 < M; ++_c18) {
              var _h11 = _c18 - j,
                  _d12 = Math.max(0, Math.ceil(_h11 / V)),
                  _T2 = Math.min(P, (F + _h11) / V);

              var _A = 0;

              for (var _n210 = _r118; _n210 < _a91; ++_n210) {
                var _r119 = _n210 * W - _s164;

                for (var _s165 = _l28; _s165 < _u18; ++_s165) {
                  var _a92 = _s165 * U - _o44;

                  for (var _i61 = _d12; _i61 < _T2; ++_i61) {
                    var _o45 = y * _e333 + k * _n210 + w * _s165 + v * _i61,
                        _l29 = $ * (E - 1 - _r119) + N * (R - 1 - _a92) + C * (F - 1 - (_i61 * V - _h11)) + S * _t291;

                    for (var _e334 = 0; _e334 < L; ++_e334) {
                      _A += x[_o45 + _e334] * I[_l29 + _e334];
                    }
                  }
                }
              }

              p[f * _e333 + g * _n209 + m * _i60 + b * _c18 + _t291] = _A;
            }
          }
        }
      }
    }

    return n.makeTensorInfo(d.shape, d.dtype, d.values);
  }
},
    Nb = {
  kernelName: "Cos",
  backendName: "cpu",
  kernelFunc: og("Cos", e => Math.cos(e))
},
    Cb = {
  kernelName: "Cosh",
  backendName: "cpu",
  kernelFunc: og("Cosh", e => Math.cosh(e))
},
    Sb = {
  kernelName: "CropAndResize",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      image: r,
      boxes: a,
      boxInd: i
    } = t,
        {
      cropSize: o,
      method: l,
      extrapolationValue: u
    } = s,
        [c, h, d, p] = r.shape,
        f = a.shape[0],
        [g, m] = o,
        b = dn([f, g, m, p], "float32"),
        x = n.data.get(a.dataId).values,
        y = n.data.get(i.dataId).values,
        k = n.data.get(r.dataId).values,
        w = A(r.shape),
        v = A(b.shape);

    for (var _e335 = 0; _e335 < f; _e335++) {
      var _t292 = 4 * _e335,
          _n211 = x[_t292],
          _s166 = x[_t292 + 1],
          _r120 = x[_t292 + 2],
          _a93 = x[_t292 + 3],
          _i62 = y[_e335];

      if (_i62 >= c) continue;

      var _o46 = g > 1 ? (_r120 - _n211) * (h - 1) / (g - 1) : 0,
          _f7 = m > 1 ? (_a93 - _s166) * (d - 1) / (m - 1) : 0;

      for (var _t293 = 0; _t293 < g; _t293++) {
        var _c19 = g > 1 ? _n211 * (h - 1) + _t293 * _o46 : .5 * (_n211 + _r120) * (h - 1);

        if (_c19 < 0 || _c19 > h - 1) for (var _n212 = 0; _n212 < m; _n212++) {
          for (var _s167 = 0; _s167 < p; _s167++) {
            b.values[_s167 + _n212 * v[2] + _t293 * v[1] + _e335 * v[0]] = u;
          }
        } else if ("bilinear" === l) {
          var _n213 = Math.floor(_c19),
              _r121 = Math.ceil(_c19),
              _o47 = _c19 - _n213;

          for (var _l30 = 0; _l30 < m; _l30++) {
            var _c20 = m > 1 ? _s166 * (d - 1) + _l30 * _f7 : .5 * (_s166 + _a93) * (d - 1);

            if (_c20 < 0 || _c20 > d - 1) {
              for (var _n214 = 0; _n214 < p; _n214++) {
                b.values[_n214 + _l30 * v[2] + _t293 * v[1] + _e335 * v[0]] = u;
              }

              continue;
            }

            var _h12 = Math.floor(_c20),
                _g14 = Math.ceil(_c20),
                _x53 = _c20 - _h12;

            for (var _s168 = 0; _s168 < p; _s168++) {
              var _a94 = _s168 + _h12 * w[2] + _n213 * w[1] + _i62 * w[0];

              var _u19 = k[_a94];
              _a94 = _s168 + _g14 * w[2] + _n213 * w[1] + _i62 * w[0];
              var _c21 = k[_a94];
              _a94 = _s168 + _h12 * w[2] + _r121 * w[1] + _i62 * w[0];
              var _d13 = k[_a94];
              _a94 = _s168 + _g14 * w[2] + _r121 * w[1] + _i62 * w[0];

              var _p11 = k[_a94],
                  _f8 = _u19 + (_c21 - _u19) * _x53;

              _a94 = _s168 + _l30 * v[2] + _t293 * v[1] + _e335 * v[0], b.values[_a94] = _f8 + (_d13 + (_p11 - _d13) * _x53 - _f8) * _o47;
            }
          }
        } else for (var _n215 = 0; _n215 < m; ++_n215) {
          var _r122 = m > 1 ? _s166 * (d - 1) + _n215 * _f7 : .5 * (_s166 + _a93) * (d - 1);

          if (_r122 < 0 || _r122 > d - 1) {
            for (var _s169 = 0; _s169 < p; _s169++) {
              b.values[_s169 + _n215 * v[2] + _t293 * v[1] + _e335 * v[0]] = u;
            }

            continue;
          }

          var _o48 = Math.round(_r122),
              _l31 = Math.round(_c19);

          for (var _s170 = 0; _s170 < p; _s170++) {
            b.values[_s170 + _n215 * v[2] + _t293 * v[1] + _e335 * v[0]] = k[_s170 + _o48 * w[2] + _l31 * w[1] + _i62 * w[0]];
          }
        }
      }
    }

    return n.makeTensorInfo(b.shape, b.dtype, b.values);
  }
},
    Tb = {
  kernelName: "Cumsum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      exclusive: i,
      reverse: o
    } = s;
    zf(r, "cumsum");
    var l = Jr([a], r.shape.length);
    var u = r;
    null != l && (u = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: l
      }
    }));
    var c = Qr(1, r.shape.length)[0];
    if (c !== u.shape.length - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=".concat(u.shape.length - 1, " but got axis=").concat(c));
    var h = dt(u.dtype, "int32"),
        p = O(d(u.shape), h),
        f = n.data.get(u.dataId).values,
        g = u.shape[u.shape.length - 1],
        m = o ? (e, t) => e + g - t - 1 : (e, t) => e + t;

    for (var _e336 = 0; _e336 < f.length; _e336 += g) {
      for (var _t294 = 0; _t294 < g; _t294++) {
        var _n216 = m(_e336, _t294);

        if (0 === _t294) p[_n216] = i ? 0 : f[_n216];else {
          var _s171 = m(_e336, _t294 - 1);

          p[_n216] = i ? f[_s171] + p[_s171] : f[_n216] + p[_s171];
        }
      }
    }

    var b = n.makeTensorInfo(u.shape, h, p);

    if (null != l) {
      var _e337 = Xg({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          perm: Zr(l)
        }
      });

      return n.disposeIntermediateTensorInfo(b), n.disposeIntermediateTensorInfo(u), _e337;
    }

    return b;
  }
},
    Eb = {
  kernelName: "DenseBincount",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      weights: a
    } = t,
        {
      size: i,
      binaryOutput: o
    } = s;

    if (1 === r.shape.length) {
      var _e338 = rg(n.data.get(r.dataId).values, n.data.get(a.dataId).values, a.dtype, a.shape, i);

      return n.makeTensorInfo([i], a.dtype, _e338);
    }

    if (2 === r.shape.length) {
      var _e339 = ag(n.bufferSync(r), n.bufferSync(a), i, o);

      return n.makeTensorInfo(_e339.shape, a.dtype, _e339.values);
    }

    throw new Error("Error in denseBincount: input must be at most rank 2, but got rank".concat(r.shape.length, "."));
  }
},
    Rb = {
  kernelName: "DepthToSpace",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockSize: a,
      dataFormat: i
    } = s;
    l("NHWC" === i, () => "Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(i)), l(a > 1, () => "blockSize should be > 1 for depthToSpace, but was: ".concat(a));
    var o = r.shape[0],
        u = r.shape[1],
        c = r.shape[2],
        h = r.shape[3],
        d = u * a,
        p = c * a,
        f = h / (a * a),
        g = n.data.get(r.dataId).values,
        m = new Float32Array(o * d * p * f);
    var b = 0;

    for (var _e340 = 0; _e340 < o; ++_e340) {
      for (var _t295 = 0; _t295 < d; ++_t295) {
        var _n217 = Math.floor(_t295 / a),
            _s172 = _t295 % a;

        for (var _t296 = 0; _t296 < p; ++_t296) {
          var _r123 = Math.floor(_t296 / a),
              _i63 = (_s172 * a + _t296 % a) * f;

          for (var _t297 = 0; _t297 < f; ++_t297) {
            m[b++] = g[_t297 + _i63 + h * (_r123 + c * (_n217 + u * _e340))];
          }
        }
      }
    }

    return n.makeTensorInfo([o, d, p, f], r.dtype, m);
  }
};

function Ab(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r,
    filter: a
  } = t,
      {
    strides: i,
    pad: o,
    dilations: u,
    dimRoundingMode: c
  } = s;
  zf([r, a], "depthwiseConv2DNative");
  var h = A(r.shape),
      d = A(a.shape);
  var p = u;
  null == p && (p = [1, 1]), l(Ss(i, p), () => "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '").concat(p, "'"));
  var f = ys(r.shape, a.shape, i, p, o, c, !0),
      {
    filterHeight: g,
    filterWidth: m,
    dilationHeight: b,
    dilationWidth: x,
    padInfo: y
  } = f,
      k = y.left,
      w = y.top,
      v = f.outChannels / f.inChannels,
      I = new et(f.outShape, r.dtype),
      $ = n.data.get(r.dataId).values,
      N = n.data.get(a.dataId).values,
      C = I.values;

  for (var _e341 = 0; _e341 < f.batchSize; ++_e341) {
    var _t298 = _e341 * h[0],
        _n218 = _e341 * I.strides[0];

    for (var _e342 = 0; _e342 < f.outHeight; ++_e342) {
      var _s173 = _n218 + _e342 * I.strides[1],
          _r124 = _e342 * f.strideHeight - w;

      for (var _e343 = 0; _e343 < g; ++_e343) {
        var _n219 = _r124 + _e343 * b;

        if (_n219 < 0 || _n219 >= f.inHeight) continue;

        var _a95 = _e343 * d[0],
            _i64 = _t298 + _n219 * h[1];

        for (var _e344 = 0; _e344 < f.outWidth; ++_e344) {
          var _t299 = _s173 + _e344 * I.strides[2],
              _n220 = _e344 * f.strideWidth - k;

          for (var _e345 = 0; _e345 < m; ++_e345) {
            var _s174 = _n220 + _e345 * x;

            if (_s174 < 0 || _s174 >= f.inWidth) continue;

            var _r125 = _i64 + _s174 * f.inChannels;

            var _o49 = _t299,
                _l32 = _a95 + _e345 * d[1];

            for (var _e346 = 0; _e346 < f.inChannels; ++_e346) {
              var _t300 = $[_r125 + _e346];

              for (var _e347 = 0; _e347 < v; ++_e347) {
                C[_o49 + _e347] += _t300 * N[_l32 + _e347];
              }

              _o49 += v, _l32 += v;
            }
          }
        }
      }
    }
  }

  return n.makeTensorInfo(I.shape, I.dtype, I.values);
}

var Fb = {
  kernelName: "DepthwiseConv2dNative",
  backendName: "cpu",
  kernelFunc: Ab
},
    Db = {
  kernelName: "DepthwiseConv2dNativeBackpropFilter",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      dilations: o,
      pad: l,
      dimRoundingMode: u,
      filterShape: c
    } = s;
    zf([r, a], "depthwiseConv2dNativeBackpropFilter");
    var h = ys(r.shape, c, i, o, l, u, !0),
        {
      strideHeight: d,
      strideWidth: p,
      filterHeight: f,
      filterWidth: g
    } = h,
        m = new et(h.filterShape, "float32"),
        b = h.padInfo.left,
        x = h.padInfo.top,
        y = h.outChannels / h.inChannels,
        k = n.data.get(r.dataId).values,
        w = new et(r.shape, r.dtype, k),
        v = n.data.get(a.dataId).values,
        I = new et(a.shape, a.dtype, v);

    for (var _e348 = 0; _e348 < f; ++_e348) {
      var _t301 = Math.max(0, Math.ceil((x - _e348) / d)),
          _n221 = Math.min(h.outHeight, (h.inHeight + x - _e348) / d);

      for (var _s175 = 0; _s175 < g; ++_s175) {
        var _r126 = Math.max(0, Math.ceil((b - _s175) / p)),
            _a96 = Math.min(h.outWidth, (h.inWidth + b - _s175) / p);

        for (var _i65 = 0; _i65 < h.outChannels; ++_i65) {
          var _o50 = Math.trunc(_i65 / y),
              _l33 = _i65 % y;

          var _u20 = 0;

          for (var _l34 = 0; _l34 < h.batchSize; ++_l34) {
            for (var _c22 = _t301; _c22 < _n221; ++_c22) {
              var _t302 = _e348 + _c22 * d - x;

              for (var _e349 = _r126; _e349 < _a96; ++_e349) {
                _u20 += w.get(_l34, _t302, _s175 + _e349 * p - b, _o50) * I.get(_l34, _c22, _e349, _i65);
              }
            }
          }

          m.set(_u20, _e348, _s175, _o50, _l33);
        }
      }
    }

    return n.makeTensorInfo(m.shape, m.dtype, m.values);
  }
},
    _b = {
  kernelName: "DepthwiseConv2dNativeBackpropInput",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      strides: i,
      dilations: o,
      pad: l,
      dimRoundingMode: u,
      inputShape: c
    } = s;
    zf([r, a], "depthwiseConv2DNativeBackpropInput");
    var h = A(r.shape),
        d = A(a.shape),
        p = ys(c, a.shape, i, o, l, u, !0),
        f = new et(p.inShape, "float32"),
        g = f.values,
        [m, b, x] = f.strides,
        y = n.data.get(r.dataId).values,
        [k, w, v] = h,
        I = n.data.get(a.dataId).values,
        [$, N, C] = d,
        {
      batchSize: S,
      filterHeight: T,
      filterWidth: E,
      inChannels: R,
      inHeight: F,
      inWidth: D,
      outChannels: _,
      outHeight: O,
      outWidth: M,
      strideHeight: L,
      strideWidth: z
    } = p,
        B = T - 1 - p.padInfo.top,
        P = E - 1 - p.padInfo.left,
        W = _ / R;

    for (var _e350 = 0; _e350 < S; ++_e350) {
      for (var _t303 = 0; _t303 < R; ++_t303) {
        for (var _n222 = 0; _n222 < F; ++_n222) {
          var _s176 = _n222 - B,
              _r127 = Math.max(0, Math.ceil(_s176 / L)),
              _a97 = Math.min(O, (T + _s176) / L);

          for (var _i66 = 0; _i66 < D; ++_i66) {
            var _o51 = _i66 - P,
                _l35 = Math.max(0, Math.ceil(_o51 / z)),
                _u21 = Math.min(M, (E + _o51) / z);

            var _c23 = 0;

            for (var _n223 = _r127; _n223 < _a97; ++_n223) {
              var _r128 = _n223 * L - _s176;

              for (var _s177 = _l35; _s177 < _u21; ++_s177) {
                var _a98 = k * _e350 + w * _n223 + v * _s177,
                    _i67 = $ * (T - 1 - _r128) + N * (E - 1 - (_s177 * z - _o51)) + C * _t303;

                for (var _e351 = 0; _e351 < W; ++_e351) {
                  _c23 += y[_a98 + (_t303 * W + _e351)] * I[_i67 + _e351];
                }
              }
            }

            g[m * _e350 + b * _n222 + x * _i66 + _t303] = _c23;
          }
        }
      }
    }

    return n.makeTensorInfo(f.shape, f.dtype, f.values);
  }
},
    Ob = {
  kernelName: "Diag",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t,
        r = d(s.shape),
        a = n.data.get(s.dataId).values,
        i = dn([r, r], s.dtype),
        o = i.values;

    for (var _e352 = 0; _e352 < a.length; _e352++) {
      o[_e352 * r + _e352] = a[_e352];
    }

    var l = [...s.shape, ...s.shape];
    return n.makeTensorInfo(l, i.dtype, i.values);
  }
},
    Mb = {
  kernelName: "Dilation2D",
  backendName: "cpu",
  kernelFunc: _ref13 => {
    var {
      inputs: e,
      backend: t,
      attrs: n
    } = _ref13;
    var {
      x: s,
      filter: r
    } = e,
        {
      strides: a,
      pad: i,
      dilations: o
    } = n,
        l = t,
        u = l.data.get(s.dataId).values,
        c = s.shape.length,
        h = l.data.get(r.dataId).values,
        p = r.shape.length,
        {
      batchSize: f,
      inHeight: g,
      inWidth: m,
      inChannels: b,
      outHeight: x,
      outWidth: y,
      padInfo: k,
      strideHeight: w,
      strideWidth: I,
      filterHeight: $,
      filterWidth: N,
      dilationHeight: C,
      dilationWidth: S,
      outShape: T
    } = ms(s.shape, r.shape, a, i, "NHWC", o),
        E = d(T),
        R = T.length,
        F = v(s.dtype, E);

    for (var _e353 = 0; _e353 < f; ++_e353) {
      for (var _t304 = 0; _t304 < x; ++_t304) {
        var _n224 = _t304 * w - k.top;

        for (var _a99 = 0; _a99 < y; ++_a99) {
          var _i68 = _a99 * I - k.left;

          for (var _o52 = 0; _o52 < b; ++_o52) {
            var _l36 = Number.MIN_SAFE_INTEGER;

            for (var _t305 = 0; _t305 < $; ++_t305) {
              var _a100 = _n224 + _t305 * C;

              if (_a100 >= 0 && _a100 < g) for (var _n225 = 0; _n225 < N; ++_n225) {
                var _d14 = _i68 + _n225 * S;

                if (_d14 >= 0 && _d14 < m) {
                  var _i69 = z([_e353, _a100, _d14, _o52], c, A(s.shape)),
                      _f9 = z([_t305, _n225, _o52], p, A(r.shape)),
                      _g15 = u[_i69] + h[_f9];

                  _g15 > _l36 && (_l36 = _g15);
                }
              }
            }

            F[z([_e353, _t304, _a99, _o52], R, A(T))] = _l36;
          }
        }
      }
    }

    return {
      dataId: l.write(Ue(F, s.dtype), T, s.dtype),
      shape: T,
      dtype: s.dtype
    };
  }
},
    Lb = {
  kernelName: "Dilation2DBackpropFilter",
  backendName: "cpu",
  kernelFunc: _ref14 => {
    var {
      inputs: e,
      backend: t,
      attrs: n
    } = _ref14;
    var {
      x: s,
      filter: r,
      dy: a
    } = e,
        {
      strides: i,
      pad: o,
      dilations: u
    } = n,
        c = t,
        h = D(s.shape, c.data.get(s.dataId).values),
        d = D(r.shape, c.data.get(r.dataId).values),
        {
      batchSize: p,
      inHeight: f,
      inWidth: g,
      inChannels: m,
      outHeight: b,
      outWidth: x,
      padInfo: y,
      strideHeight: k,
      strideWidth: w,
      filterHeight: v,
      filterWidth: I,
      dilationHeight: $,
      dilationWidth: N,
      outShape: C
    } = ms(s.shape, r.shape, i, o, "NHWC", u);
    l(a.rank === C.length, () => "Error in Dilation2DBackpropFilter, dy must have the same rank as output ".concat(C.length, ", but got ").concat(a.rank));
    var S = D(C, c.data.get(a.dataId).values),
        T = M(r.shape, r.dtype);

    for (var _e354 = 0; _e354 < p; ++_e354) {
      for (var _t306 = 0; _t306 < b; ++_t306) {
        var _n226 = _t306 * k - y.top;

        for (var _s178 = 0; _s178 < x; ++_s178) {
          var _r129 = _s178 * w - y.left;

          for (var _a101 = 0; _a101 < m; ++_a101) {
            var _i70 = Number.MIN_SAFE_INTEGER,
                _o53 = 0,
                _l37 = 0;

            for (var _t307 = 0; _t307 < v; ++_t307) {
              var _s179 = _n226 + _t307 * $;

              if (_s179 >= 0 && _s179 < f) for (var _n227 = 0; _n227 < I; ++_n227) {
                var _u22 = _r129 + _n227 * N;

                if (_u22 >= 0 && _u22 < g) {
                  var _r130 = h[_e354][_s179][_u22][_a101] + d[_t307][_n227][_a101];

                  _r130 > _i70 && (_i70 = _r130, _o53 = _t307, _l37 = _n227);
                }
              }
            }

            T[_o53][_l37][_a101] += S[_e354][_t306][_s178][_a101];
          }
        }
      }
    }

    return {
      dataId: c.write(Ue(T, s.dtype), r.shape, r.dtype),
      shape: r.shape,
      dtype: r.dtype
    };
  }
},
    zb = {
  kernelName: "Dilation2DBackpropInput",
  backendName: "cpu",
  kernelFunc: _ref15 => {
    var {
      inputs: e,
      backend: t,
      attrs: n
    } = _ref15;
    var {
      x: s,
      filter: r,
      dy: a
    } = e,
        {
      strides: i,
      pad: o,
      dilations: u
    } = n,
        c = t,
        h = D(s.shape, c.data.get(s.dataId).values),
        d = D(r.shape, c.data.get(r.dataId).values),
        {
      batchSize: p,
      inHeight: f,
      inWidth: g,
      inChannels: m,
      outHeight: b,
      outWidth: x,
      padInfo: y,
      strideHeight: k,
      strideWidth: w,
      filterHeight: v,
      filterWidth: I,
      dilationHeight: $,
      dilationWidth: N,
      outShape: C
    } = ms(s.shape, r.shape, i, o, "NHWC", u);
    l(a.rank === C.length, () => "Error in Dilation2DBackpropInput, dy must have the same rank as output ".concat(C.length, ", but got ").concat(a.rank));
    var S = D(C, c.data.get(a.dataId).values),
        T = M(s.shape, s.dtype);

    for (var _e355 = 0; _e355 < p; ++_e355) {
      for (var _t308 = 0; _t308 < b; ++_t308) {
        var _n228 = _t308 * k - y.top;

        for (var _s180 = 0; _s180 < x; ++_s180) {
          var _r131 = _s180 * w - y.left;

          for (var _a102 = 0; _a102 < m; ++_a102) {
            var _i71 = Number.MIN_SAFE_INTEGER,
                _o54 = _n228 < 0 ? 0 : _n228,
                _l38 = _r131 < 0 ? 0 : _r131;

            for (var _t309 = 0; _t309 < v; ++_t309) {
              var _s181 = _n228 + _t309 * $;

              if (_s181 >= 0 && _s181 < f) for (var _n229 = 0; _n229 < I; ++_n229) {
                var _u23 = _r131 + _n229 * N;

                if (_u23 >= 0 && _u23 < g) {
                  var _r132 = h[_e355][_s181][_u23][_a102] + d[_t309][_n229][_a102];

                  _r132 > _i71 && (_i71 = _r132, _o54 = _s181, _l38 = _u23);
                }
              }
            }

            T[_e355][_o54][_l38][_a102] += S[_e355][_t308][_s180][_a102];
          }
        }
      }
    }

    return {
      dataId: c.write(Ue(T, s.dtype), s.shape, s.dtype),
      shape: s.shape,
      dtype: s.dtype
    };
  }
};

function Bb(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    axis: a,
    keepDims: i
  } = s;
  var o;
  zf(r, "sum"), o = "bool" === r.dtype ? Jf({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      dtype: "int32"
    }
  }) : qf({
    inputs: {
      x: r
    },
    backend: n
  });
  var l = o.shape.length,
      u = y(a, o.shape),
      c = Jr(u, l);
  var h = u,
      p = o;
  null != c && (p = Xg({
    inputs: {
      x: o
    },
    backend: n,
    attrs: {
      perm: c
    }
  }), h = Qr(h.length, l)), Yr("sum", h, p.shape.length);
  var [f, g] = Kr(p.shape, h);
  var m = jf(n, f, dt(p.dtype, "int32"));
  var b = d(g),
      x = n.data.get(m.dataId).values,
      k = n.data.get(p.dataId).values;

  for (var _e356 = 0; _e356 < x.length; ++_e356) {
    var _t310 = _e356 * b;

    var _n230 = 0;

    for (var _e357 = 0; _e357 < b; ++_e357) {
      _n230 += k[_t310 + _e357];
    }

    x[_e356] = _n230;
  }

  if (i) {
    var _e358 = m;
    m = Bm({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Xr(m.shape, u)
      }
    }), n.disposeIntermediateTensorInfo(_e358);
  }

  return n.disposeIntermediateTensorInfo(o), null != c && n.disposeIntermediateTensorInfo(p), m;
}

var Pb = {
  kernelName: "Sum",
  backendName: "cpu",
  kernelFunc: Bb
},
    Wb = {
  kernelName: "Einsum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      equation: r
    } = s,
        a = t,
        {
      allDims: i,
      summedDims: o,
      idDims: l
    } = Ho(r, a.length);
    qo(i.length, l, a);
    var {
      path: u,
      steps: c
    } = Ko(o, l),
        h = c.length;
    var d = null,
        f = i.length;
    var g = [];

    for (var _e359 = 0; _e359 < h; ++_e359) {
      for (var _t311 of c[_e359]) {
        var {
          permutationIndices: _e360,
          expandDims: _s182
        } = jo(f, l[_t311]);

        var _r133 = void 0;

        Xo(_e360) ? _r133 = a[_t311] : (_r133 = Xg({
          inputs: {
            x: a[_t311]
          },
          backend: n,
          attrs: {
            perm: _e360
          }
        }), g.push(_r133));

        var _i72 = _r133.shape.slice();

        for (var _e361 = 0; _e361 < _s182.length; ++_e361) {
          _i72.splice(_s182[_e361], 0, 1);
        }

        p(_r133.shape, _i72) || (_r133 = Bm({
          inputs: {
            x: _r133
          },
          backend: n,
          attrs: {
            shape: _i72
          }
        }), g.push(_r133)), null === d ? d = _r133 : (d = Ug({
          inputs: {
            a: _r133,
            b: d
          },
          backend: n
        }), g.push(d));
      }

      _e359 < h - 1 && (u[_e359] >= 0 && (d = Bb({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          axis: u[_e359] - (i.length - f),
          keepDims: !1
        }
      }), g.push(d)), f--);
    }

    for (var _e362 of g) {
      _e362 !== d && n.disposeIntermediateTensorInfo(_e362);
    }

    return d;
  }
},
    Ub = {
  kernelName: "EluGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      dy: s,
      y: r
    } = t;
    zf([s, r], "eluGrad");
    var a = new Float32Array(d(r.shape)),
        i = n.data.get(r.dataId).values,
        o = n.data.get(s.dataId).values;

    for (var _e363 = 0; _e363 < i.length; ++_e363) {
      var _t312 = i[_e363];
      a[_e363] = _t312 >= 1 ? o[_e363] : o[_e363] * (_t312 + 1);
    }

    return n.makeTensorInfo(r.shape, "float32", a);
  }
},
    Vb = {
  kernelName: "Erf",
  backendName: "cpu",
  kernelFunc: og("Erf", e => {
    var t = Math.sign(e),
        n = Math.abs(e),
        s = 1 / (1 + .3275911 * n);
    return t * (1 - ((((1.061405429 * s - 1.453152027) * s + 1.421413741) * s - .284496736) * s + .254829592) * s * Math.exp(-n * n));
  })
};

function Gb(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    input: r
  } = t,
      {
    dim: a
  } = s,
      i = r.shape.length,
      o = r.shape.slice();
  var u = a;
  return a < 0 && (l(-(i + 1) <= a, () => "Axis must be in the interval [".concat(-(i + 1), ", ").concat(i, "]")), u = i + a + 1), o.splice(u, 0, 1), Bm({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      shape: o
    }
  });
}

var Hb = {
  kernelName: "ExpandDims",
  backendName: "cpu",
  kernelFunc: Gb
},
    jb = Qf("RealDiv", Vf((e, t) => e / t)),
    qb = {
  kernelName: "RealDiv",
  backendName: "cpu",
  kernelFunc: jb
};

function Kb(e, t, n) {
  var s = e.shape,
      r = s[0],
      a = s[1],
      i = n.data.get(e.dataId),
      o = i.complexTensorInfos.real,
      l = i.complexTensorInfos.imag,
      u = [r, a],
      c = d(u),
      h = w("float32", c),
      p = w("float32", c);

  for (var _e364 = 0; _e364 < r; _e364++) {
    var _s183 = sm({
      inputs: {
        x: o
      },
      backend: n,
      attrs: {
        begin: [_e364, 0],
        size: [1, a]
      }
    }),
        _r134 = sm({
      inputs: {
        x: l
      },
      backend: n,
      attrs: {
        begin: [_e364, 0],
        size: [1, a]
      }
    }),
        _i73 = Gf({
      inputs: {
        real: _s183,
        imag: _r134
      },
      backend: n
    }),
        {
      real: _u24,
      imag: _c24
    } = Xb(_i73, t, n),
        _d15 = Mo(_u24, _c24);

    for (var _t313 = 0; _t313 < a; _t313++) {
      var _n231 = Po(_d15, _t313);

      h[_e364 * a + _t313] = _n231.real, p[_e364 * a + _t313] = _n231.imag;
    }

    n.disposeIntermediateTensorInfo(_s183), n.disposeIntermediateTensorInfo(_r134), n.disposeIntermediateTensorInfo(_i73);
  }

  var f = n.makeTensorInfo(u, "float32", h),
      g = n.makeTensorInfo(u, "float32", p),
      m = Gf({
    inputs: {
      real: f,
      imag: g
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
}

function Xb(e, t, n) {
  var s = d(e.shape),
      r = n.data.get(e.dataId),
      a = n.data.get(r.complexTensorInfos.real.dataId).values,
      i = n.data.get(r.complexTensorInfos.imag.dataId).values;

  if (0 == ((o = s) & o - 1)) {
    var _r135 = Yb(a, i, s, t, n),
        _o55 = [e.shape[0], e.shape[1]];

    if (t) {
      var _e365 = n.makeTensorInfo(_o55, "float32", _r135.real),
          _t314 = n.makeTensorInfo(_o55, "float32", _r135.imag),
          _a103 = n.makeTensorInfo([], "float32", We(s, "float32")),
          _i74 = qf({
        inputs: {
          x: _a103
        },
        backend: n
      }),
          _l39 = qb.kernelFunc({
        inputs: {
          a: _e365,
          b: _a103
        },
        backend: n
      }),
          _u25 = qb.kernelFunc({
        inputs: {
          a: _t314,
          b: _i74
        },
        backend: n
      }),
          _c25 = n.data.get(_l39.dataId).values,
          _h13 = n.data.get(_u25.dataId).values;

      return n.disposeIntermediateTensorInfo(_e365), n.disposeIntermediateTensorInfo(_t314), n.disposeIntermediateTensorInfo(_a103), n.disposeIntermediateTensorInfo(_i74), n.disposeIntermediateTensorInfo(_l39), n.disposeIntermediateTensorInfo(_u25), {
        real: _c25,
        imag: _h13
      };
    }

    return _r135;
  }

  return Lo(function (e, t, n) {
    var s = new Float32Array(2 * t);

    for (var _r136 = 0; _r136 < t; _r136++) {
      var _a104 = 0,
          _i75 = 0;

      for (var _s184 = 0; _s184 < t; _s184++) {
        var _o56 = Vo(_r136 * _s184, t, n),
            _l40 = Po(e, _s184);

        _a104 += _l40.real * _o56.real - _l40.imag * _o56.imag, _i75 += _l40.real * _o56.imag + _l40.imag * _o56.real;
      }

      n && (_a104 /= t, _i75 /= t), Wo(s, _a104, _i75, _r136);
    }

    return s;
  }(Mo(a, i), s, t));
  var o;
}

function Yb(e, t, n, s, r) {
  if (1 === n) return {
    real: e,
    imag: t
  };

  var a = Mo(e, t),
      i = n / 2,
      o = zo(a),
      l = o.real,
      u = o.imag,
      c = [l.length],
      h = r.makeTensorInfo(c, "float32", l),
      d = r.makeTensorInfo(c, "float32", u),
      p = Gf({
    inputs: {
      real: h,
      imag: d
    },
    backend: r
  }),
      f = Bo(a),
      g = f.real,
      m = f.imag,
      b = [g.length],
      x = r.makeTensorInfo(b, "float32", g),
      y = r.makeTensorInfo(b, "float32", m),
      k = Gf({
    inputs: {
      real: x,
      imag: y
    },
    backend: r
  }),
      w = Yb(l, u, i, s, r),
      v = w.real,
      I = w.imag,
      $ = [v.length],
      N = r.makeTensorInfo($, "float32", v),
      C = r.makeTensorInfo($, "float32", I),
      S = Gf({
    inputs: {
      real: N,
      imag: C
    },
    backend: r
  }),
      T = Yb(g, m, i, s, r),
      E = T.real,
      R = T.imag,
      A = [E.length],
      F = r.makeTensorInfo(A, "float32", E),
      D = r.makeTensorInfo(A, "float32", R),
      _ = Gf({
    inputs: {
      real: F,
      imag: D
    },
    backend: r
  }),
      O = Uo(n, s),
      M = [O.real.length],
      L = r.makeTensorInfo(M, "float32", O.real),
      z = r.makeTensorInfo(M, "float32", O.imag),
      B = Gf({
    inputs: {
      real: L,
      imag: z
    },
    backend: r
  }),
      P = Ug({
    inputs: {
      a: B,
      b: _
    },
    backend: r
  }),
      W = ng({
    inputs: {
      a: S,
      b: P
    },
    backend: r
  }),
      U = bm({
    inputs: {
      a: S,
      b: P
    },
    backend: r
  }),
      V = Xf({
    inputs: {
      input: W
    },
    backend: r
  }),
      G = Xf({
    inputs: {
      input: U
    },
    backend: r
  }),
      H = fb({
    inputs: {
      input: W
    },
    backend: r
  }),
      j = fb({
    inputs: {
      input: U
    },
    backend: r
  }),
      q = mb({
    inputs: [V, G],
    backend: r,
    attrs: {
      axis: 0
    }
  }),
      K = mb({
    inputs: [H, j],
    backend: r,
    attrs: {
      axis: 0
    }
  }),
      X = r.data.get(q.dataId).values,
      Y = r.data.get(K.dataId).values;

  return r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(d), r.disposeIntermediateTensorInfo(p), r.disposeIntermediateTensorInfo(x), r.disposeIntermediateTensorInfo(y), r.disposeIntermediateTensorInfo(k), r.disposeIntermediateTensorInfo(N), r.disposeIntermediateTensorInfo(C), r.disposeIntermediateTensorInfo(S), r.disposeIntermediateTensorInfo(F), r.disposeIntermediateTensorInfo(D), r.disposeIntermediateTensorInfo(_), r.disposeIntermediateTensorInfo(L), r.disposeIntermediateTensorInfo(z), r.disposeIntermediateTensorInfo(B), r.disposeIntermediateTensorInfo(P), r.disposeIntermediateTensorInfo(W), r.disposeIntermediateTensorInfo(U), r.disposeIntermediateTensorInfo(V), r.disposeIntermediateTensorInfo(H), r.disposeIntermediateTensorInfo(G), r.disposeIntermediateTensorInfo(j), r.disposeIntermediateTensorInfo(q), r.disposeIntermediateTensorInfo(K), {
    real: X,
    imag: Y
  };
}

var Jb = {
  kernelName: "FFT",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      input: s
    } = t,
        r = d(s.shape),
        a = s.shape[s.shape.length - 1],
        i = Bm({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [r / a, a]
      }
    }),
        o = Kb(i, !1, n),
        l = Bm({
      inputs: {
        x: o
      },
      backend: n,
      attrs: {
        shape: s.shape
      }
    });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), l;
  }
};

function Zb(e) {
  var {
    backend: t,
    attrs: n
  } = e,
      {
    shape: s,
    value: r,
    dtype: a
  } = n,
      i = a || T(r),
      o = v(i, d(s));
  return function (e, t, n) {
    e.fill(t);
  }(o, r), t.makeTensorInfo(s, i, o);
}

var Qb = {
  kernelName: "Fill",
  backendName: "cpu",
  kernelFunc: Zb
},
    ex = {
  kernelName: "FlipLeftRight",
  backendName: "cpu",
  kernelFunc: _ref16 => {
    var {
      inputs: e,
      backend: t
    } = _ref16;
    var {
      image: n
    } = e,
        s = t,
        r = w(n.dtype, d(n.shape)),
        [a, i, o, l] = n.shape,
        u = s.data.get(n.dataId).values;

    for (var _e366 = 0; _e366 < a; _e366++) {
      var _t315 = _e366 * o * i * l;

      for (var _e367 = 0; _e367 < i; _e367++) {
        var _n232 = _e367 * (o * l);

        for (var _e368 = 0; _e368 < o; _e368++) {
          var _s185 = _e368 * l;

          for (var _a105 = 0; _a105 < l; _a105++) {
            var _i76 = Math.round(o - _e368 - 1),
                _c26 = _t315 + _n232 + _s185 + _a105;

            var _h14 = u[_c26];
            _i76 >= 0 && _i76 < o && (_h14 = u[_t315 + _n232 + _i76 * l + _a105]), r[_c26] = _h14;
          }
        }
      }
    }

    return {
      dataId: s.write(r, n.shape, n.dtype),
      shape: n.shape,
      dtype: n.dtype
    };
  }
},
    tx = {
  kernelName: "FloorDiv",
  backendName: "cpu",
  kernelFunc: Qf("FloorDiv", Vf((e, t) => Math.floor(e / t)), null, "int32")
},
    nx = {
  kernelName: "FusedConv2D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      strides: l,
      pad: u,
      dataFormat: c,
      dilations: h,
      dimRoundingMode: d,
      activation: p,
      leakyreluAlpha: f
    } = s;
    var g = xb({
      inputs: {
        x: r,
        filter: a
      },
      backend: n,
      attrs: {
        strides: l,
        pad: u,
        dataFormat: c,
        dilations: h,
        dimRoundingMode: d
      }
    });

    if (i) {
      var _e369 = g;
      g = ng({
        inputs: {
          a: g,
          b: i
        },
        backend: n
      }), n.disposeIntermediateTensorInfo(_e369);
    }

    if (p) {
      var _e370 = g;
      g = zm(n, g, p, o, f), n.disposeIntermediateTensorInfo(_e370);
    }

    return g;
  }
},
    sx = {
  kernelName: "FusedDepthwiseConv2D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      strides: l,
      pad: u,
      dataFormat: c,
      dilations: h,
      dimRoundingMode: d,
      activation: p,
      leakyreluAlpha: f
    } = s;
    var g = Ab({
      inputs: {
        x: r,
        filter: a
      },
      backend: n,
      attrs: {
        strides: l,
        pad: u,
        dataFormat: c,
        dilations: h,
        dimRoundingMode: d
      }
    });

    if (i) {
      var _e371 = g;
      g = ng({
        inputs: {
          a: g,
          b: i
        },
        backend: n
      }), n.disposeIntermediateTensorInfo(_e371);
    }

    if (p) {
      var _e372 = g;
      g = zm(n, g, p, o, f), n.disposeIntermediateTensorInfo(_e372);
    }

    return g;
  }
},
    rx = {
  kernelName: "GatherNd",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      params: s,
      indices: r
    } = t,
        a = d(s.shape),
        i = r.shape,
        o = i[i.length - 1],
        [l, u, c, h] = Nn(s, r);
    if (0 === u) return n.makeTensorInfo(l, s.dtype, []);
    var p = vg(n.data.get(r.dataId).values, n.bufferSync(s), s.dtype, u, o, c, h, s.shape, a);
    return n.makeTensorInfo(l, s.dtype, p.values);
  }
},
    ax = {
  kernelName: "GatherV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      indices: a
    } = t,
        {
      axis: i,
      batchDims: o
    } = s;
    zf([r, a], "gatherV2");
    var l = o;
    null == o && (l = 0);
    var u = d(a.shape),
        c = el(r, a, y(i, r.shape)[0], l),
        h = Bm({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [c.batchSize, c.outerSize, c.dimSize, c.sliceSize]
      }
    }),
        p = Bm({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: [c.batchSize, u / c.batchSize]
      }
    }),
        f = [c.batchSize, c.outerSize, u / c.batchSize, c.sliceSize],
        g = n.bufferSync(p),
        m = Ig(n.bufferSync(h), g, f);
    return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p), n.makeTensorInfo(c.outputShape, m.dtype, m.values);
  }
},
    ix = {
  kernelName: "IFFT",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      input: s
    } = t,
        r = d(s.shape),
        a = s.shape[s.shape.length - 1],
        i = Bm({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [r / a, a]
      }
    }),
        o = Kb(i, !0, n),
        l = Bm({
      inputs: {
        x: o
      },
      backend: n,
      attrs: {
        shape: s.shape
      }
    });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), l;
  }
},
    ox = {
  kernelName: "IsFinite",
  backendName: "cpu",
  kernelFunc: og("IsFinite", e => Number.isFinite(e) ? 1 : 0, "bool")
},
    lx = {
  kernelName: "IsInf",
  backendName: "cpu",
  kernelFunc: og("IsInf", e => Infinity === Math.abs(e) ? 1 : 0, "bool")
},
    ux = {
  kernelName: "IsNan",
  backendName: "cpu",
  kernelFunc: og("IsNan", e => Number.isNaN(e) ? 1 : 0, "bool")
},
    cx = {
  kernelName: "LinSpace",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      backend: t,
      attrs: n
    } = e,
        {
      start: s,
      stop: r,
      num: a
    } = n,
        i = Fg(s, r, a);
    return t.makeTensorInfo([i.length], "float32", i);
  }
},
    hx = {
  kernelName: "Log1p",
  backendName: "cpu",
  kernelFunc: og("Log1p", e => Math.log1p(e))
},
    dx = {
  kernelName: "LogicalAnd",
  backendName: "cpu",
  kernelFunc: Qf("LogicalAnd", Vf((e, t) => e && t), null, "bool")
},
    px = {
  kernelName: "LogicalNot",
  backendName: "cpu",
  kernelFunc: og("LogicalNot", e => e ? 0 : 1, "bool")
},
    fx = {
  kernelName: "LogicalOr",
  backendName: "cpu",
  kernelFunc: Qf("LogicalOr", Vf((e, t) => e || t), null, "bool")
},
    gx = {
  kernelName: "LRN",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      depthRadius: a,
      bias: i,
      alpha: o,
      beta: l
    } = s;
    zf(r, "LRN");
    var u = r.shape[3],
        c = u - 1,
        h = n.data.get(r.dataId).values,
        p = d(r.shape),
        f = new Float32Array(p);

    function g(e) {
      var t = e % u;
      var n = e - t + Math.max(0, t - a);
      var s = e - t + Math.min(t + a, c);
      var r = 0;

      for (; n <= s; n++) {
        var _e373 = h[n];
        r += _e373 * _e373;
      }

      return r;
    }

    for (var _e374 = 0; _e374 < p; _e374++) {
      var _t316 = g(_e374),
          _n233 = h[_e374] * Math.pow(i + o * _t316, -l);

      f[_e374] = _n233;
    }

    return n.makeTensorInfo(r.shape, r.dtype, f);
  }
},
    mx = {
  kernelName: "LRNGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      y: a,
      dy: i
    } = t,
        {
      depthRadius: o,
      bias: l,
      alpha: u,
      beta: c
    } = s;
    zf(i, "LRNGrad");
    var h = d(i.shape),
        p = i.shape[3],
        f = n.data.get(i.dataId).values,
        g = n.data.get(r.dataId).values,
        m = n.data.get(a.dataId).values,
        b = new Float32Array(h),
        x = h;

    for (var _e375 = 0; _e375 < x; _e375++) {
      var _t317 = _e375 % p,
          _n234 = _e375 - _t317 + Math.max(0, _t317 - o),
          _s186 = _e375 - _t317 + Math.min(p, _t317 + o + 1);

      var _r137 = 0;

      for (var _e376 = _n234; _e376 < _s186; _e376++) {
        _r137 += Math.pow(g[_e376], 2);
      }

      _r137 = u * _r137 + l;

      for (var _t318 = _n234; _t318 < _s186; _t318++) {
        var _n235 = -2 * u * c * g[_t318] * m[_e375] / _r137;

        _e375 === _t318 && (_n235 += Math.pow(_r137, -c)), _n235 *= f[_e375], b[_t318] += _n235;
      }
    }

    return n.makeTensorInfo(i.shape, r.dtype, b);
  }
};

function bx(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    reductionIndices: a,
    keepDims: i
  } = s,
      o = n;
  var l = r.shape;
  var u = l.length,
      c = y(a, l);
  var h = c;
  var p = Jr(h, u);
  var f = o.data.get(r.dataId).values;

  if (null != p) {
    var _e377 = new Array(u);

    for (var _t319 = 0; _t319 < _e377.length; _t319++) {
      _e377[_t319] = l[p[_t319]];
    }

    f = Kg(f, l, r.dtype, p, _e377), h = Qr(h.length, u), l = _e377;
  }

  zf(r, "max"), Yr("max", h, u);
  var [g, m] = Kr(l, h),
      b = Og(f, d(m), g, r.dtype),
      x = o.write(b, g, r.dtype);
  var k = g;
  return i && (k = Xr(g, c)), {
    dataId: x,
    shape: k,
    dtype: r.dtype
  };
}

var xx = {
  kernelName: "Max",
  backendName: "cpu",
  kernelFunc: bx
},
    yx = {
  kernelName: "MaxPool",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t;
    zf(r, "maxPool");
    var {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: u
    } = s;
    l(Ss(i, 1), () => "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'"));
    var c = bs(r.shape, a, i, 1, o, u);
    var h;
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) h = qf({
      inputs: {
        x: r
      },
      backend: n
    });else {
      var _e378 = n.data.get(r.dataId).values,
          _t320 = A(r.shape),
          _s187 = nb(_e378, 0, r.dtype, _t320, c, "max");

      h = n.makeTensorInfo(c.outShape, r.dtype, _s187.values);
    }
    return h;
  }
},
    kx = {
  kernelName: "MaxPool3D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: l,
      dataFormat: u
    } = s;
    zf(r, "maxPool3d");
    var c = xs(r.shape, a, i, 1, o, l, u),
        h = rb(n.data.get(r.dataId).values, 0, r.dtype, A(r.shape), c, "max");
    return n.makeTensorInfo(h.shape, "float32", h.values);
  }
},
    wx = {
  kernelName: "MaxPool3DGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        {
      filterSize: i,
      strides: o,
      pad: l,
      dimRoundingMode: u
    } = s;
    zf([r, a], "maxPool3DGrad");

    var c = xs(a.shape, i, o, 1, l, u),
        h = function (e, t) {
      var n = dn(t.outShape, "int32"),
          s = t.strideDepth,
          r = t.strideHeight,
          a = t.strideWidth,
          i = t.dilationDepth,
          o = t.dilationHeight,
          l = t.dilationWidth,
          u = t.effectiveFilterDepth,
          c = t.effectiveFilterHeight,
          h = t.effectiveFilterWidth,
          d = t.padInfo.front,
          p = t.padInfo.top,
          f = t.padInfo.left;

      for (var _g16 = 0; _g16 < t.batchSize; ++_g16) {
        for (var _m11 = 0; _m11 < t.inChannels; ++_m11) {
          for (var _b11 = 0; _b11 < t.outDepth; ++_b11) {
            var _x54 = _b11 * s - d;

            var _y9 = _x54;

            for (; _y9 < 0;) {
              _y9 += i;
            }

            var _k7 = Math.min(t.inDepth, u + _x54);

            for (var _s188 = 0; _s188 < t.outHeight; ++_s188) {
              var _u26 = _s188 * r - p;

              var _d16 = _u26;

              for (; _d16 < 0;) {
                _d16 += o;
              }

              var _w7 = Math.min(t.inHeight, c + _u26);

              for (var _r138 = 0; _r138 < t.outWidth; ++_r138) {
                var _p12 = _r138 * a - f;

                var _v5 = _p12;

                for (; _v5 < 0;) {
                  _v5 += l;
                }

                var _I4 = Math.min(t.inWidth, h + _p12);

                var _$2 = Number.NEGATIVE_INFINITY,
                    _N4 = -1;

                for (var _t321 = _y9; _t321 < _k7; _t321 += i) {
                  var _n236 = _t321 - _x54;

                  for (var _s189 = _d16; _s189 < _w7; _s189 += o) {
                    var _r139 = _s189 - _u26;

                    for (var _a106 = _v5; _a106 < _I4; _a106 += l) {
                      var _i77 = _a106 - _p12,
                          _o57 = e.get(_g16, _t321, _s189, _a106, _m11);

                      _o57 >= _$2 && (_$2 = _o57, _N4 = _n236 * c * h + _r139 * c + _i77);
                    }
                  }
                }

                n.set(_N4, _g16, _b11, _s188, _r138, _m11);
              }
            }
          }
        }
      }

      return n;
    }(n.bufferSync(a), c),
        d = c.strideDepth,
        p = c.strideHeight,
        f = c.strideWidth,
        g = c.dilationDepth,
        m = c.dilationHeight,
        b = c.dilationWidth,
        x = c.effectiveFilterDepth,
        y = c.effectiveFilterHeight,
        k = c.effectiveFilterWidth,
        w = x - 1 - c.padInfo.front,
        v = k - 1 - c.padInfo.left,
        I = y - 1 - c.padInfo.top,
        $ = dn(a.shape, "float32"),
        N = n.bufferSync(r);

    for (var _e379 = 0; _e379 < c.batchSize; ++_e379) {
      for (var _t322 = 0; _t322 < c.inChannels; ++_t322) {
        for (var _n237 = 0; _n237 < c.inDepth; ++_n237) {
          for (var _s190 = 0; _s190 < c.inHeight; ++_s190) {
            for (var _r140 = 0; _r140 < c.inWidth; ++_r140) {
              var _a107 = _n237 - w,
                  _i78 = _s190 - I,
                  _o58 = _r140 - v;

              var _l41 = 0;

              for (var _n238 = 0; _n238 < x; _n238 += g) {
                var _s191 = (_a107 + _n238) / d;

                if (!(_s191 < 0 || _s191 >= c.outDepth || Math.floor(_s191) !== _s191)) for (var _r141 = 0; _r141 < y; _r141 += m) {
                  var _a108 = (_i78 + _r141) / p;

                  if (!(_a108 < 0 || _a108 >= c.outHeight || Math.floor(_a108) !== _a108)) for (var _i79 = 0; _i79 < k; _i79 += b) {
                    var _u27 = (_o58 + _i79) / f;

                    if (_u27 < 0 || _u27 >= c.outWidth || Math.floor(_u27) !== _u27) continue;

                    var _d17 = x * y * k - 1 - h.get(_e379, _s191, _a108, _u27, _t322) === _n238 * y * k + _r141 * k + _i79 ? 1 : 0;

                    0 !== _d17 && (_l41 += N.get(_e379, _s191, _a108, _u27, _t322) * _d17);
                  }
                }
              }

              $.set(_l41, _e379, _n237, _s190, _r140, _t322);
            }
          }
        }
      }
    }

    return n.makeTensorInfo($.shape, $.dtype, $.values);
  }
},
    vx = {
  kernelName: "MaxPoolGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a,
      output: i
    } = t,
        o = a;
    zf([a, i], "maxPoolGrad");
    var {
      filterSize: l,
      strides: u,
      pad: c,
      dimRoundingMode: h
    } = s,
        d = bs(o.shape, l, u, 1, c, h),
        p = n.data.get(o.dataId).values,
        f = dn(d.outShape, o.dtype, sb(p, o.shape, o.dtype, d).values),
        g = d.strideHeight,
        m = d.strideWidth,
        b = d.dilationHeight,
        x = d.dilationWidth,
        y = d.effectiveFilterHeight,
        k = d.effectiveFilterWidth,
        w = k - 1 - d.padInfo.left,
        v = y - 1 - d.padInfo.top,
        I = dn(o.shape, "float32"),
        $ = n.data.get(r.dataId).values,
        N = dn(r.shape, "float32", $);

    for (var _e380 = 0; _e380 < d.batchSize; ++_e380) {
      for (var _t323 = 0; _t323 < d.inChannels; ++_t323) {
        for (var _n239 = 0; _n239 < d.inHeight; ++_n239) {
          for (var _s192 = 0; _s192 < d.inWidth; ++_s192) {
            var _r142 = _n239 - v,
                _a109 = _s192 - w;

            var _i80 = 0;

            for (var _n240 = 0; _n240 < y; _n240 += b) {
              var _s193 = (_r142 + _n240) / g;

              if (!(_s193 < 0 || _s193 >= d.outHeight || Math.floor(_s193) !== _s193)) for (var _r143 = 0; _r143 < k; _r143 += x) {
                var _o59 = (_a109 + _r143) / m;

                if (_o59 < 0 || _o59 >= d.outWidth || Math.floor(_o59) !== _o59) continue;

                var _l42 = y * k - 1 - f.get(_e380, _s193, _o59, _t323) === _n240 * k + _r143 ? 1 : 0;

                0 !== _l42 && (_i80 += N.get(_e380, _s193, _o59, _t323) * _l42);
              }
            }

            I.set(_i80, _e380, _n239, _s192, _t323);
          }
        }
      }
    }

    return n.makeTensorInfo(I.shape, I.dtype, I.values);
  }
},
    Ix = {
  kernelName: "MaxPoolWithArgmax",
  backendName: "cpu",
  kernelFunc: _ref17 => {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref17;
    var {
      x: s
    } = e,
        {
      filterSize: r,
      strides: a,
      pad: i,
      includeBatchInIndex: o
    } = t,
        l = n;
    zf(s, "MaxPoolWithArgmax");

    var u = l.data.get(s.dataId).values,
        c = bs(s.shape, r, a, [1, 1], i),
        [h, d] = function (e, t, n, s, r) {
      var a = nb(e, 0, n, A(t), r, "max"),
          i = sb(e, t, n, r, !0, s);
      return [a.values, i.values];
    }(u, s.shape, s.dtype, o, c),
        p = l.write(h, c.outShape, s.dtype),
        f = l.write(d, c.outShape, s.dtype);

    return [{
      dataId: p,
      shape: c.outShape,
      dtype: s.dtype
    }, {
      dataId: f,
      shape: c.outShape,
      dtype: "int32"
    }];
  }
},
    $x = {
  kernelName: "Mean",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s,
        o = y(a, r.shape),
        l = d(Kr(r.shape, o)[1]),
        u = [],
        c = n.makeTensorInfo([], "float32", new Float32Array([l]));
    u.push(c);
    var h = Jf({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        dtype: "float32"
      }
    });
    u.push(h);
    var p = jb({
      inputs: {
        a: h,
        b: c
      },
      backend: n
    });
    u.push(p);
    var f = Bb({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        axis: a,
        keepDims: i
      }
    });
    return u.forEach(e => n.disposeIntermediateTensorInfo(e)), f;
  }
},
    Nx = {
  kernelName: "Min",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s;
    zf(r, "min");
    var o = y(a, r.shape);
    var l = o;
    var u = Jr(l, r.shape.length);
    var c = r;
    null != u && (c = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), l = Qr(l.length, r.shape.length)), Yr("min", l, c.shape.length);
    var [h, p] = Kr(c.shape, l),
        f = d(p),
        g = O(d(h), c.dtype),
        m = n.data.get(c.dataId).values;

    for (var _e381 = 0; _e381 < g.length; ++_e381) {
      var _t324 = _e381 * f;

      var _n241 = m[_t324];

      for (var _e382 = 0; _e382 < f; ++_e382) {
        var _s194 = m[_t324 + _e382];
        (Number.isNaN(_s194) || _s194 < _n241) && (_n241 = _s194);
      }

      g[_e381] = _n241;
    }

    null != u && n.disposeIntermediateTensorInfo(c);
    var b = n.makeTensorInfo(h, c.dtype, g);

    if (i) {
      var _e383 = Bm({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: Xr(h, o)
        }
      });

      return n.disposeIntermediateTensorInfo(b), _e383;
    }

    return b;
  }
},
    Cx = {
  kernelName: "MirrorPad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      paddings: a,
      mode: i
    } = s;
    zf(r, "mirrorPad");
    var o = a.map((e, t) => e[0] + r.shape[t] + e[1]),
        l = a.map(e => e[0]),
        u = a.map((e, t) => e[0] + r.shape[t]),
        c = "reflect" === i ? 0 : 1,
        h = n.data.get(r.dataId).values,
        p = r.shape.length,
        f = A(r.shape),
        g = d(o),
        m = o.length,
        b = A(o),
        x = w(r.dtype, g);

    for (var _e384 = 0; _e384 < g; _e384++) {
      var _t325 = B(_e384, m, b);

      for (var _e385 = 0; _e385 < m; _e385++) {
        _t325[_e385] < l[_e385] ? _t325[_e385] = 2 * l[_e385] - _t325[_e385] - c : _t325[_e385] >= u[_e385] && (_t325[_e385] = 2 * (u[_e385] - 1) - _t325[_e385] + c);
      }

      _t325 = _t325.map((e, t) => e - l[t]);

      var _n242 = z(_t325, p, f);

      x[_e384] = h[_n242];
    }

    return {
      dataId: n.write(x, o, r.dtype),
      shape: o,
      dtype: r.dtype
    };
  }
},
    Sx = {
  kernelName: "Mod",
  backendName: "cpu",
  kernelFunc: Qf("Mod", Vf((e, t) => {
    var n = e % t;
    return e < 0 && t < 0 || e >= 0 && t >= 0 ? n : (n + t) % t;
  }))
};

function Tx(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    logits: r
  } = t,
      {
    dim: a
  } = s,
      i = r.shape.length;
  var o = a;
  if (-1 === o && (o = i - 1), o !== i - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(i, " and dim was ").concat(o));
  var l = y([o], r.shape),
      u = bx({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      reductionIndices: l,
      keepDims: !1
    }
  }),
      c = Xr(u.shape, l),
      h = Bm({
    inputs: {
      x: u
    },
    backend: n,
    attrs: {
      shape: c
    }
  }),
      d = bm({
    inputs: {
      a: r,
      b: h
    },
    backend: n
  }),
      p = mg({
    inputs: {
      x: d
    },
    backend: n
  }),
      f = Bb({
    inputs: {
      x: p
    },
    backend: n,
    attrs: {
      axis: l,
      keepDims: !1
    }
  }),
      g = Bm({
    inputs: {
      x: f
    },
    backend: n,
    attrs: {
      shape: c
    }
  }),
      m = jb({
    inputs: {
      a: p,
      b: g
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
}

var Ex = {
  kernelName: "Softmax",
  backendName: "cpu",
  kernelFunc: Tx
},
    Rx = {
  kernelName: "Multinomial",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      logits: r
    } = t,
        {
      numSamples: a,
      seed: i,
      normalized: o
    } = s;
    zf(r, "multinomial");
    var l = o ? r : Tx({
      inputs: {
        logits: r
      },
      backend: n,
      attrs: {
        dim: -1
      }
    }),
        u = l.shape[0],
        c = l.shape[1],
        h = n.data.get(l.dataId).values,
        p = [u, a],
        f = O(d(p), "int32");

    for (var _e386 = 0; _e386 < u; ++_e386) {
      var _t326 = _e386 * c,
          _n243 = new Float32Array(c - 1);

      _n243[0] = h[_t326];

      for (var _e387 = 1; _e387 < _n243.length; ++_e387) {
        _n243[_e387] = _n243[_e387 - 1] + h[_t326 + _e387];
      }

      var _s195 = _a.alea(i.toString()),
          _r144 = _e386 * a;

      for (var _e388 = 0; _e388 < a; ++_e388) {
        var _t327 = _s195();

        f[_r144 + _e388] = _n243.length;

        for (var _s196 = 0; _s196 < _n243.length; _s196++) {
          if (_t327 < _n243[_s196]) {
            f[_r144 + _e388] = _s196;
            break;
          }
        }
      }
    }

    return o || n.disposeIntermediateTensorInfo(l), n.makeTensorInfo(p, "int32", f);
  }
},
    Ax = ji,
    Fx = {
  kernelName: "NonMaxSuppressionV3",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l
    } = s;
    zf(r, "NonMaxSuppression");
    var u = n.data.get(r.dataId).values,
        c = n.data.get(a.dataId).values,
        {
      selectedIndices: h
    } = Ax(u, c, i, o, l);
    return n.makeTensorInfo([h.length], "int32", new Int32Array(h));
  }
},
    Dx = qi,
    _x = {
  kernelName: "NonMaxSuppressionV4",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l,
      padToMaxOutputSize: u
    } = s;
    zf(r, "NonMaxSuppressionPadded");
    var c = n.data.get(r.dataId).values,
        h = n.data.get(a.dataId).values,
        {
      selectedIndices: d,
      validOutputs: p
    } = Dx(c, h, i, o, l, u);
    return [n.makeTensorInfo([d.length], "int32", new Int32Array(d)), n.makeTensorInfo([], "int32", new Int32Array([p]))];
  }
},
    Ox = Ki,
    Mx = {
  kernelName: "NonMaxSuppressionV5",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l,
      softNmsSigma: u
    } = s;
    zf(r, "NonMaxSuppressionWithScore");
    var c = n.data.get(r.dataId).values,
        h = n.data.get(a.dataId).values,
        d = i,
        p = o,
        f = l,
        g = u,
        {
      selectedIndices: m,
      selectedScores: b
    } = Ox(c, h, d, p, f, g);
    return [n.makeTensorInfo([m.length], "int32", new Int32Array(m)), n.makeTensorInfo([b.length], "float32", new Float32Array(b))];
  }
},
    Lx = {
  kernelName: "OneHot",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      indices: r
    } = t,
        {
      depth: a,
      onValue: i,
      offValue: o
    } = s;
    zf(r, "oneHot");
    var l = d(r.shape),
        u = new Float32Array(l * a);
    u.fill(o);
    var c = n.data.get(r.dataId).values;

    for (var _e389 = 0; _e389 < l; ++_e389) {
      c[_e389] >= 0 && c[_e389] < a && (u[_e389 * a + c[_e389]] = i);
    }

    return n.makeTensorInfo([...r.shape, a], "int32", u);
  }
};

function zx(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    x: s
  } = t;
  if ("string" === s.dtype) throw new Error("zerosLike is not supported for string tensors");

  if ("complex64" === s.dtype) {
    var _e390 = Xf({
      inputs: {
        input: s
      },
      backend: n
    }),
        _t328 = zx({
      inputs: {
        x: _e390
      },
      backend: n
    }),
        _r145 = fb({
      inputs: {
        input: s
      },
      backend: n
    }),
        _a110 = zx({
      inputs: {
        x: _r145
      },
      backend: n
    }),
        _i81 = Gf({
      inputs: {
        real: _t328,
        imag: _a110
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_e390), n.disposeIntermediateTensorInfo(_t328), n.disposeIntermediateTensorInfo(_r145), n.disposeIntermediateTensorInfo(_a110), _i81;
  }

  return Zb({
    backend: n,
    attrs: {
      shape: s.shape,
      value: 0,
      dtype: s.dtype
    }
  });
}

var Bx = {
  kernelName: "ZerosLike",
  backendName: "cpu",
  kernelFunc: zx
},
    Px = {
  kernelName: "OnesLike",
  backendName: "cpu",
  kernelFunc: function e(t) {
    var {
      inputs: n,
      backend: s
    } = t,
        {
      x: r
    } = n;
    if ("string" === r.dtype) throw new Error("onesLike is not supported for string tensors");

    if ("complex64" === r.dtype) {
      var _t329 = Xf({
        inputs: {
          input: r
        },
        backend: s
      }),
          _n244 = e({
        inputs: {
          x: _t329
        },
        backend: s
      }),
          _a111 = fb({
        inputs: {
          input: r
        },
        backend: s
      }),
          _i82 = zx({
        inputs: {
          x: _a111
        },
        backend: s
      }),
          _o60 = Gf({
        inputs: {
          real: _n244,
          imag: _i82
        },
        backend: s
      });

      return s.disposeIntermediateTensorInfo(_t329), s.disposeIntermediateTensorInfo(_n244), s.disposeIntermediateTensorInfo(_a111), s.disposeIntermediateTensorInfo(_i82), _o60;
    }

    return Zb({
      backend: s,
      attrs: {
        shape: r.shape,
        value: 1,
        dtype: r.dtype
      }
    });
  }
};

function Wx(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    axis: r
  } = s;
  if (1 === t.length) return Gb({
    inputs: {
      input: t[0]
    },
    backend: n,
    attrs: {
      dim: r
    }
  });
  var a = t[0].shape,
      i = t[0].dtype;
  t.forEach(e => {
    u(a, e.shape, "All tensors passed to stack must have matching shapes"), l(i === e.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  var o = [],
      c = mb({
    inputs: t.map(e => {
      var t = Gb({
        inputs: {
          input: e
        },
        backend: n,
        attrs: {
          dim: r
        }
      });
      return o.push(t), t;
    }),
    backend: n,
    attrs: {
      axis: r
    }
  });
  return o.forEach(e => n.disposeIntermediateTensorInfo(e)), c;
}

var Ux = {
  kernelName: "Pack",
  backendName: "cpu",
  kernelFunc: Wx
},
    Vx = {
  kernelName: "PadV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      paddings: a,
      constantValue: i
    } = s;
    zf(r, "pad");
    var o = a.map((e, t) => e[0] + r.shape[t] + e[1]),
        l = a.map(e => e[0]),
        u = n.data.get(r.dataId).values,
        c = d(r.shape),
        h = r.shape.length,
        p = A(r.shape),
        f = d(o),
        g = o.length,
        m = A(o),
        b = w(r.dtype, f);
    0 !== i && b.fill(i);

    for (var _e391 = 0; _e391 < c; _e391++) {
      b[z(B(_e391, h, p).map((e, t) => e + l[t]), g, m)] = u[_e391];
    }

    return {
      dataId: n.write(b, o, r.dtype),
      shape: o,
      dtype: r.dtype
    };
  }
},
    Gx = {
  kernelName: "Pow",
  backendName: "cpu",
  kernelFunc: Qf("Pow", Vf((e, t) => Math.pow(e, t)))
},
    Hx = {
  kernelName: "Range",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      backend: t,
      attrs: n
    } = e,
        {
      start: s,
      stop: r,
      dtype: a,
      step: i
    } = n,
        o = Qg(s, r, i, a);
    return t.makeTensorInfo([o.length], a, o);
  }
},
    jx = {
  kernelName: "Reciprocal",
  backendName: "cpu",
  kernelFunc: og("Reciprocal", e => 1 / e)
},
    qx = {
  kernelName: "ResizeBilinear",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r
    } = t,
        {
      alignCorners: a,
      halfPixelCenters: i,
      size: o
    } = s;
    zf(r, "resizeBilinear");
    var l = A(r.shape),
        [u, c] = o,
        [h, p, f, g] = r.shape,
        m = n.data.get(r.dataId).values,
        b = new Float32Array(d([h, u, c, g])),
        x = [a && u > 1 ? p - 1 : p, a && c > 1 ? f - 1 : f],
        y = [a && u > 1 ? u - 1 : u, a && c > 1 ? c - 1 : c];
    var k = 0;
    var w = x[0] / y[0],
        v = x[1] / y[1];

    for (var _e392 = 0; _e392 < h; _e392++) {
      for (var _t330 = 0; _t330 < u; _t330++) {
        var _n245 = void 0;

        _n245 = i ? w * (_t330 + .5) - .5 : w * _t330;

        var _s197 = Math.max(0, Math.floor(_n245)),
            _r146 = _n245 - _s197,
            _a112 = Math.min(p - 1, Math.ceil(_n245)),
            _o61 = _e392 * l[0] + _s197 * l[1],
            _u28 = _e392 * l[0] + _a112 * l[1];

        for (var _e393 = 0; _e393 < c; _e393++) {
          var _t331 = void 0;

          _t331 = i ? v * (_e393 + .5) - .5 : v * _e393;

          var _n246 = Math.max(0, Math.floor(_t331)),
              _s198 = _t331 - _n246,
              _a113 = Math.min(f - 1, Math.ceil(_t331)),
              _c27 = _o61 + _n246 * l[2],
              _h15 = _u28 + _n246 * l[2],
              _d18 = _o61 + _a113 * l[2],
              _p13 = _u28 + _a113 * l[2];

          for (var _e394 = 0; _e394 < g; _e394++) {
            var _t332 = m[_c27 + _e394],
                _n247 = m[_h15 + _e394],
                _a114 = _t332 + (m[_d18 + _e394] - _t332) * _s198;

            b[k++] = _a114 + (_n247 + (m[_p13 + _e394] - _n247) * _s198 - _a114) * _r146;
          }
        }
      }
    }

    return n.makeTensorInfo([h, u, c, g], "float32", b);
  }
},
    Kx = {
  kernelName: "ResizeBilinearGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r,
      dy: a
    } = t,
        {
      alignCorners: i
    } = s;
    zf([a, r], "resizeBilinearGrad");
    var o = A(r.shape),
        [l, u, c, h] = r.shape,
        [, d, p] = a.shape,
        f = new Float32Array(l * u * c * h),
        g = [i && d > 1 ? u - 1 : u, i && p > 1 ? c - 1 : c],
        m = [i && d > 1 ? d - 1 : d, i && p > 1 ? p - 1 : p],
        b = g[0] / m[0],
        x = g[1] / m[1],
        y = n.data.get(a.dataId).values;
    var k = 0;

    for (var _e395 = 0; _e395 < l; _e395++) {
      var _t333 = _e395 * o[0];

      for (var _e396 = 0; _e396 < d; _e396++) {
        var _n248 = _e396 * b,
            _s199 = Math.floor(_n248),
            _r147 = Math.min(Math.ceil(_n248), u - 1),
            _a115 = _t333 + _s199 * o[1],
            _i83 = _t333 + _r147 * o[1],
            _l43 = _n248 - _s199,
            _d19 = 1 - _l43;

        for (var _e397 = 0; _e397 < p; _e397++) {
          var _t334 = _e397 * x,
              _n249 = Math.floor(_t334),
              _s200 = Math.min(Math.ceil(_t334), c - 1),
              _r148 = _t334 - _n249,
              _u29 = 1 - _r148,
              _p14 = _a115 + _n249 * o[2],
              _g17 = _a115 + _s200 * o[2],
              _m12 = _i83 + _n249 * o[2],
              _b12 = _i83 + _s200 * o[2],
              _w8 = _d19 * _u29,
              _v6 = _d19 * _r148,
              _I5 = _l43 * _u29,
              _$3 = _l43 * _r148;

          for (var _e398 = 0; _e398 < h; _e398++) {
            var _t335 = y[k++];
            f[_p14 + _e398] += _t335 * _w8, f[_g17 + _e398] += _t335 * _v6, f[_m12 + _e398] += _t335 * _I5, f[_b12 + _e398] += _t335 * _$3;
          }
        }
      }
    }

    return n.makeTensorInfo([l, c, u, h], "float32", f);
  }
},
    Xx = {
  kernelName: "ResizeNearestNeighbor",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r
    } = t,
        {
      alignCorners: a,
      halfPixelCenters: i,
      size: o
    } = s;
    zf(r, "resizeNearestNeighbor");
    var l = A(r.shape),
        [u, c] = o,
        [h, d, p, f] = r.shape,
        g = n.data.get(r.dataId).values,
        m = new Float32Array(h * u * c * f),
        b = [a && u > 1 ? d - 1 : d, a && c > 1 ? p - 1 : p],
        x = [a && u > 1 ? u - 1 : u, a && c > 1 ? c - 1 : c],
        y = b[0] / x[0],
        k = b[1] / x[1];
    var w = 0;

    for (var _e399 = 0; _e399 < h; _e399++) {
      var _t336 = _e399 * l[0];

      for (var _e400 = 0; _e400 < u; _e400++) {
        var _n250 = i ? y * (_e400 + .5) : y * _e400;

        var _s201 = Math.min(d - 1, a ? Math.round(_n250) : Math.floor(_n250));

        i && (_s201 = Math.max(0, _s201));

        var _r149 = _t336 + _s201 * l[1];

        for (var _e401 = 0; _e401 < c; _e401++) {
          var _t337 = i ? k * (_e401 + .5) : k * _e401;

          var _n251 = Math.min(p - 1, a ? Math.round(_t337) : Math.floor(_t337));

          i && (_n251 = Math.max(0, _n251));

          var _s202 = _r149 + _n251 * l[2];

          for (var _e402 = 0; _e402 < f; _e402++) {
            m[w++] = g[_s202 + _e402];
          }
        }
      }
    }

    return n.makeTensorInfo([h, u, c, f], r.dtype, m);
  }
},
    Yx = {
  kernelName: "ResizeNearestNeighborGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r,
      dy: a
    } = t,
        {
      alignCorners: i
    } = s;
    zf([a, r], "resizeNearestNeighborGrad");
    var o = A(r.shape),
        l = A(a.shape),
        [u, c, h, d] = r.shape,
        [, p, f] = a.shape,
        g = new Float32Array(u * c * h * d),
        m = n.data.get(a.dataId).values,
        b = [i && p > 1 ? c - 1 : c, i && f > 1 ? h - 1 : h],
        x = [i && p > 1 ? p - 1 : p, i && f > 1 ? f - 1 : f],
        y = b[0] / x[0],
        k = b[1] / x[1],
        w = 1 / y,
        v = 1 / k,
        I = 2 * Math.ceil(w) + 2,
        $ = 2 * Math.ceil(v) + 2;

    for (var _e403 = 0; _e403 < u; _e403++) {
      var _t338 = _e403 * o[0];

      for (var _e404 = 0; _e404 < c; _e404++) {
        var _n252 = _t338 + _e404 * o[1],
            _s203 = Math.floor(_e404 * w),
            _r150 = Math.floor(_s203 - I / 2);

        for (var _s204 = 0; _s204 < h; _s204++) {
          var _a116 = _n252 + _s204 * o[2],
              _u30 = Math.floor(_s204 * v),
              _b13 = Math.floor(_u30 - $ / 2);

          for (var _n253 = 0; _n253 < d; _n253++) {
            var _o62 = 0;

            for (var _a117 = 0; _a117 < I; _a117++) {
              var _u31 = _a117 + _r150;

              if (_u31 < 0 || _u31 >= p) continue;

              var _d20 = _t338 + _u31 * l[1],
                  _g18 = _u31 * y;

              if (_e404 === Math.min(c - 1, i ? Math.round(_g18) : Math.floor(_g18))) for (var _e405 = 0; _e405 < $; _e405++) {
                var _t339 = _e405 + _b13;

                if (_t339 < 0 || _t339 >= f) continue;

                var _r151 = _d20 + _t339 * l[2],
                    _a118 = _t339 * k;

                _s204 === Math.min(h - 1, i ? Math.round(_a118) : Math.floor(_a118)) && (_o62 += m[_r151 + _n253]);
              }
            }

            g[_a116 + _n253] = _o62;
          }
        }
      }
    }

    return n.makeTensorInfo(r.shape, r.dtype, g);
  }
},
    Jx = {
  kernelName: "Reverse",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      dims: a
    } = s;
    zf(r, "reverse");
    var i = r.shape.length,
        o = y(a, r.shape);
    if (0 === i) return qf({
      inputs: {
        x: r
      },
      backend: n
    });
    var l = new et(r.shape, r.dtype),
        u = n.bufferSync(r);

    var _loop31 = function _loop31(_e406) {
      var t = l.indexToLoc(_e406),
          n = t.slice();
      o.forEach(e => n[e] = r.shape[e] - 1 - n[e]), l.set(u.get(...n), ...t);
    };

    for (var _e406 = 0; _e406 < l.size; _e406++) {
      _loop31(_e406);
    }

    return n.makeTensorInfo(l.shape, l.dtype, l.values);
  }
},
    Zx = {
  kernelName: "RotateWithOffset",
  backendName: "cpu",
  kernelFunc: _ref18 => {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref18;
    var {
      image: s
    } = e,
        {
      radians: r,
      fillValue: a,
      center: i
    } = t,
        o = n,
        l = w(s.dtype, d(s.shape)),
        [u, c, h, p] = s.shape,
        [f, g] = Eo(i, c, h),
        m = Math.sin(r),
        b = Math.cos(r),
        x = o.data.get(s.dataId).values;

    for (var _e407 = 0; _e407 < u; _e407++) {
      var _t340 = _e407 * h * c * p;

      for (var _e408 = 0; _e408 < c; _e408++) {
        var _n254 = _e408 * (h * p);

        for (var _s205 = 0; _s205 < h; _s205++) {
          var _r152 = _s205 * p;

          for (var _i84 = 0; _i84 < p; _i84++) {
            var _o63 = [u, _e408, _s205, _i84],
                _d21 = _o63[2],
                _y10 = _o63[1];

            var _k8 = (_d21 - f) * b - (_y10 - g) * m,
                _w9 = (_d21 - f) * m + (_y10 - g) * b;

            _k8 = Math.round(_k8 + f), _w9 = Math.round(_w9 + g);
            var _v7 = a;
            "number" != typeof a && (_v7 = 3 === _i84 ? 255 : a[_i84]), _k8 >= 0 && _k8 < h && _w9 >= 0 && _w9 < c && (_v7 = x[_t340 + _w9 * (h * p) + _k8 * p + _i84]), l[_t340 + _n254 + _r152 + _i84] = _v7;
          }
        }
      }
    }

    return {
      dataId: o.write(l, s.shape, s.dtype),
      shape: s.shape,
      dtype: s.dtype
    };
  }
},
    Qx = {
  kernelName: "Round",
  backendName: "cpu",
  kernelFunc: og("Round", e => {
    var t = Math.floor(e);
    return e - t < .5 ? Math.floor(e) : e - t > .5 ? Math.ceil(e) : t % 2 == 0 ? t : t + 1;
  })
};

function ey(e, t, n, s, r, a, i, o, l, u) {
  var c = [s / r, r],
      h = e.values,
      d = t.values;
  if (0 === s) return dn(n, t.dtype);
  var p = dn(c, t.dtype);
  p.values.fill(l);

  for (var _e409 = 0; _e409 < a; _e409++) {
    var _a119 = [];
    var _l44 = 0;

    for (var _t341 = 0; _t341 < i; _t341++) {
      var _n255 = h[_e409 * i + _t341];
      _a119.push(_n255), _l44 += _n255 * o[_t341];
    }

    if (_l44 < 0 || _l44 >= s / r) throw new Error("Invalid indices: ".concat(_a119, " does not index into ").concat(n));

    for (var _n256 = 0; _n256 < r; _n256++) {
      u ? p.values[_l44 * r + _n256] += d[_e409 * r + _n256] : p.values[_l44 * r + _n256] = 0 === t.rank ? d[0] : d[_e409 * r + _n256];
    }
  }

  return p;
}

var ty = {
  kernelName: "ScatterNd",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      indices: r,
      updates: a
    } = t,
        {
      shape: i
    } = s,
        {
      sliceRank: o,
      numUpdates: l,
      sliceSize: u,
      strides: c,
      outputSize: h
    } = Sn(0, r, i),
        d = ey(n.bufferSync(r), n.bufferSync(a), i, h, u, l, o, c, 0, !0);
    return n.makeTensorInfo(i, d.dtype, d.values);
  }
},
    ny = {
  kernelName: "Select",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      condition: s,
      t: r,
      e: a
    } = t;
    zf([s, r, a], "select");
    var i = s.shape.length,
        o = n.data.get(s.dataId).values,
        l = n.data.get(r.dataId).values,
        u = n.data.get(a.dataId).values,
        c = dt(r.dtype, a.dtype),
        h = O(d(r.shape), c);
    var p = 0;
    var f = 0 === i || i > 1 || 1 === r.shape.length ? 1 : d(r.shape.slice(1));

    for (var _e410 = 0; _e410 < o.length; _e410++) {
      for (var _t342 = 0; _t342 < f; _t342++) {
        h[p++] = 1 === o[_e410] ? l[_e410] : u[_e410];
      }
    }

    return n.makeTensorInfo(r.shape, c, h);
  }
},
    sy = {
  kernelName: "Selu",
  backendName: "cpu",
  kernelFunc: og("Selu", e => e >= 0 ? 1.0507009873554805 * e : 1.7580993408473768 * (Math.exp(e) - 1))
},
    ry = {
  kernelName: "Sign",
  backendName: "cpu",
  kernelFunc: og("Sign", e => e < 0 ? -1 : e > 0 ? 1 : 0)
},
    ay = {
  kernelName: "Sin",
  backendName: "cpu",
  kernelFunc: og("Sin", e => Math.sin(e))
},
    iy = {
  kernelName: "Sinh",
  backendName: "cpu",
  kernelFunc: og("Sinh", e => Math.sinh(e))
},
    oy = Math.log(1.1920928955078125e-7) + 2,
    ly = {
  kernelName: "Softplus",
  backendName: "cpu",
  kernelFunc: og("Softplus", e => {
    var t = e > -oy,
        n = e < oy,
        s = Math.exp(e);
    var r;
    return r = n ? s : t ? e : Math.log(1 + s), r;
  })
},
    uy = {
  kernelName: "SpaceToBatchND",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockShape: a,
      paddings: i
    } = s;
    zf([r], "spaceToBatchND");
    var o = d(a),
        l = [[0, 0]];
    l.push(...i);

    for (var _e411 = 1 + a.length; _e411 < r.shape.length; ++_e411) {
      l.push([0, 0]);
    }

    var u = Vx.kernelFunc({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        paddings: l,
        constantValue: 0
      }
    }),
        c = Ro(u.shape, a, o, !1),
        h = Ao(c.length, a.length, !1),
        p = Fo(u.shape, a, o, !1),
        f = Bm({
      inputs: {
        x: u
      },
      backend: n,
      attrs: {
        shape: c
      }
    }),
        g = Xg({
      inputs: {
        x: f
      },
      backend: n,
      attrs: {
        perm: h
      }
    }),
        m = Bm({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        shape: p
      }
    });
    return n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
  }
},
    cy = {
  kernelName: "SparseFillEmptyRows",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      indices: s,
      values: r,
      denseShape: a,
      defaultValue: i
    } = t;
    if (1 !== a.shape.length) throw new Error("Dense shape must be a vector, saw:\n        ".concat(a.shape));
    if (2 !== s.shape.length) throw new Error("Indices must be a matrix, saw:\n        ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));
    if (0 !== i.shape.length) throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));
    var o = n.data.get(s.dataId).values,
        l = n.data.get(r.dataId).values,
        u = n.data.get(a.dataId).values,
        c = n.data.get(i.dataId).values[0],
        [h, d, p, f, g] = am(o, s.shape, s.dtype, l, r.dtype, u, c);
    return [n.makeTensorInfo(d, s.dtype, h), n.makeTensorInfo([d[0]], r.dtype, p), n.makeTensorInfo([f.length], "bool", new Uint8Array(f.map(e => Number(e)))), n.makeTensorInfo([g.length], s.dtype, new Int32Array(g))];
  }
},
    hy = {
  kernelName: "SparseReshape",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      inputIndices: s,
      inputShape: r,
      newShape: a
    } = t;
    if (2 !== s.shape.length) throw new Error("Input indices should be a matrix but received shape\n        ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Target shape should be a vector but received shape ".concat(a.shape));
    var i = Array.from(n.data.get(r.dataId).values),
        o = n.data.get(s.dataId).values,
        l = Array.from(n.data.get(a.dataId).values),
        [u, c, h] = im(o, s.shape, s.dtype, i, l);
    return [n.makeTensorInfo(c, s.dtype, u), n.makeTensorInfo([h.length], a.dtype, new Int32Array(h))];
  }
},
    dy = {
  kernelName: "SparseSegmentMean",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      data: s,
      indices: r,
      segmentIds: a
    } = t;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n          ".concat(a.shape));
    var i = n.data.get(s.dataId).values,
        o = n.data.get(r.dataId).values,
        l = n.data.get(a.dataId).values,
        [u, c] = om(i, s.shape, s.dtype, o, l, !0);
    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    py = {
  kernelName: "SparseSegmentSum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      data: s,
      indices: r,
      segmentIds: a
    } = t;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n         ".concat(a.shape));
    var i = n.data.get(s.dataId).values,
        o = n.data.get(r.dataId).values,
        l = n.data.get(a.dataId).values,
        [u, c] = om(i, s.shape, s.dtype, o, l);
    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    fy = {
  kernelName: "SparseToDense",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      sparseIndices: r,
      sparseValues: a,
      defaultValue: i
    } = t,
        {
      outputShape: o
    } = s,
        {
      sliceRank: l,
      numUpdates: u,
      sliceSize: c,
      strides: h,
      outputSize: d
    } = Sn(0, r, o),
        p = ey(n.bufferSync(r), n.bufferSync(a), o, d, c, u, l, h, n.data.get(i.dataId).values[0], !1);
    return n.makeTensorInfo(o, p.dtype, p.values);
  }
},
    gy = {
  kernelName: "SplitV",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      numOrSizeSplits: a,
      axis: i
    } = s,
        o = y(i, r.shape)[0],
        l = Jo(r, a, o),
        u = new Array(r.shape.length).fill(0),
        c = r.shape.slice();
    return l.map(e => {
      var t = [...c];
      t[o] = e;
      var s = sm({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          begin: u,
          size: t
        }
      });
      return u[o] += e, s;
    });
  }
},
    my = {
  kernelName: "Sqrt",
  backendName: "cpu",
  kernelFunc: og("Sqrt", e => Math.sqrt(e))
},
    by = {
  kernelName: "Square",
  backendName: "cpu",
  kernelFunc: _ref19 => {
    var {
      inputs: e,
      backend: t
    } = _ref19;
    var {
      x: n
    } = e,
        s = t;
    zf(n, "square");
    var r = s.data.get(n.dataId).values,
        a = new Float32Array(r.length);

    for (var _e412 = 0; _e412 < r.length; ++_e412) {
      var _t343 = r[_e412];
      a[_e412] = _t343 * _t343;
    }

    return {
      dataId: s.write(a, n.shape, n.dtype),
      shape: n.shape,
      dtype: n.dtype
    };
  }
},
    xy = {
  kernelName: "Step",
  backendName: "cpu",
  kernelFunc: og("Step", (e, t) => {
    var n = t;
    return isNaN(e) ? NaN : e > 0 ? 1 : n.alpha;
  })
},
    yy = {
  kernelName: "StridedSlice",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      begin: a,
      end: i,
      strides: o,
      beginMask: l,
      endMask: u,
      ellipsisMask: c,
      newAxisMask: h,
      shrinkAxisMask: d
    } = s;
    zf(r, "stridedSlice");
    var {
      nonStrided: p,
      $begin: f,
      $strides: g,
      size: m,
      newShape: b,
      outShape: x
    } = Vn(r.shape, a, i, o, l, u, c, h, d),
        y = Bm({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: b
      }
    });
    var k;

    if (p) {
      var _e413 = sm({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          begin: f,
          size: m
        }
      });

      k = Bm({
        inputs: {
          x: _e413
        },
        backend: n,
        attrs: {
          shape: x
        }
      }), n.disposeIntermediateTensorInfo(_e413);
    } else if (x.some(e => 0 === e)) k = n.makeTensorInfo(x, r.dtype, []);else {
      var _e414 = cm(x, n.bufferSync(y), g, f);

      k = n.makeTensorInfo(_e414.shape, _e414.dtype, _e414.values);
    }

    var w = Bm({
      inputs: {
        x: k
      },
      backend: n,
      attrs: {
        shape: x
      }
    });
    return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(k), w;
  }
},
    ky = {
  kernelName: "StringNGrams",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      separator: r,
      nGramWidths: a,
      leftPad: i,
      rightPad: o,
      padWidth: l,
      preserveShortSequences: u
    } = s,
        {
      data: c,
      dataSplits: h
    } = t,
        d = n.data.get(c.dataId).values,
        p = n.data.get(h.dataId).values,
        [f, g] = dm(d, p, r, a, i, o, l, u);
    return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(h.shape, "int32", g)];
  }
},
    wy = {
  kernelName: "StringSplit",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      skipEmpty: r
    } = s,
        {
      input: a,
      delimiter: i
    } = t;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (1 !== a.shape.length) throw new Error("Input must be a vector, got shape: ".concat(a.shape));
    if (0 !== i.shape.length) throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));
    var o = n.data.get(a.dataId).values,
        l = n.data.get(i.dataId).values[0],
        [u, c, h] = fm(o, l, r),
        d = c.length;
    return [n.makeTensorInfo([d, 2], "int32", u), n.makeTensorInfo([d], "string", c), n.makeTensorInfo([2], "int32", new Int32Array(h))];
  }
},
    vy = {
  kernelName: "StringToHashBucketFast",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      numBuckets: r
    } = s,
        {
      input: a
    } = t;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (r <= 0) throw new Error("Number of buckets must be at least 1");
    var i = gm(n.data.get(a.dataId).values, r);
    return n.makeTensorInfo(a.shape, "int32", i);
  }
},
    Iy = {
  kernelName: "Tan",
  backendName: "cpu",
  kernelFunc: og("Tan", e => Math.tan(e))
},
    $y = og("Tanh", e => Math.tanh(e));

function Ny(e, t, n) {
  switch (n) {
    case "reflect":
      return function (e, t) {
        var n = e;
        if (n < 0) {
          if (t <= 1) n = 0;else {
            var _e415 = 2 * t;

            n < _e415 && (n = _e415 * Math.trunc(-n / _e415) + n), n = n < -t ? n + _e415 : -n - 1;
          }
        } else if (n > t - 1) if (t <= 1) n = 0;else {
          var _e416 = 2 * t;

          n -= _e416 * Math.trunc(n / _e416), n >= t && (n = _e416 - n - 1);
        }
        return a(0, n, t - 1);
      }(e, t);

    case "wrap":
      return function (e, t) {
        var n = e;
        return n < 0 ? t <= 1 ? n = 0 : n += t * (Math.trunc(-n / (t - 1)) + 1) : n > t - 1 && (t <= 1 ? n = 0 : n -= t * Math.trunc(n / (t - 1))), a(0, n, t - 1);
      }(e, t);

    case "nearest":
      return function (e, t) {
        return a(0, e, t - 1);
      }(e, t);

    case "constant":
    default:
      return function (e, t) {
        return e;
      }(e);
  }
}

function Cy(e, t, n, s, r, a, i, o, l, u, c) {
  return 0 <= o && o < t && 0 <= l && l < n ? e[i * s + o * r + l * a + u] : c;
}

function Sy(e, t, n, s, r, a, i, o, l, u, c) {
  return Cy(e, t, n, s, r, a, i, Math.round(o), Math.round(l), u, c);
}

function Ty(e, t, n, s, r, a, i, o, l, u, c) {
  var h = Math.floor(o),
      d = Math.floor(l),
      p = h + 1,
      f = d + 1;
  return (p - o) * ((f - l) * Cy(e, t, n, s, r, a, i, h, d, u, c) + (l - d) * Cy(e, t, n, s, r, a, i, h, f, u, c)) + (o - h) * ((f - l) * Cy(e, t, n, s, r, a, i, p, d, u, c) + (l - d) * Cy(e, t, n, s, r, a, i, p, f, u, c));
}

var Ey = [Vm, Uf, Gm, Hm, sg, jm, qm, Km, Xm, Ym, Jm, Zm, Qm, eb, tb, ab, ib, ob, lb, Um, ub, cb, hb, Zf, cg, db, Hf, pb, bb, kb, wb, yb, Ib, $b, vb, Nb, Cb, Sb, Tb, Eb, Rb, Fb, Db, _b, Ob, Mb, zb, Lb, qb, Wb, Cm, Ub, fg, Vb, bg, Hb, yg, Jb, Qb, ex, wg, tx, nx, sx, rx, ax, Ng, Sg, Kf, ix, gb, ox, lx, ux, Tm, Eg, Ag, cx, _g, hx, dx, px, fx, gx, mx, Lg, yx, kx, wx, vx, Ix, xx, $x, Nx, Bg, Cx, Sx, Rx, Vg, Hg, Fx, _x, Mx, qg, Lx, Px, Ux, Vx, Gx, Am, Zg, Hx, Yf, jx, Dm, Om, Pm, qx, Kx, Xx, Yx, Jx, Zx, Qx, tm, ty, ny, sy, Lm, ry, ay, iy, rm, Ex, ly, uy, cy, hy, dy, py, fy, gy, my, by, um, xy, yy, ky, wy, vy, xm, Pb, Iy, {
  kernelName: "Tanh",
  backendName: "cpu",
  kernelFunc: $y
}, {
  kernelName: "Tile",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      reps: a
    } = s;
    zf(r, "tile");
    var i = ym(n.bufferSync(r), a);
    return n.makeTensorInfo(i.shape, i.dtype, i.values);
  }
}, {
  kernelName: "TopK",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      k: a,
      sorted: i
    } = s;
    zf(r, "topk");
    var o = n.data.get(r.dataId).values,
        [l, u] = vm(o, r.shape, r.dtype, a, i);
    return [n.makeTensorInfo(l.shape, l.dtype, l.values), n.makeTensorInfo(u.shape, u.dtype, u.values)];
  }
}, Yg, {
  kernelName: "Transform",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      attrs: n,
      backend: s
    } = e,
        {
      image: r,
      transforms: a
    } = t,
        {
      interpolation: i,
      fillMode: o,
      fillValue: l,
      outputShape: u
    } = n,
        [c, h, p, f] = r.shape,
        [g, m] = null != u ? u : [h, p],
        b = [c, g, m, f],
        x = A(r.shape),
        y = x[0],
        k = x[1],
        v = x[2],
        I = w(r.dtype, d(b));
    I.fill(l);
    var $ = s.data.get(r.dataId).values,
        N = s.data.get(a.dataId).values;

    for (var _e417 = 0; _e417 < c; ++_e417) {
      var _t344 = 1 === a.shape[0] ? N : N.subarray(8 * _e417, 8 * _e417 + 8);

      for (var _n257 = 0; _n257 < g; ++_n257) {
        for (var _s206 = 0; _s206 < m; ++_s206) {
          for (var _r153 = 0; _r153 < f; ++_r153) {
            var _a120 = void 0;

            var _u32 = _t344[6] * _s206 + _t344[7] * _n257 + 1;

            if (0 === _u32) continue;

            var _c28 = (_t344[3] * _s206 + _t344[4] * _n257 + _t344[5]) / _u32,
                _d22 = Ny((_t344[0] * _s206 + _t344[1] * _n257 + _t344[2]) / _u32, p, o),
                _f10 = Ny(_c28, h, o);

            switch (i) {
              case "nearest":
                _a120 = Sy($, h, p, y, k, v, _e417, _f10, _d22, _r153, l);
                break;

              case "bilinear":
                _a120 = Ty($, h, p, y, k, v, _e417, _f10, _d22, _r153, l);
                break;

              default:
                throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got ".concat(i));
            }

            I[_e417 * y + _n257 * k + _s206 * v + _r153] = _a120;
          }
        }
      }

      return s.makeTensorInfo(b, r.dtype, I);
    }

    return {
      dataId: s.write(I, b, r.dtype),
      shape: r.shape,
      dtype: r.dtype
    };
  }
}, {
  kernelName: "Unique",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      attrs: n,
      backend: s
    } = e,
        {
      axis: r
    } = n,
        {
      x: a
    } = t;
    zf(a, "unique");
    var i = s.data.get(a.dataId).values,
        {
      outputValues: o,
      outputShape: l,
      indices: u
    } = Im(i, r, a.shape, a.dtype);
    return [s.makeTensorInfo(l, a.dtype, o), s.makeTensorInfo([u.length], "int32", u)];
  }
}, {
  kernelName: "Unpack",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      value: r
    } = t;
    var {
      axis: a
    } = s;
    a < 0 && (a += r.shape.length);
    var i = r.shape.length,
        o = r.shape[a],
        l = new Array(i - 1);
    var u = 0;

    for (var _e418 = 0; _e418 < i; _e418++) {
      _e418 !== a && (l[u++] = r.shape[_e418]);
    }

    var c = new Array(i).fill(0),
        h = r.shape.slice();
    h[a] = 1;
    var d = new Array(o);

    for (var _e419 = 0; _e419 < d.length; _e419++) {
      c[a] = _e419;

      var _t345 = sm({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          begin: c,
          size: h
        }
      });

      d[_e419] = Bm({
        inputs: {
          x: _t345
        },
        backend: n,
        attrs: {
          shape: l
        }
      }), n.disposeIntermediateTensorInfo(_t345);
    }

    return d;
  }
}, {
  kernelName: "UnsortedSegmentSum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      segmentIds: a
    } = t,
        {
      numSegments: i
    } = s;
    zf(r, "unsortedSegmentSum");
    var o = [],
        l = [],
        u = r.shape.length - a.shape.length;
    var c = a;

    for (var _e420 = 0; _e420 < u; ++_e420) {
      var _t346 = Gb({
        inputs: {
          input: c
        },
        backend: n,
        attrs: {
          dim: _e420 + 1
        }
      });

      c = _t346, l.push(_t346);
    }

    for (var _e421 = 0; _e421 < i; ++_e421) {
      var _t347 = We(_e421, "int32"),
          _s207 = n.makeTensorInfo([], "int32", _t347),
          _a121 = pg({
        inputs: {
          a: _s207,
          b: c
        },
        backend: n
      }),
          _i85 = Jf({
        inputs: {
          x: _a121
        },
        backend: n,
        attrs: {
          dtype: "float32"
        }
      }),
          _u33 = Ug({
        inputs: {
          a: _i85,
          b: r
        },
        backend: n
      }),
          _h16 = Bb({
        inputs: {
          x: _u33
        },
        backend: n,
        attrs: {
          axis: 0,
          keepDims: !1
        }
      });

      o.push(_h16), l.push(_s207), l.push(_a121), l.push(_i85), l.push(_u33), l.push(_h16);
    }

    var h = Wx({
      inputs: o,
      backend: n,
      attrs: {
        axis: 0
      }
    });
    return l.forEach(e => n.disposeIntermediateTensorInfo(e)), h;
  }
}, Bx];

for (var _e422 of Ey) {
  Q(_e422);
}

var Ry = {},
    Ay = {
  alpha: !1,
  antialias: !1,
  premultipliedAlpha: !1,
  preserveDrawingBuffer: !1,
  depth: !1,
  stencil: !1,
  failIfMajorPerformanceCaveat: !0
};

function Fy(e) {
  if (!(e in Ry)) {
    var _t348 = function (e) {
      if (1 !== e && 2 !== e) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");

      var t = function (e) {
        if ("undefined" != typeof OffscreenCanvas && 2 === e) return new OffscreenCanvas(300, 150);
        if ("undefined" != typeof document) return document.createElement("canvas");
        throw new Error("Cannot create a canvas in this context");
      }(e);

      return t.addEventListener("webglcontextlost", t => {
        t.preventDefault(), delete Ry[e];
      }, !1), 1 === e ? t.getContext("webgl", Ay) || t.getContext("experimental-webgl", Ay) : t.getContext("webgl2", Ay);
    }(e);

    if (null === _t348) return console.log("Could not get context for WebGL version", e), null;
    Ry[e] = _t348;
  }

  var t = Ry[e];
  return t.isContextLost() ? (delete Ry[e], Fy(e)) : (t.disable(t.DEPTH_TEST), t.disable(t.STENCIL_TEST), t.disable(t.BLEND), t.disable(t.DITHER), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SAMPLE_COVERAGE), t.enable(t.SCISSOR_TEST), t.enable(t.CULL_FACE), t.cullFace(t.BACK), Ry[e]);
}

var Dy, _y, Oy;

function My(e, t) {
  return [t, e];
}

function Ly(e) {
  var t = d(e);
  return g(Math.ceil(t / 4));
}

function zy(e, t) {
  return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2))];
}

function By(e, t) {
  var n = e;
  var s, r, a, i, o, l, u, c, h, d;
  return 2 === V().getNumber("WEBGL_VERSION") ? (s = n.R32F, r = n.R16F, a = n.RGBA16F, i = n.RGBA32F, o = n.RED, u = 4, c = 1, h = n.HALF_FLOAT, d = n.FLOAT) : (s = e.RGBA, r = e.RGBA, a = e.RGBA, i = n.RGBA, o = e.RGBA, u = 4, c = 4, h = null != t ? t.HALF_FLOAT_OES : null, d = e.FLOAT), l = e.RGBA, {
    internalFormatFloat: s,
    internalFormatHalfFloat: r,
    internalFormatPackedHalfFloat: a,
    internalFormatPackedFloat: i,
    textureFormatFloat: o,
    downloadTextureFormat: l,
    downloadUnpackNumChannels: u,
    defaultNumChannels: c,
    textureTypeHalfFloat: h,
    textureTypeFloat: d
  };
}

function Py(e, t) {
  var n = t();
  return V().getBool("DEBUG") && function (e) {
    var t = e.getError();
    if (t !== e.NO_ERROR) throw new Error("WebGL Error: " + function (e, t) {
      switch (t) {
        case e.NO_ERROR:
          return "NO_ERROR";

        case e.INVALID_ENUM:
          return "INVALID_ENUM";

        case e.INVALID_VALUE:
          return "INVALID_VALUE";

        case e.INVALID_OPERATION:
          return "INVALID_OPERATION";

        case e.INVALID_FRAMEBUFFER_OPERATION:
          return "INVALID_FRAMEBUFFER_OPERATION";

        case e.OUT_OF_MEMORY:
          return "OUT_OF_MEMORY";

        case e.CONTEXT_LOST_WEBGL:
          return "CONTEXT_LOST_WEBGL";

        default:
          return "Unknown error code ".concat(t);
      }
    }(e, t));
  }(e), n;
}

function Wy(e) {
  return !!(V().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === e || 5.96e-8 < Math.abs(e) && Math.abs(e) < 65504);
}

function Uy(e, t) {
  return Xy(e, () => e.getExtension(t), 'Extension "' + t + '" not supported on this browser.');
}

!function (e) {
  e[e.DENSE = 0] = "DENSE", e[e.SHARED_BATCH = 1] = "SHARED_BATCH";
}(Dy || (Dy = {})), function (e) {
  e[e.RENDER = 0] = "RENDER", e[e.UPLOAD = 1] = "UPLOAD", e[e.PIXELS = 2] = "PIXELS", e[e.DOWNLOAD = 3] = "DOWNLOAD";
}(_y || (_y = {})), function (e) {
  e[e.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e[e.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e[e.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e[e.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(Oy || (Oy = {}));
var Vy = /ERROR: [0-9]+:([0-9]+):/g;

function Gy(e, t) {
  if (Py(e, () => e.validateProgram(t)), !1 === e.getProgramParameter(t, e.VALIDATE_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Shader program validation failed.");
}

function Hy(e, t, n, s, r, a, i) {
  var o = e.getAttribLocation(t, n);
  return -1 !== o && (Py(e, () => e.bindBuffer(e.ARRAY_BUFFER, s)), Py(e, () => e.vertexAttribPointer(o, r, e.FLOAT, !1, a, i)), Py(e, () => e.enableVertexAttribArray(o)), !0);
}

function jy(e, t, n) {
  Py(e, () => e.bindFramebuffer(e.FRAMEBUFFER, n)), Py(e, () => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0));
}

function qy(e, t) {
  Py(e, () => e.bindFramebuffer(e.FRAMEBUFFER, t)), Py(e, () => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0));
}

function Ky(e) {
  var t = e.checkFramebufferStatus(e.FRAMEBUFFER);
  if (t !== e.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + function (e, t) {
    switch (t) {
      case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

      case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

      case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

      case e.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";

      default:
        return "unknown error ".concat(t);
    }
  }(e, t));
}

function Xy(e, t, n) {
  var s = Py(e, () => t());
  if (null == s) throw new Error(n);
  return s;
}

function Yy(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  return d(e.slice(0, e.length - t));
}

function Jy(e) {
  if (0 === e.length) throw Error("Cannot get rows and columns of an empty shape array.");
  return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]];
}

function Zy(e) {
  var t = [1, 1, 1];
  return 0 === e.length || 1 === e.length && 1 === e[0] || (t = [Yy(e), ...Jy(e)]), t;
}

function Qy(e) {
  return e % 2 == 0;
}

function ek(e, t) {
  if (p(e = e.slice(-2), t = t.slice(-2))) return !0;
  if (!e.length || !t.length) return !0;
  if (0 === e[0] || 0 === e[1] || 0 === t[0] || 0 === t[1]) return !0;

  if (e.length !== t.length) {
    var _n258 = e.slice(-1)[0],
        _s208 = t.slice(-1)[0];
    if (_n258 === _s208) return !0;
    if (Qy(_n258) && Qy(_s208) && (1 === e[0] || 1 === t[0])) return !0;
  }

  return e[1] === t[1] && Qy(e[0]) && Qy(t[0]);
}

var tk, nk;

function sk(e, t) {
  return null != e.getExtension(t);
}

function rk(e) {
  try {
    if (null != Fy(e)) return !0;
  } catch (e) {
    return console.log("Error when getting WebGL context: ", e), !1;
  }

  return !1;
}

function ak(e) {
  var t = By(e),
      n = e.createTexture();
  e.bindTexture(e.TEXTURE_2D, n), e.texImage2D(e.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
  var s = e.createFramebuffer();
  e.bindFramebuffer(e.FRAMEBUFFER, s), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
  var r = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
  return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(n), e.deleteFramebuffer(s), r;
}

function ik(e, t) {
  Array.isArray(e) || (e = [e]), e.forEach(e => {
    null != e && l("complex64" !== e.dtype, () => "".concat(t, " does not support complex64 tensors in the WebGL backend."));
  });
}

var ok = V();

function lk() {
  var e, t, n, s, r, a, i, o, l, u;
  return 2 === V().getNumber("WEBGL_VERSION") ? (e = "#version 300 es", t = "in", n = "out", s = "in", r = "texture", a = "outputColor", i = "out vec4 outputColor;", o = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", l = "", u = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (e = "", t = "attribute", n = "varying", s = "varying", r = "texture2D", a = "gl_FragColor", i = "", o = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", l = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", u = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
    version: e,
    attribute: t,
    varyingVs: n,
    varyingFs: s,
    texture2D: r,
    output: a,
    defineOutput: i,
    defineSpecialNaN: o,
    defineSpecialInf: l,
    defineRound: u
  };
}

function uk(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "index";
  var s = A(t);
  return s.map((t, r) => "int ".concat(e[r], " = ").concat(n, " / ").concat(t, "; ").concat(r === s.length - 1 ? "int ".concat(e[r + 1], " = ").concat(n, " - ").concat(e[r], " * ").concat(t) : "index -= ".concat(e[r], " * ").concat(t), ";")).join("");
}

function ck(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "index";
  var s = A(t);
  return s.map((t, r) => "int ".concat(e[r], " = ").concat(n, " / outShapeStrides[").concat(r, "]; ").concat(r === s.length - 1 ? "int ".concat(e[r + 1], " = ").concat(n, " - ").concat(e[r], " * outShapeStrides[").concat(r, "]") : "index -= ".concat(e[r], " * outShapeStrides[").concat(r, "]"), ";")).join("");
}

function hk(e) {
  var t = A(e).map(e => e.toString());
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0], " + coords.y * ").concat(t[1], " + coords.z;\n  }\n");
}

ok.registerFlag("HAS_WEBGL", () => ok.getNumber("WEBGL_VERSION") > 0), ok.registerFlag("WEBGL_VERSION", () => rk(2) ? 2 : rk(1) ? 1 : 0), ok.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => !1), ok.registerFlag("WEBGL_BUFFER_SUPPORTED", () => 2 === ok.get("WEBGL_VERSION")), ok.registerFlag("WEBGL_CPU_FORWARD", () => !0), ok.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => !1), ok.registerFlag("WEBGL_PACK", () => ok.getBool("HAS_WEBGL")), ok.registerFlag("WEBGL_PACK_NORMALIZATION", () => ok.getBool("WEBGL_PACK")), ok.registerFlag("WEBGL_PACK_CLIP", () => ok.getBool("WEBGL_PACK")), ok.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => ok.getBool("WEBGL_PACK")), ok.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => ok.getBool("WEBGL_PACK")), ok.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => ok.getBool("WEBGL_PACK")), ok.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => ok.getBool("WEBGL_PACK")), ok.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => ok.getBool("WEBGL_PACK")), ok.registerFlag("WEBGL_PACK_REDUCE", () => ok.getBool("WEBGL_PACK")), ok.registerFlag("WEBGL_LAZILY_UNPACK", () => ok.getBool("WEBGL_PACK")), ok.registerFlag("WEBGL_CONV_IM2COL", () => ok.getBool("WEBGL_PACK")), ok.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => function (e) {
  if (null == tk) {
    var _t349 = Fy(e);

    tk = _t349.getParameter(_t349.MAX_TEXTURE_SIZE);
  }

  return tk;
}(ok.getNumber("WEBGL_VERSION"))), ok.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => function (e) {
  if (null == nk) {
    var _t350 = Fy(e);

    nk = _t350.getParameter(_t350.MAX_TEXTURE_IMAGE_UNITS);
  }

  return Math.min(16, nk);
}(ok.getNumber("WEBGL_VERSION"))), ok.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
  var e = ok.getNumber("WEBGL_VERSION");
  return 0 === e ? 0 : function (e) {
    if (0 === e) return 0;
    var t;
    var n = Fy(e);
    return t = sk(n, "EXT_disjoint_timer_query_webgl2") && 2 === e ? 2 : sk(n, "EXT_disjoint_timer_query") ? 1 : 0, t;
  }(e);
}), ok.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => ok.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !It()), ok.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => function (e) {
  if (0 === e) return !1;
  var t = Fy(e);

  if (1 === e) {
    if (!sk(t, "OES_texture_float")) return !1;
  } else if (!sk(t, "EXT_color_buffer_float")) return !1;

  return ak(t);
}(ok.getNumber("WEBGL_VERSION"))), ok.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => !ok.getBool("WEBGL_FORCE_F16_TEXTURES") && ok.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")), ok.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => function (e) {
  if (0 === e) return !1;
  var t = Fy(e);

  if (1 !== e) {
    if (sk(t, "EXT_color_buffer_float")) return ak(t);
    var _e423 = "EXT_color_buffer_half_float";

    if (sk(t, _e423)) {
      var _n259 = t.getExtension(_e423);

      return function (e, t) {
        var n = By(e, t),
            s = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, s), e.texImage2D(e.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
        var r = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, s, 0);
        var a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
        return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(s), e.deleteFramebuffer(r), a;
      }(t, _n259);
    }

    return !1;
  }

  return !!sk(t, "OES_texture_float") && !!sk(t, "WEBGL_color_buffer_float") && ak(t);
}(ok.getNumber("WEBGL_VERSION"))), ok.registerFlag("WEBGL_FENCE_API_ENABLED", () => {
  return 2 === (e = ok.getNumber("WEBGL_VERSION")) && null != Fy(e).fenceSync;
  var e;
}), ok.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => ok.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0), ok.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, e => {
  if (e < 0 && -1 !== e) throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ".concat(e, "."));
}), ok.registerFlag("WEBGL_FLUSH_THRESHOLD", () => It() && ok.getBool("IS_CHROME") ? 1 : -1, e => {
  if (e < 0 && -1 !== e) throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ".concat(e, "."));
}), ok.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128), ok.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => !1), ok.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5), ok.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
var dk = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";

class pk {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Dy.DENSE;
    var t = Ly(e),
        n = lk();
    this.outputShape = e, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(uk(["r", "c", "d"], e), "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(").concat(t[0], ", ").concat(t[1], "));\n        int index = 4 * (resTexRC.x * ").concat(t[1], " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(n.output, " = result;\n      }\n    ");
  }

}

class fk {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Dy.DENSE;
    var t = Ly(e),
        n = lk();
    this.outputShape = e, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(uk(["r", "c", "d"], e), "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(").concat(t[0], ", ").concat(t[1], "));\n        int index = 4 * (resTexRC.x * ").concat(t[1], " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(n.output, " = result;\n      }\n    ");
  }

}

class gk {
  constructor(e) {
    this.variableNames = ["A"], this.outTexUsage = _y.DOWNLOAD;
    var t = lk();
    this.outputShape = e, this.userCode = "\n      ".concat(dk, "\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output, " = encode_float(x);\n      }\n    ");
  }

}

class mk {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = _y.DOWNLOAD;
    var t = lk();
    this.outputShape = e, this.userCode = "\n      ".concat(dk, "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output, " = encode_float(x);\n      }\n    ");
  }

}

class bk {
  constructor(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    this.variableNames = ["A"];
    var s = lk(),
        [r, a] = t;
    this.outputShape = e;
    var i = "result";
    n && (i = "floor(result * 255. + 0.5)"), this.userCode = "\n      ".concat(hk(e), "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ").concat(a, ";\n        int c = imod(flatIndex, ").concat(a, ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(").concat(a, ".0, ").concat(r, ".0);\n        vec4 values = ").concat(s.texture2D, "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ").concat(s.output, " = vec4(").concat(i, ", 0., 0., 0.);\n      }\n    ");
  }

}

class xk {
  constructor(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
    var s = lk(),
        [r, a] = t;
    this.outputShape = e;
    var i = "",
        o = "result";
    n && (o = "floor(result * 255. + 0.5)");

    for (var _t351 = 0; _t351 <= 1; _t351++) {
      for (var _n260 = 0; _n260 <= 1; _n260++) {
        var _o64 = 2 * _t351 + _n260;

        i += "\n          localCoords = coords;\n          if(localCoords[2] + ".concat(_n260, " < ").concat(e[2], ") {\n            localCoords[2] += ").concat(_n260, ";\n            if(localCoords[1] + ").concat(_t351, " < ").concat(e[1], ") {\n              localCoords[1] += ").concat(_t351, ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ").concat(a, ";\n              c = imod(flatIndex, ").concat(a, ");\n              uv = (vec2(c, r) + halfCR) / vec2(").concat(a, ".0, ").concat(r, ".0);\n              values = ").concat(s.texture2D, "(A, uv);\n\n              if(offset == 0) {\n                result[").concat(_o64, "] = values[0];\n              } else if(offset == 1) {\n                result[").concat(_o64, "] = values[1];\n              } else if(offset == 2) {\n                result[").concat(_o64, "] = values[2];\n              } else {\n                result[").concat(_o64, "] = values[3];\n              }\n            }\n          }\n        ");
      }
    }

    this.userCode = "\n      ".concat(hk(e), "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ").concat(i, "\n\n        ").concat(s.output, " = ").concat(o, ";\n      }\n    ");
  }

}

function yk(e, t, n, s, r, a) {
  !function (e, t) {
    var n = V().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (e <= 0 || t <= 0) throw new Error("Requested texture size [".concat(e, "x").concat(t, "] is invalid."));
    if (e > n || t > n) throw new Error("Requested texture size [".concat(e, "x").concat(t, "] greater than WebGL maximum on this browser / GPU [").concat(n, "x").concat(n, "]."));
  }(t, n);

  var i = function (e) {
    return Xy(e, () => e.createTexture(), "Unable to create WebGLTexture.");
  }(e),
      o = e.TEXTURE_2D;

  return Py(e, () => e.bindTexture(o, i)), Py(e, () => e.texParameteri(o, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE)), Py(e, () => e.texParameteri(o, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), Py(e, () => e.texParameteri(o, e.TEXTURE_MIN_FILTER, e.NEAREST)), Py(e, () => e.texParameteri(o, e.TEXTURE_MAG_FILTER, e.NEAREST)), Py(e, () => e.texImage2D(o, 0, s, t, n, 0, r, a, null)), Py(e, () => e.bindTexture(e.TEXTURE_2D, null)), i;
}

function kk(e) {
  return e.internalFormatFloat;
}

function wk(e) {
  return e.internalFormatHalfFloat;
}

function vk(e) {
  return e.downloadTextureFormat;
}

function Ik(e) {
  return e.internalFormatPackedFloat;
}

function $k(e) {
  return e.internalFormatPackedHalfFloat;
}

class Nk {
  constructor(e) {
    this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
    var t = V().getNumber("WEBGL_VERSION");
    null != e ? (this.gl = e, function (e, t) {
      Ry[e] = t;
    }(t, e)) : this.gl = Fy(t);
    var n = "WEBGL_color_buffer_float";
    var s = "EXT_color_buffer_half_float";

    if (1 === V().getNumber("WEBGL_VERSION")) {
      var _e424 = "OES_texture_half_float";
      if (this.textureFloatExtension = Uy(this.gl, "OES_texture_float"), sk(this.gl, _e424)) this.textureHalfFloatExtension = Uy(this.gl, _e424);else if (V().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(n), sk(this.gl, s)) this.colorBufferHalfFloatExtension = Uy(this.gl, s);else if (V().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (n = "EXT_color_buffer_float", sk(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);else {
      if (!sk(this.gl, s)) throw new Error("GL context does not support color renderable floats");
      this.colorBufferHalfFloatExtension = this.gl.getExtension(s);
    }

    this.vertexBuffer = function (e) {
      return function (e, t) {
        var n = Xy(e, () => e.createBuffer(), "Unable to create WebGLBuffer");
        return Py(e, () => e.bindBuffer(e.ARRAY_BUFFER, n)), Py(e, () => e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW)), n;
      }(e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
    }(this.gl), this.indexBuffer = function (e) {
      return function (e, t) {
        var n = Xy(e, () => e.createBuffer(), "Unable to create WebGLBuffer");
        return Py(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n)), Py(e, () => e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW)), n;
      }(e, new Uint16Array([0, 1, 2, 2, 1, 3]));
    }(this.gl), this.framebuffer = function (e) {
      return Xy(e, () => e.createFramebuffer(), "Unable to create WebGLFramebuffer.");
    }(this.gl), this.textureConfig = By(this.gl, this.textureHalfFloatExtension);
  }

  get debug() {
    return V().getBool("DEBUG");
  }

  dispose() {
    if (this.disposed) return;
    null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
    var e = this.gl;
    Py(e, () => e.finish()), Py(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), Py(e, () => e.deleteFramebuffer(this.framebuffer)), Py(e, () => e.bindBuffer(e.ARRAY_BUFFER, null)), Py(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)), Py(e, () => e.deleteBuffer(this.indexBuffer)), this.disposed = !0;
  }

  createFloat32MatrixTexture(e, t) {
    return this.throwIfDisposed(), function (e, t, n, s) {
      var [r, a] = My(t, n);
      return yk(e, r, a, kk(s), s.textureFormatFloat, e.FLOAT);
    }(this.gl, e, t, this.textureConfig);
  }

  createFloat16MatrixTexture(e, t) {
    return this.throwIfDisposed(), function (e, t, n, s) {
      var [r, a] = My(t, n);
      return yk(e, r, a, wk(s), s.textureFormatFloat, s.textureTypeHalfFloat);
    }(this.gl, e, t, this.textureConfig);
  }

  createUnsignedBytesMatrixTexture(e, t) {
    return this.throwIfDisposed(), function (e, t, n, s) {
      var [r, a] = My(t, n);
      return yk(e, r, a, vk(s), e.RGBA, e.UNSIGNED_BYTE);
    }(this.gl, e, t, this.textureConfig);
  }

  uploadPixelDataToTexture(e, t) {
    this.throwIfDisposed(), function (e, t, n) {
      Py(e, () => e.bindTexture(e.TEXTURE_2D, t)), n.data instanceof Uint8Array ? Py(e, () => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, n.width, n.height, 0, e.RGBA, e.UNSIGNED_BYTE, n.data)) : Py(e, () => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n)), Py(e, () => e.bindTexture(e.TEXTURE_2D, null));
    }(this.gl, e, t);
  }

  uploadDenseMatrixToTexture(e, t, n, s) {
    this.throwIfDisposed(), function (e, t, n, s, r, a) {
      var i, o, l;
      Py(e, () => e.bindTexture(e.TEXTURE_2D, t)), r instanceof Uint8Array ? (i = new Uint8Array(n * s * 4), o = e.UNSIGNED_BYTE, l = e.RGBA) : (i = new Float32Array(n * s * 4), o = e.FLOAT, l = a.internalFormatPackedFloat), i.set(r), Py(e, () => e.texImage2D(e.TEXTURE_2D, 0, l, n, s, 0, e.RGBA, o, i)), Py(e, () => e.bindTexture(e.TEXTURE_2D, null));
    }(this.gl, e, t, n, s, this.textureConfig);
  }

  createFloat16PackedMatrixTexture(e, t) {
    return this.throwIfDisposed(), function (e, t, n, s) {
      var [r, a] = zy(t, n);
      return yk(e, r, a, $k(s), e.RGBA, s.textureTypeHalfFloat);
    }(this.gl, e, t, this.textureConfig);
  }

  createPackedMatrixTexture(e, t) {
    return this.throwIfDisposed(), function (e, t, n, s) {
      var [r, a] = zy(t, n);
      return yk(e, r, a, Ik(s), e.RGBA, e.FLOAT);
    }(this.gl, e, t, this.textureConfig);
  }

  deleteMatrixTexture(e) {
    this.throwIfDisposed(), this.outputTexture === e && (qy(this.gl, this.framebuffer), this.outputTexture = null), Py(this.gl, () => this.gl.deleteTexture(e));
  }

  downloadByteEncodedFloatMatrixFromOutputTexture(e, t, n) {
    return this.downloadMatrixDriver(e, () => function (e, t, n, s) {
      var [r, a] = My(t, n),
          i = new Uint8Array(t * n * 4);
      return Py(e, () => e.readPixels(0, 0, r, a, s.downloadTextureFormat, e.UNSIGNED_BYTE, i)), new Float32Array(i.buffer);
    }(this.gl, t, n, this.textureConfig));
  }

  downloadPackedMatrixFromBuffer(e, t, n, s, r, a) {
    return function (e, t, n, s, r, a, i, o) {
      var l = e,
          u = new Float32Array(function (e, t) {
        var [n, s] = zy(e, t);
        return n * s * 4;
      }(a, i));
      return l.bindBuffer(l.PIXEL_PACK_BUFFER, t), l.getBufferSubData(l.PIXEL_PACK_BUFFER, 0, u), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), u;
    }(this.gl, e, 0, 0, 0, r, a);
  }

  downloadFloat32MatrixFromBuffer(e, t) {
    return function (e, t, n) {
      var s = e,
          r = new Float32Array(n);
      return s.bindBuffer(s.PIXEL_PACK_BUFFER, t), s.getBufferSubData(s.PIXEL_PACK_BUFFER, 0, r), s.bindBuffer(s.PIXEL_PACK_BUFFER, null), r;
    }(this.gl, e, t);
  }

  createBufferFromTexture(e, t, n) {
    this.bindTextureToFrameBuffer(e);

    var s = function (e, t, n, s) {
      var r = e.createBuffer();
      Py(e, () => e.bindBuffer(e.PIXEL_PACK_BUFFER, r));
      var a = 16 * t * n;
      return Py(e, () => e.bufferData(e.PIXEL_PACK_BUFFER, a, e.STREAM_READ)), Py(e, () => e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, 0)), Py(e, () => e.bindBuffer(e.PIXEL_PACK_BUFFER, null)), r;
    }(this.gl, t, n);

    return this.unbindTextureToFrameBuffer(), s;
  }

  createAndWaitForFence() {
    var e = this.createFence(this.gl);
    return this.pollFence(e);
  }

  createFence(e) {
    var t, n;

    if (V().getBool("WEBGL_FENCE_API_ENABLED")) {
      var _s209 = e,
          _r154 = _s209.fenceSync(_s209.SYNC_GPU_COMMANDS_COMPLETE, 0);

      e.flush(), n = () => {
        var e = _s209.clientWaitSync(_r154, 0, 0);

        return e === _s209.ALREADY_SIGNALED || e === _s209.CONDITION_SATISFIED;
      }, t = _r154;
    } else V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), this.endQuery(), n = () => this.isQueryAvailable(t, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : n = () => !0;

    return {
      query: t,
      isFencePassed: n
    };
  }

  downloadMatrixFromPackedTexture(e, t, n) {
    return this.downloadMatrixDriver(e, () => function (e, t, n) {
      var s = new Float32Array(t * n * 4);
      return Py(e, () => e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, s)), s;
    }(this.gl, t, n));
  }

  createProgram(e) {
    this.throwIfDisposed();

    var t = this.gl,
        n = function (e, t) {
      var n = Xy(e, () => e.createShader(e.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
      if (Py(e, () => e.shaderSource(n, t)), Py(e, () => e.compileShader(n)), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw function (e, t) {
        var n = Vy.exec(t);
        if (null == n) return console.log("Couldn't parse line number in error: ".concat(t)), void console.log(e);
        var s = +n[1],
            r = e.split("\n"),
            a = r.length.toString().length + 2,
            i = r.map((e, t) => m((t + 1).toString(), a) + e);
        var o = 0;

        for (var _e425 = 0; _e425 < i.length; _e425++) {
          o = Math.max(i[_e425].length, o);
        }

        var l = i.slice(0, s - 1),
            u = i.slice(s - 1, s),
            c = i.slice(s);
        console.log(l.join("\n")), console.log(t.split("\n")[0]), console.log("%c ".concat(m(u[0], o)), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(c.join("\n"));
      }(t, e.getShaderInfoLog(n)), new Error("Failed to compile fragment shader.");
      return n;
    }(t, e);

    null == this.vertexShader && (this.vertexShader = function (e) {
      var t = lk();
      return function (e, t) {
        var n = Xy(e, () => e.createShader(e.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
        if (Py(e, () => e.shaderSource(n, t)), Py(e, () => e.compileShader(n)), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw console.log(e.getShaderInfoLog(n)), new Error("Failed to compile vertex shader.");
        return n;
      }(e, "".concat(t.version, "\n    precision highp float;\n    ").concat(t.attribute, " vec3 clipSpacePos;\n    ").concat(t.attribute, " vec2 uv;\n    ").concat(t.varyingVs, " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"));
    }(t));

    var s = function (e) {
      return Xy(e, () => e.createProgram(), "Unable to create WebGLProgram.");
    }(t);

    return Py(t, () => t.attachShader(s, this.vertexShader)), Py(t, () => t.attachShader(s, n)), function (e, t) {
      if (Py(e, () => e.linkProgram(t)), !1 === e.getProgramParameter(t, e.LINK_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.");
    }(t, s), this.debug && Gy(t, s), this.vertexAttrsAreBound || (this.setProgram(s), this.vertexAttrsAreBound = function (e, t, n) {
      return Py(e, () => e.bindBuffer(e.ARRAY_BUFFER, n)), Hy(e, t, "clipSpacePos", n, 3, 20, 0) && Hy(e, t, "uv", n, 2, 20, 12);
    }(t, this.program, this.vertexBuffer)), s;
  }

  deleteProgram(e) {
    this.throwIfDisposed(), e === this.program && (this.program = null), null != e && Py(this.gl, () => this.gl.deleteProgram(e));
  }

  setProgram(e) {
    this.throwIfDisposed(), this.program = e, null != this.program && this.debug && Gy(this.gl, this.program), Py(this.gl, () => this.gl.useProgram(e));
  }

  getUniformLocation(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    return this.throwIfDisposed(), n ? function (e, t, n) {
      return Xy(e, () => e.getUniformLocation(t, n), 'uniform "' + n + '" not present in program.');
    }(this.gl, e, t) : function (e, t, n) {
      return e.getUniformLocation(t, n);
    }(this.gl, e, t);
  }

  getAttributeLocation(e, t) {
    return this.throwIfDisposed(), Py(this.gl, () => this.gl.getAttribLocation(e, t));
  }

  getUniformLocationNoThrow(e, t) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(e, t);
  }

  setInputMatrixTexture(e, t, n) {
    this.throwIfDisposed(), this.throwIfNoProgram(), function (e, t, n, s) {
      Py(e, () => function (e, t, n) {
        !function (e, t) {
          var n = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
              s = t + e.TEXTURE0;
          if (s < e.TEXTURE0 || s > n) throw new Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE".concat(n, "]."));
        }(e, n), Py(e, () => e.activeTexture(e.TEXTURE0 + n)), Py(e, () => e.bindTexture(e.TEXTURE_2D, t));
      }(e, t, s)), Py(e, () => e.uniform1i(n, s));
    }(this.gl, e, t, n);
  }

  setOutputMatrixTexture(e, t, n) {
    this.setOutputMatrixTextureDriver(e, n, t);
  }

  setOutputPackedMatrixTexture(e, t, n) {
    this.throwIfDisposed();
    var [s, r] = zy(t, n);
    this.setOutputMatrixTextureDriver(e, s, r);
  }

  setOutputMatrixWriteRegion(e, t, n, s) {
    this.setOutputMatrixWriteRegionDriver(n, e, s, t);
  }

  setOutputPackedMatrixWriteRegion(e, t, n, s) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }

  debugValidate() {
    null != this.program && Gy(this.gl, this.program), Ky(this.gl);
  }

  executeProgram() {
    this.throwIfDisposed(), this.throwIfNoProgram();
    var e = this.gl;
    this.debug && this.debugValidate(), Py(e, () => e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
  }

  blockUntilAllProgramsCompleted() {
    this.throwIfDisposed(), Py(this.gl, () => this.gl.finish());
  }

  getQueryTimerExtension() {
    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = Uy(this.gl, 2 === V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }

  getQueryTimerExtensionWebGL2() {
    return this.getQueryTimerExtension();
  }

  getQueryTimerExtensionWebGL1() {
    return this.getQueryTimerExtension();
  }

  beginQuery() {
    if (2 === V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var _e426 = this.gl,
          _t352 = this.getQueryTimerExtensionWebGL2(),
          _n261 = _e426.createQuery();

      return _e426.beginQuery(_t352.TIME_ELAPSED_EXT, _n261), _n261;
    }

    var e = this.getQueryTimerExtensionWebGL1(),
        t = e.createQueryEXT();
    return e.beginQueryEXT(e.TIME_ELAPSED_EXT, t), t;
  }

  endQuery() {
    if (2 === V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var _e427 = this.gl,
          _t353 = this.getQueryTimerExtensionWebGL2();

      return void _e427.endQuery(_t353.TIME_ELAPSED_EXT);
    }

    var e = this.getQueryTimerExtensionWebGL1();
    e.endQueryEXT(e.TIME_ELAPSED_EXT);
  }

  waitForQueryAndGetTime(e) {
    var _this72 = this;

    return _asyncToGenerator(function* () {
      return yield b(() => _this72.disposed || _this72.isQueryAvailable(e, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), _this72.getQueryTime(e, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    })();
  }

  getQueryTime(e, t) {
    if (0 === t) return null;

    if (2 === t) {
      var _t354 = this.gl;
      return _t354.getQueryParameter(e, _t354.QUERY_RESULT) / 1e6;
    }

    {
      var _t355 = this.getQueryTimerExtensionWebGL1();

      return _t355.getQueryObjectEXT(e, _t355.QUERY_RESULT_EXT) / 1e6;
    }
  }

  isQueryAvailable(e, t) {
    if (0 === t) return !0;

    if (2 === t) {
      var _t356 = this.gl,
          _n262 = this.getQueryTimerExtensionWebGL2(),
          _s210 = _t356.getQueryParameter(e, _t356.QUERY_RESULT_AVAILABLE);

      return null == this.disjoint && (this.disjoint = this.gl.getParameter(_n262.GPU_DISJOINT_EXT)), _s210 && !this.disjoint;
    }

    {
      var _t357 = this.getQueryTimerExtensionWebGL1(),
          _n263 = _t357.getQueryObjectEXT(e, _t357.QUERY_RESULT_AVAILABLE_EXT);

      return null == this.disjoint && (this.disjoint = this.gl.getParameter(_t357.GPU_DISJOINT_EXT)), _n263 && !this.disjoint;
    }
  }

  pollFence(e) {
    return new Promise(t => {
      this.addItemToPoll(() => e.isFencePassed(), () => t());
    });
  }

  pollItems() {
    var e = function (e) {
      var t = 0;

      for (; t < e.length && e[t](); ++t) {
        ;
      }

      return t - 1;
    }(this.itemsToPoll.map(e => e.isDoneFn));

    for (var _t358 = 0; _t358 <= e; ++_t358) {
      var {
        resolveFn: _e428
      } = this.itemsToPoll[_t358];

      _e428();
    }

    this.itemsToPoll = this.itemsToPoll.slice(e + 1);
  }

  addItemToPoll(e, t) {
    this.itemsToPoll.push({
      isDoneFn: e,
      resolveFn: t
    }), this.itemsToPoll.length > 1 || b(() => (this.pollItems(), 0 === this.itemsToPoll.length));
  }

  bindTextureToFrameBuffer(e) {
    this.throwIfDisposed(), jy(this.gl, e, this.framebuffer), this.debug && Ky(this.gl);
  }

  unbindTextureToFrameBuffer() {
    null != this.outputTexture ? (jy(this.gl, this.outputTexture, this.framebuffer), this.debug && Ky(this.gl)) : qy(this.gl, this.framebuffer);
  }

  downloadMatrixDriver(e, t) {
    this.bindTextureToFrameBuffer(e);
    var n = t();
    return this.unbindTextureToFrameBuffer(), n;
  }

  setOutputMatrixTextureDriver(e, t, n) {
    this.throwIfDisposed();
    var s = this.gl;
    jy(s, e, this.framebuffer), this.debug && Ky(s), this.outputTexture = e, Py(s, () => s.viewport(0, 0, t, n)), Py(s, () => s.scissor(0, 0, t, n));
  }

  setOutputMatrixWriteRegionDriver(e, t, n, s) {
    this.throwIfDisposed(), Py(this.gl, () => this.gl.scissor(e, t, n, s));
  }

  throwIfDisposed() {
    if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
  }

  throwIfNoProgram() {
    if (null == this.program) throw new Error("No GPU program is currently set.");
  }

}

var {
  getBroadcastDims: Ck
} = sl;

function Sk(e, t, n) {
  var s = [];

  if (e.forEach(e => {
    var t = d(e.shapeInfo.logicalShape);

    if (e.shapeInfo.isUniform ? s.push("uniform float ".concat(e.name).concat(t > 1 ? "[".concat(t, "]") : "", ";")) : (s.push("uniform sampler2D ".concat(e.name, ";")), s.push("uniform int offset".concat(e.name, ";"))), n.enableShapeUniforms) {
      var {
        uniformShape: _t359
      } = Lk(n.packedInputs, e.shapeInfo.logicalShape, e.shapeInfo.texShape);

      switch (_t359.length) {
        case 1:
          s.push("uniform int ".concat(e.name, "Shape;"));
          break;

        case 2:
          s.push("uniform ivec2 ".concat(e.name, "Shape;"));
          break;

        case 3:
          s.push("uniform ivec3 ".concat(e.name, "Shape;"));
          break;

        case 4:
          s.push("uniform ivec4 ".concat(e.name, "Shape;"));
      }

      s.push("uniform ivec2 ".concat(e.name, "TexShape;"));
    }
  }), n.enableShapeUniforms) {
    switch (t.logicalShape.length) {
      case 1:
        s.push("uniform int outShape;");
        break;

      case 2:
        s.push("uniform ivec2 outShape;"), s.push("uniform int outShapeStrides;");
        break;

      case 3:
        s.push("uniform ivec3 outShape;"), s.push("uniform ivec2 outShapeStrides;");
        break;

      case 4:
        s.push("uniform ivec4 outShape;"), s.push("uniform ivec3 outShapeStrides;");
    }

    s.push("uniform ivec2 outTexShape;");
  }

  n.customUniforms && n.customUniforms.forEach(e => {
    s.push("uniform ".concat(e.type, " ").concat(e.name).concat(e.arrayIndex ? "[".concat(e.arrayIndex, "]") : "", ";"));
  });

  var r = s.join("\n"),
      a = e.map(e => function (e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = "";
    return r += n ? Ek(e, s) : Tk(e, s), e.shapeInfo.logicalShape.length <= t.logicalShape.length && (r += n ? function (e, t) {
      var n = e.name,
          s = n.charAt(0).toUpperCase() + n.slice(1),
          r = "get" + s + "AtOutCoords",
          a = e.shapeInfo.logicalShape.length,
          i = t.logicalShape.length,
          o = Ck(e.shapeInfo.logicalShape, t.logicalShape),
          l = Mk(i),
          u = i - a;
      var c;
      var h = ["x", "y", "z", "w", "u", "v"];
      c = 0 === a ? "" : i < 2 && o.length >= 1 ? "coords = 0;" : o.map(e => "coords.".concat(h[e + u], " = 0;")).join("\n");
      var p = "";
      p = i < 2 && a > 0 ? "coords" : e.shapeInfo.logicalShape.map((e, t) => "coords.".concat(h[t + u])).join(", ");
      var f = "return outputValue;";
      var g = 1 === d(e.shapeInfo.logicalShape),
          m = 1 === d(t.logicalShape);

      if (1 !== a || g || m) {
        if (g && !m) f = 1 === i ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";else if (o.length) {
          var _e429 = a - 2,
              _t360 = a - 1;

          o.indexOf(_e429) > -1 && o.indexOf(_t360) > -1 ? f = "return vec4(outputValue.x);" : o.indexOf(_e429) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : o.indexOf(_t360) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);");
        }
      } else f = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";

      return "\n    vec4 ".concat(r, "() {\n      ").concat(l, " coords = getOutputCoords();\n      ").concat(c, "\n      vec4 outputValue = get").concat(s, "(").concat(p, ");\n      ").concat(f, "\n    }\n  ");
    }(e, t) : function (e, t) {
      var n = e.name,
          s = n.charAt(0).toUpperCase() + n.slice(1),
          r = "get" + s + "AtOutCoords",
          a = e.shapeInfo.logicalShape.length,
          i = t.logicalShape.length;
      if (!e.shapeInfo.isUniform && a === i && null == e.shapeInfo.flatOffset && p(e.shapeInfo.texShape, t.texShape)) return "\n      float ".concat(r, "() {\n        return sampleTexture(").concat(n, ", resultUV);\n      }\n    ");
      var o = Mk(i),
          l = Ck(e.shapeInfo.logicalShape, t.logicalShape),
          u = i - a;
      var c;
      var h = ["x", "y", "z", "w", "u", "v"];
      c = 0 === a ? "" : i < 2 && l.length >= 1 ? "coords = 0;" : l.map(e => "coords.".concat(h[e + u], " = 0;")).join("\n");
      var d = "";
      return d = i < 2 && a > 0 ? "coords" : e.shapeInfo.logicalShape.map((e, t) => "coords.".concat(h[t + u])).join(", "), "\n    float ".concat(r, "() {\n      ").concat(o, " coords = getOutputCoords();\n      ").concat(c, "\n      return get").concat(s, "(").concat(d, ");\n    }\n  ");
    }(e, t)), r;
  }(e, t, n.packedInputs, n.enableShapeUniforms)).join("\n"),
      i = t.texShape,
      o = lk(),
      l = function (e) {
    return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D, "(textureSampler, uv).r;\n    }\n  ");
  }(o);

  var u,
      c,
      h = function (e) {
    return "".concat(e.version, "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs, " vec2 resultUV;\n    ").concat(e.defineOutput, "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN, "\n    ").concat(e.defineSpecialInf, "\n    ").concat(e.defineRound, "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(Rk, "\n    ").concat(Ak, "\n    ").concat(Fk, "\n  ");
  }(o);

  return t.isPacked ? (u = function (e, t, n) {
    switch (e.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (e, t, n) {
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
          return 1 === s[0] ? n ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(s[1], ".0);\n      }\n    ") : 1 === s[1] ? n ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(s[0], ".0);\n      }\n    ") : n ? "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(s[0], ", ").concat(s[1], "));\n      return 2 * (resTexRC.x * ").concat(s[1], " + resTexRC.y);\n    }\n  ");
        }(0, t, n);

      case 2:
        return function (e, t, n) {
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
          if (p(e, t)) return n ? "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(s[0], ", ").concat(s[1], "));\n      }\n    ");
          var r = Math.ceil(e[1] / 2);
          return n ? "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(s[0], ", ").concat(s[1], "));\n\n      int index = resTexRC.x * ").concat(s[1], " + resTexRC.y;\n      int r = 2 * (index / ").concat(r, ");\n      int c = imod(index, ").concat(r, ") * 2;\n\n      return ivec2(r, c);\n    }\n  ");
        }(e, t, n);

      case 3:
        return function (e, t, n) {
          if (n) return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
              r = Math.ceil(e[2] / 2),
              a = r * Math.ceil(e[1] / 2);
          return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(s[0], ", ").concat(s[1], "));\n      int index = resTexRC.x * ").concat(s[1], " + resTexRC.y;\n\n      int b = index / ").concat(a, ";\n      index -= b * ").concat(a, ";\n\n      int r = 2 * (index / ").concat(r, ");\n      int c = imod(index, ").concat(r, ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ");
        }(e, t, n);

      default:
        return function (e, t, n) {
          if (n) return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
              r = Math.ceil(e[e.length - 1] / 2),
              a = r * Math.ceil(e[e.length - 2] / 2);
          var i = a,
              o = "",
              l = "b, r, c";

          for (var _t361 = 2; _t361 < e.length - 1; _t361++) {
            i *= e[e.length - _t361 - 1], o = "\n      int b".concat(_t361, " = index / ").concat(i, ";\n      index -= b").concat(_t361, " * ").concat(i, ";\n    ") + o, l = "b".concat(_t361, ", ") + l;
          }

          return "\n    ivec".concat(e.length, " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(s[0], ", ").concat(s[1], "));\n      int index = resTexRC.x * ").concat(s[1], " + resTexRC.y;\n\n      ").concat(o, "\n\n      int b = index / ").concat(a, ";\n      index -= b * ").concat(a, ";\n\n      int r = 2 * (index / ").concat(r, ");\n      int c = imod(index, ").concat(r, ") * 2;\n\n      return ivec").concat(e.length, "(").concat(l, ");\n    }\n  ");
        }(e, t, n);
    }
  }(t.logicalShape, i, n.enableShapeUniforms), c = function (e) {
    return "\n    void setOutput(vec4 val) {\n      ".concat(e.output, " = val;\n    }\n  ");
  }(o)) : (u = function (e, t, n) {
    switch (e.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (e, t, n) {
          return 1 === t[0] ? n ? "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1], ".0);\n      }\n    ") : 1 === t[1] ? n ? "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0], ".0);\n      }\n    ") : n ? "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      return resTexRC.x * ").concat(t[1], " + resTexRC.y;\n    }\n  ");
        }(0, t, n);

      case 2:
        return function (e, t, n) {
          return p(e, t) ? n ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0], ", ").concat(t[1], "));\n      }\n    ") : 1 === e[1] ? n ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0], ", ").concat(t[1], "));\n        int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ") : 1 === e[0] ? n ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0], ", ").concat(t[1], "));\n        int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ") : n ? "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      int r = index / ").concat(e[1], ";\n      int c = index - r * ").concat(e[1], ";\n      return ivec2(r, c);\n    }\n  ");
        }(e, t, n);

      case 3:
        return function (e, t, n) {
          if (n) return "\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(ck(["r", "c", "d"], e), "\n    return ivec3(r, c, d);\n  }\n");
          var s = uk(["r", "c", "d"], e);
          return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      ").concat(s, "\n      return ivec3(r, c, d);\n    }\n  ");
        }(e, t, n);

      case 4:
        return function (e, t, n) {
          if (n) return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(ck(["r", "c", "d", "d2"], e), "\n      return ivec4(r, c, d, d2);\n    }\n  ");
          var s = uk(["r", "c", "d", "d2"], e);
          return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      ").concat(s, "\n      return ivec4(r, c, d, d2);\n    }\n  ");
        }(e, t, n);

      case 5:
        return function (e, t) {
          var n = uk(["r", "c", "d", "d2", "d3"], e);
          return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0], ",\n                             ").concat(t[1], "));\n\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n\n      ").concat(n, "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ");
        }(e, t);

      case 6:
        return function (e, t) {
          var n = uk(["r", "c", "d", "d2", "d3", "d4"], e);
          return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n\n      ").concat(n, "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ");
        }(e, t);

      default:
        throw new Error("".concat(e.length, "-D output sampling is not yet supported"));
    }
  }(t.logicalShape, i, n.enableShapeUniforms), c = function (e) {
    return "\n    void setOutput(float val) {\n      ".concat(e.output, " = vec4(val, 0, 0, 0);\n    }\n  ");
  }(o)), n.packedInputs && (h += Dk), [h, l, c, r, u, a, n.userCode].join("\n");
}

function Tk(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  var n = e.shapeInfo.logicalShape;

  switch (n.length) {
    case 0:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1);
        if (e.shapeInfo.isUniform) return "float ".concat(s, "() {return ").concat(n, ";}");
        var [r, a] = e.shapeInfo.texShape;
        if (1 === r && 1 === a) return "\n      float ".concat(s, "() {\n        return sampleTexture(").concat(n, ", halfCR);\n      }\n    ");

        var i = _k(n);

        if (t) return "\n    float ".concat(s, "() {\n      vec2 uv = uvFromFlat(").concat(n, "TexShape[0], ").concat(n, "TexShape[1], ").concat(i, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
        var [o, l] = e.shapeInfo.texShape;
        return "\n    float ".concat(s, "() {\n      vec2 uv = uvFromFlat(").concat(o, ", ").concat(l, ", ").concat(i, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e, t);

    case 1:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1);
        if (e.shapeInfo.isUniform) return "\n      float ".concat(s, "(int index) {\n        ").concat(Ok(e), "\n      }\n    ");
        var r = e.shapeInfo.texShape,
            a = r[0],
            i = r[1];
        if (1 === i && 1 === a) return "\n      float ".concat(s, "(int index) {\n        return sampleTexture(").concat(n, ", halfCR);\n      }\n    ");

        var o = _k(n);

        return 1 === i ? t ? "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o, ") + 0.5) / float(").concat(n, "TexShape[0]));\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o, ") + 0.5) / ").concat(a, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : 1 === a ? t ? "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2((float(index + ").concat(o, ") + 0.5) / float(").concat(n, "TexShape[1]), 0.5);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2((float(index + ").concat(o, ") + 0.5) / ").concat(i, ".0, 0.5);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : t ? "\n    float ".concat(s, "(int index) {\n      vec2 uv = uvFromFlat(").concat(n, "TexShape[0], ").concat(n, "TexShape[1], index + ").concat(o, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ") : "\n    float ".concat(s, "(int index) {\n      vec2 uv = uvFromFlat(").concat(a, ", ").concat(i, ", index + ").concat(o, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e, t);

    case 2:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = e.shapeInfo.texShape;
        if (null != a && p(n, a)) return t ? "\n      float ".concat(r, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a[1], ".0, ").concat(a[0], ".0);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ");
        var {
          newShape: i,
          keptDims: o
        } = k(n);

        if (i.length < n.length) {
          var _n264 = ["row", "col"];
          return "\n      ".concat(Tk(zk(e, i), t), "\n      float ").concat(r, "(int row, int col) {\n        return ").concat(r, "(").concat(Bk(_n264, o), ");\n      }\n    ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1], ", 1)));\n        ").concat(Ok(e), "\n      }\n    ");

        var l = a[0],
            u = a[1],
            c = _k(s);

        return 1 === u ? t ? "\n      float ".concat(r, "(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(s, "Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(s, "TexShape[0]));\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(n[1], ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l, ".0);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ") : 1 === l ? t ? "\n      float ".concat(r, "(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(s, "Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(s, "TexShape[1]), 0.5);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(n[1], ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u, ".0, 0.5);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ") : t ? "\n      float ".concat(r, "(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(s, "Shape[1] + col + ").concat(c, ";\n        vec2 uv = uvFromFlat(").concat(s, "TexShape[0], ").concat(s, "TexShape[1], index);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n  float ".concat(r, "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1], " + col + ").concat(c, ";\n    vec2 uv = uvFromFlat(").concat(l, ", ").concat(u, ", index);\n    return sampleTexture(").concat(s, ", uv);\n  }\n");
      }(e, t);

    case 3:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = n[1] * n[2],
            i = n[2],
            {
          newShape: o,
          keptDims: l
        } = k(n);

        if (o.length < n.length) {
          var _n265 = ["row", "col", "depth"];
          return "\n        ".concat(Tk(zk(e, o), t), "\n        float ").concat(r, "(int row, int col, int depth) {\n          return ").concat(r, "(").concat(Bk(_n265, l), ");\n        }\n      ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(a, ", ").concat(i, ", 1)));\n        ").concat(Ok(e), "\n      }\n    ");
        var u = e.shapeInfo.texShape,
            c = u[0],
            h = u[1],
            d = e.shapeInfo.flatOffset;
        if (h === a && null == d) return t ? "\n      float ".concat(r, "(int row, int col, int depth) {\n        int stride1 = ").concat(s, "Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n        float ".concat(r, "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(i, ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(h, ".0, ").concat(c, ".0);\n          return sampleTexture(").concat(s, ", uv);\n        }\n      ");
        if (h === i && null == d) return t ? "\n      float ".concat(r, "(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(s, "Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1], ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(h, ".0, ").concat(c, ".0);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ");

        var p = _k(s);

        return t ? "\n    float ".concat(r, "(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(s, "Shape[1] * ").concat(s, "Shape[2];\n      int stride1 = ").concat(s, "Shape[2];\n      int index = row * ").concat(a, " + col * ").concat(i, " + depth + ").concat(p, ";\n      vec2 uv = uvFromFlat(").concat(s, "TexShape[0], ").concat(s, "TexShape[1], index);\n      return sampleTexture(").concat(s, ", uv);\n    }\n    ") : "\n      float ".concat(r, "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a, " + col * ").concat(i, " + depth + ").concat(p, ";\n        vec2 uv = uvFromFlat(").concat(c, ", ").concat(h, ", index);\n        return sampleTexture(").concat(s, ", uv);\n      }\n  ");
      }(e, t);

    case 4:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = n[3],
            i = n[2] * a,
            o = n[1] * i,
            {
          newShape: l,
          keptDims: u
        } = k(n);

        if (l.length < n.length) {
          var _n266 = ["row", "col", "depth", "depth2"];
          return "\n      ".concat(Tk(zk(e, l), t), "\n      float ").concat(r, "(int row, int col, int depth, int depth2) {\n        return ").concat(r, "(").concat(Bk(_n266, u), ");\n      }\n    ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(o, ", ").concat(i, ", ").concat(a, ", 1)));\n        ").concat(Ok(e), "\n      }\n    ");
        var c = e.shapeInfo.flatOffset,
            h = e.shapeInfo.texShape,
            d = h[0],
            p = h[1],
            f = "int stride2 = ".concat(s, "Shape[3];"),
            g = "int stride1 = ".concat(s, "Shape[2] * stride2;"),
            m = "int stride0 = ".concat(s, "Shape[1] * stride1;");
        if (p === o && null == c) return t ? "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        ").concat(f, "\n        ").concat(g, "\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(i, ", ").concat(a, ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ");
        if (p === a && null == c) return t ? "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(s, "Shape[1] * ").concat(s, "Shape[2], ").concat(s, "Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1] * n[2], ", ").concat(n[2], ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ");

        var b = _k(s);

        return t ? "\n    float ".concat(r, "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f, "\n      ").concat(g, "\n      ").concat(m, "\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(s, "TexShape[0], ").concat(s, "TexShape[1], index + ").concat(b, ");\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ") : "\n    float ".concat(r, "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o, " + col * ").concat(i, " +\n          depth * ").concat(a, " + depth2;\n      vec2 uv = uvFromFlat(").concat(d, ", ").concat(p, ", index + ").concat(b, ");\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ");
      }(e, t);

    case 5:
      return function (e) {
        var t = e.shapeInfo.logicalShape,
            n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            r = t[4],
            a = t[3] * r,
            i = t[2] * a,
            o = t[1] * i,
            {
          newShape: l,
          keptDims: u
        } = k(t);

        if (l.length < t.length) {
          var _t362 = ["row", "col", "depth", "depth2", "depth3"];
          return "\n      ".concat(Tk(zk(e, l)), "\n      float ").concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(s, "(").concat(Bk(_t362, u), ");\n      }\n    ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(o, ", ").concat(i, ", ").concat(a, ", ").concat(r, ")) +\n          depth3;\n        ").concat(Ok(e), "\n      }\n    ");
        var c = e.shapeInfo.flatOffset,
            h = e.shapeInfo.texShape,
            d = h[0],
            p = h[1];
        return p === o && null == c ? "\n      float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(i, ", ").concat(a, ", ").concat(r, ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : p === r && null == c ? "\n      float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1] * t[2] * t[3], ",\n               ").concat(t[2] * t[3], ", ").concat(t[3], ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n    float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o, " + col * ").concat(i, " + depth * ").concat(a, " +\n          depth2 * ").concat(r, " + depth3 + ").concat(_k(n), ";\n      vec2 uv = uvFromFlat(").concat(d, ", ").concat(p, ", index);\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e);

    case 6:
      return function (e) {
        var t = e.shapeInfo.logicalShape,
            n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            {
          newShape: r,
          keptDims: a
        } = k(t);

        if (r.length < t.length) {
          var _t363 = ["row", "col", "depth", "depth2", "depth3", "depth4"];
          return "\n      ".concat(Tk(zk(e, r)), "\n      float ").concat(s, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(s, "(").concat(Bk(_t363, a), ");\n      }\n    ");
        }

        var i = t[5],
            o = t[4] * i,
            l = t[3] * o,
            u = t[2] * l,
            c = t[1] * u;
        if (e.shapeInfo.isUniform) return "\n      float ".concat(s, "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(c, ", ").concat(u, ", ").concat(l, ", ").concat(o, ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(i, ", 1)));\n        ").concat(Ok(e), "\n      }\n    ");
        var h = e.shapeInfo.flatOffset,
            d = e.shapeInfo.texShape,
            p = d[0],
            f = d[1];
        return f === c && null == h ? "\n      float ".concat(s, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(u, ", ").concat(l, ", ").concat(o, ", ").concat(i, ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f, ".0, ").concat(p, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : f === i && null == h ? "\n      float ".concat(s, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1] * t[2] * t[3] * t[4], ",\n               ").concat(t[2] * t[3] * t[4], ",\n               ").concat(t[3] * t[4], ",\n               ").concat(t[4], ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f, ".0, ").concat(p, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n    float ".concat(s, "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(c, " + col * ").concat(u, " + depth * ").concat(l, " +\n          depth2 * ").concat(o, " + depth3 * ").concat(i, " + depth4 + ").concat(_k(n), ";\n      vec2 uv = uvFromFlat(").concat(p, ", ").concat(f, ", index);\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e);

    default:
      throw new Error("".concat(n.length, "-D input sampling is not yet supported"));
  }
}

function Ek(e, t) {
  switch (e.shapeInfo.logicalShape.length) {
    case 0:
      return function (e) {
        var t = e.name;
        return "\n    vec4 ".concat("get" + t.charAt(0).toUpperCase() + t.slice(1), "() {\n      return ").concat(lk().texture2D, "(").concat(t, ", halfCR);\n    }\n  ");
      }(e);

    case 1:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            r = e.shapeInfo.texShape,
            a = lk();
        if (t) return "\n    vec4 ".concat(s, "(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n, "TexShape[0]) / 2.0), ceil(float(").concat(n, "TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(a.texture2D, "(").concat(n, ", uv);\n    }\n  ");
        var i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)];
        return "\n    vec4 ".concat(s, "(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0], ", ").concat(i[1], ", index);\n      return ").concat(a.texture2D, "(").concat(n, ", uv);\n    }\n  ");
      }(e, t);

    case 2:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = e.shapeInfo.texShape,
            i = a[0],
            o = a[1],
            l = lk();
        if (null != a && p(n, a)) return t ? "\n      vec4 ".concat(r, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n\n        return ").concat(l.texture2D, "(").concat(s, ", uv);\n      }\n    ") : "\n      vec4 ".concat(r, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(o, ".0, ").concat(i, ".0);\n\n        return ").concat(l.texture2D, "(").concat(s, ", uv);\n      }\n    ");
        if (t) return "\n    vec4 ".concat(r, "(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(s, "TexShape[0]) / 2.0), ceil(float(").concat(s, "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(s, "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(l.texture2D, "(").concat(s, ", uv);\n    }\n  ");
        var u = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];
        return "\n    vec4 ".concat(r, "(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(Math.ceil(n[1] / 2), ", ").concat(u[0], ", ").concat(u[1], ", row, col);\n      return ").concat(l.texture2D, "(").concat(s, ", uv);\n    }\n  ");
      }(e, t);

    case 3:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = e.shapeInfo.texShape,
            i = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];

        if (1 === n[0]) {
          var _s211 = [1, 2],
              _a122 = ["b", "row", "col"];
          return "\n        ".concat(Ek(zk(e, n.slice(1)), t), "\n        vec4 ").concat(r, "(int b, int row, int col) {\n          return ").concat(r, "(").concat(Bk(_a122, _s211), ");\n        }\n      ");
        }

        var o = lk();
        if (t) return "\n    vec4 ".concat(r, "(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(s, "TexShape[0]) / 2.0), ceil(float(").concat(s, "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(s, "Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(s, "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(o.texture2D, "(").concat(s, ", uv);\n    }\n  ");
        var l = i[0],
            u = i[1],
            c = Math.ceil(n[2] / 2);
        return "\n    vec4 ".concat(r, "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(l, ", ").concat(u, ", ").concat(c * Math.ceil(n[1] / 2), ", ").concat(c, ", b, row, col);\n      return ").concat(o.texture2D, "(").concat(s, ", uv);\n    }\n  ");
      }(e, t);

    default:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            r = lk();
        if (t) return "\n    vec4 ".concat(s, "(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n, "Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n, "Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n, "Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n, "TexShape[0]) / 2.0), ceil(float(").concat(n, "TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D, "(").concat(n, ", uv);\n    }\n  ");
        var a = e.shapeInfo.logicalShape,
            i = a.length,
            o = e.shapeInfo.texShape,
            l = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)],
            u = l[0],
            c = l[1],
            h = Math.ceil(a[i - 1] / 2);
        var d = h * Math.ceil(a[i - 2] / 2),
            p = "int b, int row, int col",
            f = "b * ".concat(d, " + (row / 2) * ").concat(h, " + (col / 2)");

        for (var _e430 = 2; _e430 < i - 1; _e430++) {
          p = "int b".concat(_e430, ", ") + p, d *= a[i - _e430 - 1], f = "b".concat(_e430, " * ").concat(d, " + ") + f;
        }

        return "\n    vec4 ".concat(s, "(").concat(p, ") {\n      int index = ").concat(f, ";\n      int texR = index / ").concat(c, ";\n      int texC = index - texR * ").concat(c, ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(c, ", ").concat(u, ");\n      return ").concat(r.texture2D, "(").concat(n, ", uv);\n    }\n  ");
      }(e, t);
  }
}

var Rk = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    Ak = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    Fk = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    Dk = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

function _k(e) {
  return "offset".concat(e);
}

function Ok(e) {
  var t = e.name,
      n = d(e.shapeInfo.logicalShape);
  return n < 2 ? "return ".concat(t, ";") : "\n    for (int i = 0; i < ".concat(n, "; i++) {\n      if (i == index) {\n        return ").concat(t, "[i];\n      }\n    }\n  ");
}

function Mk(e) {
  if (e <= 1) return "int";
  if (2 === e) return "ivec2";
  if (3 === e) return "ivec3";
  if (4 === e) return "ivec4";
  if (5 === e) return "ivec5";
  if (6 === e) return "ivec6";
  throw Error("GPU for rank ".concat(e, " is not yet supported"));
}

function Lk(e, t, n) {
  var {
    newShape: s
  } = k(t),
      r = t.length,
      a = e && 3 === r && 1 === t[0],
      i = a ? t.slice(1) : s,
      o = !e && r > 1 && !p(t, n) && s.length < r || a;
  return {
    useSqueezeShape: o,
    uniformShape: o ? i : t
  };
}

function zk(e, t) {
  var n = JSON.parse(JSON.stringify(e));
  return n.shapeInfo.logicalShape = t, n;
}

function Bk(e, t) {
  return t.map(t => e[t]).join(", ");
}

function Pk(e, t) {
  if (e.length !== t.length) throw Error("Binary was compiled with ".concat(e.length, " inputs, but was executed with ").concat(t.length, " inputs"));
  e.forEach((e, n) => {
    var s = e.logicalShape,
        r = t[n],
        a = r.shape;
    if (!p(s, a)) throw Error("Binary was compiled with different shapes than the current args. Shapes ".concat(s, " and ").concat(a, " must match"));
    if (e.isUniform && r.isUniform) return;
    var i = e.texShape,
        o = r.isUniform ? null : r.texData.texShape;
    if (!p(i, o)) throw Error("Binary was compiled with different texture shapes than the current args. Shape ".concat(i, " and ").concat(o, " must match"));
  });
}

function Wk(e) {
  return V().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e <= 4;
}

var {
  addImpl: Uk,
  bincountImpl: Vk,
  bincountReduceImpl: Gk,
  ceilImpl: Hk,
  concatImpl: jk,
  equalImpl: qk,
  expImpl: Kk,
  expm1Impl: Xk,
  floorImpl: Yk,
  gatherNdImpl: Jk,
  gatherV2Impl: Zk,
  greaterImpl: Qk,
  greaterEqualImpl: ew,
  lessImpl: tw,
  lessEqualImpl: nw,
  linSpaceImpl: sw,
  logImpl: rw,
  maxImpl: aw,
  maximumImpl: iw,
  minimumImpl: ow,
  multiplyImpl: lw,
  negImpl: uw,
  notEqualImpl: cw,
  prodImpl: hw,
  rangeImpl: dw,
  rsqrtImpl: pw,
  simpleAbsImpl: fw,
  sliceImpl: gw,
  sparseFillEmptyRowsImpl: mw,
  sparseReshapeImpl: bw,
  sparseSegmentReductionImpl: xw,
  stridedSliceImpl: yw,
  stringNGramsImpl: kw,
  stringSplitImpl: ww,
  stringToHashBucketFastImpl: vw,
  subImpl: Iw,
  tileImpl: $w,
  topKImpl: Nw,
  transposeImpl: Cw,
  uniqueImpl: Sw
} = $m;

function Tw(e, t) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, t).map(t => "".concat(e, ".").concat(t));
}

function Ew(e, t) {
  return 1 === t ? [e] : Tw(e, t);
}

class Rw {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = e;
    var t = e.length;
    if (0 === t) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else {
      var _n267 = Ew("rc", t),
          _s212 = Mk(t),
          _r155 = function (e, t, n) {
        if (1 === e) return "rc > ".concat(t[0]);
        var s = "";

        for (var _r156 = e - 2; _r156 < e; _r156++) {
          s += "".concat(n[_r156], " >= ").concat(t[_r156]), _r156 < e - 1 && (s += "||");
        }

        return s;
      }(t, e, _n267),
          _a123 = function (e, t, n, s) {
        if (1 === e) return "";
        var r = s.slice(-2);
        return "\n    int r = ".concat(r[0], ";\n    int c = ").concat(r[1], ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ").concat(t, ";\n    bool rEdge = rp1 >= ").concat(n, ";\n  ");
      }(t, e[e.length - 1], e[e.length - 2], _n267),
          _i86 = function (e, t) {
        var n = e.length,
            s = function (e, t) {
          var n = [];

          for (var _s213 = 0; _s213 <= 1; _s213++) {
            for (var _r157 = 0; _r157 <= 1; _r157++) {
              var _a124 = "".concat(0 === _s213 ? "r" : "rp1", ", ").concat(0 === _r157 ? "c" : "cp1");

              for (var _n268 = 2; _n268 < e; _n268++) {
                _a124 = "".concat(t[t.length - 1 - _n268], ",") + _a124;
              }

              n.push(_a124);
            }
          }

          return n;
        }(n, t);

        return 1 === n ? "getA(rc),\n            rc + 1 >= ".concat(e[0], " ? 0. : getA(rc + 1),\n            0, 0") : "getA(".concat(s[0], "),\n          cEdge ? 0. : getA(").concat(s[1], "),\n          rEdge ? 0. : getA(").concat(s[2], "),\n          rEdge || cEdge ? 0. : getA(").concat(s[3], ")");
      }(e, _n267);

      this.userCode = "\n        void main() {\n          ".concat(_s212, " rc = getOutputCoords();\n\n          if(").concat(_r155, ") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(_a123, "\n\n            setOutput(vec4(").concat(_i86, "));\n          }\n        }\n      ");
    }
  }

}

class Aw {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
    var n = "";

    for (var _e431 = 0; _e431 < 4; _e431++) {
      var _t364 = "thisRC = rc;";
      _e431 % 2 == 1 && (_t364 += "thisRC.z += 1;"), _e431 > 1 && (_t364 += "thisRC.y += 1;"), n += "\n        ".concat(_t364, "\n        ").concat(_e431 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "", "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(_e431, "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(_e431 > 0 ? "}" : "", "\n      ");
    }

    var s;
    this.userCode = "\n      ".concat((s = t, "\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(uk(["r", "c", "d"], s), "\n      return ivec3(r, c, d);\n    }\n  ")), "\n      ").concat(hk(e), "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(e[1], ";\n        int cols = ").concat(e[2], ";\n\n        ").concat(n, "\n\n        setOutput(result);\n      }\n    ");
  }

}

class Fw {
  constructor(e) {
    this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};
  }

  acquireTexture(e, t, n) {
    var s = _w(t, n),
        r = Ow(e, s, n);

    r in this.freeTextures || (this.freeTextures[r] = []), r in this.usedTextures || (this.usedTextures[r] = []);
    var a = Dw(e, s, this.gpgpu.gl, this.gpgpu.textureConfig, n);

    if (this.freeTextures[r].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= a, this.log();

      var _e432 = this.freeTextures[r].shift();

      return this.usedTextures[r].push(_e432), _e432;
    }

    var i;
    return s === Oy.PACKED_2X2_FLOAT32 ? i = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : s === Oy.PACKED_2X2_FLOAT16 ? i = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : s === Oy.UNPACKED_FLOAT32 ? i = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : s === Oy.UNPACKED_FLOAT16 ? i = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : s === Oy.PACKED_4X1_UNSIGNED_BYTE && (i = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[r].push(i), this.numUsedTextures++, this._numBytesAllocated += a, this.log(), i;
  }

  releaseTexture(e, t, n, s) {
    if (null == this.freeTextures) return;

    var r = _w(n, s),
        a = Ow(t, r, s);

    a in this.freeTextures || (this.freeTextures[a] = []);
    var i = Dw(t, r, this.gpgpu.gl, this.gpgpu.textureConfig, s),
        o = V().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
    -1 !== o && this._numBytesAllocated > o ? (this.gpgpu.deleteMatrixTexture(e), this._numBytesAllocated -= i) : (this.freeTextures[a].push(e), this.numFreeTextures++, this._numBytesFree += i), this.numUsedTextures--;
    var l = this.usedTextures[a],
        u = l.indexOf(e);
    if (u < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
    l.splice(u, 1), this.log();
  }

  log() {
    if (!this.logEnabled) return;
    console.log("Free/Used", "".concat(this.numFreeTextures, " / ").concat(this.numUsedTextures), "(".concat(this.numFreeTextures + this.numUsedTextures, ")"));
    var e = this._numBytesFree / this._numBytesAllocated;
    console.log("Bytes allocated: ".concat(this._numBytesAllocated)), console.log("Bytes unused: ".concat(this._numBytesFree, " (").concat(Math.round(100 * e), "%)"));
  }

  get numBytesAllocated() {
    return this._numBytesAllocated;
  }

  get numBytesFree() {
    return this._numBytesFree;
  }

  getNumUsedTextures() {
    return this.numUsedTextures;
  }

  getNumFreeTextures() {
    return this.numFreeTextures;
  }

  dispose() {
    if (null != this.freeTextures) {
      for (var _e433 in this.freeTextures) {
        this.freeTextures[_e433].forEach(e => {
          this.gpgpu.deleteMatrixTexture(e);
        });
      }

      for (var _e434 in this.usedTextures) {
        this.usedTextures[_e434].forEach(e => {
          this.gpgpu.deleteMatrixTexture(e);
        });
      }

      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
    }
  }

}

function Dw(e, t, n, s, r) {
  var a = function (e, t) {
    switch (e) {
      case Oy.PACKED_2X2_FLOAT32:
        return Ik(t);

      case Oy.PACKED_2X2_FLOAT16:
        return $k(t);

      case Oy.UNPACKED_FLOAT32:
        return kk(t);

      case Oy.UNPACKED_FLOAT16:
        return wk(t);

      case Oy.PACKED_4X1_UNSIGNED_BYTE:
        return vk(t);

      default:
        throw new Error("Unknown physical texture type ".concat(e));
    }
  }(t, s);

  var i;

  if (r) {
    var [_t365, _n269] = zy(e[0], e[1]);
    i = _t365 * _n269;
  } else {
    var [_t366, _n270] = My(e[0], e[1]);
    i = _t366 * _n270;
  }

  return i * function (e, t) {
    if (t === e.R32F) return 4;
    if (t === e.R16F) return 2;
    if (t === e.RGBA32F) return 16;
    if (t === e.RGBA) return 16;
    if (t === e.RGBA16F) return 8;
    throw new Error("Unknown internal format ".concat(t));
  }(n, a);
}

function _w(e, t) {
  if (e === _y.UPLOAD) return Oy.PACKED_2X2_FLOAT32;
  if (e === _y.RENDER || null == e) return function (e) {
    return V().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? e ? Oy.PACKED_2X2_FLOAT32 : Oy.UNPACKED_FLOAT32 : e ? Oy.PACKED_2X2_FLOAT16 : Oy.UNPACKED_FLOAT16;
  }(t);
  if (e === _y.DOWNLOAD || e === _y.PIXELS) return Oy.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type ".concat(e));
}

function Ow(e, t, n) {
  return "".concat(e[0], "_").concat(e[1], "_").concat(t, "_").concat(n);
}

class Mw {
  constructor(e, t) {
    this.variableNames = ["A"], this.outputShape = e, this.enableShapeUniforms = Wk(this.outputShape.length), this.userCode = "\n      float unaryOperation(float x) {\n        ".concat(t, "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
  }

}

var Lw = "return x;";

class zw {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.enableShapeUniforms = Wk(this.outputShape.length), this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t, "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
  }

}

class Bw {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = e;

    var t = e.length,
        n = Ew("rc", t),
        s = Mk(t),
        r = function (e, t) {
      if (1 === e) return "rc";
      var n = "";

      for (var _s214 = 0; _s214 < e; _s214++) {
        n += t[_s214], _s214 < e - 1 && (n += ",");
      }

      return n;
    }(t, n),
        a = n.slice(-2),
        i = t <= 1 ? "rc" : "vec2(".concat(a.join(","), ")");

    this.userCode = "\n      void main() {\n        ".concat(s, " rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r, ");\n\n        setOutput(getChannel(packedInput, ").concat(i, "));\n      }\n    ");
  }

}

var Pw = Ii,
    Ww = {},
    Uw = V().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");

class Vw extends n {
  constructor(e) {
    if (super(), this.pendingRead = new WeakMap(), this.pendingDisposal = new WeakSet(), this.dataRefCount = new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = !1, this.pendingDeletes = 0, this.disposed = !1, !V().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");

    if (null == e) {
      var _e435 = Fy(V().getNumber("WEBGL_VERSION"));

      this.binaryCache = ((n = V().getNumber("WEBGL_VERSION")) in Ww || (Ww[n] = {}), Ww[n]), this.gpgpu = new Nk(_e435), this.canvas = _e435.canvas, this.gpgpuCreatedLocally = !0;
    } else this.gpgpu = e, this.binaryCache = {}, this.gpgpuCreatedLocally = !1, this.canvas = e.gl.canvas;

    var n;
    this.textureManager = new Fw(this.gpgpu), this.numMBBeforeWarning = null == V().global.screen ? 1024 : V().global.screen.height * V().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024, this.texData = new t(this, Kn());
  }

  nextDataId() {
    return Vw.nextDataId++;
  }

  numDataIds() {
    return this.texData.numDataIds() - this.pendingDeletes;
  }

  write(e, t, n) {
    if ((V().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || V().getBool("DEBUG")) && this.checkNumericalProblems(e), "complex64" === n && null != e) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    var s = {
      id: this.nextDataId()
    };
    return this.texData.set(s, {
      shape: t,
      dtype: n,
      values: e,
      usage: _y.UPLOAD,
      refCount: 1
    }), s;
  }

  refCount(e) {
    return this.texData.has(e) ? this.texData.get(e).refCount : 0;
  }

  incRef(e) {
    this.texData.get(e).refCount++;
  }

  decRef(e) {
    this.texData.has(e) && this.texData.get(e).refCount--;
  }

  move(e, t, n, s, r) {
    if (V().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === s) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(e, {
      shape: n,
      dtype: s,
      values: t,
      usage: _y.UPLOAD,
      refCount: r
    });
  }

  disposeIntermediateTensorInfo(e) {
    this.disposeData(e.dataId);
  }

  readSync(e) {
    var t = this.texData.get(e),
        {
      values: n,
      dtype: s,
      complexTensorInfos: r,
      slice: a,
      shape: i,
      isPacked: o
    } = t;

    if (null != a) {
      var _t367;

      _t367 = o ? new zw(i, Lw) : new Mw(i, Lw);

      var _n271 = this.runWebGLProgram(_t367, [{
        dataId: e,
        shape: i,
        dtype: s
      }], s),
          _r158 = this.readSync(_n271.dataId);

      return this.disposeIntermediateTensorInfo(_n271), _r158;
    }

    if (null != n) return this.convertAndCacheOnCPU(e);
    if ("string" === s) return n;
    var l = null != this.activeTimers;
    var u, c;
    return l && (u = Ve()), c = "complex64" === s ? Mo(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.getValuesFromTexture(e), l && (this.downloadWaitMs += Ve() - u), this.convertAndCacheOnCPU(e, c);
  }

  read(e) {
    var _this73 = this;

    return _asyncToGenerator(function* () {
      if (_this73.pendingRead.has(e)) {
        var _t368 = _this73.pendingRead.get(e);

        return new Promise(e => _t368.push(e));
      }

      var t = _this73.texData.get(e),
          {
        values: n,
        shape: s,
        slice: r,
        dtype: a,
        complexTensorInfos: i,
        isPacked: o
      } = t;

      if (null != r) {
        var _t369;

        _t369 = o ? new zw(s, Lw) : new Mw(s, Lw);

        var _n272 = _this73.runWebGLProgram(_t369, [{
          dataId: e,
          shape: s,
          dtype: a
        }], a),
            _r159 = _this73.read(_n272.dataId);

        return _this73.disposeIntermediateTensorInfo(_n272), _r159;
      }

      if (null != n) return _this73.convertAndCacheOnCPU(e);
      if (!V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === V().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
      var l,
          u,
          c = null;

      if ("complex64" !== a && V().get("WEBGL_BUFFER_SUPPORTED")) {
        l = _this73.decode(e);

        var _t370 = _this73.texData.get(l.dataId);

        c = _this73.gpgpu.createBufferFromTexture(_t370.texture, ...Ly(s));
      }

      if (_this73.pendingRead.set(e, []), "complex64" !== a && (yield _this73.gpgpu.createAndWaitForFence()), "complex64" === a) {
        var _e436 = yield Promise.all([_this73.read(i.real.dataId), _this73.read(i.imag.dataId)]);

        u = Mo(_e436[0], _e436[1]);
      } else if (null == c) u = _this73.getValuesFromTexture(e);else {
        var _e437 = d(s);

        u = _this73.gpgpu.downloadFloat32MatrixFromBuffer(c, _e437);
      }

      if (null != l && _this73.disposeIntermediateTensorInfo(l), null != c) {
        var _e438 = _this73.gpgpu.gl;
        Py(_e438, () => _e438.deleteBuffer(c));
      }

      var h = _this73.convertAndCacheOnCPU(e, u),
          p = _this73.pendingRead.get(e);

      return _this73.pendingRead.delete(e), p.forEach(e => e(h)), _this73.pendingDisposal.has(e) && (_this73.pendingDisposal.delete(e), _this73.disposeData(e) && Kn().removeDataId(e, _this73), _this73.pendingDeletes--), h;
    })();
  }

  bufferSync(e) {
    var t = this.readSync(e.dataId);
    var n = t;
    if ("string" === e.dtype) try {
      n = t.map(e => He(e));
    } catch (e) {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return dn(e.shape, e.dtype, n);
  }

  checkNumericalProblems(e) {
    if (null != e) for (var _t371 = 0; _t371 < e.length; _t371++) {
      var _n273 = e[_t371];

      if (!Wy(_n273)) {
        if (V().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value ".concat(_n273, " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"));
        throw Error("The value ".concat(_n273, " cannot be represented on this device."));
      }
    }
  }

  getValuesFromTexture(e) {
    var {
      shape: t,
      dtype: n,
      isPacked: s
    } = this.texData.get(e),
        r = d(t);

    if (V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      var _n274 = this.decode(e),
          _s215 = this.texData.get(_n274.dataId),
          _a125 = this.gpgpu.downloadMatrixFromPackedTexture(_s215.texture, ...Ly(t)).subarray(0, r);

      return this.disposeIntermediateTensorInfo(_n274), _a125;
    }

    var a = V().getBool("WEBGL_PACK") && !0 === s,
        i = a ? Zy(t) : t,
        o = a ? new mk(i) : new gk(i),
        l = this.runWebGLProgram(o, [{
      shape: i,
      dtype: n,
      dataId: e
    }], "float32"),
        u = this.texData.get(l.dataId),
        c = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture, u.texShape[0], u.texShape[1]).subarray(0, r);
    return this.disposeIntermediateTensorInfo(l), c;
  }

  timerAvailable() {
    return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
  }

  time(e) {
    var _this74 = this;

    return _asyncToGenerator(function* () {
      var t = _this74.activeTimers,
          n = [];
      var s = !1;
      null == _this74.programTimersStack ? (_this74.programTimersStack = n, s = !0) : _this74.activeTimers.push(n), _this74.activeTimers = n, e();
      var r = h(_this74.activeTimers.map(e => e.query)).filter(e => null != e),
          a = h(_this74.activeTimers.map(e => e.name)).filter(e => null != e);
      _this74.activeTimers = t, s && (_this74.programTimersStack = null);
      var i = {
        uploadWaitMs: _this74.uploadWaitMs,
        downloadWaitMs: _this74.downloadWaitMs,
        kernelMs: null,
        wallMs: null
      };

      if (V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        var _e439 = yield Promise.all(r);

        i.kernelMs = function (e) {
          var t = 0;

          for (var _n275 = 0; _n275 < e.length; _n275++) {
            t += e[_n275];
          }

          return t;
        }(_e439), i.getExtraProfileInfo = () => _e439.map((e, t) => ({
          name: a[t],
          ms: e
        })).map(e => "".concat(e.name, ": ").concat(e.ms)).join(", ");
      } else i.kernelMs = {
        error: "WebGL query timers are not supported in this environment."
      };

      return _this74.uploadWaitMs = 0, _this74.downloadWaitMs = 0, i;
    })();
  }

  memory() {
    return {
      unreliable: !1,
      numBytesInGPU: this.numBytesInGPU,
      numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
      numBytesInGPUFree: this.textureManager.numBytesFree
    };
  }

  startTimer() {
    return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
      startMs: Ve(),
      endMs: null
    };
  }

  endTimer(e) {
    return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = Ve(), e);
  }

  getQueryTime(e) {
    var _this75 = this;

    return _asyncToGenerator(function* () {
      return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? _this75.gpgpu.waitForQueryAndGetTime(e) : e.endMs - e.startMs;
    })();
  }

  disposeData(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    if (this.pendingDisposal.has(e)) return !1;
    if (!this.texData.has(e)) return !0;
    if (t ? this.texData.get(e).refCount = 0 : this.texData.get(e).refCount--, !t && this.texData.get(e).refCount > 0) return !1;
    if (this.pendingRead.has(e)) return this.pendingDisposal.add(e), this.pendingDeletes++, !1;
    this.releaseGPUData(e);
    var {
      complexTensorInfos: n
    } = this.texData.get(e);
    return null != n && (this.disposeData(n.real.dataId, t), this.disposeData(n.imag.dataId, t)), this.texData.delete(e), !0;
  }

  releaseGPUData(e) {
    var {
      texture: t,
      dtype: n,
      texShape: s,
      usage: r,
      isPacked: a,
      slice: i
    } = this.texData.get(e),
        o = i && i.origDataId || e,
        l = this.dataRefCount.get(o);
    l > 1 ? this.dataRefCount.set(o, l - 1) : (this.dataRefCount.delete(o), null != t && (this.numBytesInGPU -= this.computeBytes(s, n), this.textureManager.releaseTexture(t, s, r, a)));
    var u = this.texData.get(e);
    u.texture = null, u.texShape = null, u.isPacked = !1, u.slice = null;
  }

  getTexture(e) {
    return this.uploadToGPU(e), this.texData.get(e).texture;
  }

  getDataInfo(e) {
    return this.texData.get(e);
  }

  shouldExecuteOnCPU(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Uw;
    return V().getBool("WEBGL_CPU_FORWARD") && e.every(e => null == this.texData.get(e.dataId).texture && d(e.shape) < t);
  }

  getGPGPUContext() {
    return this.gpgpu;
  }

  where(e) {
    Oo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    var t = e.dataSync();
    return Pw(e.shape, t);
  }

  packedUnaryOp(e, t, n) {
    var s = new zw(e.shape, t),
        r = this.compileAndRun(s, [e], n);
    return Kn().makeTensorFromDataId(r.dataId, r.shape, r.dtype);
  }

  abs(e) {
    if (this.shouldExecuteOnCPU([e]) && "complex64" !== e.dtype) {
      var _t372 = fw(this.texData.get(e.dataId).values);

      return this.makeOutput(e.shape, e.dtype, _t372);
    }

    if (V().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(e, "return abs(x);", e.dtype);
    var t = new Mw(e.shape, "return abs(x);"),
        n = this.compileAndRun(t, [e]);
    return Kn().makeTensorFromDataId(n.dataId, n.shape, n.dtype);
  }

  makeTensorInfo(e, t, n) {
    var s;

    if ("string" === t && null != n && n.length > 0 && C(n[0])) {
      var _r160 = n.map(e => Ge(e));

      s = this.write(_r160, e, t);
    } else s = this.write(n, e, t);

    return this.texData.get(s).usage = null, {
      dataId: s,
      shape: e,
      dtype: t
    };
  }

  makeOutput(e, t, n) {
    var {
      dataId: s
    } = this.makeTensorInfo(e, t, n);
    return Kn().makeTensorFromDataId(s, e, t, this);
  }

  unpackTensor(e) {
    var t = new Bw(e.shape);
    return this.runWebGLProgram(t, [e], e.dtype);
  }

  packTensor(e) {
    var t = new Rw(e.shape);
    return this.runWebGLProgram(t, [e], e.dtype, null, !0);
  }

  packedReshape(e, t) {
    var n = [Yy(e.shape), ...Jy(e.shape)],
        s = {
      dtype: e.dtype,
      shape: n,
      dataId: e.dataId
    },
        r = [Yy(t), ...Jy(t)],
        a = new Aw(r, n),
        i = this.runWebGLProgram(a, [s], e.dtype, null, !0);
    return {
      dataId: i.dataId,
      shape: t,
      dtype: i.dtype
    };
  }

  decode(e) {
    var t = this.texData.get(e),
        {
      isPacked: n,
      shape: s,
      dtype: r
    } = t,
        a = Zy(s);
    var i;
    return i = n ? new fk(a) : new pk(a), {
      dtype: r,
      shape: s,
      dataId: this.runWebGLProgram(i, [{
        shape: a,
        dtype: r,
        dataId: e
      }], r, null, !0).dataId
    };
  }

  runWebGLProgram(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    var a = this.makeTensorInfo(e.outputShape, n),
        i = this.texData.get(a.dataId);

    if (e.packedOutput && (i.isPacked = !0), e.outPackingScheme === Dy.DENSE) {
      var _t373 = Ly(e.outputShape);

      i.texShape = _t373.map(e => 2 * e);
    }

    if (null != e.outTexUsage && (i.usage = e.outTexUsage), 0 === d(a.shape)) return i.values = w(a.dtype, 0), a;
    var o = [],
        l = t.map(t => {
      if ("complex64" === t.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      var n = this.texData.get(t.dataId);

      if (null == n.texture) {
        if (!e.packedInputs && d(t.shape) <= V().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
          shape: t.shape,
          texData: null,
          isUniform: !0,
          uniformValues: n.values
        };
        e.packedInputs && (n.isPacked = !0, n.shape = t.shape);
      } else if (!!n.isPacked != !!e.packedInputs) t = n.isPacked ? this.unpackTensor(t) : this.packTensor(t), o.push(t), n = this.texData.get(t.dataId);else if (n.isPacked && !ek(n.shape, t.shape)) {
        var _e440 = t,
            _s216 = t.shape;
        t.shape = n.shape, t = this.packedReshape(t, _s216), o.push(t), n = this.texData.get(t.dataId), _e440.shape = _s216;
      }

      return this.uploadToGPU(t.dataId), {
        shape: t.shape,
        texData: n,
        isUniform: !1
      };
    });
    this.uploadToGPU(a.dataId);

    var u = {
      shape: a.shape,
      texData: i,
      isUniform: !1
    },
        c = function (e, t, n) {
      var s = "";
      t.concat(n).forEach(t => {
        var r = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0;

        if (e.enableShapeUniforms && !t.isUniform) {
          var _a126 = t.texData.texShape,
              {
            useSqueezeShape: _i87,
            uniformShape: _o65
          } = Lk(e.packedInputs, t.shape, _a126);
          var _l45 = "",
              _u34 = "",
              _c29 = "";

          if (1 === _o65.length && e.packedInputs) {
            var _e441 = [Math.ceil(_a126[0] / 2), Math.ceil(_a126[1] / 2)];
            _l45 = "".concat(_e441[0] > 1, "_").concat(_e441[1] > 1);
          } else if (2 !== _o65.length || e.packedInputs) {
            if (_o65.length > 2 && !e.packedInputs) {
              var _e442 = A(_o65);

              _c29 = "".concat(_e442[0] === _a126[1], "_").concat(_e442[_e442.length - 1] === _a126[1]);
            }
          } else _u34 = "".concat(_o65[0] > 1, "_").concat(_o65[1] > 1);

          var _h17 = t.shape.length,
              _f11 = 2 === _h17 && p(t.shape, _a126),
              _g19 = 1 === d(t.shape),
              _m13 = lr(t.shape, n.shape),
              _b14 = !e.packedInputs && _h17 === n.shape.length && p(_a126, n.texData.texShape);

          s += "".concat(_h17, "_").concat(_b14, "_").concat(_i87, "_").concat(_o65.length, "_").concat(_g19, "_").concat(_m13, "_").concat(_f11, "_").concat(_l45, "_").concat(_u34, "_").concat(_c29, "_").concat(e.packedInputs || _h17 > 2 ? "" : "".concat(_a126[0] > 1, "_").concat(_a126[1] > 1), "_").concat(r);
        } else s += "".concat(t.shape, "_").concat(t.isUniform ? "uniform" : t.texData.texShape, "_").concat(r);
      });
      var r = e.constructor.name;
      return r += "_" + s + "_" + e.userCode + "".concat(V().getNumber("WEBGL_VERSION")), r;
    }(e, l, u),
        h = this.getAndSaveBinary(c, () => function (e, t, n, s) {
      var r = n.map((e, n) => {
        var s = {
          logicalShape: e.shape,
          texShape: e.isUniform ? null : e.texData.texShape,
          isUniform: e.isUniform,
          isPacked: !e.isUniform && e.texData.isPacked,
          flatOffset: null
        };
        return null != e.texData && null != e.texData.slice && e.texData.slice.flatOffset > 0 && (s.flatOffset = e.texData.slice.flatOffset), {
          name: t.variableNames[n],
          shapeInfo: s
        };
      }),
          a = r.map(e => e.shapeInfo),
          i = {
        logicalShape: s.shape,
        texShape: s.texData.texShape,
        isUniform: !1,
        isPacked: s.texData.isPacked,
        flatOffset: null
      },
          o = Sk(r, i, t),
          l = e.createProgram(o);
      var u = null;
      var c = e.getUniformLocation(l, "NAN", !1);
      1 === V().getNumber("WEBGL_VERSION") && (u = e.getUniformLocation(l, "INFINITY", !1));
      var h = !1,
          d = {},
          p = {},
          f = {};

      for (var _n276 = 0; _n276 < t.variableNames.length; _n276++) {
        var _s217 = t.variableNames[_n276];
        d[_s217] = e.getUniformLocation(l, _s217, h), d["offset".concat(_s217)] = e.getUniformLocation(l, "offset".concat(_s217), h), t.enableShapeUniforms && (p["".concat(_s217, "Shape")] = e.getUniformLocation(l, "".concat(_s217, "Shape"), h), f["".concat(_s217, "TexShape")] = e.getUniformLocation(l, "".concat(_s217, "TexShape"), h));
      }

      var g, m, b;
      t.enableShapeUniforms && (g = e.getUniformLocation(l, "outShape", h), b = e.getUniformLocation(l, "outShapeStrides", h), m = e.getUniformLocation(l, "outTexShape", h));
      var x = [];
      return t.customUniforms && t.customUniforms.forEach((t, n) => {
        x[n] = e.getUniformLocation(l, t.name, h);
      }), {
        program: t,
        source: o,
        webGLProgram: l,
        uniformLocations: d,
        customUniformLocations: x,
        inShapeInfos: a,
        outShapeInfo: i,
        infLoc: u,
        nanLoc: c,
        inShapesLocations: p,
        inTexShapesLocations: f,
        outShapeLocation: g,
        outShapeStridesLocation: b,
        outTexShapeLocation: m
      };
    }(this.gpgpu, e, l, u)),
        f = null != this.activeTimers;

    var g;
    f && (g = this.startTimer()), function (e, t, n, s, r) {
      t.program.enableShapeUniforms || (Pk(t.inShapeInfos, n), Pk([t.outShapeInfo], [s]));
      var a = s.texData.texture,
          i = s.texData.texShape;
      s.texData.isPacked ? e.setOutputPackedMatrixTexture(a, i[0], i[1]) : e.setOutputMatrixTexture(a, i[0], i[1]), e.setProgram(t.webGLProgram), 1 === V().getNumber("WEBGL_VERSION") && null !== t.infLoc && e.gl.uniform1f(t.infLoc, Infinity), null !== t.nanLoc && e.gl.uniform1f(t.nanLoc, NaN), n.forEach((n, s) => {
        var r = t.program.variableNames[s],
            a = t.uniformLocations[r],
            i = t.uniformLocations["offset".concat(r)],
            o = t.inShapesLocations["".concat(r, "Shape")],
            l = t.inTexShapesLocations["".concat(r, "TexShape")];

        if (o) {
          var {
            uniformShape: _s218
          } = Lk(t.program.packedInputs, n.shape, n.texData.texShape);

          switch (_s218.length) {
            case 1:
              e.gl.uniform1iv(o, new Int32Array(_s218));
              break;

            case 2:
              e.gl.uniform2iv(o, new Int32Array(_s218));
              break;

            case 3:
              e.gl.uniform3iv(o, new Int32Array(_s218));
              break;

            case 4:
              e.gl.uniform4iv(o, new Int32Array(_s218));
          }
        }

        if (l && e.gl.uniform2i(l, n.texData.texShape[0], n.texData.texShape[1]), null != a) if (n.isUniform) {
          if (d(n.shape) < 2) e.gl.uniform1f(a, n.uniformValues[0]);else {
            var _t374 = n.uniformValues;
            _t374 instanceof Float32Array || (_t374 = new Float32Array(_t374)), e.gl.uniform1fv(a, _t374);
          }
        } else null != n.texData.slice && null != i && e.gl.uniform1i(i, n.texData.slice.flatOffset), e.setInputMatrixTexture(n.texData.texture, a, s);
      });
      var o = t.outShapeLocation;
      if (o) switch (s.shape.length) {
        case 1:
          e.gl.uniform1iv(o, new Int32Array(s.shape));
          break;

        case 2:
          e.gl.uniform2iv(o, new Int32Array(s.shape));
          break;

        case 3:
          e.gl.uniform3iv(o, new Int32Array(s.shape));
          break;

        case 4:
          e.gl.uniform4iv(o, new Int32Array(s.shape));
      }

      if (t.outShapeStridesLocation) {
        var _n277 = A(s.shape);

        switch (s.shape.length) {
          case 2:
            e.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(_n277));
            break;

          case 3:
            e.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(_n277));
            break;

          case 4:
            e.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(_n277));
        }
      }

      t.outTexShapeLocation && e.gl.uniform2i(t.outTexShapeLocation, s.texData.texShape[0], s.texData.texShape[1]), t.program.customUniforms && r && t.program.customUniforms.forEach((n, s) => {
        var a = t.customUniformLocations[s],
            i = r[s];
        if ("float" === n.type) e.gl.uniform1fv(a, i);else if ("vec2" === n.type) e.gl.uniform2fv(a, i);else if ("vec3" === n.type) e.gl.uniform3fv(a, i);else if ("vec4" === n.type) e.gl.uniform4fv(a, i);else if ("int" === n.type) e.gl.uniform1iv(a, i);else if ("ivec2" === n.type) e.gl.uniform2iv(a, i);else if ("ivec3" === n.type) e.gl.uniform3iv(a, i);else {
          if ("ivec4" !== n.type) throw Error("uniform type ".concat(n.type, " is not supported yet."));
          e.gl.uniform4iv(a, i);
        }
      }), e.executeProgram();
    }(this.gpgpu, h, l, u, s), o.forEach(e => this.disposeIntermediateTensorInfo(e)), f && (g = this.endTimer(g), this.activeTimers.push({
      name: e.constructor.name,
      query: this.getQueryTime(g)
    }));
    var m = V().get("WEBGL_FLUSH_THRESHOLD");

    if (m > 0) {
      var _e443 = Ve();

      _e443 - this.lastGlFlushTime > m && (this.gpgpu.gl.flush(), this.lastGlFlushTime = _e443);
    }

    if (!V().getBool("WEBGL_LAZILY_UNPACK") && i.isPacked && !1 === r) {
      var _e444 = this.unpackTensor(a);

      return this.disposeIntermediateTensorInfo(a), _e444;
    }

    return a;
  }

  compileAndRun(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    return this.runWebGLProgram(e, t, n = n || t[0].dtype, s, r);
  }

  getAndSaveBinary(e, t) {
    return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e];
  }

  getTextureManager() {
    return this.textureManager;
  }

  dispose() {
    this.disposed || (V().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach(e => {
      this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram), delete this.binaryCache[e];
    }), this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0);
  }

  floatPrecision() {
    return null == this.floatPrecisionValue && (this.floatPrecisionValue = Yn(() => {
      if (!V().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        var _e445 = V().getBool("DEBUG");

        V().set("DEBUG", !1);
        var _t375 = this.abs(qa(1e-8)).dataSync()[0];
        if (V().set("DEBUG", _e445), _t375 > 0) return 32;
      }

      return 16;
    })), this.floatPrecisionValue;
  }

  epsilon() {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }

  uploadToGPU(e) {
    var t = this.texData.get(e),
        {
      shape: n,
      dtype: s,
      values: r,
      texture: a,
      usage: o,
      isPacked: l
    } = t;
    if (null != a) return;
    var u = null != this.activeTimers;
    var c;
    u && (c = Ve());
    var h = t.texShape;

    if (null == h && (h = function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      var n = V().getNumber("WEBGL_MAX_TEXTURE_SIZE");

      if (t && (n *= 2, 1 === (e = e.map((t, n) => n >= e.length - 2 ? i(e[n]) : e[n])).length && (e = [2, e[0]])), 2 !== e.length) {
        var _t376 = k(e);

        e = _t376.newShape;
      }

      var s = d(e);
      if (e.length <= 1 && s <= n) return [1, s];
      if (2 === e.length && e[0] <= n && e[1] <= n) return e;
      if (3 === e.length && e[0] * e[1] <= n && e[2] <= n) return [e[0] * e[1], e[2]];
      if (3 === e.length && e[0] <= n && e[1] * e[2] <= n) return [e[0], e[1] * e[2]];
      if (4 === e.length && e[0] * e[1] * e[2] <= n && e[3] <= n) return [e[0] * e[1] * e[2], e[3]];
      if (4 === e.length && e[0] <= n && e[1] * e[2] * e[3] <= n) return [e[0], e[1] * e[2] * e[3]];

      if (t) {
        var _t377 = Yy(e);

        var _n278 = 2,
            _r161 = 2;
        return e.length && ([_n278, _r161] = Jy(e)), s = _t377 * (_n278 / 2) * (_r161 / 2), g(s).map(e => 2 * e);
      }

      return g(s);
    }(n, l), t.texShape = h), null != r) {
      var _e446 = Zy(n);

      var _a127,
          _i88 = h[1],
          _o66 = h[0];

      var _d23 = r instanceof Uint8Array;

      l ? ([_i88, _o66] = zy(h[0], h[1]), _a127 = new xk(_e446, [_o66, _i88], _d23)) : _a127 = new bk(_e446, [_o66, _i88], _d23);

      var _p15 = this.makeTensorInfo([_o66, _i88], s);

      this.texData.get(_p15.dataId).usage = _d23 ? _y.PIXELS : _y.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(_p15.dataId), _i88, _o66, r);

      var _f12 = this.runWebGLProgram(_a127, [_p15], s, null, !0),
          _g20 = this.texData.get(_f12.dataId);

      t.texture = _g20.texture, t.texShape = _g20.texShape, t.isPacked = _g20.isPacked, t.usage = _g20.usage, this.disposeIntermediateTensorInfo(_p15), this.texData.delete(_f12.dataId), t.values = null, u && (this.uploadWaitMs += Ve() - c);
    } else {
      var _e447 = this.acquireTexture(h, o, s, l);

      t.texture = _e447;
    }
  }

  convertAndCacheOnCPU(e, t) {
    var n = this.texData.get(e),
        {
      dtype: s
    } = n;
    return this.releaseGPUData(e), null != t && (n.values = function (e, t) {
      if ("float32" === t || "complex64" === t) return e;

      if ("int32" === t || "bool" === t) {
        var _n279 = "int32" === t ? new Int32Array(e.length) : new Uint8Array(e.length);

        for (var _t378 = 0; _t378 < _n279.length; ++_t378) {
          _n279[_t378] = Math.round(e[_t378]);
        }

        return _n279;
      }

      throw new Error("Unknown dtype ".concat(t));
    }(t, s)), n.values;
  }

  acquireTexture(e, t, n, s) {
    if (this.numBytesInGPU += this.computeBytes(e, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
      var _e448 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);

      this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: ".concat(_e448, " MB, most likely due to a memory leak"));
    }

    return this.textureManager.acquireTexture(e, t, s);
  }

  computeBytes(e, t) {
    return e[0] * e[1] * N(t);
  }

}

Vw.nextDataId = 0, $t() && Qn("webgl", () => new Vw(), 2);

class Gw {
  constructor(e, t, n) {
    this.variableNames = ["A", "B"], this.outputShape = cr(t, n), this.enableShapeUniforms = Wk(this.outputShape.length), this.userCode = "\n      float binaryOperation(float a, float b) {\n        ".concat(e, "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ");
  }

}

class Hw {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = cr(t, n);
    var r = this.outputShape.length;
    this.enableShapeUniforms = Wk(r);
    var a = "";
    if (s) if (0 === r || 1 === d(this.outputShape)) a = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if (a = "\n          ".concat(Mk(r), " coords = getOutputCoords();\n        "), 1 === r) a += this.enableShapeUniforms ? "\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          " : "\n            result.y = (coords + 1) >= ".concat(this.outputShape[0], " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else {
      var _e449 = Ew("coords", r);

      a += this.enableShapeUniforms ? "\n            bool nextRowOutOfBounds =\n              (".concat(_e449[r - 2], " + 1) >= outShape[").concat(r, " - 2];\n            bool nextColOutOfBounds =\n              (").concat(_e449[r - 1], " + 1) >= outShape[").concat(r, " - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ") : "\n            bool nextRowOutOfBounds =\n              (".concat(_e449[r - 2], " + 1) >= ").concat(this.outputShape[r - 2], ";\n            bool nextColOutOfBounds =\n              (").concat(_e449[r - 1], " + 1) >= ").concat(this.outputShape[r - 1], ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ");
    }
    this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e, "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(a, "\n\n        setOutput(result);\n      }\n    ");
  }

}

function jw(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    x: s
  } = t;
  return n.incRef(s.dataId), {
    dataId: s.dataId,
    shape: s.shape,
    dtype: s.dtype
  };
}

var qw = {
  kernelName: "Identity",
  backendName: "webgl",
  kernelFunc: jw
};

function Kw(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    real: s,
    imag: r
  } = t,
      a = n.makeTensorInfo(s.shape, "complex64"),
      i = n.texData.get(a.dataId),
      o = jw({
    inputs: {
      x: s
    },
    backend: n
  }),
      l = jw({
    inputs: {
      x: r
    },
    backend: n
  });
  return i.complexTensorInfos = {
    real: o,
    imag: l
  }, a;
}

var Xw = {
  kernelName: "Complex",
  backendName: "webgl",
  kernelFunc: Kw
},
    Yw = "return (a < 0.) ? b * a : a;",
    Jw = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
    Zw = {
  kernelName: "LeakyRelu",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      alpha: a
    } = s,
        i = n.makeTensorInfo([], "float32", We(a, "float32")),
        o = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Hw(Jw, r.shape, i.shape) : new Gw(Yw, r.shape, i.shape),
        l = n.runWebGLProgram(o, [r, i], r.dtype);
    return n.disposeIntermediateTensorInfo(i), l;
  }
},
    Qw = "return (a < 0.) ? b * a : a;",
    ev = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
    tv = {
  kernelName: "Prelu",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s,
      alpha: r
    } = t,
        a = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Hw(ev, s.shape, r.shape) : new Gw(Qw, s.shape, r.shape);
    return n.runWebGLProgram(a, [s, r], s.dtype);
  }
};

function nv(_ref20) {
  var {
    opSnippet: e,
    packedOpSnippet: t,
    cpuKernelImpl: n,
    dtype: s
  } = _ref20;
  return _ref21 => {
    var {
      inputs: r,
      backend: a
    } = _ref21;
    var {
      x: i
    } = r,
        o = a,
        l = s || i.dtype;

    if (o.shouldExecuteOnCPU([i]) && null != n) {
      var _e450 = o.texData.get(i.dataId),
          _t379 = n(_e450.values, l);

      return o.makeTensorInfo(i.shape, l, _t379);
    }

    var u;
    return u = V().getBool("WEBGL_PACK_UNARY_OPERATIONS") && null != t ? new zw(i.shape, t) : new Mw(i.shape, e), o.runWebGLProgram(u, [i], l);
  };
}

function sv(_ref22) {
  var {
    opSnippet: e,
    packedOpSnippet: t,
    checkOutOfBounds: n = !1,
    supportsComplex: s = !1,
    cpuKernelImpl: r,
    dtype: a
  } = _ref22;
  return _ref23 => {
    var {
      inputs: i,
      backend: o
    } = _ref23;
    var {
      a: l,
      b: u
    } = i,
        c = o;

    if (s && "complex64" === l.dtype) {
      var _t380 = c.texData.get(l.dataId),
          _n280 = c.texData.get(u.dataId),
          [_s219, _r162] = [[_t380.complexTensorInfos.real, _n280.complexTensorInfos.real], [_t380.complexTensorInfos.imag, _n280.complexTensorInfos.imag]].map(t => {
        var [n, s] = t,
            r = {
          dataId: n.dataId,
          dtype: n.dtype,
          shape: l.shape
        },
            a = {
          dataId: s.dataId,
          dtype: s.dtype,
          shape: u.shape
        },
            i = new Gw(e, l.shape, u.shape);
        return c.runWebGLProgram(i, [r, a], dt(n.dtype, s.dtype));
      }),
          _a128 = Kw({
        inputs: {
          real: _s219,
          imag: _r162
        },
        backend: c
      });

      return c.disposeIntermediateTensorInfo(_s219), c.disposeIntermediateTensorInfo(_r162), _a128;
    }

    var h = a || dt(l.dtype, u.dtype);

    if (("string" === l.dtype || "string" === u.dtype || c.shouldExecuteOnCPU([l, u])) && null != r) {
      var _e451 = c.texData.get(l.dataId).values,
          _t381 = c.texData.get(u.dataId).values,
          _n281 = "string" === l.dtype ? tl(_e451) : _e451,
          _s220 = "string" === l.dtype ? tl(_t381) : _t381,
          [_a129, _i89] = r(l.shape, u.shape, _n281, _s220, h),
          _o67 = c.makeTensorInfo(_i89, h);

      return c.texData.get(_o67.dataId).values = _a129, _o67;
    }

    var d;
    return d = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") && null != t ? new Hw(t, l.shape, u.shape, n) : new Gw(e, l.shape, u.shape), c.runWebGLProgram(d, [l, u], h);
  };
}

function rv(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  if ("linear" === e) return "return x;";
  if ("relu" === e) return t ? "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";
  if ("elu" === e) return t ? "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n" : "return (x >= 0.0) ? x : (exp(x) - 1.0);";
  if ("relu6" === e) return t ? "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
  if ("prelu" === e) return t ? ev : Qw;
  if ("leakyrelu" === e) return t ? Jw : Yw;
  if ("sigmoid" === e) return "return 1.0 / (1.0 + exp(-1.0 * x));";
  throw new Error("Activation ".concat(e, " has not been implemented for the WebGL backend."));
}

class av {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : !1;
    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : !1;
    this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n;
    var u = Math.ceil((s ? e[1] : e[2]) / 2),
        c = s ? "i * 2, rc.y" : "rc.y, i * 2",
        h = r ? "rc.z, i * 2" : "i * 2, rc.z",
        d = s ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
        p = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
    var f = "",
        g = "";
    i && (f = o ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(i, "\n        }") : l ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(i, "\n        }") : "vec4 activation(vec4 x) {\n          ".concat(i, "\n        }"), g = "result = activation(result);");
    var m = a ? "result += getBiasAtOutCoords();" : "";
    a && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), l && this.variableNames.push("leakyreluAlpha");
    var b = "rc.x",
        x = "rc.x";
    e[0] < t[0] ? b = "int(min(float(rc.x), ".concat(e[0] - 1, ".))") : t[0] < e[0] && (x = "int(min(float(rc.x), ".concat(t[0] - 1, ".))")), this.userCode = "\n      ".concat(f, "\n\n      const float sharedDimension = ").concat(u, ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ").concat(u, "; i++) {\n          int batchA = ").concat(b, ";\n          int batchB = ").concat(x, ";\n          vec4 a = getMatrixA(batchA, ").concat(c, ");\n          vec4 b = getMatrixB(batchB, ").concat(h, ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(d[0], " * ").concat(p[0], ");\n          result += (").concat(d[1], " * ").concat(p[1], ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(m, "\n\n        ").concat(g, "\n\n        setOutput(result);\n      }\n    ");
  }

}

class iv {
  constructor(e, t, n) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = cr(t, n), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e, "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ");
  }

}

var ov = "return a * b;";

function lv(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    a: s,
    b: r
  } = t,
      a = dt(s.dtype, r.dtype);

  if ("complex64" === s.dtype) {
    var _e452 = n.texData.get(s.dataId),
        _t382 = n.texData.get(r.dataId),
        _a130 = new iv("return areal * breal - aimag * bimag;", s.shape, r.shape),
        _i90 = new iv("return areal * bimag + aimag * breal;", s.shape, r.shape),
        _o68 = [{
      dataId: _e452.complexTensorInfos.real.dataId,
      dtype: _e452.complexTensorInfos.real.dtype,
      shape: s.shape
    }, {
      dataId: _e452.complexTensorInfos.imag.dataId,
      dtype: _e452.complexTensorInfos.imag.dtype,
      shape: s.shape
    }, {
      dataId: _t382.complexTensorInfos.real.dataId,
      dtype: _t382.complexTensorInfos.real.dtype,
      shape: r.shape
    }, {
      dataId: _t382.complexTensorInfos.imag.dataId,
      dtype: _t382.complexTensorInfos.imag.dtype,
      shape: r.shape
    }],
        _l46 = n.runWebGLProgram(_a130, _o68, "float32"),
        _u35 = n.runWebGLProgram(_i90, _o68, "float32"),
        _c30 = Kw({
      inputs: {
        real: _l46,
        imag: _u35
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_l46), n.disposeIntermediateTensorInfo(_u35), _c30;
  }

  if (n.shouldExecuteOnCPU([s, r])) {
    var _e453 = n.texData.get(s.dataId),
        _t383 = n.texData.get(r.dataId),
        [_i91, _o69] = lw(s.shape, r.shape, _e453.values, _t383.values, a),
        _l47 = n.makeTensorInfo(_o69, a);

    return n.texData.get(_l47.dataId).values = _i91, _l47;
  }

  var i;
  return i = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Hw(ov, s.shape, r.shape) : new Gw(ov, s.shape, r.shape), n.runWebGLProgram(i, [s, r], a);
}

var uv = {
  kernelName: "Multiply",
  backendName: "webgl",
  kernelFunc: lv
};

function cv(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    shape: a
  } = s,
      i = n,
      o = d(r.shape),
      u = x(a, o),
      c = d(u);
  l(o === c, () => "The new shape (".concat(u, ") has ").concat(c, " elements and the old shape (").concat(r.shape, ") has ").concat(o, " elements. The new shape and old shape must have the same number of elements."));
  var h = i.texData.get(r.dataId);
  return !h.isPacked || ek(r.shape, u) || null !== h.texture && ek(h.shape, u) ? (i.incRef(r.dataId), {
    dataId: r.dataId,
    shape: u,
    dtype: r.dtype
  }) : function (e, t, n) {
    var s = [Yy(e.shape), ...Jy(e.shape)],
        r = {
      dtype: e.dtype,
      shape: s,
      dataId: e.dataId
    },
        a = [Yy(t), ...Jy(t)],
        i = new Aw(a, s),
        o = n.runWebGLProgram(i, [r], e.dtype, null, !0);
    return {
      dataId: o.dataId,
      shape: t,
      dtype: o.dtype
    };
  }(r, u, i);
}

var hv = {
  kernelName: "Reshape",
  backendName: "webgl",
  kernelFunc: cv
};

class dv {
  constructor(e, t) {
    this.variableNames = ["x"];
    var {
      windowSize: n,
      batchSize: s,
      inSize: r,
      outSize: a
    } = e;
    this.outputShape = [s, a];
    var i = 4 * Math.floor(n / 4),
        o = n % 4;
    var l = "sumValue += dot(values, ones);";

    if (null != t) {
      var _e454 = 1 / t;

      l = "sumValue += dot(values * ".concat(f(_e454) ? _e454.toPrecision(2) : _e454, ", ones);");
    }

    var u = "";
    r % n > 0 && (u = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return 0.0;\n        }\n      ")), this.userCode = "\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(u, "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n, ";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i, "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(l, "\n        }\n\n        int inIdx = inOffset + ").concat(i, ";\n        if (").concat(1 === o, ") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(l, "\n        } else if (").concat(2 === o, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(l, "\n        } else if (").concat(3 === o, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(l, "\n        }\n        setOutput(sumValue);\n      }\n    ");
  }

}

class pv {
  constructor(e, t) {
    this.variableNames = ["x"];
    var {
      windowSize: n,
      batchSize: s,
      inSize: r,
      outSize: a
    } = e;
    this.outputShape = [s, a];
    var i = "0.0",
        o = "";
    "prod" === t ? i = "1.0" : "min" === t ? (i = "1.0 / 1e-20", o = "min") : "max" === t && (i = "-1.0 / 1e-20", o = "max");
    var l = "".concat(t, "(").concat(t, "(").concat(t, "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");
    "sum" === t ? l = "sumValue" : "prod" === t ? l = "prodValue" : "all" === t ? l = "allValue" : "any" === t && (l = "anyValue");
    var u = 4 * Math.floor(n / 4),
        c = n % 4;
    var h = "\n      if (".concat("sum" === t, ") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod" === t, ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(o, "(values, minMaxValue);\n        if (").concat("min" === t, " || ").concat("max" === t, ") {\n          minMaxValue = ").concat(o, "(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),
        d = "vec4";
    "all" === t ? (i = "1.0", h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", d = "bvec4") : "any" === t && (i = "0.0", h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", d = "bvec4");
    var p = "";
    r % n > 0 && (p = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return initializationValue;\n        }\n      ")), this.userCode = "\n      const float initializationValue = ".concat(i, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p, "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n, ";\n\n        vec4 minMaxValue = vec4(").concat(i, ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(u, "; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h, "\n        }\n\n        int inIdx = inOffset + ").concat(u, ";\n        if (").concat(1 === c, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h, "\n        } else if (").concat(2 === c, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h, "\n        } else if (").concat(3 === c, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h, "\n        }\n        setOutput(").concat(l, ");\n      }\n    ");
  }

}

function fv(e, t, n, s) {
  var r = function (e) {
    var t = [];

    for (; 0 === t.length || 1 !== t[t.length - 1].outSize;) {
      var _n282 = t.length ? t[t.length - 1].outSize : e[1],
          _s221 = To(_n282);

      t.push({
        inSize: _n282,
        windowSize: _s221,
        outSize: Math.ceil(_n282 / _s221)
      });
    }

    return t;
  }(e.shape);

  var a = e;

  for (var _i92 = 0; _i92 < r.length; _i92++) {
    var {
      inSize: _o70,
      windowSize: _l48,
      outSize: _u36
    } = r[_i92];

    var _c31 = void 0,
        _h18 = void 0;

    _c31 = "mean" === n ? 0 === _i92 ? new dv({
      windowSize: _l48,
      inSize: _o70,
      batchSize: e.shape[0],
      outSize: _u36
    }, _o70) : new dv({
      windowSize: _l48,
      inSize: _o70,
      batchSize: e.shape[0],
      outSize: _u36
    }) : new pv({
      windowSize: _l48,
      inSize: _o70,
      batchSize: e.shape[0],
      outSize: _u36
    }, n), _h18 = a, a = s.runWebGLProgram(_c31, [a], t), _h18.dataId !== e.dataId && s.disposeIntermediateTensorInfo(_h18);
  }

  return a;
}

class gv {
  constructor(e, t) {
    this.variableNames = ["A"];
    var n = new Array(e.length);

    for (var _s222 = 0; _s222 < n.length; _s222++) {
      n[_s222] = e[t[_s222]];
    }

    this.outputShape = n, this.rank = n.length;

    var s = Mk(this.rank),
        r = function (e) {
      var t = e.length;
      if (t > 6) throw Error("Transpose for rank ".concat(t, " is not yet supported"));
      var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"],
          s = new Array(t);

      for (var _t384 = 0; _t384 < e.length; _t384++) {
        s[e[_t384]] = n[_t384];
      }

      return s.join();
    }(t);

    this.userCode = "\n    void main() {\n      ".concat(s, " resRC = getOutputCoords();\n      setOutput(getA(").concat(r, "));\n    }\n    ");
  }

}

class mv {
  constructor(e, t) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
    var n = new Array(e.length);

    for (var _s223 = 0; _s223 < n.length; _s223++) {
      n[_s223] = e[t[_s223]];
    }

    if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error("Packed transpose for rank ".concat(this.rank, " is not yet supported."));
    var s = Mk(this.rank),
        r = Tw("rc", this.rank),
        a = new Array(this.rank);

    for (var _e455 = 0; _e455 < t.length; _e455++) {
      a[t[_e455]] = r[_e455];
    }

    var i = "vec2(".concat(a.slice(-2).join(), ")"),
        o = "++".concat(r[this.rank - 1], " < ").concat(n[this.rank - 1]),
        l = "getChannel(getA(".concat(a.join(), "), ").concat(i, ")");
    this.userCode = "\n    void main() {\n      ".concat(s, " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(l, ";\n      if(").concat(o, ") {\n        result[1] = ").concat(l, ";\n      }\n      --").concat(r[this.rank - 1], ";\n      if(++").concat(r[this.rank - 2], " < ").concat(n[this.rank - 2], ") {\n        result[2] = ").concat(l, ";\n        if(").concat(o, ") {\n          result[3] = ").concat(l, ";\n        }\n      }\n      setOutput(result);\n    }\n    ");
  }

}

function bv(e, t, n) {
  var s = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new mv(e.shape, t) : new gv(e.shape, t);
  return n.runWebGLProgram(s, [e], e.dtype);
}

function xv(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    axis: a,
    keepDims: i
  } = s;
  return function (e, t, n, s) {
    var r = e.shape.length,
        a = y(t, e.shape);
    var i = a;
    var o = Jr(i, r),
        l = null != o;
    var u = e;
    l && (u = bv(e, o, s), i = Qr(i.length, r)), Yr("sum", i, r);
    var [c, h] = Kr(u.shape, i);
    var p = c;
    n && (p = Xr(c, a));
    var f = d(h),
        g = cv({
      inputs: {
        x: u
      },
      attrs: {
        shape: [d(e.shape) / f, f]
      },
      backend: s
    }),
        m = fv(g, pt(e.dtype), "sum", s),
        b = cv({
      inputs: {
        x: m
      },
      attrs: {
        shape: p
      },
      backend: s
    });
    return s.disposeIntermediateTensorInfo(g), s.disposeIntermediateTensorInfo(m), l && s.disposeIntermediateTensorInfo(u), b;
  }(r, a, i, n);
}

var yv = {
  kernelName: "Sum",
  backendName: "webgl",
  kernelFunc: xv
};

function kv(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    perm: a
  } = s,
      i = n,
      o = new Array(r.shape.length);

  for (var _e456 = 0; _e456 < o.length; _e456++) {
    o[_e456] = r.shape[a[_e456]];
  }

  var l;

  if (i.shouldExecuteOnCPU([r])) {
    var _e457 = i.texData.get(r.dataId),
        _t385 = Cw(_e457.values, r.shape, r.dtype, a, o);

    l = i.makeTensorInfo(o, r.dtype), i.texData.get(l.dataId).values = _t385;
  } else l = bv(r, a, i);

  return l;
}

var wv = {
  kernelName: "Transpose",
  backendName: "webgl",
  kernelFunc: kv
};

function vv(_ref24) {
  var {
    a: e,
    b: t,
    transposeA: n,
    transposeB: s,
    backend: r,
    bias: a = null,
    preluActivationWeights: i = null,
    leakyreluAlpha: o = 0,
    activation: u = null
  } = _ref24;
  var c = e.shape.length,
      h = t.shape.length,
      p = n ? e.shape[c - 2] : e.shape[c - 1],
      f = s ? t.shape[h - 1] : t.shape[h - 2],
      g = n ? e.shape[c - 1] : e.shape[c - 2],
      m = s ? t.shape[h - 2] : t.shape[h - 1],
      b = e.shape.slice(0, -2),
      x = t.shape.slice(0, -2),
      y = d(b),
      k = d(x);
  l(c >= 2 && h >= 2 && (y === k || 1 === y || 1 === k), () => "Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (".concat(b, ") and (").concat(x, ")."));
  var w = (y > k ? e.shape.slice(0, -2) : t.shape.slice(0, -2)).concat([g, m]);
  l(p === f, () => "Error in matMul: inner shapes (".concat(p, ") and (").concat(f, ") of Tensors with shapes ").concat(e.shape, " and ").concat(t.shape, " and transposeA=").concat(n, " and transposeB=").concat(s, " must match."));
  var v = n ? [y, p, g] : [y, g, p],
      I = s ? [k, m, f] : [k, f, m],
      $ = cv({
    inputs: {
      x: e
    },
    backend: r,
    attrs: {
      shape: v
    }
  }),
      N = cv({
    inputs: {
      x: t
    },
    backend: r,
    attrs: {
      shape: I
    }
  }),
      C = [$, N],
      S = Math.max(y, k),
      T = n ? $.shape[1] : $.shape[2],
      E = null != a,
      R = null != i,
      A = "leakyrelu" === u,
      F = null != u ? rv(u, !0) : null;
  var D;

  if ((1 === g || 1 === m) && T > 1e3 && !1 === (E || R || A || null != F)) {
    var _e458 = $,
        _t386 = N;
    n && (_e458 = kv({
      inputs: {
        x: $
      },
      backend: r,
      attrs: {
        perm: [0, 2, 1]
      }
    }), C.push(_e458)), s && (_t386 = kv({
      inputs: {
        x: N
      },
      backend: r,
      attrs: {
        perm: [0, 2, 1]
      }
    }), C.push(_t386));

    var _a131 = 1 === m;

    var _i93 = _e458;
    1 !== m && (_i93 = cv({
      inputs: {
        x: _e458
      },
      backend: r,
      attrs: {
        shape: [S, T, 1]
      }
    }), C.push(_i93));

    var _o71 = 1 === m ? 2 : 1;

    var _l49 = _t386;
    _a131 && (_l49 = cv({
      inputs: {
        x: _t386
      },
      backend: r,
      attrs: {
        shape: [S, 1, T]
      }
    }), C.push(_l49));

    var _u37 = lv({
      inputs: {
        a: _i93,
        b: _l49
      },
      backend: r
    });

    D = xv({
      inputs: {
        x: _u37
      },
      backend: r,
      attrs: {
        axis: _o71,
        keepDims: !0
      }
    }), C.push(_u37);
  } else {
    var _l50 = dt(e.dtype, t.dtype),
        _u38 = new av(v, I, [S, g, m], n, s, E, F, R, A),
        _c32 = [$, N];

    if (null != a && _c32.push(a), R && _c32.push(i), A) {
      var _e459 = r.makeTensorInfo([], "float32", We(o, "float32"));

      _c32.push(_e459), C.push(_e459);
    }

    D = r.runWebGLProgram(_u38, _c32, _l50);
  }

  var _ = cv({
    inputs: {
      x: D
    },
    backend: r,
    attrs: {
      shape: w
    }
  });

  C.push(D);

  for (var _e460 of C) {
    r.disposeIntermediateTensorInfo(_e460);
  }

  return _;
}

var Iv = {
  kernelName: "_FusedMatMul",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      a: r,
      b: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      transposeA: l,
      transposeB: u,
      activation: c,
      leakyreluAlpha: h
    } = s;
    return vv({
      a: r,
      b: a,
      transposeA: l,
      transposeB: u,
      backend: n,
      bias: i,
      preluActivationWeights: o,
      leakyreluAlpha: h,
      activation: c
    });
  }
},
    $v = "return abs(x);",
    Nv = {
  kernelName: "Abs",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t;

    if (n.shouldExecuteOnCPU([s]) && "complex64" !== s.dtype) {
      var _e461 = n.texData.get(s.dataId),
          _t387 = fw(_e461.values);

      return n.makeTensorInfo(s.shape, s.dtype, _t387);
    }

    var r;
    return r = V().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new zw(s.shape, $v) : new Mw(s.shape, $v), n.runWebGLProgram(r, [s], s.dtype);
  }
},
    Cv = {
  kernelName: "Acos",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"
  })
},
    Sv = {
  kernelName: "Acosh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"
  })
},
    Tv = "return a + b;",
    Ev = {
  kernelName: "Add",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: Tv,
    packedOpSnippet: Tv,
    supportsComplex: !0,
    cpuKernelImpl: Uk
  })
};

class Rv {
  constructor(e, t) {
    this.outputShape = [], this.outputShape = e, this.variableNames = t.map((e, t) => "T".concat(t));
    var n = [];
    this.variableNames.forEach(e => {
      n.push("float v".concat(e, " = get").concat(e, "AtOutCoords();"));
    });
    var s = this.variableNames.map(e => "v".concat(e)).join(" + ");
    this.userCode = "\n      void main() {\n        ".concat(n.join("\n        "), "\n\n        float result = ").concat(s, ";\n        setOutput(result);\n      }\n    ");
  }

}

class Av {
  constructor(e, t) {
    this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.variableNames = t.map((e, t) => "T".concat(t));
    var n = [];
    this.variableNames.forEach(e => {
      n.push("vec4 v".concat(e, " = get").concat(e, "AtOutCoords();"));
    });
    var s = this.variableNames.map(e => "v".concat(e)).join(" + ");
    this.userCode = "\n      void main() {\n        ".concat(n.join("\n        "), "\n\n        vec4 result = ").concat(s, ";\n        setOutput(result);\n      }\n    ");
  }

}

var Fv = {
  kernelName: "AddN",
  backendName: "webgl",
  kernelFunc: function e(t) {
    var {
      inputs: n,
      backend: s
    } = t,
        r = n;
    if (1 === r.length) return jw({
      inputs: {
        x: r[0]
      },
      backend: s
    });

    if (r.length > V().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var _t388 = Math.floor(r.length / 2),
          _n283 = e({
        inputs: r.slice(0, _t388),
        backend: s
      }),
          _a132 = e({
        inputs: r.slice(_t388),
        backend: s
      });

      return e({
        inputs: [_n283, _a132],
        backend: s
      });
    }

    var a = r.map(e => e.dtype).reduce((e, t) => dt(e, t)),
        i = r.map(e => e.shape),
        o = V().getBool("WEBGL_PACK") ? new Av(r[0].shape, i) : new Rv(r[0].shape, i);
    return s.runWebGLProgram(o, r, a);
  }
},
    Dv = {
  kernelName: "All",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s,
        o = r.shape.length,
        l = y(a, r.shape);
    var u = l;
    var c = Jr(u, o);
    var h = r;
    null != c && (h = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), u = Qr(u.length, o)), Yr("all", u, o);
    var [p, f] = Kr(h.shape, u),
        g = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, d(f)]
      }
    }),
        m = fv(g, g.dtype, "all", n);
    var b;
    return b = cv(i ? {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Xr(p, l)
      }
    } : {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: p
      }
    }), n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), b;
  }
},
    _v = {
  kernelName: "Any",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s,
        o = r.shape.length,
        l = y(a, r.shape);
    var u = l;
    var c = Jr(u, o);
    var h = r;
    null != c && (h = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), u = Qr(u.length, o)), Yr("any", u, o);
    var [p, f] = Kr(h.shape, u),
        g = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, d(f)]
      }
    }),
        m = fv(g, g.dtype, "any", n);
    var b;
    return b = cv(i ? {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Xr(p, l)
      }
    } : {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: p
      }
    }), n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), b;
  }
};

class Ov {
  constructor(e, t, n) {
    this.variableNames = ["A"];
    var {
      windowSize: s,
      batchSize: r,
      outSize: a
    } = e;
    n || this.variableNames.push("bestIndicesA"), this.outputShape = [r, a], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(s, ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(s, "; i++) {\n          int inIdx = ").concat(n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));", ";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat("max" === t ? ">" : "<", " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ");
  }

}

class Mv {
  constructor(e, t, n, s) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, l(e.length > 2, () => "Packed arg".concat(n.charAt(0).toUpperCase() + n.slice(1), " supports only inputs with rank above 2."));
    var r = Math.ceil(e[e.length - 1] / t);
    this.outputShape = e.slice(0, -1), r > 1 && this.outputShape.push(r), s || this.variableNames.push("bestIndicesA");
    var a = this.outputShape,
        i = a.length,
        o = Mk(i),
        u = Ew("coords", i);
    var c, h;

    if (1 === r) {
      h = i + 1;

      var _e462 = Mk(h);

      c = "\n        ".concat(_e462, " sourceLocR = ").concat(_e462, "(").concat(u.join(), ", 0);\n        ++").concat(u[i - 1], ";\n        ").concat(_e462, " sourceLocG = ").concat(_e462, "(").concat(u.join(), ", 0);\n        ++").concat(u[i - 2], ";\n        ").concat(_e462, " sourceLocA = ").concat(_e462, "(").concat(u.join(), ", 0);\n        --").concat(u[i - 1], ";\n        ").concat(_e462, " sourceLocB = ").concat(_e462, "(").concat(u.join(), ", 0);\n        --").concat(u[i - 2], ";");
    } else h = i, c = "\n        ".concat(o, " sourceLocR = coords;\n        ++").concat(u[i - 1], ";\n        ").concat(o, " sourceLocG = coords;\n        ++").concat(u[i - 2], ";\n        ").concat(o, " sourceLocA = coords;\n        --").concat(u[i - 1], ";\n        ").concat(o, " sourceLocB = coords;\n        --").concat(u[i - 2], ";");

    var d = ["x", "y", "z", "w", "u", "v"].slice(0, h),
        p = "." + d[h - 1],
        f = d.map(e => "int " + e),
        g = Ew("sourceLocR", h - 1).concat("inIdx.r"),
        m = Ew("sourceLocG", h - 1).concat("inIdx.g"),
        b = Ew("sourceLocB", h - 1).concat("inIdx.b"),
        x = Ew("sourceLocA", h - 1).concat("inIdx.a"),
        y = "max" === n ? "greaterThan" : "lessThan",
        k = s ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(g.join(), "),\n                             getBestIndicesAChannel(").concat(m.join(), "),\n                             getBestIndicesAChannel(").concat(b.join(), "),\n                             getBestIndicesAChannel(").concat(x.join(), ")));"),
        w = "vec4(\n            getAChannel(".concat(g.join(), "),\n            hasNextCol ? getAChannel(").concat(m.join(), ") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(), ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(x.join(), ") : 0.)"),
        v = s ? "" : "\n      float getBestIndicesAChannel(".concat(f.join(), ") {\n        return getChannel(getBestIndicesA(").concat(d.join(), "),\n                                          vec2(").concat(d.slice(-2).join(), "));\n      }");
    this.userCode = "\n      float getAChannel(".concat(f.join(), ") {\n        return getChannel(getA(").concat(d.join(), "),\n                               vec2(").concat(d.slice(-2).join(), "));\n      }\n      ").concat(v, "\n      void main() {\n        ").concat(o, " coords = getOutputCoords();\n        bool hasNextCol = ").concat(u[i - 1], " < ").concat(a[i - 1] - 1, ";\n        bool hasNextRow = ").concat(u[i - 2], " < ").concat(a[i - 2] - 1, ";\n        ").concat(c, "\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p, ", sourceLocG").concat(p, ",\n          sourceLocB").concat(p, ", sourceLocA").concat(p, ") * ").concat(t, ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w, ";\n\n        for (int i = 0; i < ").concat(t, "; i++) {\n          inIdx = srcIdx;\n          ").concat(k, "\n          vec4 candidate = ").concat(w, ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(y, "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ");
  }

}

function Lv(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var r = t.shape[0],
      a = t.shape[1];
  null != s && (r = s.shape[0], a = s.shape[1]);
  var i = To(a),
      o = {
    windowSize: i,
    inSize: a,
    batchSize: r,
    outSize: Math.ceil(a / i)
  },
      l = new Ov(o, n, null == s),
      u = [t];
  null != s && u.push(s);
  var c = e.runWebGLProgram(l, u, "int32");
  if (1 === c.shape[1]) return c;
  var h = Lv(e, t, n, c);
  return e.disposeIntermediateTensorInfo(c), h;
}

function zv(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var r = null != s ? s.shape : t.shape,
      a = To(r[r.length - 1]),
      i = new Mv(r, a, n, null == s),
      o = e.runWebGLProgram(i, null == s ? [t] : [t, s], "int32");

  if (o.shape.length === t.shape.length) {
    var _s224 = zv(e, t, n, o);

    return e.disposeIntermediateTensorInfo(o), _s224;
  }

  return o;
}

function Bv(e, t, n, s) {
  var r = [n];

  if (Yr("arg" + s.charAt(0).toUpperCase() + s.slice(1), r, t.shape.length), !V().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
    var _n284 = [],
        [_a133, _i94] = Kr(t.shape, r),
        _o72 = d(_i94),
        _l51 = cv({
      inputs: {
        x: t
      },
      backend: e,
      attrs: {
        shape: [-1, _o72]
      }
    });

    _n284.push(_l51);

    var _u39 = Lv(e, _l51, s);

    _n284.push(_u39);

    var _c33 = cv({
      inputs: {
        x: _u39
      },
      backend: e,
      attrs: {
        shape: _a133
      }
    });

    return _n284.forEach(t => e.disposeIntermediateTensorInfo(t)), _c33;
  }

  return zv(e, t, s);
}

var Pv = {
  kernelName: "ArgMax",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a
    } = s;
    var i = y(a, r.shape);
    var o = Jr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = Qr(i.length, l.shape.length)), Yr("argMax", [i[0]], l.shape.length);
    var c = Bv(n, l, i[0], "max");
    return u.forEach(e => n.disposeIntermediateTensorInfo(e)), c;
  }
},
    Wv = {
  kernelName: "ArgMin",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a
    } = s;
    var i = y(a, r.shape);
    var o = Jr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = Qr(i.length, l.shape.length)), Yr("argMin", [i[0]], l.shape.length);
    var c = Bv(n, l, i[0], "min");
    return u.forEach(e => n.disposeIntermediateTensorInfo(e)), c;
  }
},
    Uv = {
  kernelName: "Asin",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"
  })
},
    Vv = {
  kernelName: "Asinh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"
  })
},
    Gv = {
  kernelName: "Atan",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  return atan(x);\n"
  })
},
    Hv = {
  kernelName: "Atan2",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",
    packedOpSnippet: "\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
  })
},
    jv = {
  kernelName: "Atanh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"
  })
};

class qv {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    if (this.variableNames = ["x"], "avg" === t && n) throw new Error("Cannot compute positions for average pool.");
    var a = e.filterWidth,
        i = e.strideHeight,
        o = e.strideWidth,
        l = e.dilationHeight,
        u = e.dilationWidth,
        c = e.effectiveFilterHeight,
        h = e.effectiveFilterWidth,
        d = e.padInfo.top,
        p = e.padInfo.left;
    this.outputShape = e.outShape;
    var f = "avg" === t;
    var g = "0.0";
    if (f || (g = "-1.0 / 1e-20"), n) return void (this.userCode = "\n        const ivec2 strides = ivec2(".concat(i, ", ").concat(o, ");\n        const ivec2 pads = ivec2(").concat(d, ", ").concat(p, ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(c, ";\n              wR += ").concat(l, ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h, ";\n                wC += ").concat(u, ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(s ? r ? "((batch  * ".concat(e.inHeight, " + xR) * ").concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + d") : "(xR * ".concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + d") : "wR * ".concat(h, " + wC"), ";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "));
    var m = "".concat(t, "(").concat(t, "(").concat(t, "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");
    "avg" === t && (m = "avgValue / count");
    var b = 4 * Math.floor(a / 4),
        x = a % 4,
        y = "\n      if (".concat(f, ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ");
    this.userCode = "\n      const ivec2 strides = ivec2(".concat(i, ", ").concat(o, ");\n      const ivec2 pads = ivec2(").concat(d, ", ").concat(p, ");\n      const float initializationValue = ").concat(g, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(g, ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(c, ";\n            wR += ").concat(l, ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(b, "; wC += 4) {\n            int xC = xCCorner + wC * ").concat(u, ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u, ", d),\n              getValue(batch, xR, xC + 2 * ").concat(u, ", d),\n              getValue(batch, xR, xC + 3 * ").concat(u, ", d)\n            );\n\n            ").concat(y, "\n          }\n\n          int xC = xCCorner + ").concat(b, ";\n          if (").concat(1 === x, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(y, "\n          } else if (").concat(2 === x, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u, ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(y, "\n          } else if (").concat(3 === x, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u, ", d),\n              getValue(batch, xR, xC + 2 * ").concat(u, ", d),\n              initializationValue\n            );\n\n            ").concat(y, "\n          }\n        }\n        setOutput(").concat(m, ");\n      }\n    ");
  }

}

class Kv {
  constructor(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    if (this.variableNames = ["x"], "avg" === t && n) throw new Error("Cannot compute positions for average pool.");
    var a = e.filterWidth,
        i = e.strideDepth,
        o = e.strideHeight,
        l = e.strideWidth,
        u = e.dilationDepth,
        c = e.dilationHeight,
        h = e.dilationWidth,
        d = e.effectiveFilterDepth,
        p = e.effectiveFilterHeight,
        f = e.effectiveFilterWidth,
        g = e.padInfo.front,
        m = e.padInfo.top,
        b = e.padInfo.left;
    this.outputShape = e.outShape;
    var x = "avg" === t;
    var y = "0.0";
    if (x || (y = "-1.0 / 1e-20"), n) return void (this.userCode = "\n        const ivec3 strides =\n            ivec3(".concat(i, ", ").concat(o, ", ").concat(l, ");\n        const ivec3 pads = ivec3(").concat(g, ", ").concat(m, ", ").concat(b, ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d, ";\n              wD += ").concat(u, ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth, ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p, ";\n                wR += ").concat(c, ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f, ";\n                  wC += ").concat(h, ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(s ? r ? "(((batch * ".concat(e.inDepth, " + xD) * ").concat(e.inHeight, " + xR) * ").concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + ch") : "((xD * ".concat(e.inHeight, " + xR) * ").concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + ch") : "wD * ".concat(p, " * ").concat(f, " +\n                      wR * ").concat(f, " + wC"), ";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "));
    var k = "".concat(t, "(").concat(t, "(").concat(t, "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");
    "avg" === t && (k = "avgValue / count");
    var w = 4 * Math.floor(a / 4),
        v = a % 4,
        I = "\n      if (".concat(x, ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ");
    this.userCode = "\n      const ivec3 strides =\n        ivec3(".concat(i, ", ").concat(o, ", ").concat(l, ");\n      const ivec3 pads = ivec3(").concat(g, ", ").concat(m, ", ").concat(b, ");\n      const float initializationValue = ").concat(y, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(y, ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d, ";\n            wD += ").concat(u, ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth, ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p, ";\n            wR += ").concat(c, ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w, "; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h, ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h, ", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h, ", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h, ", ch)\n              );\n\n              ").concat(I, "\n            }\n\n            int xC = xCCorner + ").concat(w, ";\n            if (").concat(1 === v, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I, "\n            } else if (").concat(2 === v, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h, ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I, "\n            } else if (").concat(3 === v, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h, ", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h, ", ch),\n                initializationValue\n              );\n\n              ").concat(I, "\n            }\n          }\n          setOutput(").concat(k, ");\n        }\n      }\n    ");
  }

}

var Xv = {
  kernelName: "AvgPool",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t;
    ik(r, "avgPool");
    var {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: u
    } = s;
    l(Ss(i, 1), () => "Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'"));
    var c = bs(r.shape, a, i, 1, o, u);
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) return jw({
      inputs: {
        x: r
      },
      backend: n
    });
    var h = new qv(c, "avg", !1);
    return n.runWebGLProgram(h, [r], "float32");
  }
},
    Yv = {
  kernelName: "AvgPool3D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: l,
      dataFormat: u
    } = s,
        c = xs(r.shape, a, i, [1, 1, 1], o, l, u),
        h = new Kv(c, "avg", !1);
    return n.runWebGLProgram(h, [r], "float32");
  }
};

class Jv {
  constructor(e) {
    this.variableNames = ["dy"], this.outputShape = e.inShape;
    var t = e.effectiveFilterHeight,
        n = e.effectiveFilterWidth;
    this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n      const float avgMultiplier = float(").concat(1 / (e.filterHeight * e.filterWidth), ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t, ";\n            wR += ").concat(e.dilationHeight, ") {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(n, ";\n            wC+= ").concat(e.dilationWidth, ") {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class Zv {
  constructor(e) {
    this.variableNames = ["dy"], this.outputShape = e.inShape;
    var t = e.effectiveFilterDepth,
        n = e.effectiveFilterHeight,
        s = e.effectiveFilterWidth;
    this.userCode = "\n      const ivec3 pads = ivec3(".concat(t - 1 - e.padInfo.front, ", ").concat(n - 1 - e.padInfo.top, ", ").concat(s - 1 - e.padInfo.left, ");\n      const float avgMultiplier = float(").concat(1 / (e.filterDepth * e.filterHeight * e.filterWidth), ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(t, ";\n            wD += ").concat(e.dilationDepth, ") {\n          float dyD = float(dyDCorner + wD) / ").concat(e.strideDepth, ".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth, ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(n, ";\n              wR += ").concat(e.dilationHeight, ") {\n            float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(s, ";\n                wC += ").concat(e.dilationWidth, ") {\n              float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

var Qv = {
  kernelName: "AvgPool3DGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        i = a,
        {
      filterSize: o,
      strides: l,
      pad: u,
      dimRoundingMode: c
    } = s,
        h = xs(i.shape, o, l, [1, 1, 1], u, c),
        d = new Zv(h);
    return n.runWebGLProgram(d, [r], i.dtype);
  }
},
    eI = {
  kernelName: "AvgPoolGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        i = a;
    ik([r, a], "avgPoolGrad");
    var {
      filterSize: o,
      strides: l,
      pad: u
    } = s,
        c = bs(i.shape, o, l, 1, u),
        h = new Jv(c);
    return n.runWebGLProgram(h, [r], i.dtype);
  }
},
    tI = {
  kernelName: "BatchMatMul",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      a: r,
      b: a
    } = t,
        {
      transposeA: i,
      transposeB: o
    } = s;
    return vv({
      a: r,
      b: a,
      transposeA: i,
      transposeB: o,
      backend: n
    });
  }
};

class nI {
  constructor(e, t, n, s, r, a) {
    this.outputShape = [], this.variableNames = ["x", "mean", "variance"], cr(e, t), cr(e, n);
    var i = "0.0";
    null != s && (cr(e, s), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
    var o = "1.0";
    null != r && (cr(e, r), this.variableNames.push("scale"), o = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(i, ";\n        float scale = ").concat(o, ";\n        float inv = scale * inversesqrt(variance + float(").concat(a, "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ");
  }

}

class sI {
  constructor(e, t, n, s, r, a) {
    this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], cr(e, t), cr(e, n);
    var i = "vec4(0.0)";
    null != s && (cr(e, s), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
    var o = "vec4(1.0)";
    null != r && (cr(e, r), this.variableNames.push("scale"), o = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = "\n      void main() {\n        vec4 offset = ".concat(i, ";\n        vec4 scale = ").concat(o, ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(a, "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ");
  }

}

var rI = {
  kernelName: "FusedBatchNorm",
  backendName: "webgl",
  kernelFunc: _ref25 => {
    var {
      inputs: e,
      backend: t,
      attrs: n
    } = _ref25;
    var {
      x: s,
      mean: r,
      variance: a,
      offset: i,
      scale: o
    } = e;
    l(r.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), l(null == i || r.shape.length === i.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), l(null == o || r.shape.length === o.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    var {
      varianceEpsilon: u
    } = n;
    null == u && (u = .001);
    var c = [s, r, a];
    var h = null;
    null != i && (h = i.shape, c.push(i));
    var d = null;
    null != o && (d = o.shape, c.push(o));
    var p = V().getBool("WEBGL_PACK_NORMALIZATION") ? new sI(s.shape, r.shape, a.shape, h, d, u) : new nI(s.shape, r.shape, a.shape, h, d, u);
    return t.runWebGLProgram(p, c, c[0].dtype);
  }
};

class aI {
  constructor(e) {
    this.variableNames = ["source"], this.outputShape = e, this.rank = e.length;
    var t = Mk(this.rank);
    this.customUniforms = [{
      name: "start",
      arrayIndex: this.rank,
      type: "int"
    }];

    var n = function (e) {
      if (1 === e) return "sourceLoc";
      if (e <= 6) return iI.slice(0, e).map(e => "sourceLoc." + e).join(",");
      throw Error("Slicing for rank ".concat(e, " is not yet supported"));
    }(this.rank);

    var s;
    s = "\n        ".concat(t, " sourceLoc;\n        ").concat(t, " coords = getOutputCoords();\n        ").concat(e.map((e, t) => "sourceLoc.".concat(iI[t], " = start[").concat(t, "] + coords.").concat(iI[t], ";")).join("\n"), "\n      "), this.userCode = "\n      void main() {\n        ".concat(s, "\n        setOutput(getSource(").concat(n, "));\n      }\n    ");
  }

}

var iI = ["x", "y", "z", "w", "u", "v"];

class oI {
  constructor(e) {
    this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.rank = e.length, this.customUniforms = [{
      name: "start",
      arrayIndex: this.rank,
      type: "int"
    }];
    var t = Mk(this.rank),
        n = Ew("coords", this.rank),
        s = Ew("sourceLoc", this.rank),
        r = 1 === this.rank ? "sourceLoc" : "vec2(".concat(s.slice(-2).join(), ")"),
        a = "getChannel(getSource(".concat(s.join(), "), ").concat(r, ")"),
        i = "\n      result.x = ".concat(a, ";\n      if (++").concat(n[this.rank - 1], " < ").concat(e[this.rank - 1], ") {\n        ++").concat(s[this.rank - 1], ";\n        result.y = ").concat(a, ";\n        --").concat(s[this.rank - 1], ";\n      }\n    "),
        o = 1 === this.rank ? "" : "\n      --".concat(n[this.rank - 1], ";\n      if (++").concat(n[this.rank - 2], " < ").concat(e[this.rank - 2], ") {\n        ++").concat(s[this.rank - 2], ";\n        result.z = ").concat(a, ";\n        if (++").concat(n[this.rank - 1], " < ").concat(e[this.rank - 1], ") {\n          ++").concat(s[this.rank - 1], ";\n          result.w = ").concat(a, ";\n        }\n      }\n    "),
        l = this.rank <= 4 ? "sourceLoc = coords +\n            ".concat(t, "(").concat(e.map((e, t) => "start[".concat(t, "]")).join(), ");") : e.map((e, t) => "".concat(s[t], " = ").concat(n[t], " + start[").concat(t, "];")).join("\n");
    this.userCode = "\n      void main() {\n        ".concat(t, " coords = getOutputCoords();\n        ").concat(t, " sourceLoc;\n        ").concat(l, "\n        vec4 result = vec4(0.);\n        ").concat(i, "\n        ").concat(o, "\n        setOutput(result);\n      }\n    ");
  }

}

function lI(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    begin: a,
    size: i
  } = s,
      [o, l] = Un(r, a, i);
  if (Tn(r, o, l), 0 === d(l)) return n.makeTensorInfo(l, r.dtype, []);

  if (n.shouldExecuteOnCPU([r]) || "string" === r.dtype) {
    var _e463 = n.texData.get(r.dataId),
        _t389 = gw(_e463.values, o, l, r.shape, r.dtype);

    return n.makeTensorInfo(l, r.dtype, _t389);
  }

  var {
    isPacked: u
  } = n.texData.get(r.dataId),
      c = Pn(r.shape, o, l);

  if (u || !c) {
    var _e464 = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new oI(l) : new aI(l);

    return n.runWebGLProgram(_e464, [r], r.dtype, [o]);
  }

  return n.uploadToGPU(r.dataId), function (e, t, n, s) {
    var r = s.texData.get(e.dataId),
        a = s.makeTensorInfo(n, e.dtype),
        i = s.texData.get(a.dataId);
    Object.assign(i, r), i.refCount = 1, i.shape = n, i.dtype = e.dtype;
    var o = Wn(t, A(e.shape));
    r.slice && (o += r.slice.flatOffset), i.slice = {
      flatOffset: o,
      origDataId: r.slice && r.slice.origDataId || e.dataId
    };
    var l = s.dataRefCount.get(i.slice.origDataId) || 1;
    return s.dataRefCount.set(i.slice.origDataId, l + 1), a;
  }(r, o, l, n);
}

var uI = {
  kernelName: "Slice",
  backendName: "webgl",
  kernelFunc: lI
},
    cI = {
  kernelName: "BatchToSpaceND",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockShape: a,
      crops: i
    } = s;
    l(r.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");

    var o = a.reduce((e, t) => e * t),
        u = Ro(r.shape, a, o),
        c = Ao(u.length, a.length),
        h = Fo(r.shape, a, o),
        d = Do(i, a.length),
        p = _o(h, i, a.length),
        f = [],
        g = cv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: u
      }
    }),
        m = kv({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        perm: c
      }
    }),
        b = cv({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: h
      }
    }),
        x = lI({
      inputs: {
        x: b
      },
      backend: n,
      attrs: {
        begin: d,
        size: p
      }
    });

    return f.push(g), f.push(m), f.push(b), f.forEach(e => n.disposeIntermediateTensorInfo(e)), x;
  }
},
    hI = {
  kernelName: "Bincount",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      weights: a
    } = t,
        {
      size: i
    } = s,
        o = n.readSync(r.dataId),
        l = n.readSync(a.dataId),
        u = Vk(o, l, a.dtype, a.shape, i);
    return n.makeTensorInfo([i], a.dtype, u);
  }
},
    dI = sv({
  opSnippet: "return float(a != b);",
  cpuKernelImpl: cw,
  dtype: "bool"
}),
    pI = {
  kernelName: "NotEqual",
  backendName: "webgl",
  kernelFunc: dI
};

function fI(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    input: s
  } = t;
  return jw({
    inputs: {
      x: n.texData.get(s.dataId).complexTensorInfos.real
    },
    backend: n
  });
}

var gI = {
  kernelName: "Real",
  backendName: "webgl",
  kernelFunc: fI
},
    mI = {
  kernelName: "Cast",
  backendName: "webgl",
  kernelFunc: function e(t) {
    var {
      inputs: n,
      backend: s,
      attrs: r
    } = t,
        {
      x: a
    } = n,
        {
      dtype: i
    } = r;

    if ("complex64" === i) {
      if ("complex64" === a.dtype) return jw({
        inputs: {
          x: a
        },
        backend: s
      });

      var _t390 = ua(a.shape),
          _n285 = e({
        inputs: {
          x: a
        },
        backend: s,
        attrs: {
          dtype: "float32"
        }
      }),
          _r163 = Kw({
        inputs: {
          real: _n285,
          imag: _t390
        },
        backend: s
      });

      return _t390.dispose(), s.disposeIntermediateTensorInfo(_n285), _r163;
    }

    if ("complex64" === a.dtype) {
      var _t391 = fI({
        inputs: {
          input: a
        },
        backend: s
      }),
          _n286 = e({
        inputs: {
          x: _t391
        },
        backend: s,
        attrs: {
          dtype: i
        }
      });

      return s.disposeIntermediateTensorInfo(_t391), _n286;
    }

    if (!I(a.dtype, i)) {
      var _e465 = jw({
        inputs: {
          x: a
        },
        backend: s
      });

      return {
        dataId: _e465.dataId,
        shape: _e465.shape,
        dtype: i
      };
    }

    if ("int32" === i) return function (e, t) {
      var n = new Mw(e.shape, "return float(int(x));"),
          s = t.runWebGLProgram(n, [e], "int32");
      return {
        dataId: s.dataId,
        shape: s.shape,
        dtype: s.dtype
      };
    }(a, s);

    if ("bool" === i) {
      var _e466 = s.makeTensorInfo([], "bool", w("bool", 1)),
          _t392 = dI({
        inputs: {
          a,
          b: _e466
        },
        backend: s
      });

      return s.disposeIntermediateTensorInfo(_e466), _t392;
    }

    throw new Error("Error in Cast: failed to cast ".concat(a.dtype, " to ").concat(i));
  }
},
    bI = "return ceil(x);",
    xI = {
  kernelName: "Ceil",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: bI,
    packedOpSnippet: bI,
    cpuKernelImpl: Hk
  })
};

class yI {
  constructor(e) {
    this.variableNames = ["A"], this.customUniforms = [{
      name: "minVal",
      type: "float"
    }, {
      name: "maxVal",
      type: "float"
    }], this.outputShape = e, this.userCode = "\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
  }

}

class kI {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
      name: "minVal",
      type: "float"
    }, {
      name: "maxVal",
      type: "float"
    }], this.outputShape = e, this.userCode = "\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
  }

}

var wI = {
  kernelName: "ClipByValue",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      clipValueMin: a,
      clipValueMax: i
    } = s;
    var o;
    return o = V().getBool("WEBGL_PACK_CLIP") ? new kI(r.shape) : new yI(r.shape), n.runWebGLProgram(o, [r], r.dtype, [[a], [i]]);
  }
};

class vI {
  constructor(e) {
    this.variableNames = ["real", "imag"], this.outputShape = e, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
  }

}

function II(e, t) {
  return {
    dataId: t.dataId,
    dtype: t.dtype,
    shape: e.shape
  };
}

var $I = {
  kernelName: "ComplexAbs",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t,
        r = n.texData.get(s.dataId),
        a = new vI(s.shape),
        i = [II(s, r.complexTensorInfos.real), II(s, r.complexTensorInfos.imag)];
    return n.runWebGLProgram(a, i, i[0].dtype);
  }
};

class NI {
  constructor(e) {
    this.outputShape = [], this.outputShape = So(e, 1), this.variableNames = e.map((e, t) => "T".concat(t));
    var t = new Array(e.length - 1);
    t[0] = e[0][1];

    for (var _n287 = 1; _n287 < t.length; _n287++) {
      t[_n287] = t[_n287 - 1] + e[_n287][1];
    }

    var n = ["if (yC < ".concat(t[0], ") setOutput(getT0(yR, yC));")];

    for (var _e467 = 1; _e467 < t.length; _e467++) {
      n.push("else if (yC < ".concat(t[_e467], ") setOutput(getT").concat(_e467, "(yR, yC-").concat(t[_e467 - 1], "));"));
    }

    n.push("else setOutput(getT".concat(t.length, "(yR, yC-").concat(t[t.length - 1], "));")), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "), "\n      }\n    ");
  }

}

class CI {
  constructor(e, t) {
    this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = So(e, t);
    var n = this.outputShape,
        s = n.length,
        r = Mk(s),
        a = Ew("coords", s),
        i = ["x", "y", "z", "w", "u", "v"].slice(0, s);
    this.variableNames = e.map((e, t) => "T".concat(t));
    var o = new Array(e.length - 1);
    o[0] = e[0][t];

    for (var _n288 = 1; _n288 < o.length; _n288++) {
      o[_n288] = o[_n288 - 1] + e[_n288][t];
    }

    var l = i[t],
        u = i.slice(-2),
        c = i.join();
    var h = "if (".concat(l, " < ").concat(o[0], ") {\n        return getChannel(\n            getT0(").concat(c, "), vec2(").concat(u.join(), "));\n        }");

    for (var _e468 = 1; _e468 < o.length; _e468++) {
      var _t393 = o[_e468 - 1];
      h += "\n        if (".concat(l, " < ").concat(o[_e468], "  && ").concat(l, " >= ").concat(o[_e468 - 1], ") {\n          return getChannel(\n            getT").concat(_e468, "(").concat(SI(i, l, _t393), "),\n            vec2(").concat(SI(u, l, _t393), "));\n        }");
    }

    var d = o[o.length - 1];
    h += "\n        return getChannel(\n          getT".concat(o.length, "(").concat(SI(i, l, d), "),\n          vec2(").concat(SI(u, l, d), "));"), this.userCode = "\n      float getValue(".concat(i.map(e => "int " + e), ") {\n        ").concat(h, "\n      }\n\n      void main() {\n        ").concat(r, " coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(a, "), 0., 0., 0.);\n\n        ").concat(a[s - 1], " = ").concat(a[s - 1], " + 1;\n        if (").concat(a[s - 1], " < ").concat(n[s - 1], ") {\n          result.g = getValue(").concat(a, ");\n        }\n\n        ").concat(a[s - 2], " = ").concat(a[s - 2], " + 1;\n        if (").concat(a[s - 2], " < ").concat(n[s - 2], ") {\n          result.a = getValue(").concat(a, ");\n        }\n\n        ").concat(a[s - 1], " = ").concat(a[s - 1], " - 1;\n        if (").concat(a[s - 2], " < ").concat(n[s - 2], " &&\n            ").concat(a[s - 1], " < ").concat(n[s - 1], ") {\n          result.b = getValue(").concat(a, ");\n        }\n        setOutput(result);\n      }\n    ");
  }

}

function SI(e, t, n) {
  var s = e.indexOf(t);
  return e.map((e, t) => t === s ? "".concat(e, " - ").concat(n) : e).join();
}

function TI(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    input: s
  } = t;
  return jw({
    inputs: {
      x: n.texData.get(s.dataId).complexTensorInfos.imag
    },
    backend: n
  });
}

var EI = {
  kernelName: "Imag",
  backendName: "webgl",
  kernelFunc: TI
};

function RI(e, t, n) {
  var s = e[0].dtype;

  if ("complex64" === s) {
    var _s225 = e.map(e => fI({
      inputs: {
        input: e
      },
      backend: n
    })),
        _r164 = e.map(e => TI({
      inputs: {
        input: e
      },
      backend: n
    })),
        _a134 = RI(_s225, t, n),
        _i95 = RI(_r164, t, n),
        _o73 = Kw({
      inputs: {
        real: _a134,
        imag: _i95
      },
      backend: n
    });

    return _s225.forEach(e => n.disposeIntermediateTensorInfo(e)), _r164.forEach(e => n.disposeIntermediateTensorInfo(e)), n.disposeIntermediateTensorInfo(_a134), n.disposeIntermediateTensorInfo(_i95), _o73;
  }

  var r = n.shouldExecuteOnCPU(e);

  if ("string" === s && (r = !0), r) {
    var _r165 = e.map(e => {
      var s = d(e.shape.slice(t));
      return cv({
        inputs: {
          x: e
        },
        backend: n,
        attrs: {
          shape: [-1, s]
        }
      });
    }),
        _a135 = _r165.map(e => ({
      vals: n.readSync(e.dataId),
      shape: e.shape
    })),
        _i96 = So(_r165.map(e => e.shape), 1),
        _o74 = jk(_a135, _i96, s, 1 === _r165[0].shape[0]),
        _l52 = So(e.map(e => e.shape), t),
        _u40 = n.makeTensorInfo(_l52, s, _o74);

    return _r165.forEach(e => n.disposeIntermediateTensorInfo(e)), _u40;
  }

  if (e.length > V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    var _s226 = Math.floor(e.length / 2),
        _r166 = RI(e.slice(0, _s226), t, n),
        _a136 = RI(e.slice(_s226), t, n),
        _i97 = RI([_r166, _a136], t, n);

    return n.disposeIntermediateTensorInfo(_r166), n.disposeIntermediateTensorInfo(_a136), _i97;
  }

  if (V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && e[0].shape.length > 1) {
    var _r167 = new CI(e.map(e => e.shape), t);

    return n.runWebGLProgram(_r167, e, s);
  }

  var {
    tensors2D: a,
    outShape: i
  } = function (e, t, n) {
    var s = So(e.map(e => e.shape), t);
    return {
      tensors2D: e.map(e => cv({
        inputs: {
          x: e
        },
        attrs: {
          shape: [-1, d(e.shape.slice(t))]
        },
        backend: n
      })),
      outShape: s
    };
  }(e, t, n),
      o = new NI(a.map(e => e.shape)),
      l = n.runWebGLProgram(o, a, s);

  a.forEach(e => n.disposeIntermediateTensorInfo(e));
  var u = cv({
    inputs: {
      x: l
    },
    attrs: {
      shape: i
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(l), u;
}

function AI(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    axis: r
  } = s,
      a = y(r, t[0].shape)[0],
      i = So(t.map(e => e.shape), a);
  if (0 === d(i)) return n.makeTensorInfo(i, t[0].dtype, []);
  var o = t.filter(e => d(e.shape) > 0);
  return 1 === o.length ? jw({
    inputs: {
      x: o[0]
    },
    backend: n
  }) : (Co(o.map(e => e.shape), a), RI(o, a, n));
}

var FI = {
  kernelName: "Concat",
  backendName: "webgl",
  kernelFunc: AI
};

class DI {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    var a = e.padInfo.top,
        i = e.padInfo.left,
        o = e.strideHeight,
        l = e.strideWidth,
        u = e.dilationHeight,
        c = e.dilationWidth,
        h = e.filterHeight,
        d = e.filterWidth,
        p = 4 * Math.floor(e.inChannels / 4),
        f = e.inChannels % 4,
        g = "channelsLast" === e.dataFormat,
        m = g ? 1 : 2,
        b = g ? 2 : 3,
        x = g ? 3 : 1;
    var y = "",
        k = "";
    n && (y = s ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n, "\n        }") : r ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n, "\n        }") : "\n          float activation(float x) {\n            ".concat(n, "\n          }\n        "), k = "result = activation(result);");
    var w = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(y, "\n\n      const ivec2 strides = ivec2(").concat(o, ", ").concat(l, ");\n      const ivec2 pads = ivec2(").concat(a, ", ").concat(i, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(x, "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(m, "], coords[").concat(b, "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h, "; wR++) {\n          int xR = xRCorner + wR * ").concat(u, ";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d, "; wC++) {\n            int xC = xCCorner + wC * ").concat(c, ";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p, "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g, ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1 === f, ") {\n\n              if (").concat(g, ") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p, ") *\n                    getW(wR, wC, ").concat(p, ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p, ", xR, xC) *\n                    getW(wR, wC, ").concat(p, ", d2);\n              }\n\n            } else if (").concat(2 === f, ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p, ", d2),\n                getW(wR, wC, ").concat(p, " + 1, d2)\n              );\n\n              if (").concat(g, ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p, "),\n                  getX(batch, xR, xC, ").concat(p, " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p, ", xR, xC),\n                  getX(batch, ").concat(p, " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3 === f, ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p, ", d2),\n                getW(wR, wC, ").concat(p, " + 1, d2),\n                getW(wR, wC, ").concat(p, " + 2, d2)\n              );\n\n              if (").concat(g, ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p, "),\n                  getX(batch, xR, xC, ").concat(p, " + 1),\n                  getX(batch, xR, xC, ").concat(p, " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p, ", xR, xC),\n                  getX(batch, ").concat(p, " + 1, xR, xC),\n                  getX(batch, ").concat(p, " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w, "\n        ").concat(k, "\n        setOutput(result);\n      }\n    ");
  }

}

class _I {
  constructor(e) {
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    var t = e.padInfo.front,
        n = e.padInfo.top,
        s = e.padInfo.left,
        r = e.strideDepth,
        a = e.strideHeight,
        i = e.strideWidth,
        o = e.dilationDepth,
        l = e.dilationHeight,
        u = e.dilationWidth,
        c = e.filterDepth,
        h = e.filterHeight,
        d = e.filterWidth,
        p = 4 * Math.floor(e.inChannels / 4),
        f = e.inChannels % 4;
    this.userCode = "\n      const ivec3 strides = ivec3(".concat(r, ", ").concat(a, ", ").concat(i, ");\n      const ivec3 pads = ivec3(").concat(t, ", ").concat(n, ", ").concat(s, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(c, "; wF++) {\n          int xF = xFCorner + wF * ").concat(o, ";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth, ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h, "; wR++) {\n            int xR = xRCorner + wR * ").concat(l, ";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d, "; wC++) {\n              int xC = xCCorner + wC * ").concat(u, ";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p, "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1 === f, ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p, ") *\n                  getW(wF, wR, wC, ").concat(p, ", d2);\n              } else if (").concat(2 === f, ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p, "),\n                  getX(batch, xF, xR, xC, ").concat(p, " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p, ", d2),\n                  getW(wF, wR, wC, ").concat(p, " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3 === f, ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p, "),\n                  getX(batch, xF, xR, xC, ").concat(p, " + 1),\n                  getX(batch, xF, xR, xC, ").concat(p, " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p, ", d2),\n                  getW(wF, wR, wC, ").concat(p, " + 1, d2),\n                  getW(wF, wR, wC, ").concat(p, " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class OI {
  constructor(e, t, n) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
    var {
      filterWidth: s,
      inChannels: r,
      strideWidth: a,
      strideHeight: i,
      padInfo: o,
      outWidth: l,
      dilationWidth: u,
      dilationHeight: c,
      dataFormat: h
    } = n,
        {
      left: d,
      top: p
    } = o,
        f = r * s,
        g = lk(),
        m = "channelsLast" === h,
        b = m ? 0 : 1,
        x = m ? 1 : 2;
    var y = "";

    for (var _n289 = 0; _n289 <= 1; _n289++) {
      for (var _s227 = 0; _s227 <= 1; _s227++) {
        y += "\n          blockIndex = rc.y + ".concat(_s227, ";\n          pos = rc.x + ").concat(_n289, ";\n\n          if(blockIndex < ").concat(e[1], " && pos < ").concat(e[0], ") {\n            offsetY = int(blockIndex / (").concat(l, ")) * ").concat(i, " - ").concat(p, ";\n            d0 = offsetY + ").concat(c, " * (pos / ").concat(f, ");\n\n            if(d0 < ").concat(t[b], " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ").concat(l, ".) * ").concat(a, ". - ").concat(d, ".);\n              d1 = offsetX + ").concat(u, " * (int(mod(float(pos), ").concat(f, ".) / ").concat(r, ".));\n\n              if(d1 < ").concat(t[x], " && d1 >= 0) {\n\n                ch = int(mod(float(pos), ").concat(r, ".));\n\n                if (").concat(m, ") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2 * _n289 + _s227, "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2 * _n289 + _s227, "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");
      }
    }

    this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(y, "\n\n        ").concat(g.output, " = result;\n      }\n    ");
  }

}

function MI(_ref26) {
  var {
    x: e,
    filter: t,
    convInfo: n,
    backend: s,
    bias: r = null,
    preluActivationWeights: a = null,
    leakyreluAlpha: i = 0,
    activation: o = null
  } = _ref26;
  var u = e.shape,
      c = s.texData.get(e.dataId),
      h = "channelsLast" === n.dataFormat;
  var d;
  var p = [],
      f = u[2] % 2 != 0 && !!c.isPacked;

  if ((1 != u[0] * u[1] * u[2] && 1 !== n.outChannels || !(n.inChannels > 1e3)) && V().getBool("WEBGL_LAZILY_UNPACK") && V().getBool("WEBGL_PACK_BINARY_OPERATIONS") && f) {
    var _f13 = {
      dataId: e.dataId,
      shape: [1, h ? u[0] * u[1] * (u[2] + 1) : u[0] * u[2] * (u[3] + 1), n.inChannels],
      dtype: e.dtype
    },
        _g21 = c.shape;
    c.shape = c.shape.slice(), c.shape[c.shape.length - 2]++, l(ek(c.shape, _f13.shape), () => "packed reshape ".concat(c.shape, " to ").concat(_f13.shape, " isn't free"));

    var _m14 = cv({
      inputs: {
        x: t
      },
      backend: s,
      attrs: {
        shape: [1, n.inChannels, n.outChannels]
      }
    });

    p.push(_m14);

    var _b15 = vv({
      a: _f13,
      b: _m14,
      backend: s,
      transposeA: !1,
      transposeB: !1,
      bias: r,
      activation: o,
      preluActivationWeights: a,
      leakyreluAlpha: i
    }),
        _x55 = s.texData.get(_b15.dataId);

    l(_x55.isPacked, () => "batchMatMul result is expected to be packed"), c.shape = _g21, _x55.shape = n.outShape, d = jw({
      inputs: {
        x: _b15
      },
      backend: s
    }), d.shape = n.outShape, p.push(_b15);
  } else {
    var _l53 = cv({
      inputs: {
        x: e
      },
      backend: s,
      attrs: {
        shape: [1, h ? u[0] * u[1] * u[2] : u[0] * u[2] * u[3], n.inChannels]
      }
    }),
        _c34 = cv({
      inputs: {
        x: t
      },
      backend: s,
      attrs: {
        shape: [1, n.inChannels, n.outChannels]
      }
    }),
        _f14 = vv({
      a: _l53,
      b: _c34,
      transposeA: !1,
      transposeB: !1,
      backend: s,
      bias: r,
      activation: o,
      preluActivationWeights: a,
      leakyreluAlpha: i
    });

    d = cv({
      inputs: {
        x: _f14
      },
      backend: s,
      attrs: {
        shape: n.outShape
      }
    }), p.push(_l53), p.push(_c34), p.push(_f14);
  }

  for (var _e469 of p) {
    s.disposeIntermediateTensorInfo(_e469);
  }

  return d;
}

function LI(_ref27) {
  var {
    x: e,
    filter: t,
    convInfo: n,
    backend: s,
    bias: r = null,
    preluActivationWeights: a = null,
    leakyreluAlpha: i = 0,
    activation: o = null
  } = _ref27;
  var {
    filterWidth: l,
    filterHeight: u,
    inChannels: c,
    outWidth: h,
    outHeight: p,
    dataFormat: f
  } = n,
      g = "channelsLast" === f,
      m = l * u * c,
      b = p * h,
      x = [m, b],
      y = [],
      k = cv({
    inputs: {
      x: e
    },
    backend: s,
    attrs: {
      shape: e.shape.slice(1)
    }
  }),
      w = cv({
    inputs: {
      x: t
    },
    backend: s,
    attrs: {
      shape: [1, m, d(t.shape) / m]
    }
  });
  y.push(k), y.push(w);
  var v = new OI(x, k.shape, n),
      I = s.runWebGLProgram(v, [k], "float32"),
      $ = cv({
    inputs: {
      x: I
    },
    backend: s,
    attrs: {
      shape: [1, x[0], x[1]]
    }
  });
  y.push(I), y.push($);
  var N = null != r,
      C = null != a,
      S = "leakyrelu" === o,
      T = o ? rv(o, !0) : null,
      E = new av($.shape, w.shape, [1, b, n.outChannels], !0, !1, N, T, C, S),
      R = [$, w];

  if (r && R.push(r), C && R.push(a), S) {
    var _e470 = s.makeTensorInfo([], "float32", We(i, "float32"));

    R.push(_e470), y.push(_e470);
  }

  var A = s.runWebGLProgram(E, R, "float32"),
      F = cv({
    inputs: {
      x: A
    },
    backend: s,
    attrs: {
      shape: g ? [1, p, h, n.outChannels] : [1, n.outChannels, p, h]
    }
  });
  y.push(A);

  for (var _e471 of y) {
    s.disposeIntermediateTensorInfo(_e471);
  }

  return F;
}

var zI = {
  kernelName: "Conv2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a
    } = t,
        {
      strides: i,
      pad: o,
      dataFormat: l,
      dilations: u,
      dimRoundingMode: c
    } = s,
        h = Ts(l),
        d = ys(r.shape, a.shape, i, u, o, c, !1, h);
    var p;
    if (1 !== d.filterHeight || 1 !== d.filterWidth || 1 !== d.dilationHeight || 1 !== d.dilationWidth || 1 !== d.strideHeight || 1 !== d.strideWidth || "SAME" !== d.padInfo.type && "VALID" !== d.padInfo.type) {
      if (V().getBool("WEBGL_CONV_IM2COL") && 1 === r.shape[0]) p = LI({
        x: r,
        filter: a,
        convInfo: d,
        backend: n
      });else {
        var _e472 = new DI(d);

        p = n.runWebGLProgram(_e472, [r, a], "float32");
      }
    } else p = MI({
      x: r,
      filter: a,
      convInfo: d,
      backend: n
    });
    var f = cv({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        shape: d.outShape
      }
    });
    return n.disposeIntermediateTensorInfo(p), f;
  }
};

class BI {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize, "; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight, "; yR++) {\n            int xR = wR + yR * ").concat(e.strideHeight, " - ").concat(e.padInfo.top, ";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth, "; yC++) {\n              int xC = wC + yC * ").concat(e.strideWidth, " - ").concat(e.padInfo.left, ";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              if (").concat("channelsLast" === e.dataFormat, ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class PI {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    var t = e.filterHeight,
        n = e.filterWidth,
        s = "channelsLast" === e.dataFormat;
    this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(s ? 3 : 1, "];\n\n        ivec2 dyCorner = ivec2(coords[").concat(s ? 1 : 2, "], coords[").concat(s ? 2 : 3, "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t, "; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n, " - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels, "; d2++) {\n\n              if (").concat(s, ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class WI {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape, this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize, "; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth, "; yF++) {\n            int xF = wF + yF * ").concat(e.strideDepth, " - ").concat(e.padInfo.front, ";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth, ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight, "; yR++) {\n              int xR = wR + yR * ").concat(e.strideHeight, " - ").concat(e.padInfo.top, ";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth, "; yC++) {\n                int xC = wC + yC * ").concat(e.strideWidth, " - ").concat(e.padInfo.left, ";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class UI {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    var t = e.filterDepth,
        n = e.filterHeight,
        s = e.filterWidth;
    this.userCode = "\n      const ivec3 pads = ivec3(".concat(t - 1 - e.padInfo.front, ", ").concat(n - 1 - e.padInfo.top, ", ").concat(s - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t, "; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(e.strideDepth, ".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth, ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t, " - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n, "; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n, " - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(s, "; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(s, " - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels, "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

var VI = {
  kernelName: "Conv2DBackpropFilter",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      pad: o,
      dataFormat: l,
      dimRoundingMode: u,
      filterShape: c
    } = s,
        h = Ts(l),
        d = ys(r.shape, c, i, 1, o, u, !1, h),
        p = new BI(d);
    return n.runWebGLProgram(p, [r, a], "float32");
  }
},
    GI = {
  kernelName: "Conv2DBackpropInput",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      inputShape: i,
      strides: o,
      pad: l,
      dataFormat: u,
      dimRoundingMode: c
    } = s,
        h = Ts(u),
        d = ys(i, a.shape, o, 1, l, c, !1, h),
        p = new PI(d);
    return n.runWebGLProgram(p, [r, a], "float32");
  }
},
    HI = {
  kernelName: "Conv3D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a
    } = t,
        {
      strides: i,
      pad: o,
      dilations: l
    } = s,
        u = ks(r.shape, a.shape, i, l, o),
        c = new _I(u);
    return n.runWebGLProgram(c, [r, a], "float32");
  }
},
    jI = {
  kernelName: "Conv3DBackpropFilterV2",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      pad: o,
      filterShape: l
    } = s,
        u = ks(r.shape, l, i, 1, o),
        c = new WI(u);
    return n.runWebGLProgram(c, [r, a], "float32");
  }
},
    qI = {
  kernelName: "Conv3DBackpropInputV2",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      pad: i,
      strides: o,
      inputShape: l
    } = s,
        u = ks(l, a.shape, o, 1, i),
        c = new UI(u);
    return n.runWebGLProgram(c, [r, a], "float32");
  }
},
    KI = {
  kernelName: "Cos",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  return cos(x);\n"
  })
},
    XI = {
  kernelName: "Cosh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"
  })
};

class YI {
  constructor(e, t, n, s, r) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
    var [a, i, o, l] = e,
        [u] = t,
        [c, h] = n;
    this.outputShape = [u, c, h, l];
    var d = "bilinear" === s ? 1 : 0,
        [p, f] = [i - 1 + ".0", o - 1 + ".0"],
        [g, m, b] = c > 1 ? ["" + (i - 1) / (c - 1), "(y2-y1) * height_ratio", "y1*".concat(p, " + float(y)*(height_scale)")] : ["0.0", "0.0", "0.5 * (y1+y2) * ".concat(p)],
        [x, y, k] = h > 1 ? ["" + (o - 1) / (h - 1), "(x2-x1) * width_ratio", "x1*".concat(f, " + float(x)*(width_scale)")] : ["0.0", "0.0", "0.5 * (x1+x2) * ".concat(f)];
    this.userCode = "\n      const float height_ratio = float(".concat(g, ");\n      const float width_ratio = float(").concat(x, ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(a, ") {\n          return;\n        }\n\n        float height_scale = ").concat(m, ";\n        float width_scale = ").concat(y, ";\n\n        float in_y = ").concat(b, ";\n        if( in_y < 0.0 || in_y > ").concat(p, " ) {\n          setOutput(float(").concat(r, "));\n          return;\n        }\n        float in_x = ").concat(k, ";\n        if( in_x < 0.0 || in_x > ").concat(f, " ) {\n          setOutput(float(").concat(r, "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d, " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ");
  }

}

var JI = {
  kernelName: "CropAndResize",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      image: r,
      boxes: a,
      boxInd: i
    } = t,
        {
      cropSize: o,
      method: l,
      extrapolationValue: u
    } = s,
        c = new YI(r.shape, a.shape, o, l, u);
    return n.runWebGLProgram(c, [r, a, i], "float32");
  }
};

class ZI {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.customUniforms = [{
      name: "index",
      type: "float"
    }], this.outputShape = e;
    var s = e.length,
        r = t ? "0.0" : "getX(".concat(QI(s, "coords"), ")"),
        a = e[e.length - 1];
    var i = "",
        o = "";
    t ? (i = n ? "end != " + (a - 1) : "end != 0", o = n ? "end + 1" : "end - 1") : (i = n ? "end + pow2 < ".concat(a) : "end >= pow2", o = n ? "end + pow2" : "end - pow2"), this.userCode = "\n      void main() {\n        ".concat(Mk(s), " coords = getOutputCoords();\n        int end = ").concat(e$(s, "coords"), ";\n        float val = ").concat(r, ";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(i, ") {\n          int idx = ").concat(o, ";\n          ").concat(e$(s, "coords"), " = idx;\n          val += getX(").concat(QI(s, "coords"), ");\n        }\n        setOutput(val);\n      }\n    ");
  }

}

function QI(e, t) {
  if (1 === e) return "".concat(t);
  if (2 === e) return "".concat(t, ".x, ").concat(t, ".y");
  if (3 === e) return "".concat(t, ".x, ").concat(t, ".y, ").concat(t, ".z");
  if (4 === e) return "".concat(t, ".x, ").concat(t, ".y, ").concat(t, ".z, ").concat(t, ".w");
  throw Error("Cumulative sum for rank ".concat(e, " is not yet supported"));
}

function e$(e, t) {
  if (1 === e) return "".concat(t);
  if (2 === e) return "".concat(t, ".y");
  if (3 === e) return "".concat(t, ".z");
  if (4 === e) return "".concat(t, ".w");
  throw Error("Cumulative sum for rank ".concat(e, " is not yet supported"));
}

var t$ = {
  kernelName: "Cumsum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      exclusive: i,
      reverse: o
    } = s,
        l = r.shape.length,
        u = Jr([a], l);
    var c = r;
    null != u && (c = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }));
    var h = Qr(1, l)[0];
    if (h !== l - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=".concat(r.shape.length - 1, " but got axis=").concat(a));
    var d = c.shape[h];
    var p = jw({
      inputs: {
        x: c
      },
      backend: n
    });

    for (var _e473 = 0; _e473 <= Math.ceil(Math.log2(d)) - 1; _e473++) {
      var _t394 = new ZI(c.shape, !1, o),
          _s228 = p;

      p = n.runWebGLProgram(_t394, [p], p.dtype, [[_e473]]), n.disposeIntermediateTensorInfo(_s228);
    }

    if (i) {
      var _e474 = new ZI(c.shape, i, o),
          _t395 = p;

      p = n.runWebGLProgram(_e474, [p], p.dtype), n.disposeIntermediateTensorInfo(_t395);
    }

    if (null != u) {
      var _e475 = kv({
        inputs: {
          x: p
        },
        backend: n,
        attrs: {
          perm: Zr(u)
        }
      });

      return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(c), _e475;
    }

    return p;
  }
},
    n$ = {
  kernelName: "DenseBincount",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      weights: a
    } = t,
        {
      size: i,
      binaryOutput: o
    } = s;

    if (1 === r.shape.length) {
      var _e476 = n.readSync(r.dataId),
          _t396 = n.readSync(a.dataId),
          _s229 = Vk(_e476, _t396, a.dtype, a.shape, i);

      return n.makeTensorInfo([i], a.dtype, _s229);
    }

    if (2 === r.shape.length) {
      var _e477 = n.bufferSync(r),
          _t397 = n.bufferSync(a),
          _s230 = Gk(_e477, _t397, i, o);

      return n.makeTensorInfo(_s230.shape, a.dtype, _s230.values);
    }

    throw new Error("Error in denseBincount: input must be at most rank 2, but got rank".concat(r.shape.length, "."));
  }
};

class s$ {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = e, this.blockSize = t, this.dataFormat = n, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(), ";\n      int w = ").concat(this.getWidthCoordString(), ";\n      int d = ").concat(this.getDepthCoordString(), ";\n\n      int in_h = h / ").concat(t, ";\n      int offset_h = imod(h, ").concat(t, ");\n      int in_w = w / ").concat(t, ";\n      int offset_w = imod(w, ").concat(t, ");\n      int offset_d = (offset_h * ").concat(t, " + offset_w) *\n        ").concat(this.getOutputDepthSize(), ";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(), ";\n      setOutput(result);\n    }\n  ");
  }

  getHeightCoordString() {
    return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
  }

  getWidthCoordString() {
    return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
  }

  getDepthCoordString() {
    return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
  }

  getOutputDepthSize() {
    return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
  }

  getInputSamplingString() {
    return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }

}

var r$ = {
  kernelName: "DepthToSpace",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockSize: a,
      dataFormat: i
    } = s;
    l(a > 1, () => "blockSize should be > 1 for depthToSpace, but was: ".concat(a));
    var o = r.shape[0],
        u = ("NHWC" === i ? r.shape[1] : r.shape[2]) * a,
        c = ("NHWC" === i ? r.shape[2] : r.shape[3]) * a,
        h = ("NHWC" === i ? r.shape[3] : r.shape[1]) / (a * a),
        d = new s$("NHWC" === i ? [o, u, c, h] : [o, h, u, c], a, i);
    return n.runWebGLProgram(d, [r], r.dtype);
  }
};

class a$ {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    var a = e.inHeight,
        i = e.inWidth,
        o = e.padInfo.top,
        l = e.padInfo.left,
        u = e.strideHeight,
        c = e.strideWidth,
        h = e.dilationHeight,
        d = e.dilationWidth,
        p = e.filterHeight,
        f = e.filterWidth,
        g = e.outChannels / e.inChannels;
    var m = "",
        b = "";
    n && (m = s ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n, "\n        }") : r ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n, "\n        }") : "\n          float activation(float x) {\n            ".concat(n, "\n          }\n        "), b = "result = activation(result);");
    var x = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(m, "\n\n      const ivec2 strides = ivec2(").concat(u, ", ").concat(c, ");\n      const ivec2 pads = ivec2(").concat(o, ", ").concat(l, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(g, ";\n        int q = d2 - d1 * ").concat(g, ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(p, "; wR++) {\n          int xR = xRCorner + wR * ").concat(h, ";\n\n          if (xR < 0 || xR >= ").concat(a, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(f, "; wC++) {\n            int xC = xCCorner + wC * ").concat(d, ";\n\n            if (xC < 0 || xC >= ").concat(i, ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(x, "\n        ").concat(b, "\n        setOutput(result);\n      }\n    ");
  }

}

class i$ {
  constructor(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.outShape;
    var a = e.outChannels / e.inChannels,
        o = e.inHeight,
        l = e.inWidth,
        u = e.padInfo.top,
        c = e.padInfo.left,
        h = e.strideHeight,
        d = e.strideWidth,
        p = e.dilationHeight,
        f = e.dilationWidth,
        g = e.filterHeight,
        m = e.filterWidth,
        b = m;
    var x = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";

    for (var _e478 = 0; _e478 < m; _e478++) {
      x += "\n          vec4 xTexelC".concat(2 * _e478, ";\n          int xTexelC").concat(2 * _e478, "Ready;\n          vec4 xTexelC").concat(2 * _e478 + 1, ";\n          int xTexelC").concat(2 * _e478 + 1, "Ready;\n          vec4 xC").concat(_e478, ";");
    }

    for (var _e479 = 0; _e479 < g; _e479++) {
      for (var _e480 = 0; _e480 < m; _e480++) {
        x += "\n          xTexelC".concat(2 * _e480, " = vec4(0.0);\n          xTexelC").concat(2 * _e480, "Ready = 0;\n          xTexelC").concat(2 * _e480 + 1, " = vec4(0.0);\n          xTexelC").concat(2 * _e480 + 1, "Ready = 0;\n          xC").concat(_e480, " = vec4(0.0);");
      }

      x += "\n        xR = xRCorner + ".concat(_e479 * p, ";\n        if (xR >=0 && xR < ").concat(o, ") {\n      ");

      for (var _t398 = 0; _t398 < (b + 1) / 2; _t398++) {
        var _n290 = 2 * _t398,
            _s231 = _n290 * f;

        if (x += "\n          xC = xCCorner + ".concat(_s231, ";\n          "), 1 === d) {
          if (_n290 < m && (c % 2 == 1 ? (x += "\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ".concat(l, " && xTexelC").concat(_n290, "Ready == 0) {\n                  xTexelC").concat(_n290, " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ").concat(l, ") {\n                    xTexelC").concat(_n290, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n290, "Ready = 1;\n                }\n              "), x += 1 === f && _s231 > 0 ? "\n                xC".concat(_n290, " = vec4(xTexelC").concat(_n290 - 2, ".zw, xTexelC").concat(_n290, ".xy);\n                ") : "\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ".concat(l, ") {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ").concat(l, ") {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC").concat(_n290, " = vec4(previous.zw, xTexelC").concat(_n290, ".xy);\n                  } else {\n                    xC").concat(_n290, " = vec4(0.0, 0.0, xTexelC").concat(_n290, ".xy);\n                  }\n                  ")) : x += "\n                if (xC >= 0 && xC < ".concat(l, " && xTexelC").concat(_n290, "Ready == 0) {\n                  xTexelC").concat(_n290, " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ").concat(l, ") {\n                    xTexelC").concat(_n290, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n290, "Ready = 1;\n                }\n\n                xC").concat(_n290, " = xTexelC").concat(_n290, ";\n                "), _s231 + 1 < m)) {
            var _e481 = c % 2 == 0 ? i(f) : f;

            f % 2 == 0 && c % 2 == 1 || f % 2 != 0 && c % 2 != 1 ? (x += "\n                  xCOffset = xC + ".concat(c % 2, " + ").concat(_e481, ";\n\n                  if (xCOffset >= 0 && xCOffset < ").concat(l, " && xTexelC").concat(_n290 + 1, "Ready == 0) {\n                    xTexelC").concat(_n290 + 1, " = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ").concat(l, ") {\n                      xTexelC").concat(_n290 + 1, ".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(_n290 + 1, "Ready = 1;\n                  }\n                  "), f > 1 && (x += "\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ".concat(l, " && xTexelC").concat(_n290, "Ready == 0) {\n                      xTexelC").concat(_n290, " = getX(batch, xR, xCOffset, d1);\n                      xTexelC").concat(_n290, "Ready = 1;\n                    }\n                    ")), x += "\n                  xC".concat(_n290 + 1, " = vec4(xTexelC").concat(_n290, ".zw, xTexelC").concat(_n290 + 1, ".xy);\n                  ")) : x += 1 === _e481 ? "\n                    xC".concat(_n290 + 1, " = xTexelC").concat(_n290, ";\n                    ") : "\n                    xCOffset = xC + ".concat(_e481, ";\n\n                    if (xCOffset >= 0 && xCOffset < ").concat(l, " && xTexelC").concat(_n290 + 1, "Ready == 0) {\n                      xTexelC").concat(_n290 + 1, " = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ").concat(l, ") {\n                        xTexelC").concat(_n290 + 1, ".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(_n290 + 1, "Ready = 1;\n                    }\n\n                    xC").concat(_n290 + 1, " = xTexelC").concat(_n290 + 1, ";\n                    ");
          }
        } else _s231 < m && (c % 2 == 1 ? (x += "\n                xCOffset = xC + 1 - ".concat(d, ";\n                if(xCOffset >= 0 && xCOffset < ").concat(l, " && xTexelC").concat(_n290, "Ready == 0) {\n                  xTexelC").concat(_n290, " = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ").concat(l, ") {\n                    xTexelC").concat(_n290, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n290, "Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ").concat(l, " && xTexelC").concat(_n290 + 1, "Ready == 0) {\n                  xTexelC").concat(_n290 + 1, " = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ").concat(l, ") {\n                    xTexelC").concat(_n290 + 1, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n290 + 1, "Ready = 1;\n                }\n\n                xC").concat(_n290, " = vec4(xTexelC").concat(_n290, ".zw, xTexelC").concat(_n290 + 1, ".zw);\n              "), _s231 + 1 < m && (x += "\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ".concat(d, ";\n                  if(xCOffset >= 0 && xCOffset < ").concat(l, ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC").concat(_n290 + 1, " = vec4(xTexelC").concat(_n290 + 1, ".xy, final.xy);\n                "))) : (x += "\n                if(xC >= 0 && xC < ".concat(l, " && xTexelC").concat(_n290, "Ready == 0) {\n                  xTexelC").concat(_n290, " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ").concat(l, ") {\n                    xTexelC").concat(_n290, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n290, "Ready = 1;\n                }\n\n                xCOffset = xC + ").concat(d, ";\n                if(xCOffset >= 0 && xCOffset < ").concat(l, " && xTexelC").concat(_n290 + 1, "Ready == 0) {\n                  xTexelC").concat(_n290 + 1, " = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ").concat(l, ") {\n                    xTexelC").concat(_n290 + 1, ".zw = vec2(0.);\n                  }\n                  xTexelC").concat(_n290 + 1, "Ready = 1;\n                }\n\n                xC").concat(_n290, " = vec4(\n                  xTexelC").concat(_n290, ".xy, xTexelC").concat(_n290 + 1, ".xy);\n              "), _s231 + 1 < m && (x += "\n                  xC".concat(_n290 + 1, " = vec4(xTexelC").concat(_n290, ".zw, xTexelC").concat(_n290 + 1, ".zw);\n                "))));

        _n290 < m && (x += "\n            wTexel = getW(".concat(_e479, ", ").concat(_s231, ", d1, q);\n            dotProd += xC").concat(_n290, " * vec4(wTexel.xz, wTexel.xz);\n          "), _s231 + 1 < m && (x += "\n              wTexel = getW(".concat(_e479, ", ").concat(_s231 + 1, ", d1, q);\n              dotProd += xC").concat(_n290 + 1, " * vec4(wTexel.xz, wTexel.xz);\n            ")));
      }

      x += "\n        }\n      ";
    }

    var y = "",
        k = "";
    n && (y = s ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n, "\n        }") : r ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n, "\n        }") : "vec4 activation(vec4 x) {\n          ".concat(n, "\n        }"), k = "result = activation(result);");
    var w = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(y, "\n\n      const ivec2 strides = ivec2(").concat(h, ", ").concat(d, ");\n      const ivec2 pads = ivec2(").concat(u, ", ").concat(c, ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(a, ";\n        int q = d2 - d1 * ").concat(a, ";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(x, "\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(w, "\n        ").concat(k, "\n        setOutput(result);\n      }\n    ");
  }

}

var o$ = {
  kernelName: "DepthwiseConv2dNative",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a
    } = t,
        {
      strides: i,
      pad: o,
      dilations: u,
      dimRoundingMode: c
    } = s;
    var h = u;
    null == h && (h = [1, 1]), l(Ss(i, h), () => "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '").concat(h, "'"));
    var d = ys(r.shape, a.shape, i, h, o, c, !0);
    var p;
    return p = V().getBool("WEBGL_PACK_DEPTHWISECONV") && d.strideWidth <= 2 && d.outChannels / d.inChannels == 1 ? new i$(d) : new a$(d), n.runWebGLProgram(p, [r, a], "float32");
  }
};

class l$ {
  constructor(e) {
    this.variableNames = ["x", "dy"], this.outputShape = e.filterShape, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(e.outChannels / e.inChannels, " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize, "; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight, "; yR++) {\n            int xR = wR + yR * ").concat(e.strideHeight, " - ").concat(e.padInfo.top, ";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth, "; yC++) {\n              int xC = wC + yC * ").concat(e.strideWidth, " - ").concat(e.padInfo.left, ";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class u$ {
  constructor(e) {
    this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
    var t = e.filterHeight,
        n = e.filterWidth,
        s = e.outChannels / e.inChannels;
    this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t, "; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n, " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(s, "; dm++) {\n              int d2 = d1 * ").concat(s, " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

var c$ = {
  kernelName: "DepthwiseConv2dNativeBackpropFilter",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      dy: a
    } = t,
        {
      strides: i,
      dilations: o,
      pad: l,
      dimRoundingMode: u,
      filterShape: c
    } = s,
        h = ys(r.shape, c, i, o, l, u, !0),
        d = new l$(h);
    return n.runWebGLProgram(d, [r, a], "float32");
  }
},
    h$ = {
  kernelName: "DepthwiseConv2dNativeBackpropInput",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      filter: a
    } = t,
        {
      strides: i,
      dilations: o,
      pad: l,
      dimRoundingMode: u,
      inputShape: c
    } = s,
        h = ys(c, a.shape, i, o, l, u, !0),
        d = new u$(h);
    return n.runWebGLProgram(d, [r, a], "float32");
  }
};

class d$ {
  constructor(e) {
    this.variableNames = ["X"], this.outputShape = [e, e], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
  }

}

var p$ = {
  kernelName: "Diag",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t,
        r = [...s.shape, ...s.shape],
        a = d(s.shape),
        i = cv({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [a]
      }
    }),
        o = new d$(a),
        l = n.runWebGLProgram(o, [i], i.dtype),
        u = cv({
      inputs: {
        x: l
      },
      backend: n,
      attrs: {
        shape: r
      }
    });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(l), u;
  }
};

class f$ {
  constructor(e) {
    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    var {
      inHeight: t,
      inWidth: n,
      padInfo: s,
      strideHeight: r,
      strideWidth: a,
      filterHeight: i,
      filterWidth: o,
      dilationHeight: l,
      dilationWidth: u
    } = e,
        {
      top: c,
      left: h
    } = s;
    this.userCode = "\n      const ivec2 strides = ivec2(".concat(r, ", ").concat(a, ");\n      const ivec2 pads = ivec2(").concat(c, ", ").concat(h, ");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(i, "; h++) {\n          int hIn = hBeg + h * ").concat(l, ";\n\n          if (hIn >= 0 && hIn < ").concat(t, ") {\n            for (int w = 0; w < ").concat(o, "; w++) {\n              int wIn = wBeg + w * ").concat(u, ";\n\n              if (wIn >= 0 && wIn < ").concat(n, ") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ");
  }

}

var g$ = {
  kernelName: "Dilation2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a
    } = t,
        {
      strides: i,
      pad: o,
      dilations: l
    } = s,
        u = ms(r.shape, a.shape, i, o, "NHWC", l);
    var c;
    var h = new f$(u);
    c = n.runWebGLProgram(h, [r, a], "float32");
    var d = cv({
      inputs: {
        x: c
      },
      backend: n,
      attrs: {
        shape: u.outShape
      }
    });
    return n.disposeIntermediateTensorInfo(c), d;
  }
},
    m$ = {
  kernelName: "Einsum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      equation: r
    } = s,
        a = t,
        {
      allDims: i,
      summedDims: o,
      idDims: l
    } = Ho(r, a.length);
    qo(i.length, l, a);
    var {
      path: u,
      steps: c
    } = Ko(o, l),
        h = c.length;
    var d = null,
        f = i.length;
    var g = [];

    for (var _e482 = 0; _e482 < h; ++_e482) {
      for (var _t399 of c[_e482]) {
        var {
          permutationIndices: _e483,
          expandDims: _s232
        } = jo(f, l[_t399]);

        var _r168 = void 0;

        Xo(_e483) ? _r168 = a[_t399] : (_r168 = kv({
          inputs: {
            x: a[_t399]
          },
          backend: n,
          attrs: {
            perm: _e483
          }
        }), g.push(_r168));

        var _i98 = _r168.shape.slice();

        for (var _e484 = 0; _e484 < _s232.length; ++_e484) {
          _i98.splice(_s232[_e484], 0, 1);
        }

        p(_r168.shape, _i98) || (_r168 = cv({
          inputs: {
            x: _r168
          },
          backend: n,
          attrs: {
            shape: _i98
          }
        }), g.push(_r168)), null === d ? d = _r168 : (d = lv({
          inputs: {
            a: _r168,
            b: d
          },
          backend: n
        }), g.push(d));
      }

      _e482 < h - 1 && (u[_e482] >= 0 && (d = xv({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          axis: u[_e482] - (i.length - f),
          keepDims: !1
        }
      }), g.push(d)), f--);
    }

    for (var _e485 of g) {
      _e485 !== d && n.disposeIntermediateTensorInfo(_e485);
    }

    return d;
  }
},
    b$ = {
  kernelName: "Elu",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);",
    packedOpSnippet: "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"
  })
},
    x$ = {
  kernelName: "EluGrad",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      dy: s,
      y: r
    } = t,
        a = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Hw("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", s.shape, r.shape) : new Gw("return (b >= 1.0) ? a : a * (b + 1.0);", s.shape, r.shape);
    return n.runWebGLProgram(a, [s, r], s.dtype);
  }
},
    y$ = {
  kernelName: "Equal",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a == b);",
    packedOpSnippet: "\n  return vec4(equal(a, b));\n",
    dtype: "bool",
    cpuKernelImpl: qk
  })
},
    k$ = {
  kernelName: "Erf",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n'
  })
},
    w$ = "return exp(x);",
    v$ = nv({
  opSnippet: w$,
  packedOpSnippet: w$,
  cpuKernelImpl: Kk
}),
    I$ = {
  kernelName: "Exp",
  backendName: "webgl",
  kernelFunc: v$
};

function $$(e) {
  var {
    inputs: t,
    attrs: n,
    backend: s
  } = e,
      {
    dim: r
  } = n,
      {
    input: a
  } = t,
      i = a.shape.length,
      o = a.shape.slice();
  var u = r;
  return r < 0 && (l(-(i + 1) <= r, () => "Axis must be in the interval [".concat(-(i + 1), ", ").concat(i, "]")), u = i + r + 1), o.splice(u, 0, 1), cv({
    inputs: {
      x: a
    },
    backend: s,
    attrs: {
      shape: o
    }
  });
}

var N$ = {
  kernelName: "ExpandDims",
  backendName: "webgl",
  kernelFunc: $$
},
    C$ = "return exp(x) - 1.0;",
    S$ = {
  kernelName: "Expm1",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: C$,
    packedOpSnippet: C$,
    cpuKernelImpl: Xk
  })
};

class T$ {
  constructor(e, t, n) {
    this.variableNames = ["real", "imag"];
    var s = t[1];
    this.outputShape = t;
    var r = n ? "2.0 * ".concat(Math.PI) : "-2.0 * ".concat(Math.PI),
        a = n ? "".concat(s, ".0") : "1.0";
    var i;
    if ("real" === e) i = "return real * expR - imag * expI;";else {
      if ("imag" !== e) throw new Error("FFT component must be either \"real\" or \"imag\", got ".concat(e, "."));
      i = "return real * expI + imag * expR;";
    }
    this.userCode = "\n      const float exponentMultiplier = ".concat(r, ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(i, "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(s, ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(s, "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(a, ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ");
  }

}

function E$(e, t, n) {
  var s = n.texData.get(e.dataId),
      r = d(e.shape),
      a = e.shape[e.shape.length - 1],
      i = cv({
    inputs: {
      x: e
    },
    backend: n,
    attrs: {
      shape: [r / a, a]
    }
  }),
      o = i.shape,
      l = new T$("real", o, t),
      u = new T$("imag", o, t),
      c = [{
    dataId: s.complexTensorInfos.real.dataId,
    dtype: s.complexTensorInfos.real.dtype,
    shape: o
  }, {
    dataId: s.complexTensorInfos.imag.dataId,
    dtype: s.complexTensorInfos.imag.dtype,
    shape: o
  }],
      h = n.runWebGLProgram(l, c, "float32"),
      p = n.runWebGLProgram(u, c, "float32"),
      f = Kw({
    inputs: {
      real: h,
      imag: p
    },
    backend: n
  });
  n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p);
  var g = cv({
    inputs: {
      x: f
    },
    backend: n,
    attrs: {
      shape: e.shape
    }
  });
  return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(f), g;
}

var R$ = {
  kernelName: "FFT",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      input: s
    } = t;
    return E$(s, !1, n);
  }
};

class A$ {
  constructor(e, t) {
    this.outputShape = [], this.customUniforms = [{
      name: "value",
      type: "float"
    }], this.variableNames = ["x"], this.outputShape = e, this.userCode = "\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
  }

}

function F$(e) {
  var {
    backend: t,
    attrs: n
  } = e,
      {
    shape: s,
    value: r
  } = n;
  var {
    dtype: a
  } = n;

  if (a = a || T(r), "string" === a) {
    var _e486 = v(a, d(s));

    return _e486.fill(r), t.makeTensorInfo(s, a, _e486);
  }

  {
    var _e487 = new A$(s, r);

    return t.runWebGLProgram(_e487, [], a, [[r]]);
  }
}

var D$ = {
  kernelName: "Fill",
  backendName: "webgl",
  kernelFunc: F$
};

class _$ {
  constructor(e) {
    this.variableNames = ["Image"], this.outputShape = [];
    var t = e[2];
    this.outputShape = e, this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t, " - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t, ") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ");
  }

}

var O$ = {
  kernelName: "FlipLeftRight",
  backendName: "webgl",
  kernelFunc: _ref28 => {
    var {
      inputs: e,
      backend: t
    } = _ref28;
    var {
      image: n
    } = e,
        s = t,
        r = new _$(n.shape);
    return s.runWebGLProgram(r, [n], n.dtype);
  }
},
    M$ = "return floor(x);",
    L$ = {
  kernelName: "Floor",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: M$,
    packedOpSnippet: M$,
    cpuKernelImpl: Yk
  })
},
    z$ = {
  kernelName: "FloorDiv",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",
    packedOpSnippet: "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
    dtype: "int32"
  })
};

class B$ {
  constructor(e) {
    this.variableNames = ["A"];
    var t = lk(),
        [n, s] = e;
    this.outputShape = e, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(s, ".0, ").concat(n, ".0);\n\n        vec4 values = ").concat(t.texture2D, "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ");
  }

}

class P$ {
  constructor(e) {
    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
    var t = lk(),
        [n, s] = e;
    this.outputShape = e, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(s, ".0, ").concat(n, ".0);\n            vec4 values = ").concat(t.texture2D, "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output, " = result;\n      }\n    ");
  }

}

var W$ = {
  kernelName: "FromPixels",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e;
    var {
      pixels: r
    } = t;
    var {
      numChannels: a
    } = s,
        i = "undefined" != typeof HTMLVideoElement && r instanceof HTMLVideoElement,
        o = "undefined" != typeof HTMLImageElement && r instanceof HTMLImageElement,
        [l, u] = i ? [r.videoWidth, r.videoHeight] : [r.width, r.height],
        c = [u, l],
        h = [u, l, a];
    (o || i) && (null == U$ && (U$ = document.createElement("canvas").getContext("2d")), U$.canvas.width = l, U$.canvas.height = u, U$.drawImage(r, 0, 0, l, u), r = U$.canvas);
    var d = n.makeTensorInfo(c, "int32");
    n.texData.get(d.dataId).usage = _y.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), r);
    var p = V().getBool("WEBGL_PACK") ? new P$(h) : new B$(h),
        f = n.runWebGLProgram(p, [d], "int32");
    return n.disposeData(d.dataId), f;
  }
};
var U$;
var V$ = {
  kernelName: "FusedConv2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      strides: l,
      pad: u,
      dataFormat: c,
      dilations: h,
      dimRoundingMode: d,
      activation: p,
      leakyreluAlpha: f
    } = s,
        g = Ts(c),
        m = ys(r.shape, a.shape, l, h, u, d, !1, g);
    var b;
    var x = [];
    if (1 !== m.filterHeight || 1 !== m.filterWidth || 1 !== m.dilationHeight || 1 !== m.dilationWidth || 1 !== m.strideHeight || 1 !== m.strideWidth || "SAME" !== m.padInfo.type && "VALID" !== m.padInfo.type) {
      if (V().getBool("WEBGL_CONV_IM2COL") && 1 === r.shape[0]) b = LI({
        x: r,
        filter: a,
        convInfo: m,
        backend: n,
        bias: i,
        activation: p,
        preluActivationWeights: o,
        leakyreluAlpha: f
      });else {
        var _e488 = null != i,
            _t400 = null != o,
            _s233 = "leakyrelu" === p,
            _l54 = p ? rv(p, !1) : null,
            _u41 = new DI(m, _e488, _l54, _t400, _s233),
            _c35 = [r, a];

        if (i && _c35.push(i), o && _c35.push(o), _s233) {
          var _e489 = n.makeTensorInfo([], "float32", We(f, "float32"));

          _c35.push(_e489), x.push(_e489);
        }

        b = n.runWebGLProgram(_u41, _c35, "float32");
      }
    } else b = MI({
      x: r,
      filter: a,
      convInfo: m,
      backend: n,
      bias: i,
      activation: p,
      preluActivationWeights: o,
      leakyreluAlpha: f
    });
    var y = cv({
      inputs: {
        x: b
      },
      backend: n,
      attrs: {
        shape: m.outShape
      }
    });
    return x.push(b), x.forEach(e => n.disposeIntermediateTensorInfo(e)), y;
  }
},
    G$ = {
  kernelName: "FusedDepthwiseConv2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      filter: a,
      bias: i,
      preluActivationWeights: o
    } = t,
        {
      strides: u,
      pad: c,
      dilations: h,
      dimRoundingMode: d,
      activation: p,
      leakyreluAlpha: f
    } = s,
        g = [];
    var m = h;
    null == m && (m = [1, 1]), l(Ss(u, m), () => "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(u, " and dilations '").concat(m, "'"));
    var b = ys(r.shape, a.shape, u, m, c, d, !0),
        x = V().getBool("WEBGL_PACK_DEPTHWISECONV") && b.strideWidth <= 2 && b.outChannels / b.inChannels == 1,
        y = p ? rv(p, x) : null,
        k = [r, a],
        w = null != i,
        v = null != o,
        I = "leakyrelu" === p;

    if (w && k.push(i), v && k.push(o), I) {
      var _e490 = n.makeTensorInfo([], "float32", We(f, "float32"));

      k.push(_e490), g.push(_e490);
    }

    var $;
    $ = x ? new i$(b, w, y, v, I) : new a$(b, w, y, v, I);
    var N = n.runWebGLProgram($, k, "float32");
    return g.forEach(e => n.disposeIntermediateTensorInfo(e)), N;
  }
};

class H$ {
  constructor(e, t, n) {
    this.sliceDim = e, this.strides = t, this.variableNames = ["x", "indices"], this.outputShape = n;
    var s = Mk(t.length),
        r = Mk(n.length);
    this.userCode = "\n        ".concat(s, " strides = ").concat(s, "(").concat(this.strides, ");\n         void main() {\n          ").concat(r, " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ").concat(this.sliceDim, "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ").concat(this.sliceDim > 1 ? "strides[j]" : "strides", ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ");
  }

}

var j$ = {
  kernelName: "GatherNd",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      params: s,
      indices: r
    } = t,
        a = r.shape,
        i = a[a.length - 1],
        o = d(s.shape),
        [l, u, c, h] = Nn(s, r),
        p = cv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [u, i]
      }
    }),
        f = cv({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [d(s.shape) / c, c]
      }
    });

    if (n.shouldExecuteOnCPU([s, r]) || "string" === s.dtype) {
      var _e491 = n.readSync(r.dataId),
          _t401 = n.bufferSync(s),
          _a137 = Jk(_e491, _t401, s.dtype, u, i, c, h, s.shape, o);

      return n.makeTensorInfo(l, s.dtype, _a137.values);
    }

    var g = new H$(i, h, [u, c]),
        m = n.runWebGLProgram(g, [f, p], f.dtype),
        b = cv({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: l
      }
    });
    return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), b;
  }
};

class q$ {
  constructor(e, t) {
    this.variableNames = ["A", "indices"], this.outputShape = t, this.rank = t.length;

    var n = Mk(this.rank),
        s = function (e, t) {
      var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
          s = [];

      for (var _t402 = 0; _t402 < e.length; _t402++) {
        s.push(2 === _t402 ? "int(getIndices(resRC.x, resRC.z))" : "".concat(n[_t402]));
      }

      return s.join();
    }(e);

    this.userCode = "\n      void main() {\n        ".concat(n, " resRC = getOutputCoords();\n        setOutput(getA(").concat(s, "));\n      }\n    ");
  }

}

function K$(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r,
    indices: a
  } = t,
      {
    axis: i,
    batchDims: o
  } = s,
      l = el(r, a, y(i, r.shape)[0], o),
      u = d(a.shape),
      c = [],
      h = cv({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      shape: [l.batchSize, l.outerSize, l.dimSize, l.sliceSize]
    }
  }),
      p = cv({
    inputs: {
      x: a
    },
    backend: n,
    attrs: {
      shape: [l.batchSize, u / l.batchSize]
    }
  });
  c.push(h), c.push(p);
  var f = [l.batchSize, l.outerSize, u / l.batchSize, l.sliceSize];

  if (n.shouldExecuteOnCPU([r, a]) || "string" === r.dtype) {
    var _e492 = n.bufferSync(p),
        _t403 = n.bufferSync(h),
        _s234 = Zk(_t403, _e492, f);

    return c.forEach(e => n.disposeIntermediateTensorInfo(e)), n.makeTensorInfo(l.outputShape, _s234.dtype, _s234.values);
  }

  var g = new q$(h.shape, f),
      m = n.runWebGLProgram(g, [h, p], h.dtype);
  c.push(m);
  var b = cv({
    inputs: {
      x: m
    },
    backend: n,
    attrs: {
      shape: l.outputShape
    }
  });
  return c.forEach(e => n.disposeIntermediateTensorInfo(e)), b;
}

var X$ = {
  kernelName: "GatherV2",
  backendName: "webgl",
  kernelFunc: K$
},
    Y$ = {
  kernelName: "Greater",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a > b);",
    packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n",
    cpuKernelImpl: Qk,
    dtype: "bool"
  })
},
    J$ = {
  kernelName: "GreaterEqual",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a >= b);",
    packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n",
    dtype: "bool",
    cpuKernelImpl: ew
  })
},
    Z$ = {
  kernelName: "IFFT",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      input: s
    } = t;
    return E$(s, !0, n);
  }
},
    Q$ = {
  kernelName: "IsFinite",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return float(!isnan(x) && !isinf(x));",
    dtype: "bool"
  })
},
    eN = {
  kernelName: "IsInf",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return float(isinf(x));",
    dtype: "bool"
  })
},
    tN = {
  kernelName: "IsNan",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return float(isnan(x));",
    dtype: "bool"
  })
},
    nN = {
  kernelName: "Less",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a < b);",
    packedOpSnippet: "\n  return vec4(lessThan(a, b));\n",
    cpuKernelImpl: tw,
    dtype: "bool"
  })
},
    sN = {
  kernelName: "LessEqual",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a <= b);",
    packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n",
    cpuKernelImpl: nw,
    dtype: "bool"
  })
},
    rN = {
  kernelName: "LinSpace",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      backend: t,
      attrs: n
    } = e,
        {
      start: s,
      stop: r,
      num: a
    } = n,
        i = sw(s, r, a);
    return t.makeTensorInfo([i.length], "float32", i);
  }
},
    aN = {
  kernelName: "Log",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (x < 0.0) return NAN;\n  return log(x);",
    packedOpSnippet: "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: rw
  })
},
    iN = {
  kernelName: "Log1p",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return log(1.0 + x);"
  })
},
    oN = {
  kernelName: "LogicalAnd",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a >= 1.0 && b >= 1.0);",
    packedOpSnippet: "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",
    dtype: "bool"
  })
},
    lN = {
  kernelName: "LogicalNot",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return float(!(x >= 1.0));"
  })
},
    uN = {
  kernelName: "LogicalOr",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a >= 1.0 || b >= 1.0);",
    packedOpSnippet: "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",
    dtype: "bool"
  })
};

class cN {
  constructor(e, t, n, s, r) {
    this.variableNames = ["x"], this.outputShape = [];
    var a = t,
        i = e[3] - 1;
    var o;
    this.outputShape = e;
    var l = "float(".concat(n, ") + float(").concat(s, ") * sum");
    o = .5 === r ? "inversesqrt(".concat(l, ")") : 1 === r ? "1.0/(".concat(l, ")") : "exp(log(".concat(l, ") * float(-").concat(r, "));"), this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(a, "; j <= ").concat(a, "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(i, ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(o, ";\n        setOutput(val);\n      }\n    ");
  }

}

class hN {
  constructor(e, t, n, s, r) {
    this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
    var a = t,
        i = e[3] - 1;
    var o;
    this.outputShape = e;
    var l = "float(".concat(n, ") + float(").concat(s, ") * sum");
    o = .5 === r ? "inversesqrt(".concat(l, ")") : 1 === r ? "1.0/(".concat(l, ")") : "exp(log(".concat(l, ") * float(-").concat(r, "));"), this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3], ";\n        bool hasNextRow = c < ").concat(this.outputShape[2], ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(a, ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(a, "; j <= ").concat(a, "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(i, "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(o, ";\n        setOutput(result);\n      }\n    ");
  }

}

var dN = {
  kernelName: "LRN",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      depthRadius: a,
      bias: i,
      alpha: o,
      beta: l
    } = s,
        u = V().getBool("WEBGL_PACK_NORMALIZATION") ? new hN(r.shape, a, i, o, l) : new cN(r.shape, a, i, o, l);
    return n.runWebGLProgram(u, [r], r.dtype);
  }
};

class pN {
  constructor(e, t, n, s, r) {
    this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = t, this.bias = n, this.alpha = s, this.beta = r, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth, "; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t, ")));\n          int depthEnd = int(min(float(").concat(this.depth, "),\n              float(d + ").concat(t, " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth, ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(s, ") * norm + float(").concat(n, ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(s, ")\n                * float(").concat(r, ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r, ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ");
  }

}

var fN = {
  kernelName: "LRNGrad",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      y: a,
      dy: i
    } = t,
        {
      depthRadius: o,
      bias: l,
      alpha: u,
      beta: c
    } = s,
        h = new pN(r.shape, o, l, u, c);
    return n.runWebGLProgram(h, [r, a, i], r.dtype);
  }
};

function gN(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    reductionIndices: a,
    keepDims: i
  } = s,
      o = r.shape.length,
      l = y(a, r.shape);
  var u = l;
  var c = Jr(u, o),
      h = null != c,
      p = n.shouldExecuteOnCPU([r]);
  var f = r;

  if (h) {
    if (p) {
      var _e493 = n.texData.get(f.dataId).values,
          _t404 = new Array(o);

      for (var _e494 = 0; _e494 < _t404.length; _e494++) {
        _t404[_e494] = r.shape[c[_e494]];
      }

      var _s235 = Cw(_e493, r.shape, r.dtype, c, _t404);

      f = n.makeTensorInfo(_t404, r.dtype), n.texData.get(f.dataId).values = _s235;
    } else f = bv(r, c, n);

    u = Qr(u.length, o);
  }

  Yr("max", u, o);
  var [g, m] = Kr(f.shape, u);
  var b,
      x = g;

  if (i && (x = Xr(g, l)), p) {
    var _e495 = n.texData.get(f.dataId),
        _t405 = aw(_e495.values, d(m), x, r.dtype);

    b = n.makeTensorInfo(x, r.dtype), n.texData.get(b.dataId).values = _t405;
  } else b = function (e, t, n, s) {
    var r = d(t),
        a = cv({
      inputs: {
        x: e
      },
      attrs: {
        shape: [d(e.shape) / r, r]
      },
      backend: s
    }),
        i = fv(a, e.dtype, "max", s),
        o = cv({
      inputs: {
        x: i
      },
      attrs: {
        shape: n
      },
      backend: s
    });
    return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), o;
  }(f, m, x, n);

  return h && n.disposeIntermediateTensorInfo(f), b;
}

var mN = {
  kernelName: "Max",
  backendName: "webgl",
  kernelFunc: gN
},
    bN = {
  kernelName: "Maximum",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",
    packedOpSnippet: "\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: iw
  })
},
    xN = {
  kernelName: "MaxPool",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t;
    ik(r, "maxPool");
    var {
      filterSize: a,
      strides: i,
      pad: o,
      dimRoundingMode: u
    } = s;
    l(Ss(i, 1), () => "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'"));
    var c = bs(r.shape, a, i, 1, o, u);
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) return jw({
      inputs: {
        x: r
      },
      backend: n
    });
    var h = new qv(c, "max", !1);
    return n.runWebGLProgram(h, [r], r.dtype);
  }
},
    yN = {
  kernelName: "MaxPool3D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      filterSize: a,
      strides: i,
      pad: o,
      dataFormat: l,
      dimRoundingMode: u
    } = s,
        c = xs(r.shape, a, i, [1, 1, 1], o, u, l),
        h = new Kv(c, "max", !1);
    return n.runWebGLProgram(h, [r], r.dtype);
  }
};

class kN {
  constructor(e) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
    var t = e.effectiveFilterHeight,
        n = e.effectiveFilterWidth;
    this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t, ";\n          wR += ").concat(e.dilationHeight, ") {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(n, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(t * n - 1, " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(n, " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

class wN {
  constructor(e) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
    var t = e.effectiveFilterDepth,
        n = e.effectiveFilterHeight,
        s = e.effectiveFilterWidth;
    this.userCode = "\n      const ivec3 pads = ivec3(".concat(t - 1 - e.padInfo.front, ", ").concat(n - 1 - e.padInfo.top, ", ").concat(s - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(t, ";\n           wD += ").concat(e.dilationDepth, ") {\n          float dyD = float(dyDCorner + wD) / ").concat(e.strideDepth, ".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth, ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(n, ";\n              wR += ").concat(e.dilationHeight, ") {\n            float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(s, ";\n                wC += ").concat(e.dilationWidth, ") {\n              float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(t * n * s - 1, " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(n, " * ").concat(s, " +\n                  wR * ").concat(s, " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
  }

}

var vN = {
  kernelName: "MaxPool3DGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a
    } = t,
        i = a,
        {
      filterSize: o,
      strides: l,
      pad: u,
      dimRoundingMode: c
    } = s,
        h = xs(i.shape, o, l, [1, 1, 1], u, c),
        d = new Kv(h, "max", !0),
        p = n.runWebGLProgram(d, [i], i.dtype),
        f = new wN(h),
        g = n.runWebGLProgram(f, [r, p], i.dtype);
    return n.disposeIntermediateTensorInfo(p), g;
  }
},
    IN = {
  kernelName: "MaxPoolGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      dy: r,
      input: a,
      output: i
    } = t,
        o = a;
    ik([a, i], "maxPoolGrad");
    var {
      filterSize: l,
      strides: u,
      pad: c,
      dimRoundingMode: h
    } = s,
        d = bs(o.shape, l, u, 1, c, h),
        p = new qv(d, "max", !0),
        f = n.runWebGLProgram(p, [o], o.dtype),
        g = new kN(d),
        m = n.runWebGLProgram(g, [r, f], o.dtype);
    return n.disposeIntermediateTensorInfo(f), m;
  }
},
    $N = {
  kernelName: "MaxPoolWithArgmax",
  backendName: "webgl",
  kernelFunc: _ref29 => {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref29;
    var {
      x: s
    } = e,
        {
      filterSize: r,
      strides: a,
      pad: i,
      includeBatchInIndex: o
    } = t,
        u = n;
    l(4 === s.shape.length, () => "Error in maxPool: input must be rank 4 but got rank ".concat(s.shape.length, "."));
    var c = [1, 1];
    l(Ss(a, c), () => "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(a, " and dilations '").concat(c, "'"));

    var h = bs(s.shape, r, a, c, i),
        [d, p] = function (e, t, n, s) {
      var r = new qv(n, "max", !1);
      var a = s.runWebGLProgram(r, [e], "float32");
      return r = new qv(n, "max", !0, !0, t), [a, s.runWebGLProgram(r, [e], "float32")];
    }(s, o, h, u);

    return [d, p];
  }
},
    NN = {
  kernelName: "Mean",
  backendName: "webgl",
  kernelFunc: _ref30 => {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref30;
    var {
      x: s
    } = e,
        {
      keepDims: r,
      axis: a
    } = t,
        i = n,
        o = s.shape.length,
        l = y(a, s.shape);
    var u = l;
    var c = Jr(u, o),
        h = null != c,
        p = i.shouldExecuteOnCPU([s]),
        f = [];
    var g = s;

    if (h) {
      if (p) {
        var _e496 = i.texData.get(g.dataId).values,
            _t406 = new Array(o);

        for (var _e497 = 0; _e497 < _t406.length; _e497++) {
          _t406[_e497] = s.shape[c[_e497]];
        }

        var _n291 = Cw(_e496, s.shape, s.dtype, c, _t406);

        g = i.makeTensorInfo(_t406, s.dtype), i.texData.get(g.dataId).values = _n291;
      } else g = bv(s, c, i);

      f.push(g), u = Qr(u.length, o);
    }

    Yr("sum", u, o);
    var [m, b] = Kr(g.shape, u);
    var x = m;
    r && (x = Xr(m, l));

    var k = function (e, t, n, s) {
      var r = d(t),
          a = cv({
        inputs: {
          x: e
        },
        attrs: {
          shape: [d(e.shape) / r, r]
        },
        backend: s
      }),
          i = fv(a, "float32", "mean", s),
          o = cv({
        inputs: {
          x: i
        },
        attrs: {
          shape: n
        },
        backend: s
      });
      return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), o;
    }(g, b, x, i);

    for (var _e498 of f) {
      i.disposeIntermediateTensorInfo(_e498);
    }

    return k;
  }
},
    CN = {
  kernelName: "Min",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s,
        o = r.shape.length,
        l = y(a, r.shape);
    var u = l;
    var c = Jr(u, o);
    var h = r;
    null != c && (h = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), u = Qr(u.length, r.shape.length)), Yr("min", u, o);
    var [p, f] = Kr(h.shape, u),
        g = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, d(f)]
      }
    }),
        m = fv(g, g.dtype, "min", n);
    var b;
    return b = cv(i ? {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Xr(p, l)
      }
    } : {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: p
      }
    }), n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), b;
  }
},
    SN = {
  kernelName: "Minimum",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",
    packedOpSnippet: "\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: ow
  })
};

class TN {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.outputShape = t.map((t, n) => t[0] + e[n] + t[1]);
    var s = e.length,
        r = Mk(s),
        a = t.map(e => e[0]).join(","),
        i = t.map((t, n) => t[0] + e[n]).join(","),
        o = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s),
        l = "reflect" === n ? 0 : 1;
    this.userCode = 1 !== s ? "\n      ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outC = getOutputCoords();\n        for (int i = 0; i < ").concat(s, "; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(l, ";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(l, ";\n          }\n        }\n        ").concat(r, " coords = outC - start;\n        setOutput(getX(").concat(o, "));\n      }\n    ") : "\n        int start = ".concat(a, ";\n        int end = ").concat(i, ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(l, ";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(l, ";\n          }\n          setOutput(getX(outC - start));\n        }\n      ");
  }

}

class EN {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.map((t, n) => t[0] + e[n] + t[1]);
    var s = e.length,
        r = Mk(s),
        a = t.map(e => e[0]).join(","),
        i = t.map((t, n) => t[0] + e[n]).join(","),
        o = Ew("rc", s),
        l = Ew("source", s),
        u = "".concat(o[s - 1], " < ").concat(this.outputShape[s - 1]),
        c = 1 === s ? "source" : "vec2(".concat(l.slice(-2).join(), ")"),
        h = "reflect" === n ? 0 : 1;
    var d = "";

    if (1 === s) {
      var _e499 = "\n        ".concat(r, " source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h, ";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h, ";\n        }\n        source -= start;\n      ");

      d = "\n        ".concat(r, " rc = outputLoc;\n        ").concat(_e499, "\n        result[0] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        ").concat(o[s - 1], " += 1;\n        if(").concat(u, ") {\n          ").concat(_e499, "\n          result[1] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        }\n      ");
    } else {
      var _e500 = "\n        ".concat(r, " source = rc;\n        ").concat(r, " lt = ").concat(r, "(lessThan(source, start));\n        ").concat(r, " gte = ").concat(r, "(greaterThanEqual(source, end));\n        ").concat(r, " orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h, ") +\n                gte * ((end - 1) * 2 - source + ").concat(h, ");\n        source -= start;\n      ");

      d = "\n        ".concat(r, " rc = outputLoc;\n        ").concat(_e500, "\n        result[0] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        ").concat(o[s - 1], " += 1;\n        if(").concat(u, ") {\n          ").concat(_e500, "\n          result[1] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        }\n        rc = outputLoc;\n        ").concat(o[s - 2], " += 1;\n        if(").concat(o[s - 2], " < ").concat(this.outputShape[s - 2], ") {\n          ").concat(_e500, "\n          result[2] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n          ").concat(o[s - 1], " += 1;\n          if(").concat(u, ") {\n            ").concat(_e500, "\n            result[3] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n          }\n        }\n      ");
    }

    this.userCode = "\n      const ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      const ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d, "\n        setOutput(result);\n      }\n    ");
  }

}

var RN = {
  kernelName: "MirrorPad",
  backendName: "webgl",
  kernelFunc: _ref31 => {
    var {
      inputs: e,
      backend: t,
      attrs: n
    } = _ref31;
    var {
      x: s
    } = e,
        {
      paddings: r,
      mode: a
    } = n,
        i = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new EN(s.shape, r, a) : new TN(s.shape, r, a);
    return t.runWebGLProgram(i, [s], s.dtype);
  }
},
    AN = {
  kernelName: "Mod",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);",
    packedOpSnippet: "\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
  })
};

class FN {
  constructor(e, t, n) {
    this.variableNames = ["probs"], this.customUniforms = [{
      name: "seed",
      type: "float"
    }], this.outputShape = [e, n], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t - 1, "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t - 1, "));\n      }\n    ");
  }

}

var DN = sv({
  opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
  packedOpSnippet: "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
  checkOutOfBounds: !0
}),
    _N = {
  kernelName: "RealDiv",
  backendName: "webgl",
  kernelFunc: DN
},
    ON = "return a - b;",
    MN = sv({
  opSnippet: ON,
  packedOpSnippet: ON,
  supportsComplex: !0,
  cpuKernelImpl: Iw
}),
    LN = {
  kernelName: "Sub",
  backendName: "webgl",
  kernelFunc: MN
};

function zN(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    logits: r
  } = t,
      {
    dim: a
  } = s,
      i = y([a], r.shape),
      o = gN({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      reductionIndices: i,
      keepDims: !1
    }
  }),
      l = Xr(o.shape, i),
      u = cv({
    inputs: {
      x: o
    },
    backend: n,
    attrs: {
      shape: l
    }
  }),
      c = MN({
    inputs: {
      a: r,
      b: u
    },
    backend: n
  }),
      h = v$({
    inputs: {
      x: c
    },
    backend: n
  }),
      d = xv({
    inputs: {
      x: h
    },
    backend: n,
    attrs: {
      axis: i,
      keepDims: !1
    }
  }),
      p = cv({
    inputs: {
      x: d
    },
    backend: n,
    attrs: {
      shape: l
    }
  }),
      f = DN({
    inputs: {
      a: h,
      b: p
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(p), f;
}

var BN = {
  kernelName: "Softmax",
  backendName: "webgl",
  kernelFunc: zN
},
    PN = {
  kernelName: "Multinomial",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      logits: r
    } = t,
        {
      numSamples: a,
      seed: i,
      normalized: o
    } = s,
        l = o ? r : zN({
      inputs: {
        logits: r
      },
      backend: n,
      attrs: {
        dim: r.shape.length - 1
      }
    }),
        u = new FN(l.shape[0], l.shape[1], a),
        c = n.runWebGLProgram(u, [l], "int32", [[i]]);
    return o || n.disposeIntermediateTensorInfo(l), c;
  }
},
    WN = "return -x;",
    UN = {
  kernelName: "Neg",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      x: s
    } = t;

    if (n.shouldExecuteOnCPU([s])) {
      var _e501 = n.texData.get(s.dataId),
          [_t407, _r169] = uw(_e501.values, s.shape, s.dtype);

      return n.makeTensorInfo(_r169, s.dtype, _t407);
    }

    var r;
    return r = V().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new zw(s.shape, WN) : new Mw(s.shape, WN), n.runWebGLProgram(r, [s], s.dtype);
  }
},
    VN = ji,
    GN = {
  kernelName: "NonMaxSuppressionV3",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    Oo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l
    } = s,
        u = n.readSync(r.dataId),
        c = n.readSync(a.dataId),
        {
      selectedIndices: h
    } = VN(u, c, i, o, l);
    return n.makeTensorInfo([h.length], "int32", new Int32Array(h));
  }
},
    HN = qi,
    jN = {
  kernelName: "NonMaxSuppressionV4",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    Oo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l,
      padToMaxOutputSize: u
    } = s,
        c = n.readSync(r.dataId),
        h = n.readSync(a.dataId),
        {
      selectedIndices: d,
      validOutputs: p
    } = HN(c, h, i, o, l, u);
    return [n.makeTensorInfo([d.length], "int32", new Int32Array(d)), n.makeTensorInfo([], "int32", new Int32Array([p]))];
  }
},
    qN = Ki,
    KN = {
  kernelName: "NonMaxSuppressionV5",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    Oo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      boxes: r,
      scores: a
    } = t,
        {
      maxOutputSize: i,
      iouThreshold: o,
      scoreThreshold: l,
      softNmsSigma: u
    } = s,
        c = n.readSync(r.dataId),
        h = n.readSync(a.dataId),
        d = i,
        p = o,
        f = l,
        g = u,
        {
      selectedIndices: m,
      selectedScores: b
    } = qN(c, h, d, p, f, g);
    return [n.makeTensorInfo([m.length], "int32", new Int32Array(m)), n.makeTensorInfo([b.length], "float32", new Float32Array(b))];
  }
};

class XN {
  constructor(e, t, n, s) {
    this.variableNames = ["indices"], this.outputShape = [e, t], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(s, "), float(").concat(n, "),\n                      float(index == coords.y)));\n      }\n    ");
  }

}

var YN = {
  kernelName: "OneHot",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      indices: r
    } = t,
        {
      depth: a,
      onValue: i,
      offValue: o
    } = s,
        l = d(r.shape),
        u = new XN(l, a, i, o),
        c = cv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [l]
      }
    }),
        h = n.runWebGLProgram(u, [c], r.dtype);
    n.disposeIntermediateTensorInfo(c);
    var p = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [...r.shape, a]
      }
    });
    return n.disposeIntermediateTensorInfo(h), p;
  }
};

function JN(e) {
  var {
    inputs: t,
    backend: n
  } = e,
      {
    x: s
  } = t;

  if ("complex64" === s.dtype) {
    var _e502 = fI({
      inputs: {
        input: s
      },
      backend: n
    }),
        _t408 = JN({
      inputs: {
        x: _e502
      },
      backend: n
    }),
        _r170 = TI({
      inputs: {
        input: s
      },
      backend: n
    }),
        _a138 = JN({
      inputs: {
        x: _r170
      },
      backend: n
    }),
        _i99 = Kw({
      inputs: {
        real: _t408,
        imag: _a138
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_e502), n.disposeIntermediateTensorInfo(_t408), n.disposeIntermediateTensorInfo(_r170), n.disposeIntermediateTensorInfo(_a138), _i99;
  }

  return F$({
    attrs: {
      shape: s.shape,
      dtype: s.dtype,
      value: "string" === s.dtype ? "" : 0
    },
    backend: n
  });
}

var ZN = {
  kernelName: "ZerosLike",
  backendName: "webgl",
  kernelFunc: JN
},
    QN = {
  kernelName: "OnesLike",
  backendName: "webgl",
  kernelFunc: function e(t) {
    var {
      inputs: n,
      backend: s
    } = t,
        {
      x: r
    } = n;
    if ("string" === r.dtype) throw new Error("onesLike is not supported under string dtype");

    if ("complex64" === r.dtype) {
      var _t409 = fI({
        inputs: {
          input: r
        },
        backend: s
      }),
          _n292 = e({
        inputs: {
          x: _t409
        },
        backend: s
      }),
          _a139 = TI({
        inputs: {
          input: r
        },
        backend: s
      }),
          _i100 = JN({
        inputs: {
          x: _a139
        },
        backend: s
      }),
          _o75 = Kw({
        inputs: {
          real: _n292,
          imag: _i100
        },
        backend: s
      });

      return s.disposeIntermediateTensorInfo(_t409), s.disposeIntermediateTensorInfo(_n292), s.disposeIntermediateTensorInfo(_a139), s.disposeIntermediateTensorInfo(_i100), _o75;
    }

    return F$({
      attrs: {
        shape: r.shape,
        dtype: r.dtype,
        value: 1
      },
      backend: s
    });
  }
},
    eC = {
  kernelName: "Pack",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      axis: r
    } = s;
    if (1 === t.length) return $$({
      inputs: {
        input: t[0]
      },
      backend: n,
      attrs: {
        dim: r
      }
    });
    var a = t[0].shape,
        i = t[0].dtype;
    t.forEach(e => {
      u(a, e.shape, "All tensors passed to stack must have matching shapes"), l(i === e.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    var o = [],
        c = AI({
      inputs: t.map(e => {
        var t = $$({
          inputs: {
            input: e
          },
          backend: n,
          attrs: {
            dim: r
          }
        });
        return o.push(t), t;
      }),
      backend: n,
      attrs: {
        axis: r
      }
    });
    return o.forEach(e => n.disposeIntermediateTensorInfo(e)), c;
  }
};

class tC {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.customUniforms = [{
      name: "value",
      type: "float"
    }], this.outputShape = t.map((t, n) => t[0] + e[n] + t[1]);
    var s = e.length,
        r = Mk(s),
        a = t.map(e => e[0]).join(","),
        i = t.map((t, n) => t[0] + e[n]).join(","),
        o = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s);
    this.userCode = 1 !== s ? "\n      ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r, " coords = outC - start;\n          setOutput(getX(").concat(o, "));\n        }\n      }\n    ") : "\n        int start = ".concat(a, ";\n        int end = ").concat(i, ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ");
  }

}

class nC {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
      name: "value",
      type: "float"
    }], this.outputShape = t.map((t, n) => t[0] + e[n] + t[1]);
    var s = e.length,
        r = Mk(s),
        a = t.map(e => e[0]).join(","),
        i = t.map((t, n) => t[0] + e[n]).join(","),
        o = Ew("rc", s),
        l = Ew("source", s),
        u = "".concat(o[s - 1], " < ").concat(this.outputShape[s - 1]),
        c = 1 === s ? "source" : "vec2(".concat(l.slice(-2).join(), ")"),
        h = ["".concat(r, " rc = outputLoc;"), "".concat(o[s - 1], " += 1;\n       if(").concat(u, ") {\n      "), 1 === s ? "" : "}\n       rc = outputLoc;\n       ".concat(o[s - 2], " += 1;\n       if(").concat(o[s - 2], " < ").concat(this.outputShape[s - 2], ") {"), 1 === s ? "" : "  ".concat(o[s - 1], " += 1;\n         if(").concat(u, ") {")],
        d = 1 === s ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
    var p = "";

    for (var _e503 = 0, _t410 = 1 === s ? 2 : 4; _e503 < _t410; _e503++) {
      p += "\n        ".concat(h[_e503], "\n        if (").concat(d, ") {\n          result[").concat(_e503, "] = float(value);\n        } else {\n          ").concat(r, " source = rc - start;\n          result[").concat(_e503, "] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        }\n      ");
    }

    p += 1 === s ? "} " : "}}", this.userCode = "\n      const ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      const ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p, "\n        setOutput(result);\n      }\n    ");
  }

}

var sC = e => {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    paddings: a,
    constantValue: i
  } = s,
      o = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new nC(r.shape, a, i) : new tC(r.shape, a, i);
  return n.runWebGLProgram(o, [r], r.dtype, [[i]]);
},
    rC = {
  kernelName: "PadV2",
  backendName: "webgl",
  kernelFunc: sC
},
    aC = {
  kernelName: "Pow",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",
    packedOpSnippet: "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
  })
},
    iC = {
  kernelName: "Prod",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      axis: a,
      keepDims: i
    } = s,
        o = r.shape.length,
        l = [],
        u = y(a, r.shape);
    var c = u;
    var h = Jr(c, o);
    var p,
        f = r;

    if (null != h && (f = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: h
      }
    }), c = Qr(c.length, o), l.push(f)), Yr("prod", c, o), n.shouldExecuteOnCPU([f])) {
      var _e504 = n.texData.get(f.dataId).values,
          {
        outVals: _t411,
        outShape: _s236,
        outDtype: _r171
      } = hw(f.shape, f.dtype, _e504, c);
      p = n.makeTensorInfo(_s236, _r171, _t411);
    } else {
      var [_e505, _t412] = Kr(f.shape, c),
          _s237 = d(_t412),
          _a140 = cv({
        inputs: {
          x: f
        },
        backend: n,
        attrs: {
          shape: [-1, _s237]
        }
      }),
          _i101 = fv(_a140, pt(r.dtype), "prod", n);

      p = cv({
        inputs: {
          x: _i101
        },
        backend: n,
        attrs: {
          shape: _e505
        }
      }), l.push(_a140), l.push(_i101);
    }

    if (i) {
      l.push(p);

      var _e506 = Xr(p.shape, u);

      p = cv({
        inputs: {
          x: p
        },
        backend: n,
        attrs: {
          shape: _e506
        }
      });
    }

    return l.forEach(e => n.disposeIntermediateTensorInfo(e)), p;
  }
},
    oC = e => {
  var {
    backend: t,
    attrs: n
  } = e,
      {
    start: s,
    stop: r,
    step: a,
    dtype: i
  } = n,
      o = dw(s, r, a, i);
  return t.makeTensorInfo([o.length], i, o);
},
    lC = {
  kernelName: "Range",
  backendName: "webgl",
  kernelFunc: oC
},
    uC = {
  kernelName: "Reciprocal",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return 1.0 / x;"
  })
},
    cC = {
  kernelName: "Relu",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",
    packedOpSnippet: "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
  })
},
    hC = {
  kernelName: "Relu6",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
    packedOpSnippet: "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
  })
};

class dC {
  constructor(e, t, n, s, r) {
    this.variableNames = ["A"], this.outputShape = [];
    var [a, i, o, l] = e;
    this.outputShape = [a, t, n, l];
    var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
        c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
    var h;
    h = r ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ");\n      const vec2 inputShapeRC = vec2(").concat(i, ".0, ").concat(o, ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ");
  }

}

class pC {
  constructor(e, t, n, s, r) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
    var [a, i, o, l] = e;
    this.outputShape = [a, t, n, l];
    var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
        c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
    var h;
    h = r ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ",\n          ").concat(u[1] / c[1], ");\n      const vec3 inputShapeRC = vec3(").concat(i, ".0, ").concat(o, ".0,\n                                     ").concat(o, ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l - 1, ";\n        bool hasNextRow = coords.z < ").concat(n - 1, ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ");
  }

}

var fC = {
  kernelName: "ResizeBilinear",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r
    } = t,
        {
      alignCorners: a,
      halfPixelCenters: i,
      size: o
    } = s,
        [l, u] = o,
        c = V().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new pC(r.shape, l, u, a, i) : new dC(r.shape, l, u, a, i);
    return n.runWebGLProgram(c, [r], "float32");
  }
};

class gC {
  constructor(e, t, n) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;
    var [, s, r] = t,
        [, a, i] = e,
        o = [n && a > 1 ? s - 1 : s, n && i > 1 ? r - 1 : r],
        l = [n && a > 1 ? a - 1 : a, n && i > 1 ? i - 1 : i],
        u = o[0] / l[0],
        c = o[1] / l[1],
        h = 1 / u,
        d = 1 / c,
        p = 2 * Math.ceil(h) + 2,
        f = 2 * Math.ceil(d) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(u, ");\n        const float widthScale = float(").concat(c, ");\n\n        const float invHeightScale = float(").concat(h, ");\n        const float invWidthScale = float(").concat(d, ");\n\n        const int winHeight = int(").concat(p, ");\n        const int winWidth = int(").concat(f, ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(a, ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i, ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(s - 1, ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r - 1, ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ");
  }

}

var mC = {
  kernelName: "ResizeBilinearGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r,
      dy: a
    } = t,
        {
      alignCorners: i
    } = s,
        o = new gC(a.shape, r.shape, i);
    return n.runWebGLProgram(o, [a], a.dtype);
  }
};

class bC {
  constructor(e, t, n, s, r) {
    this.variableNames = ["A"], this.outputShape = [];
    var [a, i, o, l] = e;
    this.outputShape = [a, t, n, l];
    var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
        c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
    var h;
    h = r ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ");\n      const vec2 inputShapeRC = vec2(").concat(i, ".0, ").concat(o, ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(s ? "0.5" : "0.0", ")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ");
  }

}

class xC {
  constructor(e, t, n, s, r) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
    var [a, i, o, l] = e;
    this.outputShape = [a, t, n, l];
    var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
        c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
    var h;
    h = r ? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ",\n          ").concat(u[1] / c[1], ");\n      const vec3 inputShapeRC = vec3(").concat(i, ".0, ").concat(o, ".0,\n                                     ").concat(o, ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(s ? "0.5" : "0.0", ")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l - 1, ";\n        bool hasNextRow = coords.z < ").concat(n - 1, ";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ");
  }

}

var yC = {
  kernelName: "ResizeNearestNeighbor",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r
    } = t,
        {
      alignCorners: a,
      halfPixelCenters: i,
      size: o
    } = s,
        [l, u] = o,
        c = V().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new xC(r.shape, l, u, a, i) : new bC(r.shape, l, u, a, i);
    return n.runWebGLProgram(c, [r], r.dtype);
  }
};

class kC {
  constructor(e, t, n) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;
    var [, s, r] = t,
        [, a, i] = e,
        o = [n && a > 1 ? s - 1 : s, n && i > 1 ? r - 1 : r],
        l = [n && a > 1 ? a - 1 : a, n && i > 1 ? i - 1 : i],
        u = o[0] / l[0],
        c = o[1] / l[1],
        h = 1 / u,
        d = 1 / c,
        p = 2 * Math.ceil(h) + 2,
        f = 2 * Math.ceil(d) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(u, ");\n        const float widthScale = float(").concat(c, ");\n\n        const float invHeightScale = float(").concat(h, ");\n        const float invWidthScale = float(").concat(d, ");\n\n        const int winHeight = int(").concat(p, ");\n        const int winWidth = int(").concat(f, ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(a, ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i, ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(o[0], ") *\n                (float(dyR) / float(").concat(l[0], "));\n\n            float sourceFracCol =\n                float(").concat(o[1], ") *\n                  (float(dyC) / float(").concat(l[1], "));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(s, ") - 1),\n                ").concat(n, " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r, ") - 1),\n                ").concat(n, " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ");
  }

}

var wC = {
  kernelName: "ResizeNearestNeighborGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      images: r,
      dy: a
    } = t,
        {
      alignCorners: i
    } = s,
        o = new kC(a.shape, r.shape, i);
    return n.runWebGLProgram(o, [a], a.dtype);
  }
};

class vC {
  constructor(e, t) {
    this.variableNames = ["x"];
    var n = e.length;
    if (n > 4) throw new Error("WebGL backend: Reverse of rank-".concat(n, " tensor is not yet supported"));
    if (this.outputShape = e, 1 === n) return void (this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0], " - coord - 1));\n        }\n      "));
    var s = e.map((n, s) => (n => -1 !== t.indexOf(n) && 1 !== e[n] ? "".concat(e[n], " - coords[").concat(n, "] - 1") : "coords[".concat(n, "]"))(s)).join(","),
        r = Mk(n);
    this.userCode = "\n      void main() {\n        ".concat(r, " coords = getOutputCoords();\n        setOutput(getX(").concat(s, "));\n      }\n    ");
  }

}

class IC {
  constructor(e, t) {
    this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
    var n = e.length;
    if (n > 4) throw new Error("WebGL backend: Reverse of rank-".concat(n, " tensor is not yet supported"));
    this.outputShape = e;
    var s = Ew("rc", n),
        r = "".concat(s[n - 1], " + 1 < ").concat(this.outputShape[n - 1]),
        a = "".concat(s[n - 2], " + 1 < ").concat(this.outputShape[n - 2]),
        i = Mk(n);

    function o(n) {
      var s = e.map((s, r) => function (n, s) {
        return -1 !== t.indexOf(n) && 1 !== e[n] ? "".concat(e[n], " - ").concat(s[n], " - 1") : "".concat(s[n]);
      }(r, n));
      return "getChannel(getX(".concat(s.join(","), "), vec2(").concat(s.slice(-2).join(","), "))");
    }

    this.userCode = 1 === n ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0], " - rc - 1),\n            ").concat(e[0], " - rc - 1);\n          if(").concat(r, "){\n              result.g = getChannel(getX(").concat(e[0], " - (rc  + 1) - 1),\n                ").concat(e[0], " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ") : "\n        void main() {\n          ".concat(i, " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function (e) {
      return o(e);
    }(s.slice()), ";\n          if(").concat(r, "){\n            result.g = ").concat(function (e) {
      return e[n - 1] = "(" + e[n - 1] + " + 1)", o(e);
    }(s.slice()), ";\n          }\n          if(").concat(a, ") {\n            result.b = ").concat(function (e) {
      return e[n - 2] = "(" + e[n - 2] + " + 1)", o(e);
    }(s.slice()), ";\n            if(").concat(r, ") {\n              result.a = ").concat(function (e) {
      return e[n - 1] = "(" + e[n - 1] + " + 1)", e[n - 2] = "(" + e[n - 2] + " + 1)", o(e);
    }(s.slice()), ";\n            }\n          }\n          setOutput(result);\n        }\n    ");
  }

}

var $C = {
  kernelName: "Reverse",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      dims: a
    } = s,
        i = r.shape.length,
        o = y(a, r.shape);
    if (0 === i) return jw({
      inputs: {
        x: r
      },
      backend: n
    });
    var l = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new IC(r.shape, o) : new vC(r.shape, o);
    return n.runWebGLProgram(l, [r], r.dtype);
  }
};

class NC {
  constructor(e, t) {
    this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{
      name: "params",
      type: "vec4"
    }];
    var n = e[1],
        s = e[2];
    this.outputShape = e;
    var r = "";
    r = "number" == typeof t ? "float outputValue = ".concat(t.toFixed(2), ";") : "\n        vec3 fill = vec3(".concat(t.join(","), ");\n        float outputValue = fill[coords[3]];"), this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r, "\n          if(coordX >= 0 && coordX < ").concat(s, " && coordY >= 0 && coordY < ").concat(n, ") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ");
  }

}

var CC = {
  kernelName: "RotateWithOffset",
  backendName: "webgl",
  kernelFunc: _ref32 => {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref32;
    var {
      image: s
    } = e,
        {
      radians: r,
      fillValue: a,
      center: i
    } = t,
        o = n,
        l = new NC(s.shape, a),
        [u, c] = Eo(i, s.shape[1], s.shape[2]),
        h = [[u, c, Math.sin(r), Math.cos(r)]];
    return o.runWebGLProgram(l, [s], s.dtype, h);
  }
},
    SC = {
  kernelName: "Round",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"
  })
},
    TC = {
  kernelName: "Rsqrt",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return inversesqrt(x);",
    cpuKernelImpl: pw
  })
};

class EC {
  constructor(e, t, n, s, r, a) {
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
    this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a;
    var o = Mk(r.length),
        l = Mk(a.length);
    var u = "";
    1 === n ? u = "i" : 2 === n && (u = "i, j");
    var c = "";
    1 === s ? c = "i" : 2 === s && (c = "i, coords[1]"), this.userCode = "\n        ".concat(o, " strides = ").concat(o, "(").concat(r, ");\n\n        void main() {\n          ").concat(l, " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e, "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t, "; j++) {\n              int index = round(getIndices(").concat(u, "));\n              flattenedIndex += index * ").concat(t > 1 ? "strides[j]" : "strides", ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(").concat(c, ");\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ");
  }

}

var RC = {
  kernelName: "ScatterNd",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      indices: r,
      updates: a
    } = t,
        {
      shape: i
    } = s,
        {
      sliceRank: o,
      numUpdates: l,
      sliceSize: u,
      strides: c,
      outputSize: h
    } = Sn(0, r, i),
        d = [h / u, u];
    if (0 === h) return n.makeTensorInfo(i, r.dtype);
    var p = cv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [l, o]
      }
    }),
        f = cv({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: [l, u]
      }
    }),
        g = n.makeTensorInfo([], "float32", new Float32Array([0])),
        m = new EC(l, o, p.shape.length, f.shape.length, c, d),
        b = n.runWebGLProgram(m, [f, p, g], f.dtype),
        x = cv({
      inputs: {
        x: b
      },
      backend: n,
      attrs: {
        shape: i
      }
    });
    return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(b), n.disposeIntermediateTensorInfo(g), x;
  }
};

class AC {
  constructor(e, t, n) {
    var s, r;
    if (this.variableNames = ["c", "a", "b"], this.outputShape = t, n > 4) throw Error("Where for rank ".concat(n, " is not yet supported"));
    if (1 === n) r = "resRC", s = "resRC";else {
      var _n293 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
          _a141 = [],
          _i102 = [];

      for (var _s238 = 0; _s238 < t.length; _s238++) {
        _i102.push("".concat(_n293[_s238])), _s238 < e && _a141.push("".concat(_n293[_s238]));
      }

      s = _a141.join(), r = _i102.join();
    }
    var a = Mk(n);
    this.userCode = "\n      void main() {\n        ".concat(a, " resRC = getOutputCoords();\n        float cVal = getC(").concat(s, ");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r, "));\n        } else {\n          setOutput(getB(").concat(r, "));\n        }\n      }\n    ");
  }

}

var FC = {
  kernelName: "Select",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      condition: s,
      t: r,
      e: a
    } = t,
        i = new AC(s.shape.length, r.shape, r.shape.length);
    return n.runWebGLProgram(i, [s, r, a], dt(r.dtype, a.dtype));
  }
},
    DC = {
  kernelName: "Selu",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n"
  })
},
    _C = {
  kernelName: "Sigmoid",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return 1.0 / (1.0 + exp(-1.0 * x));"
  })
},
    OC = {
  kernelName: "Sign",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"
  })
},
    MC = {
  kernelName: "Sin",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  return sin(x);\n"
  })
},
    LC = {
  kernelName: "Sinh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"
  })
},
    zC = {
  kernelName: "Softplus",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"
  })
},
    BC = {
  kernelName: "SpaceToBatchND",
  backendName: "webgl",
  kernelFunc: e => {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      blockShape: a,
      paddings: i
    } = s;
    l(r.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
    var o = a.reduce((e, t) => e * t),
        u = [[0, 0]];
    u.push(...i);

    for (var _e507 = 1 + a.length; _e507 < r.shape.length; ++_e507) {
      u.push([0, 0]);
    }

    var c = [],
        h = sC({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        paddings: u,
        constantValue: 0
      }
    }),
        d = Ro(h.shape, a, o, !1),
        p = Ao(d.length, a.length, !1),
        f = Fo(h.shape, a, o, !1),
        g = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: d
      }
    }),
        m = kv({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        perm: p
      }
    }),
        b = cv({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: f
      }
    });
    return c.push(h), c.push(g), c.push(m), c.forEach(e => n.disposeIntermediateTensorInfo(e)), b;
  }
},
    PC = {
  kernelName: "SparseFillEmptyRows",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      indices: s,
      values: r,
      denseShape: a,
      defaultValue: i
    } = t;
    if (1 !== a.shape.length) throw new Error("Dense shape must be a vector, saw:\n         ".concat(a.shape));
    if (2 !== s.shape.length) throw new Error("Indices must be a matrix, saw:\n         ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));
    if (0 !== i.shape.length) throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));
    var o = n.readSync(s.dataId),
        l = n.readSync(r.dataId),
        u = n.readSync(a.dataId),
        c = n.readSync(i.dataId)[0],
        [h, d, p, f, g] = mw(o, s.shape, s.dtype, l, r.dtype, u, c);
    return [n.makeTensorInfo(d, s.dtype, h), n.makeTensorInfo([d[0]], r.dtype, p), n.makeTensorInfo([f.length], "bool", new Uint8Array(f.map(e => Number(e)))), n.makeTensorInfo([g.length], s.dtype, new Int32Array(g))];
  }
},
    WC = {
  kernelName: "SparseReshape",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      inputIndices: s,
      inputShape: r,
      newShape: a
    } = t;
    if (2 !== s.shape.length) throw new Error("Input indices should be a matrix but received shape ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Input shape should be a vector but received shape ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Target shape should be a vector but received shape ".concat(a.shape));
    var i = Array.from(n.readSync(r.dataId)),
        o = n.readSync(s.dataId),
        l = Array.from(n.readSync(a.dataId)),
        [u, c, h] = bw(o, s.shape, s.dtype, i, l);
    return [n.makeTensorInfo(c, s.dtype, u), n.makeTensorInfo([h.length], a.dtype, new Int32Array(h))];
  }
},
    UC = {
  kernelName: "SparseSegmentMean",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      data: s,
      indices: r,
      segmentIds: a
    } = t;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n              ".concat(a.shape));
    var i = n.readSync(s.dataId),
        o = n.readSync(r.dataId),
        l = n.readSync(a.dataId),
        [u, c] = xw(i, s.shape, s.dtype, o, l, !0);
    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    VC = {
  kernelName: "SparseSegmentSum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n
    } = e,
        {
      data: s,
      indices: r,
      segmentIds: a
    } = t;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n             ".concat(a.shape));
    var i = n.readSync(s.dataId),
        o = n.readSync(r.dataId),
        l = n.readSync(a.dataId),
        [u, c] = xw(i, s.shape, s.dtype, o, l);
    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    GC = {
  kernelName: "SparseToDense",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      sparseIndices: r,
      sparseValues: a,
      defaultValue: i
    } = t,
        {
      outputShape: o
    } = s,
        {
      sliceRank: l,
      numUpdates: u,
      strides: c,
      outputSize: h
    } = Sn(0, r, o),
        d = new EC(u, l, r.shape.length, a.shape.length, c, [h, 1], !1),
        p = n.runWebGLProgram(d, [a, r, i], a.dtype),
        f = cv({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        shape: o
      }
    });
    return n.disposeIntermediateTensorInfo(p), f;
  }
},
    HC = {
  kernelName: "SplitV",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      numOrSizeSplits: a,
      axis: i
    } = s,
        o = y(i, r.shape)[0],
        l = Jo(r, a, o),
        u = new Array(r.shape.length).fill(0),
        c = r.shape.slice();
    return l.map(e => {
      var t = [...c];
      t[o] = e;
      var s = lI({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          begin: u,
          size: t
        }
      });
      return u[o] += e, s;
    });
  }
},
    jC = {
  kernelName: "Sqrt",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return sqrt(x);"
  })
},
    qC = {
  kernelName: "Square",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return x * x;"
  })
},
    KC = {
  kernelName: "SquaredDifference",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return (a - b) * (a - b);",
    packedOpSnippet: "return (a - b) * (a - b);"
  })
},
    XC = {
  kernelName: "Step",
  backendName: "webgl",
  kernelFunc: function kernelFunc(_ref33) {
    var {
      inputs: e,
      attrs: t,
      backend: n
    } = _ref33;
    var {
      x: s
    } = e,
        r = new Mw(s.shape, "if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(".concat(t.alpha, ");\n  "));
    return n.runWebGLProgram(r, [s], s.dtype);
  }
};

class YC {
  constructor(e, t, n) {
    this.variableNames = ["x"], this.outputShape = n;
    var s = n.length,
        r = Mk(n.length),
        a = Mk(n.length);
    var i = "";
    if (1 === s) i = "coords * strides + begin";else {
      var _e508 = 0;
      i = n.map((t, s) => (_e508++, 1 === n.length ? "coords * strides[".concat(s, "] + begin[").concat(s, "]") : "coords[".concat(_e508 - 1, "] * strides[").concat(s, "] + begin[").concat(s, "]"))).join(",");
    }
    this.userCode = "\n      ".concat(r, " begin = ").concat(r, "(").concat(e, ");\n      ").concat(r, " strides = ").concat(r, "(").concat(t, ");\n\n      void main() {\n        ").concat(a, " coords = getOutputCoords();\n        setOutput(getX(").concat(i, "));\n      }\n    ");
  }

}

var JC = {
  kernelName: "StridedSlice",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      begin: a,
      end: i,
      strides: o,
      beginMask: l,
      endMask: u,
      ellipsisMask: c,
      newAxisMask: h,
      shrinkAxisMask: d
    } = s,
        {
      nonStrided: p,
      $begin: f,
      $strides: g,
      size: m,
      newShape: b,
      outShape: x
    } = Vn(r.shape, a, i, o, l, u, c, h, d),
        y = cv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: b
      }
    });
    var k;

    if (p) {
      var _e509 = lI({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          begin: f,
          size: m
        }
      });

      k = cv({
        inputs: {
          x: _e509
        },
        backend: n,
        attrs: {
          shape: x
        }
      }), n.disposeIntermediateTensorInfo(_e509);
    } else if (x.some(e => 0 === e)) k = n.makeTensorInfo(x, r.dtype, []);else if (n.shouldExecuteOnCPU([y])) {
      var _e510 = n.texData.get(y.dataId),
          _t413 = dn(y.shape, y.dtype, _e510.values),
          _s239 = yw(x, _t413, g, f);

      k = n.makeTensorInfo(x, y.dtype, _s239.values);
    } else {
      var _e511 = new YC(f, g, x);

      k = n.runWebGLProgram(_e511, [y], y.dtype);
    }

    var w = cv({
      inputs: {
        x: k
      },
      backend: n,
      attrs: {
        shape: x
      }
    });
    return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(k), w;
  }
},
    ZC = {
  kernelName: "StringNGrams",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      separator: r,
      nGramWidths: a,
      leftPad: i,
      rightPad: o,
      padWidth: l,
      preserveShortSequences: u
    } = s,
        {
      data: c,
      dataSplits: h
    } = t,
        d = n.readSync(c.dataId),
        p = n.readSync(h.dataId),
        [f, g] = kw(d, p, r, a, i, o, l, u);
    return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(h.shape, "int32", g)];
  }
},
    QC = {
  kernelName: "StringSplit",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      skipEmpty: r
    } = s,
        {
      input: a,
      delimiter: i
    } = t;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (1 !== a.shape.length) throw new Error("Input must be a vector, got shape: ".concat(a.shape));
    if (0 !== i.shape.length) throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));
    var o = n.readSync(a.dataId),
        l = n.readSync(i.dataId)[0],
        [u, c, h] = ww(o, l, r),
        d = c.length;
    return [n.makeTensorInfo([d, 2], "int32", u), n.makeTensorInfo([d], "string", c), n.makeTensorInfo([2], "int32", new Int32Array(h))];
  }
},
    eS = {
  kernelName: "StringToHashBucketFast",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      numBuckets: r
    } = s,
        {
      input: a
    } = t;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (r <= 0) throw new Error("Number of buckets must be at least 1");
    var i = n.readSync(a.dataId),
        o = vw(i, r);
    return n.makeTensorInfo(a.shape, "int32", o);
  }
},
    tS = {
  kernelName: "Tan",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return tan(x);"
  })
},
    nS = {
  kernelName: "Tanh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"
  })
};

class sS {
  constructor(e, t) {
    this.variableNames = ["A"];
    var n = new Array(e.length);

    for (var _s240 = 0; _s240 < n.length; _s240++) {
      n[_s240] = e[_s240] * t[_s240];
    }

    this.outputShape = n, this.rank = n.length;

    var s = Mk(this.rank),
        r = function (e) {
      var t = e.length;
      if (t > 5) throw Error("Tile for rank ".concat(t, " is not yet supported"));
      if (1 === t) return "imod(resRC, ".concat(e[0], ")");
      var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"],
          s = [];

      for (var _t414 = 0; _t414 < e.length; _t414++) {
        s.push("imod(".concat(n[_t414], ", ").concat(e[_t414], ")"));
      }

      return s.join();
    }(e);

    this.userCode = "\n      void main() {\n        ".concat(s, " resRC = getOutputCoords();\n        setOutput(getA(").concat(r, "));\n      }\n    ");
  }

}

function rS(e) {
  var {
    inputs: t,
    backend: n,
    attrs: s
  } = e,
      {
    x: r
  } = t,
      {
    reps: a
  } = s;

  if ("string" === r.dtype || r.shape.length > 5) {
    var _e512 = n.readSync(r.dataId),
        _t415 = "string" === r.dtype ? _e512.map(e => He(e)) : _e512,
        _s241 = dn(r.shape, r.dtype, _t415),
        _i103 = $w(_s241, a);

    return n.makeTensorInfo(_i103.shape, _i103.dtype, _i103.values);
  }

  var i = new sS(r.shape, a);
  return n.runWebGLProgram(i, [r], r.dtype);
}

var aS = {
  kernelName: "Tile",
  backendName: "webgl",
  kernelFunc: rS
};

class iS {
  constructor(e) {
    this.variableNames = ["x", "indices"], this.customUniforms = [{
      name: "n",
      type: "int"
    }, {
      name: "firstPass",
      type: "int"
    }, {
      name: "negativeInf",
      type: "float"
    }, {
      name: "dir",
      type: "int"
    }, {
      name: "inc",
      type: "int"
    }], this.outputShape = e, this.userCode = "\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     ";
  }

}

class oS {
  constructor(e) {
    this.variableNames = ["x", "indices"], this.customUniforms = [{
      name: "n",
      type: "int"
    }, {
      name: "firstPass",
      type: "int"
    }, {
      name: "k",
      type: "int"
    }], this.outputShape = e, this.userCode = "\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     ";
  }

}

function lS(e, t) {
  null !== t && e.disposeIntermediateTensorInfo(t);
}

function uS(e) {
  var t = 1;

  for (; t < e;) {
    t *= 2;
  }

  return t;
}

var cS = {
  kernelName: "TopK",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r
    } = t,
        {
      k: a,
      sorted: i
    } = s,
        o = V().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),
        l = V().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),
        u = r.shape,
        c = u[u.length - 1];

    if (n.shouldExecuteOnCPU([r]) || c < o || a > l) {
      var _e513 = n.readSync(r.dataId),
          [_t416, _s242] = Nw(_e513, u, r.dtype, a, i);

      return [n.makeTensorInfo(_t416.shape, _t416.dtype, _t416.values), n.makeTensorInfo(_s242.shape, _s242.dtype, _s242.values)];
    }

    if (0 === a) return u[u.length - 1] = 0, [n.makeTensorInfo(u, r.dtype, []), n.makeTensorInfo(u, "int32", [])];
    if (1 === c) return [r, F$({
      attrs: {
        shape: u,
        dtype: "int32",
        value: 0
      },
      backend: n
    })];
    var h = n.texData.get(r.dataId),
        p = null !== h && h.isPacked,
        f = p ? n.unpackTensor(r) : r,
        g = d(u) / c,
        m = cv({
      inputs: {
        x: f
      },
      attrs: {
        shape: [g, c]
      },
      backend: n
    });
    p && lS(n, f);
    var b = uS(a),
        x = uS(c);
    var y = null;

    var k = () => null === y ? [m, m] : [m, y],
        w = (e, t, s) => {
      var r = k(),
          a = new iS(s),
          i = y;
      y = n.runWebGLProgram(a, r, "int32", [[c], [null === y ? 1 : 0], [Number.NEGATIVE_INFINITY], [e], [t]]), lS(n, i);
    };

    for (var _e514 = 1; _e514 < b; _e514 *= 2) {
      var _t417 = 2 * _e514;

      for (var _n294 = _e514; _n294 >= 1; _n294 /= 2) {
        w(_t417, _n294, [g, x]);
      }
    }

    for (var _e515 = x; _e515 > b; _e515 /= 2) {
      var _t418 = k(),
          _s243 = new oS([g, _e515 / 2]),
          _r172 = y;

      y = n.runWebGLProgram(_s243, _t418, "int32", [[c], [null === y ? 1 : 0], [b]]), lS(n, _r172);

      var _a142 = b / 2,
          _i104 = 2 * _a142;

      for (var _e516 = _a142; _e516 >= 1; _e516 /= 2) {
        w(_i104, _e516, y.shape);
      }
    }

    var v = y;
    y = lI({
      inputs: {
        x: y
      },
      backend: n,
      attrs: {
        begin: 0,
        size: [g, a]
      }
    }), lS(n, v);
    var I = K$({
      inputs: {
        x: m,
        indices: y
      },
      backend: n,
      attrs: {
        axis: 1,
        batchDims: 1
      }
    });
    lS(n, m);
    var $ = u.slice(0, -1);
    $.push(a), v = y, y = cv({
      inputs: {
        x: y
      },
      attrs: {
        shape: $
      },
      backend: n
    }), lS(n, v);
    var N = I;
    return I = cv({
      inputs: {
        x: I
      },
      attrs: {
        shape: $
      },
      backend: n
    }), lS(n, N), [I, y];
  }
};

class hS {
  constructor(e, t, n, s, r, a) {
    this.variableNames = ["Image", "Transforms"], this.outputShape = a;
    var i = "nearest" === n ? 1 : 2;
    var o;

    switch (s) {
      case "constant":
        o = 1;
        break;

      case "reflect":
        o = 2;
        break;

      case "wrap":
        o = 3;
        break;

      case "nearest":
        o = 4;
        break;

      default:
        o = 1;
    }

    this.userCode = "\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(o, " == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o, " == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o, " == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e, " && 0 <= coordX && coordX < ").concat(t, ") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r, ");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r, ");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t, "));\n                float mapY = mapCoord(inY, float(").concat(e, "));\n\n                if (").concat(i, " == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ");
  }

}

var dS = {
  kernelName: "Transform",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      image: r,
      transforms: a
    } = t,
        {
      interpolation: i,
      fillMode: o,
      fillValue: l,
      outputShape: u
    } = s,
        [c, h, d, p] = r.shape,
        [f, g] = null != u ? u : [h, d],
        m = new hS(h, d, i, o, l, [c, f, g, p]);
    return n.runWebGLProgram(m, [r, a], "float32");
  }
},
    pS = {
  kernelName: "Unique",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      attrs: n,
      backend: s
    } = e,
        {
      axis: r
    } = n,
        {
      x: a
    } = t;
    ik(a, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
    var i = s.readSync(a.dataId),
        {
      outputValues: o,
      outputShape: l,
      indices: u
    } = Sw(i, r, a.shape, a.dtype);
    return [s.makeTensorInfo(l, a.dtype, o), s.makeTensorInfo([u.length], "int32", u)];
  }
},
    fS = {
  kernelName: "Unpack",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      value: r
    } = t;
    var {
      axis: a
    } = s;
    a < 0 && (a += r.shape.length);
    var i = r,
        o = i.shape.length,
        l = r.shape[a],
        u = new Array(o - 1);
    var c = 0;

    for (var _e517 = 0; _e517 < o; _e517++) {
      _e517 !== a && (u[c++] = i.shape[_e517]);
    }

    var h = [],
        d = new Array(o).fill(0),
        p = i.shape.slice();
    p[a] = 1;
    var f = new Array(l);

    for (var _e518 = 0; _e518 < f.length; _e518++) {
      d[a] = _e518;

      var _t419 = lI({
        inputs: {
          x: i
        },
        backend: n,
        attrs: {
          begin: d,
          size: p
        }
      }),
          _s244 = cv({
        inputs: {
          x: _t419
        },
        backend: n,
        attrs: {
          shape: u
        }
      });

      f[_e518] = _s244, h.push(_t419);
    }

    return h.forEach(e => n.disposeIntermediateTensorInfo(e)), f;
  }
};

class gS {
  constructor(e, t) {
    this.variableNames = ["x", "segmentIds"];
    var n = e.windowSize,
        s = e.batchSize,
        r = e.inSize,
        a = e.numSegments,
        i = a * Math.ceil(r / n);
    this.outputShape = [s, i];
    var o = 4 * Math.floor(n / 4),
        l = n % 4,
        u = "\n        sumValue += dot(values, segFilter);\n    ";
    var c = "";
    r % n > 0 && (c = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return initializationValue;\n        }\n      "));
    var h = "";
    r % n > 0 && (h = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return -1.0;\n        }\n      ")), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ".concat(c, "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h, "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(a, ")) * float(").concat(n, "));\n        int currentSeg = int(mod(float(outIdx), float(").concat(a, ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o, "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(u, "\n        }\n\n        int inIdx = inOffset + ").concat(o, ";\n        if (").concat(1 === l, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(u, "\n        } else if (").concat(2 === l, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(u, "\n        } else if (").concat(3 === l, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(u, "\n        }\n        setOutput(sumValue);\n      }\n    ");
  }

}

var mS = [dN, fN, Iv, Nv, Cv, Sv, Ev, Fv, Dv, _v, Pv, Wv, Uv, Vv, Hv, Gv, jv, Yv, Xv, Qv, eI, tI, rI, cI, hI, mI, xI, wI, $I, Xw, FI, VI, GI, zI, jI, qI, HI, KI, XI, JI, t$, n$, r$, c$, h$, o$, p$, g$, m$, b$, x$, y$, k$, I$, N$, S$, R$, D$, O$, L$, z$, W$, V$, G$, j$, X$, Y$, J$, qw, Z$, EI, Q$, eN, tN, Zw, nN, sN, rN, iN, aN, oN, lN, uN, mN, yN, xN, vN, IN, $N, bN, NN, CN, SN, RN, AN, PN, uv, UN, GN, jN, KN, pI, YN, QN, eC, rC, aC, tv, iC, lC, gI, _N, uC, hC, cC, hv, fC, mC, yC, wC, $C, CC, SC, TC, RC, FC, DC, _C, OC, MC, LC, uI, BN, zC, BC, PC, WC, UC, VC, GC, HC, jC, qC, KC, XC, JC, ZC, QC, eS, LN, yv, tS, nS, aS, cS, dS, wv, pS, fS, {
  kernelName: "UnsortedSegmentSum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var {
      inputs: t,
      backend: n,
      attrs: s
    } = e,
        {
      x: r,
      segmentIds: a
    } = t,
        {
      numSegments: i
    } = s,
        o = r.shape.length,
        l = [];
    var u = 0;
    var c = Jr([u], o);
    var h = r;
    null != c && (h = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), l.push(h), u = Qr(1, o)[0]);
    var p = Qo(h.shape, u, i),
        f = d([h.shape[u]]),
        g = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, f]
      }
    });
    l.push(g);

    var m = pt(r.dtype),
        b = (e, t, s, r, a) => {
      var i = e.shape[0],
          o = e.shape[1],
          u = Zo(o, a),
          c = new gS({
        windowSize: u,
        inSize: o,
        batchSize: i,
        numSegments: a
      }, t),
          h = n.compileAndRun(c, [e, s], r);
      if (l.push(h), h.shape[1] === a) return h;
      var d = oC({
        backend: n,
        attrs: {
          start: 0,
          stop: a,
          step: 1,
          dtype: "float32"
        }
      }),
          p = rS({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          reps: [o / u]
        }
      });
      return l.push(d), l.push(p), b(h, t, p, r, a);
    },
        x = cv({
      inputs: {
        x: b(g, "unsortedSegmentSum", a, m, i)
      },
      backend: n,
      attrs: {
        shape: p
      }
    });

    var y = x;

    if (null != c) {
      l.push(x);

      var _e519 = Zr(c);

      y = kv({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          perm: _e519
        }
      });
    }

    return l.forEach(e => n.disposeIntermediateTensorInfo(e)), y;
  }
}, ZN];

for (var _e520 of mS) {
  Q(_e520);
}

var bS = ["worker"],
    xS = {
  train: function () {
    var _train = _asyncToGenerator(function* (e) {
      var {
        data: t
      } = e;
      var n = [];

      var s = function (e, t, n) {
        if (c(e), null != t && 3 !== t.length) throw new Error("tensor3d() requires shape to have three numbers");
        var s = Ct(e, n);
        if (3 !== s.length && 1 !== s.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
        if (1 === s.length && null == t) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
        return Dt(e, t, s, n);
      }(t.xData, [t.xData.length, t.model.inputShape[0], t.model.inputShape[1]]),
          r = In(mi(t.yData, "int32"), t.model.labels.length),
          {
        epochs: a,
        model: i
      } = function (e, t) {
        var n = new Ed(void 0);
        return "" == t && (n.add(Of({
          inputShape: e.inputShape,
          kernelSize: [4],
          strides: 1,
          filters: 16,
          activation: "relu"
        })), n.add(Lf({
          poolSize: [2]
        })), n.add(Mf({
          rate: .1
        })), n.add(Of({
          kernelSize: [2],
          strides: 1,
          filters: 16,
          activation: "relu"
        })), n.add(Lf({
          poolSize: [2]
        })), n.add(Mf({
          rate: .1
        })), n.add(Of({
          kernelSize: [2],
          strides: 1,
          filters: 16,
          activation: "relu"
        })), n.add(Mf({
          rate: .1
        })), n.add(new Hp(void 0)), n.add(new Gp({
          units: e.outputShape,
          activation: "softmax"
        })), n.compile({
          loss: "categoricalCrossentropy",
          optimizer: "adam",
          metrics: ["accuracy"]
        })), {
          model: n,
          epochs: 250
        };
      }(t.model, t.modelBlockJSON);

      var o;
      yield i.fit(s, r, {
        epochs: a,
        callbacks: {
          onEpochEnd: yS
        }
      }).then(e => {
        n = e.history.acc;
      }), yield i.save({
        save: e => {
          o = e;
          var t = {
            modelArtifactsInfo: {
              dateSaved: new Date(),
              modelTopologyType: "JSON"
            }
          };
          return Promise.resolve(t);
        }
      });
      var l = o.weightData;
      return o.weightData = null, {
        modelJSON: JSON.stringify(o),
        modelWeights: l,
        trainingInfo: n
      };
    });

    function train(_x56) {
      return _train.apply(this, arguments);
    }

    return train;
  }(),
  predict: function () {
    var _predict = _asyncToGenerator(function* (e) {
      var {
        data: t
      } = e,
          n = _t(t.zData),
          s = JSON.parse(t.model.modelJSON);

      s.weightData = new Uint32Array(t.model.weights).buffer;
      var r = yield (a = {
        load: () => Promise.resolve(s)
      }, null == i && (i = {}), function () {
        var _ref34 = _asyncToGenerator(function* (e, t) {
          if (null == t && (t = {}), "string" == typeof e) {
            var _n295 = Gt.getLoadHandlers(e, t);

            if (0 === _n295.length) _n295.push(wn(e, t));else if (_n295.length > 1) throw new bu("Found more than one (".concat(_n295.length, ") load handlers for URL '").concat(e, "'"));
            e = _n295[0];
          }

          return function () {
            var _ref35 = _asyncToGenerator(function* (e, t, n) {
              if (null == n && (n = {}), null == e.load) throw new bu("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
              var s = yield e.load();
              var r = s.modelTopology;
              null != r.model_config && (r = r.model_config);
              var a = null == n.strict || n.strict,
                  i = null != s.weightData && null != s.weightSpecs && a,
                  o = Eh(td(r), void 0, i),
                  l = s.trainingConfig;

              if (null != l && o.loadTrainingConfig(l), null != s.userDefinedMetadata && o.setUserDefinedMetadata(s.userDefinedMetadata), null != s.weightData) {
                if (null == s.weightSpecs) throw new bu("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");

                var {
                  modelWeights: _e521,
                  optimizerWeights: _t420
                } = function (e, t) {
                  var n = function (e, t) {
                    var n = {};
                    var s,
                        r = 0;

                    for (var _a143 of t) {
                      var _t421 = _a143.name,
                          _i105 = _a143.dtype,
                          _o76 = _a143.shape,
                          _l55 = d(_o76);

                      var _u42 = void 0;

                      if ("quantization" in _a143) {
                        var _n296 = _a143.quantization;

                        if ("uint8" === _n296.dtype || "uint16" === _n296.dtype) {
                          if (!("min" in _n296) || !("scale" in _n296)) throw new Error("Weight ".concat(_a143.name, " with quantization ").concat(_n296.dtype, " doesn't have corresponding metadata min and scale."));
                        } else {
                          if ("float16" !== _n296.dtype) throw new Error("Weight ".concat(_a143.name, " has unknown quantization dtype ").concat(_n296.dtype, ". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'."));
                          if ("float32" !== _i105) throw new Error("Weight ".concat(_a143.name, " is quantized with ").concat(_n296.dtype, " which only supports weights of type float32 not ").concat(_i105, "."));
                        }

                        var _o77 = Ot[_n296.dtype],
                            _c36 = e.slice(r, r + _l55 * _o77),
                            _h19 = "uint8" === _n296.dtype ? new Uint8Array(_c36) : new Uint16Array(_c36);

                        if ("float32" === _i105) {
                          if ("uint8" === _n296.dtype || "uint16" === _n296.dtype) {
                            _u42 = new Float32Array(_h19.length);

                            for (var _e522 = 0; _e522 < _h19.length; _e522++) {
                              _u42[_e522] = _h19[_e522] * _n296.scale + _n296.min;
                            }
                          } else {
                            if ("float16" !== _n296.dtype) throw new Error("Unsupported quantization type ".concat(_n296.dtype, " for weight type float32."));
                            void 0 === s && (s = Vt()), _u42 = s(_h19);
                          }
                        } else {
                          if ("int32" !== _i105) throw new Error("Unsupported dtype in weight '".concat(_t421, "': ").concat(_i105));
                          if ("uint8" !== _n296.dtype && "uint16" !== _n296.dtype) throw new Error("Unsupported quantization type ".concat(_n296.dtype, " for weight type int32."));
                          _u42 = new Int32Array(_h19.length);

                          for (var _e523 = 0; _e523 < _h19.length; _e523++) {
                            _u42[_e523] = Math.round(_h19[_e523] * _n296.scale + _n296.min);
                          }
                        }
                        r += _l55 * _o77;
                      } else if ("string" === _i105) {
                        var _t422 = d(_a143.shape);

                        _u42 = [];

                        for (var _n297 = 0; _n297 < _t422; _n297++) {
                          var _t423 = new Uint32Array(e.slice(r, r + 4))[0];
                          r += 4;

                          var _n298 = new Uint8Array(e.slice(r, r + _t423));

                          _u42.push(_n298), r += _t423;
                        }
                      } else {
                        var _s245 = Ot[_i105],
                            _a144 = e.slice(r, r + _l55 * _s245);

                        if ("float32" === _i105) _u42 = new Float32Array(_a144);else if ("int32" === _i105) _u42 = new Int32Array(_a144);else if ("bool" === _i105) _u42 = new Uint8Array(_a144);else {
                          if ("complex64" !== _i105) throw new Error("Unsupported dtype in weight '".concat(_t421, "': ").concat(_i105));
                          {
                            _u42 = new Float32Array(_a144);

                            var _e524 = new Float32Array(_u42.length / 2),
                                _s246 = new Float32Array(_u42.length / 2);

                            for (var _t424 = 0; _t424 < _e524.length; _t424++) {
                              _e524[_t424] = _u42[2 * _t424], _s246[_t424] = _u42[2 * _t424 + 1];
                            }

                            var _r173 = _t(_e524, _o76, "float32"),
                                _i106 = _t(_s246, _o76, "float32");

                            n[_t421] = Ft(_r173, _i106), _r173.dispose(), _i106.dispose();
                          }
                        }
                        r += _l55 * _s245;
                      }

                      "complex64" !== _i105 && (n[_t421] = _t(_u42, _o76, _i105));
                    }

                    return n;
                  }(e, t),
                      s = {},
                      r = [];

                  return t.forEach(e => {
                    "optimizer" === e.group ? r.push({
                      name: e.name,
                      tensor: n[e.name]
                    }) : s[e.name] = n[e.name];
                  }), {
                    modelWeights: s,
                    optimizerWeights: r
                  };
                }(s.weightData, s.weightSpecs);

                o.loadWeights(_e521, a), null != o.optimizer && _t420.length > 0 && (yield o.optimizer.setWeights(_t420)), Jn(_e521), Jn(_t420.map(e => e.tensor));
              }

              return o;
            });

            return function (_x60, _x61, _x62) {
              return _ref35.apply(this, arguments);
            };
          }()(e, 0, t);
        });

        return function (_x58, _x59) {
          return _ref34.apply(this, arguments);
        };
      }()(a, i));
      var a, i;
      var o = yield r.predict(n);
      return {
        prediction: yield o.dataSync()
      };
    });

    function predict(_x57) {
      return _predict.apply(this, arguments);
    }

    return predict;
  }()
};

function yS(e, t) {
  self.postMessage({
    type: "progress",
    data: t
  });
}

self.addEventListener("message", /*#__PURE__*/function () {
  var _ref36 = _asyncToGenerator(function* (t) {
    var n = t.data,
        {
      worker: s
    } = n,
        r = function (e, t) {
      if (null == e) return {};
      var n,
          s,
          r = {},
          a = Object.keys(e);

      for (s = 0; s < a.length; s++) {
        t.indexOf(n = a[s]) >= 0 || (r[n] = e[n]);
      }

      return r;
    }(n, bS);

    if ("tf" !== s) return;
    var a = e({
      worker: s
    }, r, {
      data: yield function () {
        var _ref37 = _asyncToGenerator(function* (e) {
          try {
            var _t425 = xS[e.type];
            return yield null == _t425 ? void 0 : _t425(e);
          } catch (e) {
            return void console.error(e);
          }
        });

        return function (_x64) {
          return _ref37.apply(this, arguments);
        };
      }()(n)
    });
    self.postMessage(a);
  });

  return function (_x63) {
    return _ref36.apply(this, arguments);
  };
}()), console.debug("jacdac tf: worker registered");

/***/ })

}]);
//# sourceMappingURL=8e0cf18a-57bf784dc5e73b95f8f5.js.map